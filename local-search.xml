<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>手写call-apply-bind</title>
    <link href="/2024/05/15/%E6%89%8B%E5%86%99call-apply-bind/"/>
    <url>/2024/05/15/%E6%89%8B%E5%86%99call-apply-bind/</url>
    
    <content type="html"><![CDATA[<h3 id="手写-call-函数"><a href="#手写-call-函数" class="headerlink" title="手写 call 函数"></a>手写 call 函数</h3><p>call 函数的实现步骤：</p><ol><li>判断调用对象是否为函数，即使我们是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。</li><li>判断传入上下文对象是否存在，如果不存在，则设置为 window 。</li><li>处理传入的参数，截取第一个参数后的所有参数。</li><li>将函数作为上下文对象的一个属性。</li><li>使用上下文对象来调用这个方法，并保存返回结果。</li><li>删除刚才新增的属性。</li><li>返回结果。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// call函数实现</span><br><span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">myCall</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">context</span>) &#123;     <span class="hljs-comment">//call方法中call(a),a是this要指向哪个</span><br>  <span class="hljs-comment">// 判断调用对象</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-variable language_">this</span> !== <span class="hljs-string">&quot;function&quot;</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&quot;type error&quot;</span>);<br>  &#125;<br>  <span class="hljs-comment">// 获取参数</span><br>  <span class="hljs-keyword">let</span> args = [...<span class="hljs-variable language_">arguments</span>].<span class="hljs-title function_">slice</span>(<span class="hljs-number">1</span>),<br>  <span class="hljs-keyword">let</span> result = <span class="hljs-literal">null</span>;<br>  <span class="hljs-comment">// 判断 context 是否传入，如果未传入则设置为 window</span><br>  context = context || <span class="hljs-variable language_">window</span>;<br>  <span class="hljs-comment">// 将调用函数设为对象的方法</span><br>  context.<span class="hljs-property">fn</span> = <span class="hljs-variable language_">this</span>;   <span class="hljs-comment">//这里的this是指调用的当前函数</span><br>  <span class="hljs-comment">// 调用函数</span><br>  result = context.<span class="hljs-title function_">fn</span>(...args);<br>  <span class="hljs-comment">// 将属性删除</span><br>  <span class="hljs-keyword">delete</span> context.<span class="hljs-property">fn</span>;<br>  <span class="hljs-keyword">return</span> result;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="手写apply"><a href="#手写apply" class="headerlink" title="手写apply"></a>手写apply</h2><p>方法同call，只是apply方法里，传递的参数是一个数组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// apply 函数实现</span><br><span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">myApply</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">context</span>) &#123;<br>  <span class="hljs-comment">// 判断调用对象是否为函数</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-variable language_">this</span> !== <span class="hljs-string">&quot;function&quot;</span>) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeError</span>(<span class="hljs-string">&quot;Error&quot;</span>);<br>  &#125;<br>  <span class="hljs-keyword">let</span> result = <span class="hljs-literal">null</span>;<br>  <span class="hljs-comment">// 判断 context 是否存在，如果未传入则为 window</span><br>  context = context || <span class="hljs-variable language_">window</span>;<br>  <span class="hljs-comment">// 将函数设为对象的方法</span><br>  context.<span class="hljs-property">fn</span> = <span class="hljs-variable language_">this</span>;<br>  <span class="hljs-comment">// 调用方法</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">arguments</span>[<span class="hljs-number">1</span>]) &#123;<br>    result = context.<span class="hljs-title function_">fn</span>(...<span class="hljs-variable language_">arguments</span>[<span class="hljs-number">1</span>]);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    result = context.<span class="hljs-title function_">fn</span>();<br>  &#125;<br>  <span class="hljs-comment">// 将属性删除</span><br>  <span class="hljs-keyword">delete</span> context.<span class="hljs-property">fn</span>;<br>  <span class="hljs-keyword">return</span> result;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="手写bind"><a href="#手写bind" class="headerlink" title="手写bind"></a>手写bind</h2><p>bind与call、apply的区别是不会自动执行函数，而是返回一个新的函数。</p><p>bind 函数的实现步骤：</p><ol><li>判断调用对象是否为函数，即使我们是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。</li><li>保存当前函数的引用，获取其余传入参数值。</li><li>创建一个函数返回</li><li>函数内部使用 apply 来绑定函数调用，需要判断函数作为构造函数的情况，这个时候需要传入当前函数的 this 给 apply 调用，其余情况都传入指定的上下文对象。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// bind 函数实现</span><br><span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">myBind</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">context</span>) &#123;<br>  <span class="hljs-comment">// 判断调用对象是否为函数</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-variable language_">this</span> !== <span class="hljs-string">&quot;function&quot;</span>) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeError</span>(<span class="hljs-string">&quot;Error&quot;</span>);<br>  &#125;<br>  <span class="hljs-comment">// 获取参数</span><br>  <span class="hljs-keyword">let</span> args = [...<span class="hljs-variable language_">arguments</span>].<span class="hljs-title function_">slice</span>(<span class="hljs-number">1</span>),<br>  <span class="hljs-keyword">let</span> fn = <span class="hljs-variable language_">this</span>;   <span class="hljs-comment">//fn为当前调用mybind的函数</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Fn</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// 根据调用方式，传入不同绑定值    //bind方法返回的是一个函数</span><br>    <span class="hljs-keyword">const</span> target = <span class="hljs-variable language_">this</span> <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Fn</span> ? <span class="hljs-variable language_">this</span> : context  <span class="hljs-comment">//注意这两行代码</span><br>    <span class="hljs-keyword">return</span> fn.<span class="hljs-title function_">apply</span>(target,args.<span class="hljs-title function_">concat</span>(...<span class="hljs-variable language_">arguments</span>));<br>  &#125;;<br>&#125;;<br></code></pre></td></tr></table></figure><p><img src="image-20240516142545111.png" alt="image-20240516142545111"></p><p>关于bind、apply、call的区别和应用见文章：<a href="https://fanyang888.github.io/2023/05/22/%E5%87%BD%E6%95%B0%E5%8F%8Athis%E6%8C%87%E5%90%91%E9%97%AE%E9%A2%98/">https://fanyang888.github.io/2023/05/22/%E5%87%BD%E6%95%B0%E5%8F%8Athis%E6%8C%87%E5%90%91%E9%97%AE%E9%A2%98/</a></p>]]></content>
    
    
    <categories>
      
      <category>常见问题</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>常见状态码</title>
    <link href="/2024/05/07/%E5%B8%B8%E8%A7%81%E7%8A%B6%E6%80%81%E7%A0%81/"/>
    <url>/2024/05/07/%E5%B8%B8%E8%A7%81%E7%8A%B6%E6%80%81%E7%A0%81/</url>
    
    <content type="html"><![CDATA[<h3 id="2XX一般表示请求成功"><a href="#2XX一般表示请求成功" class="headerlink" title="2XX一般表示请求成功"></a>2XX一般表示请求成功</h3><table><thead><tr><th>状态码 2xx</th><th>说明</th></tr></thead><tbody><tr><td>200</td><td>请求被正确处理</td></tr><tr><td>204 No content</td><td>请求成功，但响应报文不含实体的主体部分</td></tr><tr><td>205 Reset Content</td><td>请求成功，但是与 204 响应不同在于要求请求方重置内容</td></tr><tr><td>206 Partial Content</td><td>进行范围请求</td></tr></tbody></table><h3 id="3XX一般表示重定向、304除外"><a href="#3XX一般表示重定向、304除外" class="headerlink" title="3XX一般表示重定向、304除外"></a>3XX一般表示重定向、304除外</h3><table><thead><tr><th>状态码3xx</th><th>说明</th></tr></thead><tbody><tr><td>301</td><td>永久重定向</td></tr><tr><td>302（http1.0）</td><td>临时重定向</td></tr><tr><td>303（http1.1）</td><td>明确表示客户端应当采⽤get⽅法获取资源，把POST请求变为GET请求进⾏重定向</td></tr><tr><td>307 （http1.1）</td><td>遵照浏览器标准，不会从POST变为GET</td></tr><tr><td>304</td><td>协商缓存</td></tr></tbody></table><h3 id="4XX一般表示客户端错误"><a href="#4XX一般表示客户端错误" class="headerlink" title="4XX一般表示客户端错误"></a>4XX一般表示客户端错误</h3><table><thead><tr><th>状态码4xx</th><th>说明</th></tr></thead><tbody><tr><td>400 bad request</td><td>请求报文存在语法错误</td></tr><tr><td>401 unauthorized</td><td>未认证、未授权</td></tr><tr><td>403 forbidden</td><td>被禁止访问</td></tr><tr><td>404 not found</td><td>服务器未找到资源</td></tr></tbody></table><h3 id="5XX一般表示服务端错误"><a href="#5XX一般表示服务端错误" class="headerlink" title="5XX一般表示服务端错误"></a>5XX一般表示服务端错误</h3><table><thead><tr><th>状态码5xx</th><th>说明</th></tr></thead><tbody><tr><td>500 internal sever error</td><td>服务器执行请求时发生错误</td></tr><tr><td>501 Not Implemented</td><td>服务器不支持当前请求的某个功能</td></tr><tr><td>502 Bad Gateway</td><td>网关或代理服务器接收到的请求无效，通常需要找网络管理员解决</td></tr><tr><td>503 Service Unavailable</td><td>服务器超负载或停机</td></tr><tr><td>504 Gateway Timeout(http1.1)</td><td>服务器请求超时</td></tr></tbody></table>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>关于promise注意点</title>
    <link href="/2024/05/07/%E5%85%B3%E4%BA%8Epromise%E6%B3%A8%E6%84%8F%E7%82%B9/"/>
    <url>/2024/05/07/%E5%85%B3%E4%BA%8Epromise%E6%B3%A8%E6%84%8F%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<p>1.then .catch 中 的参数期望是函数，<strong>传入非函数则会发生</strong>值透传</p><p>2 返回任意一个非 promise 的值都会被包裹成 promise 对象</p><p>3 Promise.resolve方法的参数如果是一个原始值，或者是一个不具有then方法的对象，则Promise.resolve方法返回一个新的Promise对象，状态为resolved</p><p>4 执行顺序  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-string">&quot;1&quot;</span>)<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res); <span class="hljs-comment">//1</span><br>  &#125;)<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;111111&quot;</span>);<br>  &#125;)<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;finally&quot;</span>);<br>  &#125;);<br><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-string">&quot;2&quot;</span>)<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res);<br>  &#125;)<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">123</span>);<br>  &#125;);<br><br>打印结果  <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">111111</span> <span class="hljs-number">123</span> <span class="hljs-keyword">finally</span><br></code></pre></td></tr></table></figure><p>5 finally</p><ul><li><strong><code>.finally()</code>方法不管Promise对象最后的状态如何都会执行</strong></li><li><code>.finally()</code>方法的回调函数<strong>不接受任何的参数</strong></li><li><strong>finally本质上是then方法的特例</strong></li><li>finally最终返回的默认会是一个上一次的Promise对象值，不过如果抛出的是一个异常则返回异常的Promise对象</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>for..in与for..of的区别</title>
    <link href="/2024/03/19/for-in%E4%B8%8Efor-of%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/2024/03/19/for-in%E4%B8%8Efor-of%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<table><thead><tr><th>方法名</th><th>描述</th></tr></thead><tbody><tr><td>for…in</td><td>For…in语句只遍历<strong>可枚举属性</strong>（包括它的原型链上的可枚举属性）（不能保证返回对象属性的顺序）</td></tr><tr><td>for…of</td><td>For…of语句用于遍历<strong>可迭代对象</strong>，例如数组、字符串、Map、Set等（会按照可迭代对象的next()方法产生值的顺序迭代元素）</td></tr></tbody></table><p><strong>区别</strong></p><table><thead><tr><th>方法名</th><th>适用的目标</th></tr></thead><tbody><tr><td>for…in</td><td>for…in 用于可枚举的数据，如对象，数组，字符串得到key</td></tr><tr><td>for…of</td><td>for…of用于可迭代的数据，如数组，字符串，map,set,arguments,</td></tr></tbody></table><table><thead><tr><th>方法名</th><th>遍历的范围</th></tr></thead><tbody><tr><td>for…in</td><td>for…in 原型链上的可枚举的属性也能被遍历到</td></tr><tr><td>for…of</td><td>for…of 一般只遍历自身的</td></tr></tbody></table><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">foo</span> = <span class="hljs-number">4</span>;<br>      <span class="hljs-keyword">const</span> arr = [<span class="hljs-number">7</span>];<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> arr) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;key--&quot;</span>, key, arr[key]);<span class="hljs-comment">//7 4</span><br>      &#125;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> item <span class="hljs-keyword">of</span> arr) &#123;   <br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(item); <span class="hljs-comment">//7</span><br>      &#125;<br></code></pre></td></tr></table></figure><p><img src="image-20240319144134442.png" alt="image-20240319144134442"></p><table><thead><tr><th>方法名</th><th>得到的结果</th></tr></thead><tbody><tr><td>for…in</td><td>for…in 的到的是key(并且不保证顺序)，遍历对象得到的则是<strong>属性名</strong>，遍历数组得到的是<strong>下标</strong></td></tr><tr><td>for…of</td><td>for…of一般得到的是value</td></tr></tbody></table><br><p>ps：</p><ul><li>迭代（iterate），指的是按照某种顺序反复多次执行一段程序，通常会有明确的终止条件。</li><li>遍历（traversal），指的是按照一定的规则访问树形结构中的每个节点，而且每个节点都只访问一次。</li></ul>]]></content>
    
    
    <categories>
      
      <category>javascript</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>防抖和节流</title>
    <link href="/2024/03/19/%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81/"/>
    <url>/2024/03/19/%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81/</url>
    
    <content type="html"><![CDATA[<h2 id="1-定义"><a href="#1-定义" class="headerlink" title="1.定义"></a>1.定义</h2><p>防抖（Debounce）和节流（Throttle）都是用来控制某个函数在一定时间内触发次数，两者都是为了<strong>减少触发频率</strong>，以便提高性能</p><p>防抖是触发高频事件后n秒内函数只会执行一次，如果n秒内高频事件再次被触发，则重新计算时间。适用于可以<strong>多次触发但触发只生效最后一次</strong>的场景。</p><p>节流是高频事件触发，但在n秒内只会执行一次，如果n秒内触发多次函数，只有一次生效，节流会稀释函数的执行频率。</p><br><h2 id="2-代码"><a href="#2-代码" class="headerlink" title="2.代码"></a>2.代码</h2><p>防抖和节流都是通过闭包来实现的。</p><p>防抖：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">debounce</span>(<span class="hljs-params">fn, waittime</span>) &#123;<br>        <span class="hljs-keyword">let</span> timer = <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>          <span class="hljs-built_in">clearTimeout</span>(timer);<br>          timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>            <span class="hljs-title function_">fn</span>();<br>          &#125;, waittime);<br>        &#125;;<br>      &#125;<br></code></pre></td></tr></table></figure><p>节流：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">throttle</span>(<span class="hljs-params">fun, wait</span>) &#123;<br>        <span class="hljs-keyword">var</span> lasttime = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>();<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>          <span class="hljs-keyword">var</span> currenttime = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>();<br>          <span class="hljs-keyword">if</span> (currenttime - lasttime &gt; wait) &#123;<br>            <span class="hljs-title function_">fun</span>();<br>            lasttime = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>();<br>          &#125;<br>        &#125;;<br>&#125;<br><br><span class="hljs-comment">//或者利用节流阀写法</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">throttle</span>(<span class="hljs-params">fn, delay</span>) &#123;<br>        <span class="hljs-keyword">let</span> valid = <span class="hljs-literal">true</span>;  <span class="hljs-comment">//节流阀</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>          <span class="hljs-keyword">if</span> (valid) &#123;<br>            <span class="hljs-comment">//如果阀门已经打开，就继续往下</span><br>            <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>              fn.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, <span class="hljs-variable language_">arguments</span>); <span class="hljs-comment">//定时器结束后执行</span><br>              valid = <span class="hljs-literal">true</span>; <span class="hljs-comment">//执行完成后打开阀门</span><br>            &#125;, delay);<br>            valid = <span class="hljs-literal">false</span>; <span class="hljs-comment">//关闭阀门</span><br>          &#125;<br>        &#125;;<br>&#125;<br><br></code></pre></td></tr></table></figure><br><h2 id="3-应用场景："><a href="#3-应用场景：" class="headerlink" title="3.应用场景："></a>3.应用场景：</h2><ol><li>滚动事件处理：</li></ol><p>节流：用于限制滚动事件处理的频率，以减少滚动事件的处理次数，从而提高性能。<br>防抖：用于延迟执行滚动事件处理，以确保用户完成滚动操作后再触发相关操作，例如加载更多数据。<br>2. 窗口大小调整事件：</p><p>节流：用于在窗口大小不断调整时，限制事件处理的频率，以避免过多的重绘操作。<br>防抖：用于确保只有在用户停止调整窗口大小后才执行相应的调整操作。<br>3. 搜索框自动完成：</p><p>防抖：用于在用户输入搜索关键字时，延迟执行自动完成搜索操作，以减少请求次数，降低服务器负担。<br>4. 表单输入验证：</p><p>防抖：用于在用户输入表单字段时，延迟进行验证操作，以减少验证请求的频率。<br>5. 按钮点击事件：</p><p>节流：用于限制按钮点击事件的频率，以避免用户多次点击导致的重复操作。<br>6. 实时聊天：</p><p>防抖：用于实时聊天应用中，延迟发送用户输入的消息，以减少网络请求和提高性能。<br>7. 轮播图切换：</p><p>节流：用于限制轮播图切换的频率，以提高用户体验，防止用户快速切换图片。<br>8. 鼠标移动事件：</p><p>节流：用于限制鼠标移动事件的频率，以减少处理次数，提高性能。</p>]]></content>
    
    
    <categories>
      
      <category>javascript</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>TypeScript类中的常见修饰符</title>
    <link href="/2024/03/14/TypeScript%E7%B1%BB%E4%B8%AD%E7%9A%84%E5%B8%B8%E8%A7%81%E4%BF%AE%E9%A5%B0%E7%AC%A6/"/>
    <url>/2024/03/14/TypeScript%E7%B1%BB%E4%B8%AD%E7%9A%84%E5%B8%B8%E8%A7%81%E4%BF%AE%E9%A5%B0%E7%AC%A6/</url>
    
    <content type="html"><![CDATA[<table><thead><tr><th>修饰符</th><th>说明</th></tr></thead><tbody><tr><td>public</td><td>公有的，<strong>默认值</strong>，类的内外都可以访问</td></tr><tr><td>private</td><td>私有的，只有对应属性<strong>当前类的内部</strong>可以访问，其他类和外部都不能访问</td></tr><tr><td>protected</td><td>受保护的，对应属性<strong>当前类的内部和其子类内部</strong>可以访问，其他类和外部都不能访问</td></tr><tr><td>static</td><td>静态的属性、方法，是<strong>属于类</strong>的，直接通过类名获取，不能通过实例对象获取</td></tr><tr><td>abstract</td><td>抽象类，<strong>不能被实例化</strong>，只能被继承，作用类似于接口</td></tr></tbody></table><p>例子：<br>1.public</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Car</span> &#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-attr">brand</span>: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">brand: <span class="hljs-built_in">string</span></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">brand</span> = brand;<br>  &#125;<br><br>  <span class="hljs-title function_">drive</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Driving a <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.brand&#125;</span> car.`</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> myCar = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Car</span>(<span class="hljs-string">&quot;Toyota&quot;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(myCar.<span class="hljs-property">brand</span>); <span class="hljs-comment">// 可以访问 brand 属性</span><br>myCar.<span class="hljs-title function_">drive</span>(); <span class="hljs-comment">// 可以调用 drive 方法</span><br><br></code></pre></td></tr></table></figure><p>2.private</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">class</span> <span class="hljs-title class_">BankAccount</span> &#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-attr">balance</span>: <span class="hljs-built_in">number</span>;<br><br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">initialBalance: <span class="hljs-built_in">number</span></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">balance</span> = initialBalance;<br>  &#125;<br><br>  <span class="hljs-title function_">deposit</span>(<span class="hljs-params">amount: <span class="hljs-built_in">number</span></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">balance</span> += amount;<br>  &#125;<br><br>  <span class="hljs-title function_">withdraw</span>(<span class="hljs-params">amount: <span class="hljs-built_in">number</span></span>) &#123;<br>    <span class="hljs-keyword">if</span> (amount &lt;= <span class="hljs-variable language_">this</span>.<span class="hljs-property">balance</span>) &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">balance</span> -= amount;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Insufficient balance.&quot;</span>);<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-title function_">getBalance</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">balance</span>;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> myAccount = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BankAccount</span>(<span class="hljs-number">1000</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(myAccount.<span class="hljs-property">balance</span>); <span class="hljs-comment">// 编译错误，无法访问私有属性</span><br>myAccount.<span class="hljs-title function_">deposit</span>(<span class="hljs-number">500</span>); <span class="hljs-comment">// 可以调用 deposit 方法，修改私有属性</span><br></code></pre></td></tr></table></figure><p>3.protected</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>  <span class="hljs-keyword">protected</span> <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;<br><br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Employee</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Person</span> &#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-attr">employeeId</span>: <span class="hljs-built_in">number</span>;<br><br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span>, employeeId: <span class="hljs-built_in">number</span></span>) &#123;<br>    <span class="hljs-variable language_">super</span>(name);   <span class="hljs-comment">//不报错，如果Person中的name是private，那这里也会报错</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">employeeId</span> = employeeId;<br>  &#125;<br><br>  <span class="hljs-title function_">getDetails</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Employee Name: <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.name&#125;</span>, Employee ID: <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.employeeId&#125;</span>`</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> employee = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Employee</span>(<span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-number">12345</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(employee.<span class="hljs-property">name</span>); <span class="hljs-comment">// 编译错误，外部无法访问受保护属性</span><br>employee.<span class="hljs-title function_">getDetails</span>(); <span class="hljs-comment">// 可以调用 getDetails 方法，访问受保护属性</span><br><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>TypeScript</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>vue插槽与react的区别</title>
    <link href="/2024/03/12/vue%E6%8F%92%E6%A7%BD%E4%B8%8Ereact%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/2024/03/12/vue%E6%8F%92%E6%A7%BD%E4%B8%8Ereact%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<h2 id="1-vue插槽-slot"><a href="#1-vue插槽-slot" class="headerlink" title="1 vue插槽-slot"></a>1 vue插槽-slot</h2><h3 id="什么是插槽"><a href="#什么是插槽" class="headerlink" title="什么是插槽"></a>什么是插槽</h3><p>插槽（Slot）是 vue 为组件的封装者提供的能力。允许开发者在封装组件时，把不确定的、希望由用户指定的 部分定义为插槽。用于<strong>提高组件的复用性</strong></p><p><img src="image-20240312221529332.png" alt="image-20240312221529332"></p><p>插槽分为： 匿名插槽、具名插槽、作用域插槽</p><h3 id="①匿名插槽"><a href="#①匿名插槽" class="headerlink" title="①匿名插槽"></a>①匿名插槽</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;!--封装组件 假设 在 slot-component 组件中创建一个插槽--&gt;<br>&lt;template&gt;<br>  &lt;p&gt;这是插槽组件&lt;/p&gt;<br>  &lt;slot&gt;&lt;/slot&gt;  &lt;!--若slot中间有值，则该值为默认值--&gt;<br>&lt;/template&gt;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;!--插槽使用 假如封装的组件为Com1--&gt;<br>&lt;Com1&gt;<br>    hello<br>&lt;/Com1&gt;<br><br>&lt;!--显示的结果为 这是插槽组件 hello--&gt;<br></code></pre></td></tr></table></figure><h3 id="②具名插槽"><a href="#②具名插槽" class="headerlink" title="②具名插槽"></a>②具名插槽</h3><p>如果在封装组件时需要预留多个插槽节点，则需要为每个 <slot> 插槽指定具体的 name 名称。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;div class=&quot;container&quot;&gt;<br>    &lt;header&gt;<br>      &lt;!-- 头部内容 --&gt;<br>      &lt;slot name=&quot;header&quot;&gt;&lt;/slot&gt;<br>    &lt;/header&gt;<br>    &lt;main&gt;<br>      &lt;!-- 主要内容 --&gt;<br>      &lt;slot&gt;&lt;/slot&gt;<br>    &lt;/main&gt;<br>    &lt;footer&gt;<br>      &lt;!-- 底部内容 --&gt;<br>      &lt;slot name=&quot;footer&quot;&gt;&lt;/slot&gt;<br>    &lt;/footer&gt;<br>&lt;/div&gt;<br><br>&lt;!--注意：没有指定 name 名称的插槽， 会有隐含的名称叫做 “default”。--&gt;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;my-com-2&gt;<br>    &lt;template v-slot:header&gt;<br>      &lt;h1&gt;标题&lt;/h1&gt;<br>    &lt;/template&gt;<br> <br>    &lt;template v-slot:default&gt;<br>      &lt;p&gt;内容&lt;/p&gt;<br>    &lt;/template&gt;<br> <br>    &lt;template #footer&gt;    &lt;!-- v-slot:的缩写为# --&gt;<br>      &lt;p&gt;结尾&lt;/p&gt;<br>    &lt;/template&gt;<br>&lt;/my-com-2&gt;<br></code></pre></td></tr></table></figure><h3 id="③作用域插槽-后续改进"><a href="#③作用域插槽-后续改进" class="headerlink" title="③作用域插槽(后续改进)"></a>③作用域插槽(后续改进)</h3><p>在封装组件的过程中，可以为预留的 <slot> 插槽绑定 props 数据，这种带有 props 数据的 <slot> 叫做“作用域插槽”。示例代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;tbody&gt;<br>    &lt;!-- 下面的slot是一个作用域插槽 --&gt;<br>    &lt;slot v-for=&quot;item in list&quot; :user=&quot;item&quot;&gt;&lt;/slot&gt;<br>&lt;/tbody&gt;<br></code></pre></td></tr></table></figure><p>作用域插槽对外提供的数据对象，可以使用解构赋值简化数据的接收过程。示例代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;my-com-3&gt;<br>    &lt;!-- 1.接收作用域插槽对外提供的数据 --&gt;<br>    &lt;template v-slot:default=&quot;scoped&quot;&gt;<br>      &lt;tr&gt;<br>        &lt;!-- 2.使用作用域插槽的数据 --&gt;<br>        &lt;td&gt;&#123;&#123; scoped &#125;&#125;&lt;/td&gt;<br>      &lt;/tr&gt;<br>    &lt;/template&gt;<br>&lt;/my-com-3&gt;<br></code></pre></td></tr></table></figure><p>作用域插槽对外提供的数据对象，可以使用解构赋值简化数据的接收过程。示例代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;my-com-3&gt;<br>    &lt;!-- v-slot: 可以简化成 # --&gt;<br>    &lt;template #default=&quot;&#123;user&#125;&quot;&gt;<br>      &lt;tr&gt;<br>        &lt;!-- 作用域插槽对外提供的数据 --&gt;<br>        &lt;td&gt;&#123;&#123; user.id &#125;&#125;&lt;/td&gt;<br>        &lt;td&gt;&#123;&#123; user.name &#125;&#125;&lt;/td&gt;<br>        &lt;td&gt;&#123;&#123; user.state &#125;&#125;&lt;/td&gt;<br>      &lt;/tr&gt;<br>    &lt;/template&gt;<br>  &lt;/my-com-3&gt;<br></code></pre></td></tr></table></figure><br><h2 id="2-react实现插槽"><a href="#2-react实现插槽" class="headerlink" title="2 react实现插槽"></a>2 react实现插槽</h2><p><em>注意：react中其实是没有插槽这个概念的</em></p><ol><li>默认插槽：通过组件标签体传入结构，固定写法<code>props.children</code>,即直接在组件标签内写内容，组件内部通过props.children能够拿到内容。</li><li>具名插槽：通过标签属性<code>props</code>传入结构</li></ol><p>默认插槽，使用的是函数式组件写法：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-comment">//子组件</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Son</span>(<span class="hljs-params">props</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>&#123;props.children&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>&#125;<br><span class="hljs-comment">//父组件</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params">props</span>) &#123;<br>    <span class="hljs-keyword">return</span> (<br>        <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">Son</span>&gt;</span></span><br><span class="language-xml">                <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>Hello World<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;/<span class="hljs-name">Son</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>    )<br>&#125;<br><span class="hljs-comment">//结果</span><br>&lt;div&gt;<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>Hello World<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>&lt;/div&gt;<br><br></code></pre></td></tr></table></figure><p>具名插槽，使用的是类组件写法：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; <span class="hljs-title class_">Component</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Component</span> &#123;<br>    <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">Son</span></span></span><br><span class="hljs-tag"><span class="language-xml">                <span class="hljs-attr">left</span>=<span class="hljs-string">&#123;</span>&lt;<span class="hljs-attr">div</span>&gt;</span>back<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>&#125;     //属性传值</span><br><span class="language-xml">                right=&#123;<span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>next<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>&#125;</span><br><span class="language-xml">            &gt;</span><br><span class="language-xml">            <span class="hljs-tag">&lt;/<span class="hljs-name">Son</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;/&gt;</span></span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Son</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Component</span> &#123;<br>    state = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;fang&#x27;</span> &#125;<br>    <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>&#123;this.props.left&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>   //props接受值</span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>&#123;this.props.right&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;/&gt;</span></span><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="React-Children-map"><a href="#React-Children-map" class="headerlink" title="React.Children.map"></a>React.Children.map</h3><p>this.props.children 的值有三种可能：</p><p>如果当前组件没有子节点，它就是 undefined ;<br>如果有一个子节点，数据类型是 Object；<br>如果有多个子节点，数据类型就是 Array。<br>所以，处理 this.props.children 的时候要小心</p><p>React 提供一个工具方法 React.Children 来处理 this.props.children 。我们可以用 React.Children.map 来遍历子节点，而不用担心 this.props.children 的数据类型是 undefined 还是 object。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; <span class="hljs-title class_">Component</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Component</span> &#123;<br>    <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;&gt;</span></span><br><span class="language-xml">            &#123;/* 没有子节点 */&#125;</span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">Son</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Son</span>&gt;</span></span><br><span class="language-xml">            &#123;/* 字符串 */&#125;</span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">Son</span>&gt;</span>Hello World<span class="hljs-tag">&lt;/<span class="hljs-name">Son</span>&gt;</span></span><br><span class="language-xml">            &#123;/* 一个子节点 */&#125;</span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">Son</span>&gt;</span></span><br><span class="language-xml">                <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>Hello React<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;/<span class="hljs-name">Son</span>&gt;</span></span><br><span class="language-xml">            &#123;/* 多个子节点 */&#125;</span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">Son</span>&gt;</span></span><br><span class="language-xml">                <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>apple<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">                <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>orange<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">                <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>banana<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;/<span class="hljs-name">Son</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;/&gt;</span></span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Son</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Component</span> &#123;<br>    state = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;fang&#x27;</span> &#125;<br>    <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;&gt;</span></span><br><span class="language-xml">            &#123;console.log(this.props.children)&#125;</span><br><span class="language-xml">            &#123;/* &#123;this.props.children&#125; */&#125;</span><br><span class="language-xml">            &#123;React.Children.map(this.props.children, (el) =&gt; &#123;</span><br><span class="language-xml">                return el</span><br><span class="language-xml">            &#125;)&#125;</span><br><span class="language-xml">        <span class="hljs-tag">&lt;/&gt;</span></span><br>    &#125;<br>&#125;<br><span class="hljs-comment">//console.log打印结果分别是</span><br><span class="hljs-comment">// undefined</span><br><span class="hljs-comment">// Hello World</span><br><span class="hljs-comment">// Object</span><br><span class="hljs-comment">// Array</span><br><br></code></pre></td></tr></table></figure><p>上面代码我们可以看出this.props.children既可以是对象，数组，undefined，那么按照平时处理数据的方式进行处理他的话，会显得很麻烦，那么我们就可以通过react官方提供的React.Children去进行处理，并且如果你想遍历它的话，可以通过React.Children.map去遍历它。</p><p>参考原文链接：</p><p><a href="https://blog.csdn.net/m0_51371862/article/details/120760430">https://blog.csdn.net/m0_51371862/article/details/120760430</a></p><p><a href="https://blog.csdn.net/linfeng_meng/article/details/126951889">https://blog.csdn.net/linfeng_meng/article/details/126951889</a></p>]]></content>
    
    
    <categories>
      
      <category>vue</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>react中状态更新及Immer</title>
    <link href="/2024/03/12/react%E4%B8%AD%E7%8A%B6%E6%80%81%E6%9B%B4%E6%96%B0%E5%8F%8AImmer/"/>
    <url>/2024/03/12/react%E4%B8%AD%E7%8A%B6%E6%80%81%E6%9B%B4%E6%96%B0%E5%8F%8AImmer/</url>
    
    <content type="html"><![CDATA[<h2 id="1-什么是状态值"><a href="#1-什么是状态值" class="headerlink" title="1 什么是状态值"></a>1 什么是状态值</h2><p>状态（state）是组件的一个重要概念，用于存储和管理组件的数据。每个React组件可以拥有自己的状态，这些状态可以随事件的发生改变，触发重新渲染</p><p><code>const [x, setX] = useState(0);</code></p><p><code>const [position,setPosition] = useState(&#123;x:0,y:0&#125;)</code></p><h2 id="2-状态更新"><a href="#2-状态更新" class="headerlink" title="2.状态更新"></a>2.状态更新</h2><p>状态可以保存任何类型的 JavaScript 值，包括对象，但是你<strong>不应该直接改变 React 状态</strong>。</p><p><strong>错误</strong>做法：</p><p><code>x=100</code></p><p><code>position.x = 10</code></p><p>这些类型的 JavaScript 值是 “不可变的”，表示不可更改或 “read-only”。你可以触发重新渲染以替换值</p><p>正确做法：<code>setX(5)</code></p><p><font color='yellow'>注意：<code>x</code> 状态从 <code>0</code> 变为 <code>5</code>，但数字 <code>0</code> 本身没有变化。无法对 JavaScript 中的数字、字符串和布尔值等内置原始值进行任何更改。</font></p><p>因此，更改position的值只能</p><p><code>setPosition(&#123;x:10,y:0&#125;)</code>  此时对象{x:10,y:0}可以看作是一个新对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//案例中</span><br><span class="hljs-comment">//错误做法：</span><br><span class="hljs-comment">//这段代码修改了从 之前的渲染 分配给 position 的对象。但是没有使用状态设置函数，React 不知道对象发生了变化。所以 React 不会做任何响应。</span><br>onPointerMove=&#123;<span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> &#123;<br>  position.<span class="hljs-property">x</span> = e.<span class="hljs-property">clientX</span>;<br>  position.<span class="hljs-property">y</span> = e.<span class="hljs-property">clientY</span>;<br>&#125;&#125;<br><br><span class="hljs-comment">//正确做法：</span><br><span class="hljs-comment">//使用setPosition，相当于告诉react：用新对象替换position，并再次渲染这个组件</span><br>onPointerMove=&#123;<span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> &#123;<br>  <span class="hljs-title function_">setPosition</span>(&#123;<br>    <span class="hljs-attr">x</span>: e.<span class="hljs-property">clientX</span>,<br>    <span class="hljs-attr">y</span>: e.<span class="hljs-property">clientY</span><br>  &#125;);<br>&#125;&#125;<br></code></pre></td></tr></table></figure><h2 id="3-对象状态更新的方法"><a href="#3-对象状态更新的方法" class="headerlink" title="3.对象状态更新的方法"></a>3.对象状态更新的方法</h2><p>主要有以下几种方法：</p><p><strong>①复制一份原来的对象</strong>（注意浅拷贝深拷贝！）复制方法可见博客：<a href="https://yang-fan01.gitee.io/2023/05/24/%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B-%E6%B5%85%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B7%B1%E6%8B%B7%E8%B4%9D/">https://yang-fan01.gitee.io/2023/05/24/%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B-%E6%B5%85%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B7%B1%E6%8B%B7%E8%B4%9D/</a></p><p><strong>②利用展开运算符</strong></p><p><strong>③利用第三方库实现对象状态更新（Immer）</strong>：<a href="https://github.com/immerjs/use-immer">Immer</a> 是一个流行的库，它允许你使用方便但可变的语法进行编写，并负责为你生成副本</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//利用展开运算符</span><br><span class="hljs-keyword">import</span> &#123; useState &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Form</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [person, setPerson] = <span class="hljs-title function_">useState</span>(&#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Niki de Saint Phalle&#x27;</span>,<br>    <span class="hljs-attr">artwork</span>: &#123;<br>      <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;Blue Nana&#x27;</span>,<br>      <span class="hljs-attr">city</span>: <span class="hljs-string">&#x27;Hamburg&#x27;</span>,<br>      <span class="hljs-attr">image</span>: <span class="hljs-string">&#x27;https://i.imgur.com/Sd1AgUOm.jpg&#x27;</span>,<br>    &#125;<br>  &#125;);<br><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">handleNameChange</span>(<span class="hljs-params">e</span>) &#123;<br>    <span class="hljs-title function_">setPerson</span>(&#123;<br>      ...person,   <span class="hljs-comment">//展开运算符</span><br>      <span class="hljs-attr">name</span>: e.<span class="hljs-property">target</span>.<span class="hljs-property">value</span><br>    &#125;);<br>  &#125;<br><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">handleTitleChange</span>(<span class="hljs-params">e</span>) &#123;<br>    <span class="hljs-title function_">setPerson</span>(&#123;<br>      ...person,<br>      <span class="hljs-attr">artwork</span>: &#123;<br>        ...person.<span class="hljs-property">artwork</span>,   <span class="hljs-comment">//多层则利用多次展开运算符</span><br>        <span class="hljs-attr">title</span>: e.<span class="hljs-property">target</span>.<span class="hljs-property">value</span><br>      &#125;<br>    &#125;);<br>  &#125;<br><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">handleImageChange</span>(<span class="hljs-params">e</span>) &#123;<br>    <span class="hljs-title function_">setPerson</span>(&#123;<br>      ...person,<br>      <span class="hljs-attr">artwork</span>: &#123;<br>        ...person.<span class="hljs-property">artwork</span>,<br>        <span class="hljs-attr">image</span>: e.<span class="hljs-property">target</span>.<span class="hljs-property">value</span><br>      &#125;<br>    &#125;);<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;&gt;</span></span><br><span class="language-xml">      ...</span><br><span class="language-xml">    <span class="hljs-tag">&lt;/&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//利用Immer库</span><br><span class="hljs-keyword">import</span> &#123; useImmer &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;use-immer&#x27;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Form</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [person, updatePerson] = <span class="hljs-title function_">useImmer</span>(&#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Niki de Saint Phalle&#x27;</span>,<br>    <span class="hljs-attr">artwork</span>: &#123;<br>      <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;Blue Nana&#x27;</span>,<br>      <span class="hljs-attr">city</span>: <span class="hljs-string">&#x27;Hamburg&#x27;</span>,<br>      <span class="hljs-attr">image</span>: <span class="hljs-string">&#x27;https://i.imgur.com/Sd1AgUOm.jpg&#x27;</span>,<br>    &#125;<br>  &#125;);<br><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">handleNameChange</span>(<span class="hljs-params">e</span>) &#123;<br>    <span class="hljs-title function_">updatePerson</span>(<span class="hljs-function"><span class="hljs-params">draft</span> =&gt;</span> &#123;<br>      draft.<span class="hljs-property">name</span> = e.<span class="hljs-property">target</span>.<span class="hljs-property">value</span>;<br>    &#125;);<br>  &#125;<br><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">handleTitleChange</span>(<span class="hljs-params">e</span>) &#123;<br>    <span class="hljs-title function_">updatePerson</span>(<span class="hljs-function"><span class="hljs-params">draft</span> =&gt;</span> &#123;<br>      draft.<span class="hljs-property">artwork</span>.<span class="hljs-property">title</span> = e.<span class="hljs-property">target</span>.<span class="hljs-property">value</span>;<br>    &#125;);<br>  &#125;<br><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">handleCityChange</span>(<span class="hljs-params">e</span>) &#123;<br>    <span class="hljs-title function_">updatePerson</span>(<span class="hljs-function"><span class="hljs-params">draft</span> =&gt;</span> &#123;<br>      draft.<span class="hljs-property">artwork</span>.<span class="hljs-property">city</span> = e.<span class="hljs-property">target</span>.<span class="hljs-property">value</span>;<br>    &#125;);<br>  &#125;<br><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">handleImageChange</span>(<span class="hljs-params">e</span>) &#123;<br>    <span class="hljs-title function_">updatePerson</span>(<span class="hljs-function"><span class="hljs-params">draft</span> =&gt;</span> &#123;<br>      draft.<span class="hljs-property">artwork</span>.<span class="hljs-property">image</span> = e.<span class="hljs-property">target</span>.<span class="hljs-property">value</span>;<br>    &#125;);<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;&gt;</span></span><br><span class="language-xml">      ...</span><br><span class="language-xml">    <span class="hljs-tag">&lt;/&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-更新数组状态"><a href="#4-更新数组状态" class="headerlink" title="4.更新数组状态"></a>4.更新数组状态</h2><p>数组其实也是对象，所以第三点中的完全符合</p><p>数组主要就是要区分哪些操作会影响原数组，哪些操作会返回一个新数组</p><p><img src="image-20240312193025713.png" alt="image-20240312193025713"></p><p>注意区分splice和slice</p><p><img src="image-20240312193054300.png" alt="image-20240312193054300"></p><p>详细可见react官网：<a href="https://react.nodejs.cn/learn/updating-arrays-in-state">https://react.nodejs.cn/learn/updating-arrays-in-state</a></p>]]></content>
    
    
    <categories>
      
      <category>react</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>promise-async与await</title>
    <link href="/2024/03/08/promise-async%E4%B8%8Eawait/"/>
    <url>/2024/03/08/promise-async%E4%B8%8Eawait/</url>
    
    <content type="html"><![CDATA[<h2 id="1-回调地狱问题？"><a href="#1-回调地狱问题？" class="headerlink" title="1.回调地狱问题？"></a>1.回调地狱问题？</h2><p>回调地狱，就是异步调用获取到结果后，为下一个异步函数提供参数，所以就会一层一层的出现回调里面嵌入回调，导致层次很深，代码维护起来特别的复杂。</p><p>如下案例所示。uniapp中request请求就是一个异步函数，需要依次 获取列表id &#x3D;》用列表id获取文章 &#x3D;》用文章id获取评论</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs vue">getData()&#123;<br>  //获取分类列表id<br>  uni.request(&#123;<br>    url:&quot;https://ku.qingnian8.com/dataApi/news/navlist.php&quot;,<br>    success:res=&gt;&#123;<br>      let id=res.data[0].id<br>      // 根据分类id获取该分类下的所有文章<br>      uni.request(&#123;<br>        url:&quot;https://ku.qingnian8.com/dataApi/news/newslist.php&quot;,<br>        data:&#123;<br>          cid:id<br>        &#125;,<br>        success:res2=&gt;&#123;<br>          //获取到一篇文章的id，根据文章id找到该文章下的评论<br>          let id=res2.data[0].id;<br>          uni.request(&#123;<br>            url:&quot;https://ku.qingnian8.com/dataApi/news/comment.php&quot;,<br>            data:&#123;<br>              aid:id<br>            &#125;,<br>            success:res3=&gt;&#123;<br>              //找到该文章下所有的评论<br>              console.log(res3)<br>            &#125;<br>          &#125;)<br>        &#125;<br>      &#125;)<br><br>    &#125;<br>  &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p>在ES6promise出现之前，上述问题的优化方法：将功能封装，然后嵌套调用（本质还是回调地狱）</p><p>功能封装：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs vue">methods: &#123;<br>    //先获取导航分类接口，将结果进行返回，到调用函数的地方获取<br>    getNav(callback)&#123;<br>      uni.request(&#123;<br>        url:&quot;https://ku.qingnian8.com/dataApi/news/navlist.php&quot;,<br>        success:res=&gt;&#123;<br>          callback(res)<br>        &#125;<br>      &#125;)<br>    &#125;,<br><br>    //获取文章数据，将文章列表进行返回<br>    getArticle(id,callback)&#123;<br>      uni.request(&#123;<br>        url:&quot;https://ku.qingnian8.com/dataApi/news/newslist.php&quot;,<br>        data:&#123;<br>          cid:id<br>        &#125;,<br>        success:res=&gt;&#123;<br>          callback(res)<br>        &#125;<br>      &#125;)<br>    &#125;,<br><br>      //获取文章下的所有评论<br>      getComment(id,callback)&#123;<br>        uni.request(&#123;<br>          url:&quot;https://ku.qingnian8.com/dataApi/news/comment.php&quot;,<br>          data:&#123;<br>            aid:id<br>          &#125;,<br>          success:res=&gt;&#123;<br>            callback(res)<br>          &#125;<br>        &#125;)<br>      &#125;<br>&#125; <br></code></pre></td></tr></table></figure><p>功能调用：本质还是多层嵌套，没有解决回调地狱，但是代码可读性变高了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs vue">//在onload初始化后调用相应的函数<br>onLoad() &#123;<br>  //调用导航函数，并拿到函数的返回值<br>  this.getNav(res=&gt;&#123;<br>    let id=res.data[0].id;<br>    //拿到分类id作为参数<br>    this.getArticle(id,res2=&gt;&#123;<br>      //拿到文章id作为参数<br>      let id=res2.data[0].id;<br>      this.getComment(id,res3=&gt;&#123;<br>        //最终获取到第一个分类下，第一篇文章下，所有评论<br>        console.log(res3)<br>      &#125;)<br>    &#125;)<br>  &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><br><h2 id="2-ES6-Promise"><a href="#2-ES6-Promise" class="headerlink" title="2.ES6-Promise"></a>2.ES6-Promise</h2><p>promise是<strong>解决异步</strong>的方法，本质上是一个<em><strong>构造函数</strong></em>，可以用它实例化一个对象。</p><p><strong>对象</strong>身上有resolve、reject、all，<strong>原型</strong>上有then、catch方法。</p><p>我们可以利用<code>console.dir(Promise)</code>查看其构造函数本身的方法以及原型上的方法。</p><p><img src="635325a24b82fc2a4d93f680bc4716050a1b4c00.png@!web-article-pic.avif" alt="img"></p><p>promise对象有三种状态：pending（初识状态&#x2F;进行中）、fulfilled（成功）、rejected（失败）</p><ol><li><p>pending。它的意思是 “待定的，将发生的”，相当于是一个初始状态。创建Promise对象时，且没有调用resolve或者是reject方法，相当于是初始状态。这个初始状态会随着你调用resolve，或者是reject函数而切换到另一种状态。 </p><p><img src="e88fe23f57f762727dbb830804611d1f8b0c2de3.png@!web-article-pic.avif" alt="img"></p></li><li><p>fulfilled(或resolved)。表示解决了，就是说这个承诺实现了。 要实现从pending到fulfilled(或resolved)的转变，需要在 创建Promise对象时，在函数体中调用了resolve方法。</p><p><img src="d63f6b0479759c50fdfbce3e5e895e4e554ed7b0.png@!web-article-pic.avif" alt="img"></p></li><li><p>rejected。拒绝，失败。表示这个承诺没有做到，失败了。要实现从pending到rejected的转换，只需要在创建Promise对象时，调用reject函数。</p><p><img src="6b9fca24a24a7a938a8a88a9b8090d6c0c4103f0.png@!web-article-pic.avif" alt="img"></p><br></li></ol><h3 id="利用promise解决回调地狱问题。"><a href="#利用promise解决回调地狱问题。" class="headerlink" title="利用promise解决回调地狱问题。"></a>利用promise解决回调地狱问题。</h3><p>封装功能，每个函数都返回一个promise对象，只有promise对象才有.then方法，才能链式调用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs vue">methods: &#123;<br>    //先获取导航分类接口，将结果进行返回，到调用函数的地方获取<br>    getNav(callback)&#123;<br>      return new Promise((resolve,reject)=&gt;&#123;   //返回值为一个promise对象，只有promise对象才有.then方法，才能链式调用<br>        uni.request(&#123;<br>          url:&quot;https://ku.qingnian8.com/dataApi/news/navlist.php&quot;,<br>          success:res=&gt;&#123;<br>            resolve(res)        //成功回调：执行resolve方法   pending -&gt; fulfilled<br>          &#125;,<br>          fail:err=&gt;&#123;<br>            reject(err)         //失败回调：执行reject方法    pending -&gt; rejected<br>          &#125;<br>        &#125;)<br>      &#125;)<br>    &#125;,<br><br><br>    //获取文章数据，将文章列表进行返回<br>    getArticle(id)&#123;<br>      return new Promise((resolve,reject)=&gt;&#123;    //返回值为一个promise对象，只有promise对象才有.then方法，才能链式调用<br>        uni.request(&#123;<br>          url:&quot;https://ku.qingnian8.com/dataApi/news/newslist.php&quot;,<br>          data:&#123;<br>            cid:id<br>          &#125;,<br>          success:res=&gt;&#123;<br>            resolve(res)<br>          &#125;,<br>          fail:err=&gt;&#123;<br>            reject(err)<br>          &#125;<br>        &#125;)<br>      &#125;)<br>    &#125;,<br><br>      //获取文章下的所有评论<br>      getComment(id)&#123;<br>        return new Promise((resolve,reject)=&gt;&#123;  //返回值为一个promise对象，只有promise对象才有.then方法，才能链式调用<br>          uni.request(&#123;<br>            url:&quot;https://ku.qingnian8.com/dataApi/news/comment.php&quot;,<br>            data:&#123;<br>              aid:id<br>            &#125;,<br>            success:res=&gt;&#123;<br>              resolve(res)<br>            &#125;,<br>            fail:err=&gt;&#123;<br>              reject(err)<br>            &#125;<br>          &#125;)<br>        &#125;)<br><br>&#125;<br></code></pre></td></tr></table></figure><p>.then链式调用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs vue">this.getNav()<br>.then(res=&gt;&#123;<br>  let id=res.data[0].id;<br>  return this.getArticle(id);  //返回promise对象<br>&#125;)<br>.then(res=&gt;&#123;<br>  let id=res.data[0].id;<br>  return this.getComment(id)<br>&#125;)<br>.then(res=&gt;&#123;<br>  console.log(res)<br>&#125;) <br>.catch(err=&gt;&#123;<br>  console.log(err)<br>&#125;)<br></code></pre></td></tr></table></figure><p>promise的优点：解决了回调地狱的问题，增强了代码的可读性。</p><p>promise的缺点：大量then的使用。&#x3D;》es7 async、await</p><br><h2 id="3-ES7-async、await-异步处理同步化"><a href="#3-ES7-async、await-异步处理同步化" class="headerlink" title="3.ES7-async、await 异步处理同步化"></a>3.ES7-async、await 异步处理同步化</h2><p>定义：</p><p><code>async 是异步的意思，await则可以理解为 async wait。所以可以理解async就是用来声明一个异步方法，而 await是用来等待异步方法执行 async作为一个关键字放在函数前面，表示该函数是一个异步函数，异步函数意味着该函数的执行不会阻塞后面代码的执行；而 await 用于等待一个异步方法执行完成； await 等待一个 Promise 对象，如果 Promise的状态变成了 resolve 或者 rejcet，那么 async函数会恢复执行。并会阻塞该函数内后面的代码。 使用 async/await 可以实现用同步代码的风格来编写异步代码，这是因为 async/await 的基础技术使用了生成器和 Promise，生成器是协程的实现，利用生成器能实现生成器函数的暂停和恢复。 为了优化 .then 链而开发出来的。</code></p><p>async和await必须成对出现，如果只有await会报错，如果只有async不会报错，但也没效果</p><p>使用方法：上述2中，.then方法利用async、await来优化</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs vue">async onLoad() &#123;<br>  let id,res;<br>  res=await this.getNav();   //await等待的是一个promise对象<br>  id=res.data[0].id;<br>  res=await this.getArticle(id);<br>  id=res.data[0].id;<br>  res=await this.getComment(id);<br>  console.log(res)<br>&#125;<br></code></pre></td></tr></table></figure><p>关于async、await详细讲解见此博客：<a href="https://blog.csdn.net/weixin_45811256/article/details/123638582?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522170986334516800184170309%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=170986334516800184170309&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-123638582-null-null.142%5Ev99%5Econtrol&utm_term=async%20await&spm=1018.2226.3001.4187">https://blog.csdn.net/weixin_45811256/article/details/123638582?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522170986334516800184170309%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=170986334516800184170309&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-123638582-null-null.142^v99^control&amp;utm_term=async%20await&amp;spm=1018.2226.3001.4187</a></p><p>本文参考：作者：咸虾米_ <a href="https://www.bilibili.com/read/cv18799030/">https://www.bilibili.com/read/cv18799030/</a> 出处：bilibili</p>]]></content>
    
    
    <categories>
      
      <category>javascript</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>前端面试题</title>
    <link href="/2024/03/06/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <url>/2024/03/06/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>[toc]</p><h3 id="大前端面试题"><a href="#大前端面试题" class="headerlink" title="大前端面试题"></a>大前端面试题</h3><p>​作者：kerwin</p><p>​版本：QF1.0</p><p>​版权：千锋HTML5大前端教研院</p><p>​公众号: 大前端私房菜</p><blockquote><p><strong>千锋精品教程，好学得不像实力派！</strong></p></blockquote><h4 id="一-HTML5面试题"><a href="#一-HTML5面试题" class="headerlink" title="一. HTML5面试题"></a>一. HTML5面试题</h4><h5 id="1-如何理解HTML5结构语义化？"><a href="#1-如何理解HTML5结构语义化？" class="headerlink" title="1. 如何理解HTML5结构语义化？"></a>1. 如何理解HTML5结构语义化？</h5><p>简单来说，我们可以理解为：<strong>用正确的标签做正确的事情。</strong></p><p>段落用 p 标签，标题用 h 系列标签，边栏用 aside 标签，主要内容用 main 标签。</p><p>对开发者：</p><ul><li><p>便于团队的开发和维护。</p></li><li><p>在没有加载 CSS 的情况下也能呈现较好的内容结构与代码结构，易于阅读。</p></li></ul><p>对浏览器：</p><ul><li><p>有利于 SEO ，搜索引擎的爬⾍依赖于标签来确定上下⽂和各个关键字的权重。</p></li><li><p>方便其他设备的解析（如屏幕阅读器、盲人阅读器等），利于无障碍阅读，提⾼可访问性。</p></li></ul><h5 id="2-html5的新特性？"><a href="#2-html5的新特性？" class="headerlink" title="2. html5的新特性？"></a>2. html5的新特性？</h5><ul><li><p>HTML5 现在已经不是 SGML 的子集，主要是关于图像，位置，存储，多任务等功能的增加</p><ul><li>用于媒介回放的 video 和 audio 元素</li><li>本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失</li><li>sessionStorage 的数据在浏览器关闭后自动删除</li><li>语意化更好的内容元素，比如 article、footer、header、nav、section</li><li>表单控件，calendar、date、time、email、url、search</li><li>新的技术webworker, websocket, Geolocation</li></ul></li><li><p>移除的元素：</p><ul><li>纯表现的元素：basefont，big，center，font, s，strike，tt，u</li><li>对可用性产生负面影响的元素：frame，frameset，noframes</li></ul></li><li><p>支持HTML5新标签：</p><ul><li>IE8&#x2F;IE7&#x2F;IE6支持通过document.createElement方法产生的标签</li><li>可以利用这一特性让这些浏览器支持HTML5新标签</li><li>浏览器支持新标签后，还需要添加标签默认的样式</li></ul></li><li><p>当然也可以直接使用成熟的框架、比如html5shim</p></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--[if lt IE 9]&gt;</span><br><span class="hljs-comment">&lt;script&gt; src=&quot;http://html5shim.googlecode.com</span><br><span class="hljs-comment">/svn/trunk/html5.js&quot;&lt;/script&gt;&lt;![endif]--&gt;</span><br></code></pre></td></tr></table></figure><ul><li>如何区分HTML5： DOCTYPE声明\新增的结构元素\功能元素</li></ul><h5 id="3-请描述一下-cookies，sessionStorage-和-localStorage-的区别？"><a href="#3-请描述一下-cookies，sessionStorage-和-localStorage-的区别？" class="headerlink" title="3. 请描述一下 cookies，sessionStorage 和 localStorage 的区别？"></a>3. 请描述一下 cookies，sessionStorage 和 localStorage 的区别？</h5><ul><li><p>cookie是网站为了标示用户身份而储存在用户本地终端（Client Side）上的数据（通常经过加密）</p></li><li><p>cookie数据始终在同源的http请求中携带（即使不需要），即会在浏览器和服务器间来回传递</p></li><li><p><code>sessionStorage</code>和<code>localStorage</code>不会自动把数据发给服务器，仅在本地保存</p></li><li><p>存储大小：</p><ul><li><code>cookie</code>数据大小不能超过4k</li><li><code>sessionStorage</code>和<code>localStorage</code>虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大</li></ul></li><li><p>有期时间：</p><ul><li><code>localStorage</code> 存储持久数据，浏览器关闭后数据不丢失除非主动删除数据</li><li><code>sessionStorage</code>  数据在当前浏览器窗口关闭后自动删除</li><li><code>cookie</code>  设置的<code>cookie</code>过期时间之前一直有效，即使窗口或浏览器关闭</li></ul></li></ul><h5 id="4-浏览器的渲染机制一般分为几个步骤-（4，5详见-https-yang-fan01-gitee-io-2023-05-10-E6-B5-8F-E8-A7-88-E5-99-A8-E6-98-AF-E5-A6-82-E4-BD-95-E6-B8-B2-E6-9F-93-E9-A1-B5-E9-9D-A2-E7-9A-84-）"><a href="#4-浏览器的渲染机制一般分为几个步骤-（4，5详见-https-yang-fan01-gitee-io-2023-05-10-E6-B5-8F-E8-A7-88-E5-99-A8-E6-98-AF-E5-A6-82-E4-BD-95-E6-B8-B2-E6-9F-93-E9-A1-B5-E9-9D-A2-E7-9A-84-）" class="headerlink" title="4. 浏览器的渲染机制一般分为几个步骤?     （4，5详见 https://yang-fan01.gitee.io/2023/05/10/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%98%AF%E5%A6%82%E4%BD%95%E6%B8%B2%E6%9F%93%E9%A1%B5%E9%9D%A2%E7%9A%84/）"></a>4. 浏览器的渲染机制一般分为几个步骤?     （4，5详见 <a href="https://yang-fan01.gitee.io/2023/05/10/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%98%AF%E5%A6%82%E4%BD%95%E6%B8%B2%E6%9F%93%E9%A1%B5%E9%9D%A2%E7%9A%84/%EF%BC%89">https://yang-fan01.gitee.io/2023/05/10/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%98%AF%E5%A6%82%E4%BD%95%E6%B8%B2%E6%9F%93%E9%A1%B5%E9%9D%A2%E7%9A%84/）</a></h5><ul><li><p>处理 <code>HTML</code> 并构建 <code>DOM</code> 树。</p></li><li><p>处理 <code>CSS</code> 构建 <code>CSSOM</code> 树。</p></li><li><p>将 <code>DOM</code> 与 <code>CSSOM</code> 合并成一个渲染树。</p></li><li><p>根据渲染树来布局，计算每个节点的位置。</p></li><li><p>调用 <code>GPU</code> 绘制，合成图层，显示在屏幕上。</p><p><strong>注意：</strong></p></li><li><p>在构建 CSSOM 树时，会阻塞渲染，直至 CSSOM 树构建完成。并且构建 CSSOM 树是一个十分消耗性能的过程，所以应该尽量保证层级扁平，减少过度层叠，越是具体的 CSS 选择器，执行速度越慢</p></li><li><p>当 HTML 解析到 script 标签时，会暂停构建 DOM，完成后才会从暂停的地方重新开始。也就是说，如果你想首屏渲染的越快，就越不应该在首屏就加载 JS 文件。</p></li></ul><h5 id="5-重绘（Repaint）和回流（Reflow）"><a href="#5-重绘（Repaint）和回流（Reflow）" class="headerlink" title="5. 重绘（Repaint）和回流（Reflow）"></a>5. 重绘（Repaint）和回流（Reflow）</h5><ul><li>重绘是当节点需要更改外观而不会影响布局的，比如改变 color 就叫称为重绘</li><li>回流是布局或者几何属性需要改变就称为回流（需要计算它们在设备视口(viewport)内的确切位置和大小）</li></ul><blockquote><p>回流必定会发生重绘，重绘不一定会引发回流。回流所需的成本比重绘高的多，改变深层次的节点很可能导致父节点的一系列回流</p></blockquote><p><em>所以以下几个动作可能会导致性能问题：</em></p><ul><li>添加或删除可见的DOM元素</li><li>元素的位置发生变化</li><li>元素的尺寸发生变化（包括外边距、内边框、边框大小、高度和宽度等）</li><li>内容发生变化，比如文本变化或图片被另一个不同尺寸的图片所替代。</li><li>定位或者浮动</li><li>浏览器的窗口尺寸变化（因为回流是根据视口的大小来计算元素的位置和大小的）</li></ul><p><em>减少重绘和回流</em></p><ul><li><p>批量修改DOM</p></li><li><p>对于复杂动画效果,使用绝对定位让其脱离文档流</p></li><li><p>css3硬件加速（GPU加速）transform、opacity、filters这些动画不会引起回流重绘</p></li></ul><h5 id="6-简述data-属性的用法（如何设置，如何获取），有何优势？"><a href="#6-简述data-属性的用法（如何设置，如何获取），有何优势？" class="headerlink" title="6.  简述data:属性的用法（如何设置，如何获取），有何优势？"></a>6.  简述data:属性的用法（如何设置，如何获取），有何优势？</h5><p>data-* 的值的获取和设置，2种方法：</p><p>1）传统方法 getAttribute() 获取data-属性值； setAttribute() 设置data-属性值</p><p>getAttribute() 获取data-属性值；</p><p>setAttribute() 设置data-属性值</p><p>2)HTML5新⽅法 </p><p>例如 data-kerwin</p><p>dataset.kerwin 获取data-kerwin属性值</p><p>dataset.kerwin &#x3D; “赵钱孙李” 设置data-kerwin属性值</p><p>注意：</p><ul><li><p>传统⽅法⽆兼容性问题，但是不够优雅、⽅便</p></li><li><p>HTML5新⽅法很优雅、⽅便，但是有兼容性问题。</p></li></ul><p>优势：⾃定义的数据可以让⻚⾯拥有更好的交互体验（不需要使⽤ Ajax 或去服务端查询数据）</p><h4 id="二-CSS面试题"><a href="#二-CSS面试题" class="headerlink" title="二. CSS面试题"></a>二. CSS面试题</h4><h5 id="1-display-none-与-visibility-hidden-的区别"><a href="#1-display-none-与-visibility-hidden-的区别" class="headerlink" title="1. display: none; 与 visibility: hidden; 的区别"></a>1. display: none; 与 visibility: hidden; 的区别</h5><ul><li>联系：它们都能让元素不可见</li><li>区别：<ul><li><code>display:none</code>;会让元素完全从渲染树中消失，渲染的时候不占据任何空间；<code>visibility: hidden</code>;不会让元素从渲染树消失，渲染师元素继续占据空间，只是内容不可见</li><li>修改常规流中元素的<code>display</code>通常会造成文档重排。修改<code>visibility</code>属性只会造成本元素的重绘</li></ul></li></ul><h5 id="2-外边距折叠-collapsing-margins"><a href="#2-外边距折叠-collapsing-margins" class="headerlink" title="2. 外边距折叠(collapsing margins)"></a>2. 外边距折叠(collapsing margins)</h5><ul><li>毗邻的两个或多个 <code>margin</code> 会合并成一个<code>margin</code>，叫做外边距折叠。规则如下：<ul><li>两个或多个毗邻的普通流中的块元素垂直方向上的<code>margin</code>会折叠</li><li>浮动元素或<code>inline-block</code>元素或绝对定位元素的<code>margin</code>不会和垂直方向上的其他元素的margin折叠</li><li>创建了块级格式化上下文（BFC）的元素，不会和它的子元素发生margin折叠</li></ul></li></ul><h5 id="3-z-index是什么？在position的值什么时候可以触发"><a href="#3-z-index是什么？在position的值什么时候可以触发" class="headerlink" title="3. z-index是什么？在position的值什么时候可以触发?"></a>3. z-index是什么？在position的值什么时候可以触发?</h5><p>z-index 属性设置元素的堆叠顺序。拥有更⾼堆叠顺序的元素总是会处于堆叠顺序较低的元素的前⾯，当 脱离⽂档流内容较多，并且相互重叠的时候，就有可能发⽣本想完全显示的内容被其他内容遮挡的结 果，这时我们就需要⼈为指定哪个层在上⾯，哪个在下⾯，z-index属性就是⼲这个⽤的。</p><p>注意：Z-index 仅能在定位元素上奏效.</p><p>在position的值是relative、absolute、fixed、sticky时候可以触发</p><h5 id="4-简述box-sizing的有效值以及所对应的盒模型规则"><a href="#4-简述box-sizing的有效值以及所对应的盒模型规则" class="headerlink" title="4. 简述box-sizing的有效值以及所对应的盒模型规则"></a>4. 简述box-sizing的有效值以及所对应的盒模型规则</h5><p>box-sizing 属性允许您以特定的⽅式定义匹配某个区域的特定元素。</p><p>语法：box-sizing: content-box|border-box|inherit;</p><p>1）box-sizing:content-box；这是由 CSS2.1 规定的宽度⾼度⾏为。宽度和⾼度分别应⽤到元素的内容框。 在宽度和⾼度之外绘制元素的内边距和边框。是默认值。如果你设置⼀个元素的宽为100px，那么这个元 素的内容区会有100px 宽，并且任何边框和内边距的宽度都会被增加到最后绘制出来的元素宽度中</p><p>2）box-sizing:border-box；为元素指定的任何内边距和边框都将在已设定的宽度和⾼度内进⾏绘制。告诉 浏览器去理解你设置的边框和内边距的值是包含在width内的。也就是说，如果你将⼀个元素的width设 为100px,那么这100px会包含其它的border和padding，内容区的实际宽度会是width减去border + padding 的计算值。⼤多数情况下这使得我们更容易的去设定⼀个元素的宽⾼</p><p>3）box-sizing:inherit;；规定应从⽗元素继承 box-sizing 属性的值</p><h5 id="5-移动端适配怎么做？"><a href="#5-移动端适配怎么做？" class="headerlink" title="5. 移动端适配怎么做？"></a>5. 移动端适配怎么做？</h5><p>1） meta viewport（视⼝）</p><p>移动端初始视⼝的⼤⼩为什么默认是980px？</p><p>因为世界上绝⼤多数PC⽹⻚的版⼼宽度为 980px ，如果⽹⻚没有专⻔做移动端适配，此时⽤⼿机访问⽹ ⻚旁边刚好没有留⽩，不过⻚⾯缩放后⽂字会变得⾮常⼩。</p><p>为了解决⻚⾯缩放的体验问题，在⽹⻚代码的头部，加⼊⼀⾏viewport元标签。</p><p>这⾥的device-width告诉浏览器，将视⼝的宽度设置为设备宽度（这个宽度是⼈为预设的，不设的话就是 980px）。 属性含义</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">initial-<span class="hljs-keyword">scale：第⼀次进⼊⻚⾯的初始⽐例</span><br><span class="hljs-keyword"></span> minimum-<span class="hljs-keyword">scale：允许缩⼩最⼩⽐例</span><br><span class="hljs-keyword"></span> maximum-<span class="hljs-keyword">scale：允许放⼤最⼤⽐例</span><br><span class="hljs-keyword"></span> user-<span class="hljs-keyword">scalable：允许使⽤者缩放，1 </span><span class="hljs-keyword">or </span><span class="hljs-number">0</span> (yes <span class="hljs-keyword">or </span>no)<br></code></pre></td></tr></table></figure><p>2） 图⽚适配</p><p>img { max-width: 100%; } 此时图⽚会⾃动缩放，同时图⽚最⼤显示为其⾃身的100%（即最⼤只 可以显示为⾃身那么⼤） 为什么不⽤ img { width: 100%; } ？ 当容器⼤于图⽚宽度时，图⽚会⽆ 情的拉伸变形</p><p>3） 媒体查询</p><p>为什么要媒体查询？</p><p>针对不⽤的设备提前为⽹⻚设定各种 CSS 样式CSS3中的Media Query模块，⾃动检测屏幕宽度，然后加载 相应的CSS⽂件 </p><p>语法举例</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-keyword">@media</span> screen <span class="hljs-keyword">and</span> (<span class="hljs-attribute">min-width</span>:<span class="hljs-number">1200px</span>)&#123;<br> <span class="hljs-selector-tag">body</span>&#123;<br> <span class="hljs-attribute">background-color</span>: red;<br> &#125;<br></code></pre></td></tr></table></figure><p>当屏幕宽度⼤于1200px时，背景⾊变为红⾊</p><p>4） 动态 rem ⽅案</p><p>为什么要⽤rem？</p><p>和媒体查询配合，实现响应式布局</p><p>px、em、rem 有什么不同？</p><p>px是pixel（像素），是屏幕上显示数据的最基本的点，在HTML中，默认的单位就是px；em 是⼀个相对 ⼤⼩，相对于⽗元素font-size的百分⽐⼤⼩rem 是相对于根元素的font-size</p><p>⽤法示例</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment"> * @作者: kerwin</span><br><span class="hljs-comment"> * @公众号: 大前端私房菜</span><br><span class="hljs-comment">--&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">        *&#123;</span><br><span class="language-css">            <span class="hljs-attribute">margin</span>:<span class="hljs-number">0</span>;</span><br><span class="language-css">            <span class="hljs-attribute">padding</span>:<span class="hljs-number">0</span>;</span><br><span class="language-css">        &#125;</span><br><span class="language-css"></span><br><span class="language-css">        <span class="hljs-selector-tag">html</span>&#123;</span><br><span class="language-css">            <span class="hljs-attribute">font-size</span>: <span class="hljs-number">100px</span>;</span><br><span class="language-css">        &#125;</span><br><span class="language-css">        <span class="hljs-selector-tag">body</span>&#123;</span><br><span class="language-css">            <span class="hljs-attribute">font-size</span>: <span class="hljs-number">16px</span>;</span><br><span class="language-css">        &#125;</span><br><span class="language-css"></span><br><span class="language-css">        <span class="hljs-selector-class">.box</span>&#123;</span><br><span class="language-css">            <span class="hljs-attribute">width</span>: <span class="hljs-number">7.5rem</span>;</span><br><span class="language-css">            <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;</span><br><span class="language-css">            <span class="hljs-attribute">background</span>:yellow;</span><br><span class="language-css">            <span class="hljs-comment">/* font-size: 16px; */</span></span><br><span class="language-css">        &#125;</span><br><span class="language-css">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">        <span class="hljs-comment">//fontsize 计算   </span></span><br><span class="language-javascript">        <span class="hljs-variable language_">document</span>.<span class="hljs-property">documentElement</span>.<span class="hljs-property">style</span>.<span class="hljs-property">fontSize</span>=<span class="hljs-variable language_">document</span>.<span class="hljs-property">documentElement</span>.<span class="hljs-property">clientWidth</span>/<span class="hljs-number">750</span> * <span class="hljs-number">100</span> +<span class="hljs-string">&#x27;px&#x27;</span></span><br><span class="language-javascript"></span><br><span class="language-javascript"></span><br><span class="language-javascript">        <span class="hljs-comment">// fontsize = 当前设备的css布局宽度/物理分辨率(设计稿的宽度)* 基准font-size</span></span><br><span class="language-javascript">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;box&quot;</span>&gt;</span><br>        赵钱孙李<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h5 id="6-什么是CSS3-transform-transition-animation-区别是什么？"><a href="#6-什么是CSS3-transform-transition-animation-区别是什么？" class="headerlink" title="6.  什么是CSS3 transform? transition? animation? 区别是什么？"></a>6.  什么是CSS3 transform? transition? animation? 区别是什么？</h5><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs css">CSS3属性中关于制作动画的三个属性：<span class="hljs-attribute">Transform</span>,<span class="hljs-attribute">Transition</span>,<span class="hljs-attribute">Animation</span>。<br><span class="hljs-number">1</span>、<span class="hljs-attribute">transform</span>：描述了元素的静态样式，本身不会呈现动画效果，可以对元素进⾏ 旋转rotate、扭曲skew、缩放<br>scale和移动translate以及矩阵变形matrix。<br><span class="hljs-selector-tag">div</span>&#123;<br>　　<span class="hljs-attribute">transform</span>:<span class="hljs-built_in">scale</span>(<span class="hljs-number">2</span>);<br>&#125;<br><br><span class="hljs-attribute">transition</span>和<span class="hljs-attribute">animation</span>两者都能实现动画效果<br><span class="hljs-attribute">transform</span>常常配合<span class="hljs-attribute">transition</span>和<span class="hljs-attribute">animation</span>使⽤<br><br><br><span class="hljs-number">2</span>、<span class="hljs-attribute">transition</span>样式过渡，从⼀种效果逐渐改变为另⼀种效果<br><span class="hljs-attribute">transition</span>是⼀个合写属性<br><span class="hljs-attribute">transition</span>:transition-property transition-duration transition-timing-function<br>transition-delay<br>从左到右分别是：css属性、过渡效果花费时间、速度曲线、过渡开始的延迟时间<br>div&#123;<br> <span class="hljs-attribute">width</span>：<span class="hljs-number">100px</span>;<br> <span class="hljs-attribute">height</span>:<span class="hljs-number">100px</span>;<br> <span class="hljs-attribute">transition</span>:transform <span class="hljs-number">2s</span>;<br>&#125;<br><span class="hljs-selector-tag">div</span>：hover&#123;<br> <span class="hljs-attribute">transform</span>:<span class="hljs-built_in">rotate</span>(<span class="hljs-number">180deg</span>);<br>&#125;<br><span class="hljs-attribute">transition</span>通常和hover等事件配合使⽤，需要由事件来触发过渡<br>我们知道 <span class="hljs-attribute">transition</span> 虽然简单好⽤，但是我们会发现它受到各种限制。<br>(<span class="hljs-number">1</span>)<span class="hljs-attribute">transition</span>需要⼀个事件来触发，⽐如hover，所以没法在⽹⻚加载时⾃动发⽣<br>(<span class="hljs-number">2</span>) <span class="hljs-attribute">transition</span>是⼀次性的，不能重复发⽣，除⾮⼀再触发。<br>(<span class="hljs-number">3</span>) <span class="hljs-attribute">transition</span>只能定义开始状态和结束状态，不能定义中间状态，也就是说只有两个状态。<br>(<span class="hljs-number">4</span>)⼀条<span class="hljs-attribute">transition</span>规则，只能定义⼀个属性的变化，不能涉及多个属性。<br><br><br><span class="hljs-number">3</span>、<span class="hljs-attribute">animation</span>动画 由<span class="hljs-keyword">@keyframes</span>来描述每⼀帧的样式<br>div&#123;<br>　　<span class="hljs-attribute">animation</span>:myAnimation <span class="hljs-number">5s</span> infinite<br>&#125;<br><span class="hljs-keyword">@keyframes</span> myAnimation &#123;<br>　　<span class="hljs-number">0%</span>&#123;<span class="hljs-attribute">left</span>:<span class="hljs-number">0</span>;<span class="hljs-attribute">transform</span>:<span class="hljs-built_in">rotate</span>(<span class="hljs-number">0</span>);&#125;<br>　　<span class="hljs-number">100%</span>&#123;<span class="hljs-attribute">left</span>:<span class="hljs-number">200px</span>;<span class="hljs-attribute">transform</span>:<span class="hljs-built_in">rotate</span>(<span class="hljs-number">180deg</span>);&#125;<br>&#125;<br><br><br>区别：<br>（<span class="hljs-number">1</span>）<span class="hljs-attribute">transform</span>仅描述元素的静态样式，常常配合<span class="hljs-attribute">transition</span>和<span class="hljs-attribute">animation</span>使⽤<br>（<span class="hljs-number">2</span>）<span class="hljs-attribute">transition</span>通常和hover等事件配合使⽤，<span class="hljs-attribute">animation</span>是⾃发的，⽴即播放<br>（<span class="hljs-number">3</span>）<span class="hljs-attribute">animation</span>可设置循环次数<br>（<span class="hljs-number">4</span>）<span class="hljs-attribute">animation</span>可设置每⼀帧的样式和时间，<span class="hljs-attribute">transition</span>只能设置头尾<br>（<span class="hljs-number">5</span>）<span class="hljs-attribute">transition</span>可与js配合使⽤，js设定要变化的样式，<span class="hljs-attribute">transition</span>负责动画效果，如：<br><br><span class="hljs-attribute">animation</span>属性类似于<span class="hljs-attribute">transition</span>，他们都是随着时间改变元素的属性值，<br>其主要区别在于：<span class="hljs-attribute">transition</span>需要触发⼀个事件才会随着时间改变其CSS属性；<br><span class="hljs-attribute">animation</span>在不需要触发任何事件的情况下，也可以显式的随时间变化来改变元素CSS属性，达到⼀种动画的效果<br><span class="hljs-number">1</span>）动画不需要事件触发，过渡需要。<br><span class="hljs-number">2</span>）过渡只有⼀组（两个：开始-结束） 关键帧，动画可以设置多个。<br></code></pre></td></tr></table></figure><h5 id="7-⽗元素和⼦元素宽⾼不固定，如何实现⽔平垂直居中"><a href="#7-⽗元素和⼦元素宽⾼不固定，如何实现⽔平垂直居中" class="headerlink" title="7. ⽗元素和⼦元素宽⾼不固定，如何实现⽔平垂直居中"></a>7. ⽗元素和⼦元素宽⾼不固定，如何实现⽔平垂直居中</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment"> * @作者: kerwin</span><br><span class="hljs-comment">--&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;IE=edge&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">        * &#123;</span><br><span class="language-css">            <span class="hljs-attribute">padding</span>: <span class="hljs-number">0</span>;</span><br><span class="language-css">            <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span>;</span><br><span class="language-css">        &#125;</span><br><span class="language-css"></span><br><span class="language-css">        <span class="hljs-selector-tag">html</span>,</span><br><span class="language-css">        <span class="hljs-selector-tag">body</span> &#123;</span><br><span class="language-css">            <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;</span><br><span class="language-css">            <span class="hljs-attribute">height</span>: <span class="hljs-number">100%</span>;</span><br><span class="language-css">        &#125;</span><br><span class="language-css"></span><br><span class="language-css">        <span class="hljs-selector-tag">body</span> &#123;</span><br><span class="language-css">            <span class="hljs-attribute">background-color</span>: azure;</span><br><span class="language-css">        &#125;</span><br><span class="language-css"></span><br><span class="language-css">        <span class="hljs-selector-class">.parent</span> &#123;</span><br><span class="language-css">            <span class="hljs-attribute">width</span>: <span class="hljs-number">500px</span>;</span><br><span class="language-css">            <span class="hljs-attribute">height</span>: <span class="hljs-number">500px</span>;</span><br><span class="language-css">            <span class="hljs-attribute">background-color</span>: yellowgreen;</span><br><span class="language-css">            <span class="hljs-attribute">position</span>: relative;</span><br><span class="language-css">        &#125;</span><br><span class="language-css"></span><br><span class="language-css">        <span class="hljs-selector-class">.child</span> &#123;</span><br><span class="language-css">            <span class="hljs-attribute">position</span>: absolute;</span><br><span class="language-css">            <span class="hljs-attribute">top</span>: <span class="hljs-number">50%</span>;</span><br><span class="language-css">            <span class="hljs-attribute">left</span>: <span class="hljs-number">50%</span>;</span><br><span class="language-css">            <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translate</span>(-<span class="hljs-number">50%</span>, -<span class="hljs-number">50%</span>);</span><br><span class="language-css">            <span class="hljs-comment">/* 使⽤css3的transform来实现 */</span></span><br><span class="language-css">        &#125;</span><br><span class="language-css"></span><br><span class="language-css">        <span class="hljs-selector-class">.child</span> <span class="hljs-selector-tag">p</span> &#123;</span><br><span class="language-css">            <span class="hljs-attribute">width</span>: <span class="hljs-number">300px</span>;</span><br><span class="language-css">            <span class="hljs-attribute">height</span>: <span class="hljs-number">300px</span>;</span><br><span class="language-css">            <span class="hljs-attribute">background-color</span>: blue;</span><br><span class="language-css">        &#125;</span><br><span class="language-css">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;parent&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;child&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment"> * @作者: kerwin</span><br><span class="hljs-comment">--&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;IE=edge&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">        * &#123;</span><br><span class="language-css">            <span class="hljs-attribute">padding</span>: <span class="hljs-number">0</span>;</span><br><span class="language-css">            <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span>;</span><br><span class="language-css">        &#125;</span><br><span class="language-css"></span><br><span class="language-css">        <span class="hljs-selector-tag">body</span>,</span><br><span class="language-css">        <span class="hljs-selector-tag">html</span> &#123;</span><br><span class="language-css">            <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;</span><br><span class="language-css">            <span class="hljs-attribute">height</span>: <span class="hljs-number">100%</span>;</span><br><span class="language-css">        &#125;</span><br><span class="language-css"></span><br><span class="language-css">        <span class="hljs-selector-class">.parent</span> &#123;</span><br><span class="language-css">            <span class="hljs-attribute">display</span>: flex;</span><br><span class="language-css">            <span class="hljs-attribute">justify-content</span>: center;</span><br><span class="language-css">            <span class="hljs-attribute">align-items</span>: center;</span><br><span class="language-css">            <span class="hljs-attribute">width</span>: <span class="hljs-number">600px</span>;</span><br><span class="language-css">            <span class="hljs-attribute">height</span>: <span class="hljs-number">600px</span>;</span><br><span class="language-css">            <span class="hljs-attribute">background</span>: yellow;</span><br><span class="language-css">        &#125;</span><br><span class="language-css"></span><br><span class="language-css">        <span class="hljs-selector-class">.parent</span> <span class="hljs-selector-class">.child</span> &#123;</span><br><span class="language-css">            <span class="hljs-attribute">color</span>: <span class="hljs-number">#fff</span>;</span><br><span class="language-css">            <span class="hljs-attribute">width</span>: <span class="hljs-number">300px</span>;</span><br><span class="language-css">            <span class="hljs-attribute">height</span>: <span class="hljs-number">300px</span>;</span><br><span class="language-css">            <span class="hljs-attribute">text-align</span>: center;</span><br><span class="language-css">            <span class="hljs-attribute">background-color</span>: blue;</span><br><span class="language-css">        &#125;</span><br><span class="language-css">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;parent&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;child&quot;</span>&gt;</span>hello world<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h5 id="8-假设高度默认100px-，请写出三栏布局，其中左栏、右栏各为300px，中间自适应。"><a href="#8-假设高度默认100px-，请写出三栏布局，其中左栏、右栏各为300px，中间自适应。" class="headerlink" title="8. 假设高度默认100px ，请写出三栏布局，其中左栏、右栏各为300px，中间自适应。"></a>8. 假设高度默认<code>100px</code> ，请写出三栏布局，其中左栏、右栏各为<code>300px</code>，中间自适应。</h5><p><img src="%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/20180305_1520.png"></p><ul><li>方法1：浮动</li><li>方法2：绝对定位</li><li>方法3：<code>flexbox</code>。移动开发里经常用到。</li></ul><p><em>方法1、浮动：</em></p><blockquote><p>左侧设置左浮动，右侧设置右浮动即可，中间会自动地自适应。</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment"> * @作者: kerwin</span><br><span class="hljs-comment">--&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">        *&#123;</span><br><span class="language-css">            <span class="hljs-attribute">margin</span>:<span class="hljs-number">0</span>;</span><br><span class="language-css">            <span class="hljs-attribute">padding</span>:<span class="hljs-number">0</span>;</span><br><span class="language-css">        &#125;</span><br><span class="language-css"></span><br><span class="language-css">        <span class="hljs-selector-class">.box</span> <span class="hljs-selector-tag">div</span>&#123;</span><br><span class="language-css">            <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;</span><br><span class="language-css">        &#125;</span><br><span class="language-css"></span><br><span class="language-css">        <span class="hljs-selector-class">.left</span>&#123;</span><br><span class="language-css">            <span class="hljs-attribute">width</span>: <span class="hljs-number">300px</span>;</span><br><span class="language-css">            <span class="hljs-attribute">float</span><span class="hljs-selector-pseudo">:left</span>;</span><br><span class="language-css">            <span class="hljs-attribute">background</span>:gray;</span><br><span class="language-css">        &#125;</span><br><span class="language-css">        <span class="hljs-selector-class">.right</span>&#123;</span><br><span class="language-css">            <span class="hljs-attribute">width</span>: <span class="hljs-number">300px</span>;</span><br><span class="language-css">            <span class="hljs-attribute">float</span>: right;;</span><br><span class="language-css">            <span class="hljs-attribute">background</span>:gray;</span><br><span class="language-css">        &#125;</span><br><span class="language-css">        <span class="hljs-selector-class">.center</span>&#123;</span><br><span class="language-css">            <span class="hljs-attribute">background-color</span>: yellowgreen;</span><br><span class="language-css">        &#125;</span><br><span class="language-css">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;box&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;left&quot;</span>&gt;</span>left<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;right&quot;</span>&gt;</span>right<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;center&quot;</span>&gt;</span>center<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p><em>方法2、绝对定位：</em></p><blockquote><p>左侧设置为绝对定位， <code> left：0px</code>。右侧设置为绝对定位， <code>right：0px</code>。中间设置为绝对定位，<code>left </code>和<code>right</code> 都为<code>300px</code>，即可。中间的宽度会自适应。</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment"> * @作者: kerwin</span><br><span class="hljs-comment">--&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">        *&#123;</span><br><span class="language-css">            <span class="hljs-attribute">margin</span>:<span class="hljs-number">0</span>;</span><br><span class="language-css">            <span class="hljs-attribute">padding</span>:<span class="hljs-number">0</span>;</span><br><span class="language-css">        &#125;</span><br><span class="language-css"></span><br><span class="language-css">        <span class="hljs-selector-class">.box</span> <span class="hljs-selector-tag">div</span>&#123;</span><br><span class="language-css">            <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;</span><br><span class="language-css">        &#125;</span><br><span class="language-css"></span><br><span class="language-css">        <span class="hljs-selector-class">.left</span>&#123;</span><br><span class="language-css">            <span class="hljs-attribute">width</span>: <span class="hljs-number">300px</span>;</span><br><span class="language-css">            <span class="hljs-attribute">position</span>: absolute;</span><br><span class="language-css">            <span class="hljs-attribute">left</span>:<span class="hljs-number">0</span>;</span><br><span class="language-css">            <span class="hljs-attribute">background</span>:gray;</span><br><span class="language-css">        &#125;</span><br><span class="language-css">        <span class="hljs-selector-class">.right</span>&#123;</span><br><span class="language-css">            <span class="hljs-attribute">width</span>: <span class="hljs-number">300px</span>;</span><br><span class="language-css">            <span class="hljs-attribute">position</span>: absolute;</span><br><span class="language-css">            <span class="hljs-attribute">right</span>:<span class="hljs-number">0</span>;</span><br><span class="language-css">            <span class="hljs-attribute">background</span>:gray;</span><br><span class="language-css">        &#125;</span><br><span class="language-css">        <span class="hljs-selector-class">.center</span>&#123;</span><br><span class="language-css">            <span class="hljs-attribute">position</span>: absolute;</span><br><span class="language-css">            <span class="hljs-attribute">left</span>:<span class="hljs-number">300px</span>;</span><br><span class="language-css">            <span class="hljs-attribute">right</span>:<span class="hljs-number">300px</span>;</span><br><span class="language-css">            <span class="hljs-attribute">background-color</span>: yellowgreen;</span><br><span class="language-css">        &#125;</span><br><span class="language-css">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;box&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;left&quot;</span>&gt;</span>left<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;center&quot;</span>&gt;</span>center<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;right&quot;</span>&gt;</span>right<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p><em>方法3、flexbox布局</em></p><blockquote><p>将左中右所在的容器设置为<code>display: flex</code>，设置两侧的宽度后，然后让中间的<code>flex = 1</code>，即可。</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment"> * @作者: kerwin</span><br><span class="hljs-comment">--&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">        *&#123;</span><br><span class="language-css">            <span class="hljs-attribute">margin</span>:<span class="hljs-number">0</span>;</span><br><span class="language-css">            <span class="hljs-attribute">padding</span>:<span class="hljs-number">0</span>;</span><br><span class="language-css">        &#125;</span><br><span class="language-css"></span><br><span class="language-css">        <span class="hljs-selector-class">.box</span> <span class="hljs-selector-tag">div</span>&#123;</span><br><span class="language-css">            <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;</span><br><span class="language-css">        &#125;</span><br><span class="language-css">        <span class="hljs-selector-class">.box</span>&#123;</span><br><span class="language-css">            <span class="hljs-attribute">display</span>: flex;</span><br><span class="language-css">        &#125;</span><br><span class="language-css"></span><br><span class="language-css">        <span class="hljs-selector-class">.left</span>&#123;</span><br><span class="language-css">            <span class="hljs-attribute">width</span>: <span class="hljs-number">300px</span>;</span><br><span class="language-css">            <span class="hljs-attribute">background</span>:gray;</span><br><span class="language-css">        &#125;</span><br><span class="language-css">        <span class="hljs-selector-class">.right</span>&#123;</span><br><span class="language-css">            <span class="hljs-attribute">width</span>: <span class="hljs-number">300px</span>;</span><br><span class="language-css">            <span class="hljs-attribute">background</span>:gray;</span><br><span class="language-css">        &#125;</span><br><span class="language-css">        <span class="hljs-selector-class">.center</span>&#123;</span><br><span class="language-css">            <span class="hljs-attribute">flex</span>:<span class="hljs-number">1</span>;</span><br><span class="language-css">            <span class="hljs-attribute">background-color</span>: yellowgreen;</span><br><span class="language-css">        &#125;</span><br><span class="language-css">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;box&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;left&quot;</span>&gt;</span>left<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;center&quot;</span>&gt;</span>center<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;right&quot;</span>&gt;</span>right<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="三-JS高频面试题"><a href="#三-JS高频面试题" class="headerlink" title="三. JS高频面试题"></a>三. JS高频面试题</h4><h5 id="1-介绍JS有哪些内置对象？"><a href="#1-介绍JS有哪些内置对象？" class="headerlink" title="1. 介绍JS有哪些内置对象？"></a>1. 介绍JS有哪些内置对象？</h5><ul><li>数据封装类对象：Object、Array、Boolean、Number、String</li><li>其他对象：Function、Arguments、Math、Date、RegExp、Error</li><li>ES6新增对象：Symbol（标识唯一性的ID）、Map、Set、Promises、Proxy、Reflect</li></ul><h5 id="2-如何最小化重绘-repaint-和回流-reflow-？"><a href="#2-如何最小化重绘-repaint-和回流-reflow-？" class="headerlink" title="2. 如何最小化重绘(repaint)和回流(reflow)？"></a>2. 如何最小化重绘(repaint)和回流(reflow)？</h5><ul><li><p>需要要对元素进行复杂的操作时，可以先隐藏(display:”none”)，操作完成后再显示</p></li><li><p>需要创建多个DOM节点时，使用DocumentFragment创建完后一次性的加入document</p></li><li><p>缓存Layout属性值，如：var left &#x3D; elem.offsetLeft; 这样，多次使用 left 只产生一次回流</p></li><li><p>尽量避免用table布局（table元素一旦触发回流就会导致table里所有的其它元素回流）</p></li></ul><h5 id="3-Javascript作用域链"><a href="#3-Javascript作用域链" class="headerlink" title="3. Javascript作用域链?"></a>3. Javascript作用域链?</h5><ul><li>全局函数无法查看局部函数的内部细节，但局部函数可以查看其上层的函数细节，直至全局细节</li><li>如果当前作用域没有找到属性或方法，会向上层作用域[[Scoped]]查找，直至全局函数，这种形式就是作用域链</li></ul><h5 id="4-数据请求"><a href="#4-数据请求" class="headerlink" title="4. 数据请求"></a>4. 数据请求</h5><p> <em>(1) XHR</em> </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>();<br>xhr.<span class="hljs-title function_">open</span>(<span class="hljs-string">&#x27;get&#x27;</span>,<span class="hljs-string">&quot;www.aaaa.com&quot;</span>,<span class="hljs-literal">true</span>);<span class="hljs-comment">//异步</span><br>xhr.<span class="hljs-title function_">send</span>();<br>xhr.<span class="hljs-property">onreadystatechange</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br><span class="hljs-comment">// readstate  4</span><br><span class="hljs-comment">// status  200-300</span><br><span class="hljs-comment">// 200 成功 （有可能强缓存策略，cache-control,expired）</span><br><span class="hljs-comment">// 301 302 redirect</span><br><span class="hljs-comment">// 304 从缓存读取数据。(协商缓存策略,etag)</span><br><span class="hljs-comment">// 404 not found</span><br><span class="hljs-comment">// 500 服务器错误。</span><br>&#125;<br>  xhr 可以取消？<br>  xhr.<span class="hljs-title function_">abort</span>();<span class="hljs-comment">//终止请求。</span><br><br></code></pre></td></tr></table></figure><p> <em>(2) fetch （w3c）</em></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">fetch</span>(<span class="hljs-string">&quot;url&quot;</span>,  <br>   &#123;<span class="hljs-attr">method</span>:<span class="hljs-string">&quot;post&quot;</span>,<span class="hljs-attr">body</span>:<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-attr">credencial</span>:<span class="hljs-string">&#x27;include&#x27;</span>&#125;)<br>   .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span>=&gt;</span>res.<span class="hljs-title function_">json</span>())<br>   .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span>=&gt;</span>&#123;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res)&#125;)<br>   <span class="hljs-comment">// 兼容性问题</span><br>   <span class="hljs-comment">// 发出的请求，默认是不带cookie.  credencial:&#x27;include&#x27;</span><br></code></pre></td></tr></table></figure><p> <em>(3) jsonp (解决跨域)</em>  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js">动态创建script src指向没有跨域限制，  onload<br><br>后端返回的数据格式 一定是， <span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;[&quot;111&quot;,&quot;222&quot;,&quot;3333&quot;]&#x27;</span>);<br><br>前端提前定义好 test这个方法，通过形参就拿到数据了。<br><br>jsonp 可以做get请求， 无法做post请求（缺点）;<br><br>jsonp可以取消吗？不能<br></code></pre></td></tr></table></figure><h5 id="5-跨域和同源策略"><a href="#5-跨域和同源策略" class="headerlink" title="5. 跨域和同源策略"></a>5. 跨域和同源策略</h5><p>所谓的同源策略其实是浏览器的一种机制，只允许在同源，也就是同协议、同域名、同端口的的情况下才能进行数据交互。 但是我们在开发项目的过程中， 往往一个项目的接口不止一个域，所以往往就需要做跨域的处理，通常的跨域方式有这么几种：</p><p>1）</p><p>JSONP，主要依赖的是script标签不受同源策略影响，src指向某一个接口的地址， 同步需要传递callback回调函数名字， 这样当接口调用成功后， 本地创建的全局回调函数就会执行， 并且接收到数据。不使用img标签的原因是因为img标签无法执行js语句</p><ol start="2"><li></li></ol><p>CORS，依赖服务端对前端的请求头信息进行放行，不做限制。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Access</span>-<span class="hljs-title class_">Control</span>-<span class="hljs-title class_">Allow</span>-<span class="hljs-title class_">Origin</span>配置成*<br></code></pre></td></tr></table></figure><ol start="3"><li></li></ol><p>代理访问，前端访问不存在跨域问题的代理服务器，代理服务器再去访问目标服务器（服务器之间没有跨域限制）</p><h5 id="6-面向对象"><a href="#6-面向对象" class="headerlink" title="6. 面向对象"></a>6. 面向对象</h5><p>   <em>(1)构造函数</em></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Test</span>(<span class="hljs-params">name,age</span>)&#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> =age;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">getName</span>= <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>;<br>    &#125;<br>&#125;<br><span class="hljs-comment">// Test();</span><br><span class="hljs-keyword">var</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Test</span>(<span class="hljs-string">&quot;kerwin&quot;</span>,<span class="hljs-number">100</span>);<br><br><span class="hljs-keyword">var</span> obj2 =<span class="hljs-keyword">new</span> <span class="hljs-title class_">Test</span>(<span class="hljs-string">&quot;xiaoming&quot;</span>,<span class="hljs-number">18</span>)<br></code></pre></td></tr></table></figure><p>   <em>(2)原型</em></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"> <span class="hljs-comment">//内存只有一份</span><br><span class="hljs-title class_">Test</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">getName</span>= <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br><br>&#125;<br><span class="hljs-comment">//缺点是？</span><br><br>原型容易被覆盖<br><br><span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">concat</span> = ....<br></code></pre></td></tr></table></figure><p>   <em>(3)继承</em></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//构造函数继承</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Test2</span>(<span class="hljs-params">name,age,location</span>)&#123;<br>    <span class="hljs-comment">// this.name =name;</span><br>    <span class="hljs-comment">// this.age =age;</span><br>    <span class="hljs-comment">// Test.call(this,name,age);</span><br>    <span class="hljs-title class_">Test</span>.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>,[name,age])<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">location</span> = location;<br>&#125;<br><span class="hljs-keyword">var</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Test2</span>();<br><br><span class="hljs-comment">//原型继承</span><br><span class="hljs-title class_">Test2</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> =<span class="hljs-title class_">Test</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span><br><span class="hljs-comment">//Test2.prototype =new Test()</span><br><span class="hljs-title class_">Test2</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constructor</span> =<span class="hljs-title class_">Test2</span>;<br><br><span class="hljs-comment">//混合继承</span><br><br></code></pre></td></tr></table></figure><p><em>(4)原型链</em></p><blockquote><p><strong>原型链的基本原理</strong>：任何一个<strong>实例</strong>，通过原型链，找到它上面的<strong>原型</strong>，该原型对象中的方法和属性，可以被所有的原型实例共享。</p></blockquote><p><img src="image-20200411192514703-1675990853293.png" alt="image-20200411192514703"></p><h5 id="7-闭包"><a href="#7-闭包" class="headerlink" title="7. 闭包"></a>7. 闭包</h5><p>闭包是JS中的一种特性，往往用于解决一些特定的问题，当A函数中返回了B函数， 并且返回的B函数中有使用到A函数中的局部变量（包含参数）就会形成一个特性的形态，就叫闭包。</p><p>此时，理论上来说A函数执行完成后，生成了B函数后，应该被垃圾回收机制回收，但是因为生成的B函数还在使用A函数中的局部变量， 就会导致A函数没有及时回收，导致内存泄露。</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//1. 函数防抖(搜索查询)</span><br><br>inputelement.<span class="hljs-property">oninput</span> = (<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br><span class="hljs-keyword">var</span> timer =<span class="hljs-literal">null</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>           <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;scroll&quot;</span>)<br><span class="hljs-keyword">if</span>(timer)&#123;<br><span class="hljs-built_in">clearTimeout</span>(timer);<br>&#125;<br>timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;代码执行,ajax&quot;</span>); <br>               <br>&#125;, <span class="hljs-number">500</span>)<br>&#125;<br>&#125;)()<br><span class="hljs-comment">// 2. 函数节流（onrize，onscroll）</span><br>       <span class="hljs-variable language_">window</span>.<span class="hljs-property">onscroll</span> = (<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>           <span class="hljs-keyword">var</span> date = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>();<br>           <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br><br>               <span class="hljs-keyword">if</span>(<span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>()-date&gt;<span class="hljs-number">500</span>)&#123;<br>                   date = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>();<br>                   <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;代码执行echarts resize&quot;</span>)<br><br>               &#125;<br>           &#125;<br>       &#125;)()<br><br><span class="hljs-comment">// 3. ul li</span><br><span class="hljs-keyword">var</span> oli = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementsByTagName</span>(<span class="hljs-string">&quot;li&quot;</span>);<br><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i=<span class="hljs-number">0</span>;i&lt;oli.<span class="hljs-property">length</span>;i++)&#123;<br>oli[i].<span class="hljs-property">onclick</span> =(<span class="hljs-keyword">function</span>(<span class="hljs-params">index</span>)&#123;<br>           <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>               <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(index)<br>           &#125;<br>       &#125;)(i)   <br>&#125;<br></code></pre></td></tr></table></figure><h5 id="8-数组去重"><a href="#8-数组去重" class="headerlink" title="8. 数组去重"></a>8. 数组去重</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>];<br><br><span class="hljs-keyword">var</span> myset = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>(arr);<br><span class="hljs-keyword">var</span> mya = <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(myset);<br></code></pre></td></tr></table></figure><h5 id="9-数组常用的合并方法"><a href="#9-数组常用的合并方法" class="headerlink" title="9. 数组常用的合并方法"></a>9. 数组常用的合并方法</h5><ul><li><p>concat</p></li><li><p>[…a, …b]展开运算符</p></li><li><p>[a, b].flat()</p></li><li><p>……</p></li></ul><h5 id="10-cookie和session"><a href="#10-cookie和session" class="headerlink" title="10. cookie和session"></a>10. cookie和session</h5><p>cookie和session是为HTTP请求挂载状态的，也就说在前后端交互的过程中，往往需要利用cookie或者session来对客户端进行标记。</p><p>传统的cookie验证方式是这样的：</p><p>1. </p><p>   客户端在向服务端登录的时候，服务端直接通过响应头上set-cookie字段，为浏览器客户端注入cookie，或者将对应的信息放置在响应内容中，客户端自行将其存储在cookie中。</p><p>2. </p><p>   客户端在每次发送请求的时候就可以将cookie携带在请求头上进行数据的传递，服务端拿到此次请求头中的cookie进行验证。</p><p>3. </p><p>   客户端自行设置cookie或者由服务端设置cookie的时候也去设置此cookie的过期时间，当cookie过期后相当于登录过期了。</p><p>session的验证方式：</p><p>1. </p><p>   客户端在向服务端登录的时候，服务端自行建立客户信息表，并且建立生命周期机制，服务端再将此信息通过cookie或者数据直接返回的形式，返回给客户端。</p><p>2. </p><p>   客户端拿到验证信息后，可以选择存储在cookie中获取localStorage中都可以。</p><p>3. </p><p>   每次请求的时候携带验证信息（cookie就自动写到，localStorage需要取出携带）</p><p>4. </p><p>   服务端接收到请求后，判断该验证信息是否过期</p><p>cookie和session本质是都是利用cookie或者localStorage来进行数据交互，而cookie和localStorage又都有跨域的限制：</p><p>cookie通过设置domain可以实现一级域名下的二级域名之间可以互相访问，localStorage则不能跨域。</p><h5 id="11-线程和进程的区别"><a href="#11-线程和进程的区别" class="headerlink" title="11. 线程和进程的区别"></a>11. 线程和进程的区别</h5><p>进程是资源分配的最小单元，线程是代码执行的最小单元。</p><p>一个应用程序可能会开启多个进程，进程之间数据不共享，一个进程内部可以开启多个线程，线程之间的数据可以共享的，所以多线程的情况下，往往要考虑的是线程间的执行顺序问题。</p><p>浏览器其实也可以通过webWorkers开启多线程。</p><h5 id="12-协商缓存和强缓存区别"><a href="#12-协商缓存和强缓存区别" class="headerlink" title="12.协商缓存和强缓存区别"></a>12.协商缓存和强缓存区别</h5><p>协商缓存和强缓存指的都是浏览器对静态资源文件的缓存机制。描述的就是什么时候去服务器请求，什么时候直接读取缓存中的文件。</p><p>强缓存是客户端直接查看本地的缓存文件是否过期，如果没有过期就直接取用。</p><ol><li>查看过期的方法主要是依赖响应头上的expires(绝对时间)和cache-control（相对时间）上的时间来对比的</li></ol><p>协商缓存指的是客户端去询问服务器对应的文件是否有更新，如果有更新才会重新请求。</p><ol start="2"><li>依靠的是响应头上的last-modified（最后更新时间）及etag(内容变更的标识)来确认文件是否有更新。</li></ol><p>一个文件是否重新请求要经过强缓存和协商缓存的完整过程后才能决定。 </p><p><img src="watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAc3R1YmJvcm7kuLZsaWxp,size_16,color_FFFFFF,t_70,g_se,x_16.png" alt="img"></p><p>1. </p><p>   强制缓存和协商缓存都针对静态资源</p><p>2. </p><p>   强制缓存在前，协商缓存在后。</p><p>3. </p><p>   资源未过期触发强制缓存，资源过期后再触发协商缓存。</p><p>4. </p><p>   判断过期的方法expires（绝对时间）、cache-control（相对时间）</p><p>5. </p><p>   判断资源是否有更新（Last-Modified 和 ETag）</p><blockquote><p>需要注意的是，即使是静态资源，也是依靠url来进行缓存的，也就是说只要是url地址不一样，就一定会去获取最新的数据。</p><p>所以我们往往会有这样的需求，在静态文件的src后面添加一个时间戳，获取在打包的时候动态的生成带有hash值的文件名，这样可以阻止浏览器缓存，使用户获取到最新的文件，使用到最新的功能。</p></blockquote><h5 id="13-http和https区别以及哪个更安全"><a href="#13-http和https区别以及哪个更安全" class="headerlink" title="13. http和https区别以及哪个更安全"></a>13. http和https区别以及哪个更安全</h5><p>HTTP明文传输，数据没有加密，安全性较差，HTTPS（HTTP + SSL），数据传输过程是加密的，安全性要好一些。</p><p>使用HTTPS协议要经过SSL认证来申请SSL证书，认证拿到证书的过程一般都是收费的，所以成本略高。</p><p>HTTP的速度要比HTTPS要更快一些，就是因为HTTP和服务器建立连接要通过TCP的三次握手，客户端和服务端只需要交换3个包，HTTPS在进行连接的时候除了要TCP的3个包，还要加上SSL握手的9个包，一共12个包。</p><p>默认端口不同，http默认80端口，https默认443接口。</p><p>HTTPS认证是怎么认证的？</p><p>客户端和服务端进行数据传输之前，先通过证书对双方进行身份验证：</p><p>1. </p><p>   客户端在发送SSL握手信息给服务端要求连接</p><p>2. </p><p>   服务端会将证书发送给客户端</p><p>3. </p><p>   客户端检查服务端证书，确认这个这个证书的签发机构是否值得信任，如果检查有问题，客户端会将是否继续通讯的决定权交给客户端，如果检查无误，或者用户选择继续，就表现客户端认可服务端身份。</p><p>4. </p><p>   服务端要求客户端发送证书，并且检查是否通过验证， 失败就关闭连接，成功的话就得到客户端的公钥</p><p>至此，服务端及客户端双方身份认证接受，双方都确保彼此身份可靠。</p><p>HTTPS一定安全吗？</p><p>不一定，HTTPS往往无法阻止中间人攻击。</p><p>A和B进行数据交互的时候，可以采用加密的方式，加密分为对称和不对称两种。</p><p>对称加密只要被破解出加密方式，就很容易泄露信息。</p><p>A生成一个秘钥ka，B生成一个秘钥kb；ka用于解密A加密的数据，kb用于解密B加密的数据。</p><p>A将ka传递给B，B将kb传递A，这样的话，A再给B传递信息的时候，B接受到之后用ka来进行解密。</p><p>HTTPS进行密文传输的时候采用的不对称加密的方式。但是如果有中间人拦截请求后模仿A和B来与B和A进行通信的时候也会泄露数据。</p><h5 id="14-对于工作中的跨域问题你是怎么解决的"><a href="#14-对于工作中的跨域问题你是怎么解决的" class="headerlink" title="14.对于工作中的跨域问题你是怎么解决的"></a>14.对于工作中的跨域问题你是怎么解决的</h5><p>在线上的各种环境中（开发、测试、生产）环境一般是不会有跨域问题的，因为服务器和前端资源一般是会部署在同一个域的服务器下的，但是也有端口或者不同域的情况，这些时候往往都是后端去利用CORS来处理的跨域问题。</p><p>在本地开发的过程中，本地服务器访问测试服务器接口的，也基本都是后端去处理CORS跨域，但是有些时候也可能需要前端在脚手架对应的devServer中配置Proxy来进行开发时候的跨域处理。</p><p>在一些极少的情况下加，项目中可能会访问一些第三方的Api，比如定位、天气等等接口的时候，可能会根据接口需求进行jsonp的跨域处理。</p><h5 id="15-事件循环"><a href="#15-事件循环" class="headerlink" title="15. 事件循环"></a>15. 事件循环</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js">（<span class="hljs-number">1</span>）所有同步任务在主线程上执行，形成一个执行栈 <br><br>（<span class="hljs-number">2</span>）主线程之外，还存在一个<span class="hljs-string">&quot;任务队列&quot;</span>（task queue）。只要异步任务(<span class="hljs-built_in">setInterval</span>,<span class="hljs-built_in">setTimeout</span>，i/o...)有了结果，就在<span class="hljs-string">&quot;任务队列&quot;</span>之中放置一个事件。<br><br>（<span class="hljs-number">3</span>）一旦<span class="hljs-string">&quot;执行栈&quot;</span>中的所有同步任务执行完毕，系统就会读取<span class="hljs-string">&quot;任务队列&quot;</span>，拿到队列的第一个任务，进入执行栈，开始执行。<br><br>（<span class="hljs-number">4</span>）主线程不断重复上面的(<span class="hljs-number">3</span>)。<br><br>主线程从<span class="hljs-string">&quot;任务队列&quot;</span>中读取事件，这个过程是循环不断的，所以整个的这种运行机制又称为<span class="hljs-title class_">Event</span> <span class="hljs-title class_">Loop</span>（事件循环）<br><br></code></pre></td></tr></table></figure><p><img src="image-20230210103331701.png" alt="image-20230210103331701"></p><h5 id="16-微任务和宏任务"><a href="#16-微任务和宏任务" class="headerlink" title="16. 微任务和宏任务"></a>16. 微任务和宏任务</h5><blockquote><p>Promise的出现让问题变复杂了, 它跟setTimeout 优先级？ 上面的事件循环解释不够用了。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;script start&#x27;</span>)<br><br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;timer over&#x27;</span>)<br>&#125;, <span class="hljs-number">0</span>)<br><br><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>().<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;promise1&#x27;</span>)<br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;promise2&#x27;</span>)<br>&#125;)<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;script end&#x27;</span>)<br><br><span class="hljs-comment">// script start</span><br><span class="hljs-comment">// script end</span><br><span class="hljs-comment">// promise1</span><br><span class="hljs-comment">// promise2</span><br><span class="hljs-comment">// timer over</span><br><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">所有任务分为宏任务（macrotask ）和微任务（microtask ） 两种。<br><span class="hljs-title class_">MacroTask</span>（宏任务）：* script全部代码、<span class="hljs-built_in">setTimeout</span>、<span class="hljs-built_in">setInterval</span>、I/O、<span class="hljs-variable constant_">UI</span> <span class="hljs-title class_">Rendering</span>。<br><span class="hljs-title class_">MicroTask</span>（微任务）：* <span class="hljs-title class_">Process</span>.<span class="hljs-property">nextTick</span>（<span class="hljs-title class_">Node</span>独有）、<span class="hljs-title class_">Promise</span>...<br><br>在挂起任务时，<span class="hljs-variable constant_">JS</span> 引擎会将所有任务按照类别分到这两个队列中，首先在 宏任务 的队列中取出第一个任务，执行完毕后取出 微任务 队列中的所有任务顺序执行；之后新的事件循环开始，取宏任务的第一个，周而复始，直至两个队列的任务都取完。<br></code></pre></td></tr></table></figure><p><img src="15586502-4f2d3f71a94a4a00.webp" alt="img"></p><p><img src="15586502-30ee422b0922669e.webp" alt="img"></p><h5 id="17-http相关"><a href="#17-http相关" class="headerlink" title="17. http相关"></a>17. http相关</h5><p><strong>http状态码有那些？分别代表是什么意思？</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs tap">  [<br>     <span class="hljs-number"> 100 </span> Continue   继续，一般在发送post请求时，已发送了http header之后服务端将返回此信息，表示确认，之后发送具体参数信息<br>     <span class="hljs-number"> 200 </span> OK         正常返回信息<br>     <span class="hljs-number"> 201 </span> Created    请求成功并且服务器创建了新的资源<br>     <span class="hljs-number"> 202 </span> Accepted   服务器已接受请求，但尚未处理<br>      <br>     <span class="hljs-number"> 301 </span> Moved Permanently  请求的网页已永久移动到新位置。<br>     <span class="hljs-number"> 302 </span>Found       临时性重定向。<br>     <span class="hljs-number"> 307 </span>Internal Redirect  内部重定向<br>      <br>     <span class="hljs-number"> 304 </span> Not Modified 自从上次请求后，请求的网页未修改过。 协商缓存 <br>200  memory cache  强缓存<br><br>     <span class="hljs-number"> 400 </span>Bad Request  服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起请求。<br>     <span class="hljs-number"> 401 </span>Unauthorized 请求未授权。<br>     <span class="hljs-number"> 403 </span>Forbidden   禁止访问。<br>     <span class="hljs-number"> 404 </span>Not Found   找不到如何与 URI 相匹配的资源。<br><br>     <span class="hljs-number"> 500 </span>Internal Server Error  最常见的服务器端错误。<br>     <span class="hljs-number"> 503 </span>Service Unavailable 服务器端暂时无法处理请求（可能是过载或维护）。<br>  ]<br></code></pre></td></tr></table></figure><h5 id="18-一个页面从输入-URL-到页面加载显示完成，这个过程中都发生了什么？"><a href="#18-一个页面从输入-URL-到页面加载显示完成，这个过程中都发生了什么？" class="headerlink" title="18. 一个页面从输入 URL 到页面加载显示完成，这个过程中都发生了什么？"></a>18. 一个页面从输入 URL 到页面加载显示完成，这个过程中都发生了什么？</h5><ul><li>01.浏览器查找域名对应的IP地址(DNS 查询：浏览器缓存-&gt;系统缓存-&gt;路由器缓存-&gt;ISP DNS 缓存-&gt;根域名服务器)</li><li>02.浏览器向 Web 服务器发送一个 HTTP 请求（TCP三次握手）</li><li>03.服务器 301 重定向（从 <a href="http://example.com/">http://example.com</a> 重定向到 <a href="http://www.example.com)/">http://www.example.com）</a></li><li>04.浏览器跟踪重定向地址，请求另一个带 www 的网址</li><li>05.服务器处理请求（通过路由读取资源）</li><li>06.服务器返回一个 HTTP 响应（报头中把 Content-type 设置为 ‘text&#x2F;html’）</li><li>07.浏览器进 DOM 树构建</li><li>08.浏览器发送请求获取嵌在 HTML 中的资源（如图片、音频、视频、CSS、JS等）</li><li>09.浏览器显示完成页面</li><li>10.浏览器发送异步请求</li></ul><h5 id="19-前端攻击"><a href="#19-前端攻击" class="headerlink" title="19. 前端攻击"></a>19. 前端攻击</h5><h6 id="1-CSRF的基本概念、缩写、全称"><a href="#1-CSRF的基本概念、缩写、全称" class="headerlink" title="1) CSRF的基本概念、缩写、全称"></a>1) CSRF的基本概念、缩写、全称</h6><blockquote><p><code>CSRF</code>（<code>Cross-site request forgery</code>）：<strong>跨站请求伪造</strong>。</p></blockquote><p><img src="20180307_1735.png"></p><blockquote><p>用户是网站A的注册用户，且登录进去，于是网站A就给用户下发<code>cookie</code>。</p></blockquote><blockquote><p>从上图可以看出，要完成一次<code>CSRF</code>攻击，受害者必须满足两个必要的条件：</p></blockquote><ol><li>登录受信任网站<code>A</code>，并在本地生成<code>Cookie</code>。（如果用户没有登录网站<code>A</code>，那么网站<code>B</code>在诱导的时候，请求网站<code>A</code>的<code>api</code>接口时，会提示你登录）</li><li>在不登出<code>A</code>的情况下，访问危险网站<code>B</code>（其实是利用了网站<code>A</code>的漏洞）。</li></ol><blockquote><p>我们在讲<code>CSRF</code>时，一定要把上面的两点说清楚。</p></blockquote><blockquote><p>温馨提示一下，<code>cookie</code>保证了用户可以处于登录状态，但网站<code>B</code>其实拿不到 <code>cookie</code>。</p></blockquote><blockquote><p>举个例子，前段时间里，微博网站有个<code>api</code>接口有漏洞，导致很多用户的粉丝暴增。</p></blockquote><p><strong>CSRF的防范措施</strong></p><p><strong>方法一、Token 验证：</strong>（用的最多）</p><ol><li>服务器发送给客户端一个<code>token</code>；</li><li>客户端提交的表单中带着这个<code>token</code>。</li><li>如果这个 <code>token</code> 不合法，那么服务器拒绝这个请求。</li></ol><p><strong>方法二：隐藏令牌：</strong></p><ul><li>把 <code>token</code> 隐藏在 <code>http</code> 的 <code>head</code>头中。</li></ul><blockquote><p>方法二和方法一有点像，本质上没有太大区别，只是使用方式上有区别。</p></blockquote><p><strong>方法三、Referer 验证：</strong></p><blockquote><p><code>Referer</code> 指的是页面请求来源。意思是，<strong>只接受本站的请求，服务器才做响应</strong>；如果不是，就拦截。</p></blockquote><h6 id="2-XSS的攻击原理"><a href="#2-XSS的攻击原理" class="headerlink" title="2) XSS的攻击原理"></a>2) XSS的攻击原理</h6><blockquote><p><code>XSS</code>攻击的核心原理是：不需要你做任何的登录认证，它会通过合法的操作（比如在<code>url</code>中输入、在评论框中输入），向你的页面注入脚本（可能是<code>js</code>、<code>hmtl</code>代码块等）。</p></blockquote><blockquote><p>最后导致的结果可能是：</p></blockquote><ul><li>盗用<code>Cookie</code></li><li>破坏页面的正常结构，插入广告等恶意内容</li><li><code>D-doss</code>攻击</li></ul><p><strong>XSS的防范措施主要有三个：</strong></p><p><strong>1. 编码</strong>：</p><blockquote><p>对用户输入的数据进行<code>HTML Entity</code>编码。</p></blockquote><p><strong>2、过滤：</strong></p><ul><li>移除用户输入的和事件相关的属性。如<code>onerror</code>可以自动触发攻击，还有<code>onclick</code>等。（总而言是，过滤掉一些不安全的内容）</li><li>移除用户输入的<code>Style</code>节点、<code>Script</code>节点、<code>Iframe</code>节点。（尤其是<code>Script</code>节点，它可是支持跨域的呀，一定要移除）。</li></ul><h6 id="3-CSRF-和-XSS-的区别"><a href="#3-CSRF-和-XSS-的区别" class="headerlink" title="3)  CSRF 和 XSS 的区别"></a>3)  CSRF 和 XSS 的区别</h6><blockquote><p>面试官还可能喜欢问二者的区别。</p></blockquote><ul><li><code>CSRF</code>：是利用网站<code>A</code>本身的漏洞，去请求网站<code>A</code>的<code>api</code>。</li><li><code>XSS</code>：是向网站 <code>A</code> 注入 <code>JS</code>代码，然后执行 <code>JS</code> 里的代码，篡改网站<code>A</code>的内容。</li></ul><h4 id="四-ES6-ES13高频面试题"><a href="#四-ES6-ES13高频面试题" class="headerlink" title="四. ES6-ES13高频面试题"></a>四. ES6-ES13高频面试题</h4><h5 id="1-ES6新增的方法"><a href="#1-ES6新增的方法" class="headerlink" title="1. ES6新增的方法"></a>1. ES6新增的方法</h5><ul><li><p>let和const，解构赋值、模板字符串、箭头函数。</p></li><li><p>Symbol、Map、Set三种常用的数据类型。</p></li><li><p>Proxy重新定义了数据劫持的能力</p></li><li><p>Reflect定义了一套标准化的数据操作的方式</p></li><li><p>Promise确实的解决了异步逻辑嵌套及回调地狱问题。定义了异步逻辑的三种状态pending、rejected、fullfilled, 搭配then、catch、all、race等方法以及async await语法糖，大量简化了异步操作。</p></li><li><p>Generator函数，可以将异步逻辑划片执行。</p><ul><li>Generator 函数是 ES6 提供的一种异步编程解决方案</li><li>Generator 函数是一个状态机，封装了多个内部状态。</li><li>执行 Generator 函数会返回一个遍历器对象，也就是说，Generator 函数除了状态机，还是一个遍历器对象生成函数。返回的遍历器对象，可以依次遍历 Generator 函数内部的每一个状态。</li></ul></li><li><p>新增了class类的概念</p></li><li><p>ES6 Modules</p></li></ul><h5 id="2-var-let-const的区别"><a href="#2-var-let-const的区别" class="headerlink" title="2. var, let, const的区别"></a>2. var, let, const的区别</h5><p>ES6新增了定义变量的关键字 let和const， 分别用于定义块级变量和常量</p><p>let， const不会声明提前， 存在暂时性死区</p><p>外部无法使用到内部的let和const定义的变量， 存在块级作用域限制]</p><p>const 定义的常量， 无法更改。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">if</span>(<span class="hljs-literal">true</span>)&#123;<br>     <span class="hljs-keyword">let</span> name =<span class="hljs-string">&quot;kerwin&quot;</span><br> &#125;<br> <br> <span class="hljs-keyword">const</span> obj = &#123;<span class="hljs-attr">name</span>:<span class="hljs-string">&quot;kerwin&quot;</span>&#125;<br> obj.<span class="hljs-property">name</span>=<span class="hljs-string">&quot;xiaoming&quot;</span><br> <span class="hljs-comment">// obj = &#123;name:&quot;xioamng&quot;&#125;</span><br> <span class="hljs-comment">// obj= &#x27;dwadwa&#x27;</span><br></code></pre></td></tr></table></figure><h5 id="3-箭头函数"><a href="#3-箭头函数" class="headerlink" title="3. 箭头函数"></a>3. 箭头函数</h5><p>箭头函数是ES6推出的，所以在低版本浏览器是有兼容问题的，语法简介明了，逻辑更清晰。</p><p>箭头函数没有自己的this，this指向外部的this，并且this会在创建的时候就绑定好.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> fn1 = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>)<br>&#125;<br><span class="hljs-title function_">fn1</span>() <span class="hljs-comment">// window</span><br><span class="hljs-keyword">const</span> obj = &#123;  <br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;tom&#x27;</span>,  <br>  fn2 () &#123;    <br>    <span class="hljs-title function_">fn1</span>() <span class="hljs-comment">// window    </span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>) <span class="hljs-comment">// obj  </span><br>  &#125;<br>&#125;<br>obj.<span class="hljs-title function_">fn2</span>()<br></code></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 在箭头函数定义的位置往上数，这一行是可以打印出 this 的</span><br><span class="hljs-comment">// 因为这里的 this 是 window</span><br><span class="hljs-comment">// 所以箭头函数内部的 this 就是 window</span><br><span class="hljs-keyword">const</span> obj = &#123;<br>  fn: function () &#123;<br>    console.log(<span class="hljs-keyword">this</span>)<br>  &#125;,<br>  <span class="hljs-comment">// 这个位置是箭头函数的上一行，但是不能打印出 this</span><br>  <span class="hljs-function"><span class="hljs-keyword">fun</span>: <span class="hljs-params">()</span></span> =&gt; &#123;<br>    <span class="hljs-comment">// 箭头函数内部的 this 是书写箭头函数的上一行一个可以打印出 this 的位置</span><br>    console.log(<span class="hljs-keyword">this</span>)<br>  &#125;<br>&#125;<br><br>obj.fn()<br>obj.<span class="hljs-keyword">fun</span>()<br></code></pre></td></tr></table></figure><h5 id="4-解构"><a href="#4-解构" class="headerlink" title="4. 解构"></a>4. 解构</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> &#123;type,payload&#125; = data;  <span class="hljs-comment">// &#123;type:&quot;&quot;,payload:&quot;&quot;&#125;</span><br></code></pre></td></tr></table></figure><h5 id="5-…-展开合并"><a href="#5-…-展开合并" class="headerlink" title="5 … 展开合并"></a>5 … 展开合并</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">[...arr1,...arr2] <br>&#123;...obj1,...obj2&#125; <br></code></pre></td></tr></table></figure><h5 id="6-promise"><a href="#6-promise" class="headerlink" title="6. promise"></a>6. promise</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//异步处理方案</span><br><span class="hljs-number">1.</span> 回调函数<br>   <span class="hljs-number">2.</span> <span class="hljs-title class_">Promise</span><br>   <span class="hljs-number">3.</span> generator 生成器 <span class="hljs-keyword">yield</span> <br>   <span class="hljs-number">4.</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">await</span><br><br><span class="hljs-comment">//解决回调地狱 ，嵌套金字塔</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">test1</span>(<span class="hljs-params"></span>)&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,rejet</span>)=&gt;</span>&#123;<br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&quot;123&quot;</span>)<br>&#125;, <span class="hljs-number">2000</span>)<br>&#125;)<br>&#125;<br><br><span class="hljs-title function_">test1</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span>=&gt;</span>&#123;<br><br>&#125;).<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">error</span>=&gt;</span>&#123;<br><br>&#125;)<br><span class="hljs-comment">// pending reject fullfilled</span><br><br>axios.<span class="hljs-title function_">get</span>(<span class="hljs-string">&quot;1.php&quot;</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span>=&gt;</span>&#123;<br><span class="hljs-keyword">return</span> axios.<span class="hljs-title function_">get</span>(<span class="hljs-number">2.</span>php,&#123;res&#125;)<br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span>=&gt;</span>&#123;<br><span class="hljs-keyword">return</span> axios.<span class="hljs-title function_">get</span>(<span class="hljs-number">3.</span>php)<br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span>=&gt;</span>&#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res.<span class="hljs-property">data</span>)<br>&#125;).<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">error</span>=&gt;</span>&#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(error)<br>&#125;)<br><span class="hljs-keyword">async</span> <span class="hljs-keyword">await</span> 写起来<br><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">test</span>(<span class="hljs-params"></span>)&#123;<br><span class="hljs-keyword">var</span> a = <span class="hljs-keyword">await</span> axios.<span class="hljs-title function_">get</span>(<span class="hljs-number">1</span>);<br><span class="hljs-keyword">var</span> b= <span class="hljs-keyword">await</span> axios.<span class="hljs-title function_">get</span>(<span class="hljs-number">2</span>,&#123;a&#125;);<br><span class="hljs-keyword">var</span> c= <span class="hljs-keyword">await</span> axios.<span class="hljs-title function_">get</span>(<span class="hljs-number">3</span>,&#123;b&#125;)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(c);<br>&#125;<br><br><span class="hljs-title function_">test</span>()<br><br><span class="hljs-comment">//所有的异步都结束</span><br><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>([axios.<span class="hljs-title function_">get</span>(<span class="hljs-number">1</span>),axios.<span class="hljs-title function_">get</span>(<span class="hljs-number">2</span>)]).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span>=&gt;</span>&#123;<br><span class="hljs-comment">//loading隐藏</span><br>&#125;).<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">error</span>=&gt;</span>&#123;<br><br>&#125;)<br><br><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">race</span>([axios.<span class="hljs-title function_">get</span>(<span class="hljs-number">1</span>),axios.<span class="hljs-title function_">get</span>(<span class="hljs-number">2</span>)])<br><br><span class="hljs-string">`Promise.any()`</span>跟<span class="hljs-string">`Promise.race()`</span>方法很像，只有一点不同，就是<span class="hljs-string">`Promise.any()`</span>不会因为某个 <span class="hljs-title class_">Promise</span> 变成<span class="hljs-string">`rejected`</span>状态而结束，必须等到所有参数 <span class="hljs-title class_">Promise</span> 变成<span class="hljs-string">`rejected`</span>状态才会结束。<br></code></pre></td></tr></table></figure><h5 id="7-class-语法糖-x3D-gt-构造函数-babel-loader"><a href="#7-class-语法糖-x3D-gt-构造函数-babel-loader" class="headerlink" title="7 .class (语法糖 &#x3D;&gt;  构造函数,babel-loader)"></a>7 .class (语法糖 &#x3D;&gt;  构造函数,babel-loader)</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>&#123;<br><span class="hljs-title function_">constructor</span>(<span class="hljs-params">name,age</span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> =age;<br>&#125;<br>say=<span class="hljs-function">()=&gt;</span>&#123;<br><br>&#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">person</span>&#123;<br><span class="hljs-title function_">constructor</span>(<span class="hljs-params">name,age,location</span>) &#123;<br>  <span class="hljs-variable language_">super</span>(name,age);<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">location</span> = location;<br>&#125;<br>      <br>&#125;<br></code></pre></td></tr></table></figure><h5 id="8-模块化"><a href="#8-模块化" class="headerlink" title="8 .模块化"></a>8 .模块化</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> obj <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./a&quot;</span> ;  <br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> aaa;<br><br><span class="hljs-keyword">import</span> &#123;test&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./b&quot;</span> ; <br><span class="hljs-keyword">export</span> &#123;test&#125; ; <br><span class="hljs-keyword">export</span> <span class="hljs-keyword">var</span> test =<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;&#125;<br><br><span class="hljs-variable constant_">AMD</span> - 前端 异步加载 - 提前下载， 提前加载 <span class="hljs-built_in">require</span>.<span class="hljs-property">js</span><br><span class="hljs-variable constant_">CMD</span> -  异步加载 - 提前下载 ， 按需加载 -- 玉伯 -sea.<span class="hljs-property">js</span><br><span class="hljs-title class_">CommonJs</span> -同步加载（webpack）<br><span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;./b&quot;</span>)    <br>=&gt;<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> <br>=&gt;<span class="hljs-built_in">exports</span><br><span class="hljs-title class_">ES6</span> - 模块化<br><br><span class="hljs-comment">//ES6 和 commonJS区别？</span><br><span class="hljs-comment">//ES6可以导入某几个接口 import &#123;a&#125; from &#x27;./module.js&#x27; + webpack- tree shaking 摇树优化</span><br><br><span class="hljs-comment">//commonJS 导入整个文件</span><br></code></pre></td></tr></table></figure><h5 id="9-异步遍历器生成函数-大厂面试"><a href="#9-异步遍历器生成函数-大厂面试" class="headerlink" title="9. 异步遍历器生成函数(大厂面试)"></a>9. 异步遍历器生成函数(大厂面试)</h5><blockquote><p>Generator 函数返回一个同步遍历器，异步 Generator 函数的作用，是返回一个异步遍历器对象。在语法上，异步 Generator 函数就是async函数与 Generator 函数的结合。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">timer</span>(<span class="hljs-params">t</span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> &#123;<br>          <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>              <span class="hljs-title function_">resolve</span>(t)<br>          &#125;, t)<br>      &#125;)<br> &#125;<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span>* <span class="hljs-title function_">fn</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">yield</span> <span class="hljs-title function_">timer</span>(<span class="hljs-number">1000</span>)<span class="hljs-comment">//任务1</span><br>    <span class="hljs-keyword">yield</span> <span class="hljs-title function_">timer</span>(<span class="hljs-number">2000</span>)<span class="hljs-comment">//任务2</span><br>    <span class="hljs-keyword">yield</span> <span class="hljs-title function_">timer</span>(<span class="hljs-number">3000</span>)<span class="hljs-comment">//任务3</span><br>&#125;<br><br><span class="hljs-comment">// 使用一下 for await ...of</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">fn1</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">for</span> <span class="hljs-title function_">await</span>(<span class="hljs-params"><span class="hljs-keyword">const</span> val <span class="hljs-keyword">of</span> fn()</span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;start&quot;</span>,<span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>())<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(val);<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;end&quot;</span>,<span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>())<br>    &#125;<br>&#125;<br><span class="hljs-title function_">fn1</span>();<br></code></pre></td></tr></table></figure><h4 id="五-工程化-amp-代码管理高频面试题"><a href="#五-工程化-amp-代码管理高频面试题" class="headerlink" title="五. 工程化&amp;代码管理高频面试题"></a>五. 工程化&amp;代码管理高频面试题</h4><h5 id="1-git常用命令以及工作中都怎么工作"><a href="#1-git常用命令以及工作中都怎么工作" class="headerlink" title="1. git常用命令以及工作中都怎么工作"></a>1. git常用命令以及工作中都怎么工作</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs js">git init 初始化仓库<br><br>git status 查看当前各个区域的代码状态。<br><br>git log查看commit记录<br><br>git reflog查看完整记录<br><br>git add 添加工作区代码到暂存区<br><br><span class="hljs-title class_">Git</span> commit 暂存区代码的提交<br><br>git reset 代码的版本回退<br><br>git stash 将暂存处代码收起来<br><br>git stash pop 将收起来的暂存区的代码释放出来<br><br><span class="hljs-title class_">Git</span> tag 可以打标签<br><br><span class="hljs-title class_">Git</span> branch 基于当前分支创建一个分支<br><br>git checkout 切换分支<br><br>git merge 合并分支<br><br>git remote add origin 添加远端仓库地址<br><br>git clone 克隆仓库<br><br>git pull下拉对应分支代码<br><br>git push 上传对应分支代码<br><br><br></code></pre></td></tr></table></figure><p>公司中每一个项目都会有一个对应的远端仓库（gitLab），我们需要创建账号并配置权限。</p><p>一般公司会有几个主要分支，分别对应4个环境，当代码更新的时候会通过流水线自动部署到对应的环境：</p><p>1. </p><p>   发布分支（prod、master）这个分支代码对应的就是线上的代码</p><p>2. </p><p>   UAT分支（uat），这个分支上的代码对应的是公司内部演示用的分支</p><p>3. </p><p>   TEST分支（test），这个分支的代码是用于测试</p><p>4. </p><p>   DEV分支（dev），研发自测分支</p><p>正常功能开发或者bug修复， 从dev分支拉取代码，进行开发就可以。</p><p>如果是解决线上bug，应该从master拉取一个分支（hotfix__）, 然后开发完成后将其合并到test或者uat，测试没有问题后，将其合并到master。还要将hotfix上对应的commit合并到dev分支， 专业dev分支也就修复了这个bug。</p><p>如果当前版本代码需要回退（功能不做了，要么要去先着急干别的）， 执行git reset –hard， 再回到当前的commit也是git reset 只不过需要注意，此时要通过git reflog来查看时间最后的一次commit。</p><h5 id="2-sass和-scss的区别"><a href="#2-sass和-scss的区别" class="headerlink" title="2. sass和 scss的区别"></a>2. sass和 scss的区别</h5><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gcode">Sass 是一款强化 CSS 的辅助工具，它在 CSS 语法的基础上增加了变量 <span class="hljs-comment">(variables)</span>、嵌套 <span class="hljs-comment">(nested rules)</span>、混合 <span class="hljs-comment">(mixins)</span>、导入 <span class="hljs-comment">(inline imports)</span> 等高级功能，这些拓展令 CSS 更加强大与优雅。使用 Sass 以及 Sass 的样式库（如 Compass）有助于更好地组织管理样式文件，以及更高效地开发项目。<br></code></pre></td></tr></table></figure><p>scss只是sass的一个语言版本，.scss文件的特点是层级靠{}来区分，.sass文件的特点的层级靠缩进来区分</p><h5 id="3-前端工程化工具"><a href="#3-前端工程化工具" class="headerlink" title="3. 前端工程化工具"></a>3. 前端工程化工具</h5><blockquote><p>gulp&amp;webpack </p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js">gulp -<span class="hljs-function"><span class="hljs-params">src</span>=&gt;</span><span class="hljs-title function_">pipe</span>(scss翻译).<span class="hljs-title function_">pipe</span>(css 合并).<span class="hljs-title function_">pipe</span>(css压缩)=&gt;dist<br>gulp -<span class="hljs-function"><span class="hljs-params">src</span>=&gt;</span><span class="hljs-title function_">pipe</span>(模块化编译).<span class="hljs-title function_">pipe</span>(js压缩)=&gt;dist<br>流程化<br>webpack<br>    模块化 默认支持的commonjs规范<br><br>所有js模块打包生成一个js文件<br>编译解析浏览器不能识别的语言 （scss ,.<span class="hljs-property">vue</span>, jsx, ts, <span class="hljs-title class_">ES6</span>） <br><br>配置？<br> 入口<br> 出口<br> devserver 启动 自动刷新，热更新， 反向代理<br> sourcemap-调试代码 .<span class="hljs-property">map</span> （地图）<br><br> <span class="hljs-attr">loaders</span>: sass-loader css-loader file-loader  babel-loader vue-loader postcss-loader<br><br> <span class="hljs-attr">plugin</span>:  压缩, 提取公共库<br><br></code></pre></td></tr></table></figure><h5 id="4-webpack配置并且是否熟知代码分割流程及操作"><a href="#4-webpack配置并且是否熟知代码分割流程及操作" class="headerlink" title="4. webpack配置并且是否熟知代码分割流程及操作"></a>4. webpack配置并且是否熟知代码分割流程及操作</h5><p>webpack包含mode模式、entry入口、output出口、plugins插件、loader、resolve、devServer开发服务器相关的基本配置。</p><p>在webpack中可以通过多入口的配置，每个入口都会去查询对应的依赖关系图，进行单独的代码。</p><p>在模块化开发过程中往往会将各种不同类型的文件都看做是模块来进行互相导入导出，比如将图片、css、sass之类的文件都可以导入到js文件中，但是在打包的过程中需要将这些文件都寻找到然后单独的分离出去，这样就需要用到对应的loader来进行文件处理，不同的文件、不同的loader，处理方式也不一样。</p><p>比如css文件可以利用style-loader将其代码生成style标签放入到head中，也可以利用minicssextra插件中 loader将其抽离成css文件。</p><p>img文件可以利用url-loader和file-loader对其进行base64的转化或者单独抽出。</p><p>组件模块化导入的时候可以采用懒加载的形式，就会单独打包对应的代码。</p><p><img src="image-20230214103342487.png" alt="image-20230214103342487"></p><h5 id="5-webpack-4大核心理念，-编译原理"><a href="#5-webpack-4大核心理念，-编译原理" class="headerlink" title="5.  webpack 4大核心理念， 编译原理?"></a>5.  webpack 4大核心理念， 编译原理?</h5><p>​      entry,output , loaders , pluguins<br>​       一切皆为模块，由于webpack只支持js文件，所以需要用loader 转换为webpack支持的模块，其中plugin 用于扩张webpack 的功能，在webpack构建生命周期的过程中，在合适的时机做了合适的事情。</p><h5 id="6-webapck构建优化实战-打包时间过长，-可以优化时间短点-20s"><a href="#6-webapck构建优化实战-打包时间过长，-可以优化时间短点-20s" class="headerlink" title="6. webapck构建优化实战 (打包时间过长， 可以优化时间短点  20s)"></a>6. webapck构建优化实战 (打包时间过长， 可以优化时间短点  20s)</h5><pre><code class="hljs">（1）提取公共库， 避免重复引用。  使用 DllPlugin，把第三方库文件分离出来单独编译，并且缓存; 极大的减少业务页面的编译时间   dll方式也就是通过配置，告诉webpack指定库在项目中的位置，从而直接引入，不将其打包在内。 （2）happypack, 多线程解析文件，如babel-loader等耗时较长的。 还可以配合cache-loader使用。 （3）缓存  cache-loader （4）  loaders应尽可能配置解析路径include参数，排除路径exclude参数， 减少解析时查询范围。 （5）dev 阶段 devtool 设置成cheap-module-eval-source-map， 已经能满足调试需求， 编译能更快。 （6）product 阶段 去掉source-map </code></pre><h4 id="六-NodeJS高频面试题"><a href="#六-NodeJS高频面试题" class="headerlink" title="六. NodeJS高频面试题"></a>六. NodeJS高频面试题</h4><h5 id="1-nodejs-创建静态服务器？"><a href="#1-nodejs-创建静态服务器？" class="headerlink" title="1. nodejs 创建静态服务器？"></a>1. nodejs 创建静态服务器？</h5><blockquote><p>要使用 HTTP 服务器和客户端，则必须 <code>require(&#39;http&#39;)</code>。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;http&#x27;</span>);<br><br><span class="hljs-comment">// 创建本地服务器来从其接收数据</span><br><span class="hljs-keyword">const</span> server = http.<span class="hljs-title function_">createServer</span>(<span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  res.<span class="hljs-title function_">writeHead</span>(<span class="hljs-number">200</span>, &#123; <span class="hljs-string">&#x27;Content-Type&#x27;</span>: <span class="hljs-string">&#x27;application/json&#x27;</span> &#125;);<br>  res.<span class="hljs-title function_">end</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(&#123;<br>    <span class="hljs-attr">data</span>: <span class="hljs-string">&#x27;Hello World!&#x27;</span><br>  &#125;));<br>&#125;);<br><br>server.<span class="hljs-title function_">listen</span>(<span class="hljs-number">8000</span>);<br><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;http&#x27;</span>);<br><br><span class="hljs-comment">// 创建本地服务器来从其接收数据</span><br><span class="hljs-keyword">const</span> server = http.<span class="hljs-title function_">createServer</span>();<br><br><span class="hljs-comment">// 监听请求事件</span><br>server.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;request&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">request, res</span>) =&gt;</span> &#123;<br>  res.<span class="hljs-title function_">writeHead</span>(<span class="hljs-number">200</span>, &#123; <span class="hljs-string">&#x27;Content-Type&#x27;</span>: <span class="hljs-string">&#x27;application/json&#x27;</span> &#125;);<br>  res.<span class="hljs-title function_">end</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(&#123;<br>    <span class="hljs-attr">data</span>: <span class="hljs-string">&#x27;Hello World!&#x27;</span><br>  &#125;));<br>&#125;);<br><br>server.<span class="hljs-title function_">listen</span>(<span class="hljs-number">8000</span>);<br></code></pre></td></tr></table></figure><h5 id="2-commonJS规范-vs-ES6-模块化规范"><a href="#2-commonJS规范-vs-ES6-模块化规范" class="headerlink" title="2. commonJS规范 vs ES6 模块化规范"></a>2. commonJS规范 vs ES6 模块化规范</h5><pre><code class="hljs">&gt; require导入， module.exports 导出import 导入， export default 导出</code></pre><blockquote><p>区别：import {某个几个接口} from ‘antd’  &#x2F;&#x2F;webpack  (tree shaking 摇树优化)<br>           var myview &#x3D; require(“antd”) &#x2F;&#x2F;导入整个接口</p></blockquote><h5 id="3-socket通信-聊天"><a href="#3-socket通信-聊天" class="headerlink" title="3. socket通信 聊天"></a>3. socket通信 聊天</h5><p>WebSocket并不是全新的协议，而是利用了HTTP协议来建立连接。我们来看看WebSocket连接是如何创建的。</p><p>首先，WebSocket连接必须由浏览器发起，因为请求协议是一个标准的HTTP请求，格式如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable constant_">GET</span> <span class="hljs-attr">ws</span>:<span class="hljs-comment">//localhost:3000/ws/chat HTTP/1.1</span><br><span class="hljs-title class_">Host</span>: localhost<br><span class="hljs-title class_">Upgrade</span>: websocket<br><span class="hljs-title class_">Connection</span>: <span class="hljs-title class_">Upgrade</span><br><span class="hljs-title class_">Origin</span>: <span class="hljs-attr">http</span>:<span class="hljs-comment">//localhost:3000</span><br><span class="hljs-title class_">Sec</span>-<span class="hljs-title class_">WebSocket</span>-<span class="hljs-title class_">Key</span>: client-random-string<br><span class="hljs-title class_">Sec</span>-<span class="hljs-title class_">WebSocket</span>-<span class="hljs-title class_">Version</span>: <span class="hljs-number">13</span><br></code></pre></td></tr></table></figure><p>该请求和普通的HTTP请求有几点不同：</p><ol><li>GET请求的地址不是类似<code>/path/</code>，而是以<code>ws://</code>开头的地址；</li><li>请求头<code>Upgrade: websocket</code>和<code>Connection: Upgrade</code>表示这个连接将要被转换为WebSocket连接；</li><li><code>Sec-WebSocket-Key</code>是用于标识这个连接，并非用于加密数据；</li><li><code>Sec-WebSocket-Version</code>指定了WebSocket的协议版本。</li></ol><p>随后，服务器如果接受该请求，就会返回如下响应：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-meta">HTTP/1.1</span> <span class="hljs-number">101</span> Switching Protocols<br><span class="hljs-attribute">Upgrade</span><span class="hljs-punctuation">: </span>websocket<br><span class="hljs-attribute">Connection</span><span class="hljs-punctuation">: </span>Upgrade<br><span class="hljs-attribute">Sec-WebSocket-Accept</span><span class="hljs-punctuation">: </span>server-random-string<br></code></pre></td></tr></table></figure><p>该响应代码<code>101</code>表示本次连接的HTTP协议即将被更改，更改后的协议就是<code>Upgrade: websocket</code>指定的WebSocket协议。</p><p>版本号和子协议规定了双方能理解的数据格式，以及是否支持压缩等等。如果仅使用WebSocket的API，就不需要关心这些。</p><p>现在，一个WebSocket连接就建立成功，浏览器和服务器就可以随时主动发送消息给对方。消息有两种，一种是文本，一种是二进制数据。通常，我们可以发送JSON格式的文本，这样，在浏览器处理起来就十分容易。</p><p><strong>为什么WebSocket连接可以实现全双工通信而HTTP连接不行呢？实际上HTTP协议是建立在TCP协议之上的，TCP协议本身就实现了全双工通信，但是HTTP协议的请求－应答机制限制了全双工通信。WebSocket连接建立以后，其实只是简单规定了一下：接下来，咱们通信就不使用HTTP协议了，直接互相发数据吧。</strong></p><p>安全的WebSocket连接机制和HTTPS类似。首先，浏览器用<code>wss://xxx</code>创建WebSocket连接时，会先通过HTTPS创建安全的连接，然后，该HTTPS连接升级为WebSocket连接，底层通信走的仍然是安全的SSL&#x2F;TLS协议。</p><p>  <code>websocket全双工, 双向通信 onopen  onmessage  onclose onerror</code></p><p>服务器：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span>  <span class="hljs-title class_">WebSocket</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;ws&quot;</span>)<br><span class="hljs-title class_">WebSocketServer</span> = <span class="hljs-title class_">WebSocket</span>.<span class="hljs-property">WebSocketServer</span><br><span class="hljs-keyword">const</span> wss = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WebSocketServer</span>(&#123; <span class="hljs-attr">port</span>: <span class="hljs-number">8080</span> &#125;);<br>wss.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;connection&#x27;</span>, <span class="hljs-keyword">function</span> <span class="hljs-title function_">connection</span>(<span class="hljs-params">ws</span>) &#123;<br>    ws.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;message&#x27;</span>, <span class="hljs-keyword">function</span> <span class="hljs-title function_">message</span>(<span class="hljs-params">data, isBinary</span>) &#123;<br>        wss.<span class="hljs-property">clients</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-keyword">function</span> <span class="hljs-title function_">each</span>(<span class="hljs-params">client</span>) &#123;<br>            <span class="hljs-keyword">if</span> (client !== ws &amp;&amp; client.<span class="hljs-property">readyState</span> === <span class="hljs-title class_">WebSocket</span>.<span class="hljs-property">OPEN</span>) &#123;<br>                client.<span class="hljs-title function_">send</span>(data, &#123; <span class="hljs-attr">binary</span>: isBinary &#125;);<br>            &#125;<br>        &#125;);<br><br>    &#125;);<br><br>    ws.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;欢迎加入聊天室&#x27;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><p>客户端：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> ws = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WebSocket</span>(<span class="hljs-string">&quot;ws://localhost:8080&quot;</span>)<br>ws.<span class="hljs-property">onopen</span> = <span class="hljs-function">()=&gt;</span>&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;open&quot;</span>)<br>&#125;<br>ws.<span class="hljs-property">onmessage</span> = <span class="hljs-function">(<span class="hljs-params">evt</span>)=&gt;</span>&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(evt.<span class="hljs-property">data</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="4-mongoDB-基本操作-增删改查"><a href="#4-mongoDB-基本操作-增删改查" class="headerlink" title="4. mongoDB 基本操作(增删改查)"></a>4. mongoDB 基本操作(增删改查)</h5><img src="前端面试题/image-20220413085332378.png" alt="image-20220413085332378" style="zoom:67%;float:left" /><img src="image-20220413090707891.png" alt="image-20220413090707891" style="zoom: 67%;float:left;" /><p>连接数据库</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> mongoose = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;mongoose&quot;</span>)<br><br>mongoose.<span class="hljs-title function_">connect</span>(<span class="hljs-string">&quot;mongodb://127.0.0.1:27017/company-system&quot;</span>)<br></code></pre></td></tr></table></figure><p>创建模型</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> mongoose = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;mongoose&quot;</span>)<br><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">Schema</span> = mongoose.<span class="hljs-property">Schema</span><br><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">UserType</span> = &#123;<br>    <span class="hljs-attr">username</span>:<span class="hljs-title class_">String</span>,<br>    <span class="hljs-attr">password</span>:<span class="hljs-title class_">String</span>,<br>    <span class="hljs-attr">gender</span>:<span class="hljs-title class_">Number</span>,<br>    <span class="hljs-attr">introduction</span>:<span class="hljs-title class_">String</span>,<br>    <span class="hljs-attr">avatar</span>:<span class="hljs-title class_">String</span>,<br>    <span class="hljs-attr">role</span>:<span class="hljs-title class_">Number</span><br>&#125;<br><span class="hljs-keyword">const</span> <span class="hljs-title class_">UserModel</span> = mongoose.<span class="hljs-title function_">model</span>(<span class="hljs-string">&quot;user&quot;</span>,<span class="hljs-keyword">new</span> <span class="hljs-title class_">Schema</span>(<span class="hljs-title class_">UserType</span>))<br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span>  = <span class="hljs-title class_">UserModel</span> <br></code></pre></td></tr></table></figure><p>增加数据</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">UserModel</span>.<span class="hljs-title function_">create</span>(&#123;<br>    introduction,username,gender,avatar,password,role<br>&#125;)<br></code></pre></td></tr></table></figure><p>查询数据</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">UserModel</span>.<span class="hljs-title function_">find</span>(&#123;<span class="hljs-attr">username</span>:<span class="hljs-string">&quot;kerwin&quot;</span>&#125;,[<span class="hljs-string">&quot;username&quot;</span>,<span class="hljs-string">&quot;role&quot;</span>,<span class="hljs-string">&quot;introduction&quot;</span>,<span class="hljs-string">&quot;password&quot;</span>]).<span class="hljs-title function_">sort</span>(&#123;<span class="hljs-attr">createTime</span>:-<span class="hljs-number">1</span>&#125;).<span class="hljs-title function_">skip</span>(<span class="hljs-number">10</span>).<span class="hljs-title function_">limit</span>(<span class="hljs-number">10</span>)<br></code></pre></td></tr></table></figure><p>更新数据</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">UserModel</span>.<span class="hljs-title function_">updateOne</span>(&#123;<br>    _id<br>&#125;,&#123;<br>    introduction,username,gender,avatar<br>&#125;)<br></code></pre></td></tr></table></figure><p>删除数据</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">UserModel</span>.<span class="hljs-title function_">deleteOne</span>(&#123;_id&#125;)<br></code></pre></td></tr></table></figure><h5 id="5-token（jwt-json-web-token）-与-session配合cookie-（登录，鉴权）"><a href="#5-token（jwt-json-web-token）-与-session配合cookie-（登录，鉴权）" class="headerlink" title="5. token（jwt-json web token） 与 session配合cookie  （登录，鉴权）"></a>5. token（jwt-json web token） 与 session配合cookie  （登录，鉴权）</h5><h6 id="1-Cookie-amp-Session"><a href="#1-Cookie-amp-Session" class="headerlink" title="1. Cookie&amp;Session"></a>1. Cookie&amp;Session</h6><p>「HTTP 无状态」<strong>我们知道，HTTP 是无状态的。也就是说，HTTP 请求方和响应方间无法维护状态，都是一次性的，它不知道前后的请求都发生了什么。但有的场景下，我们需要维护状态。最典型的，一个用户登陆微博，发布、关注、评论，都应是在登录后的用户状态下的。</strong>「标记」那解决办法是什么呢？<img src="image-20220414095345868.png" alt="image-20220414095345868"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;express&quot;</span>);<br><span class="hljs-keyword">const</span> session = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;express-session&quot;</span>);<br><span class="hljs-keyword">const</span> <span class="hljs-title class_">MongoStore</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;connect-mongo&quot;</span>);<br><span class="hljs-keyword">const</span> app = <span class="hljs-title function_">express</span>();<br><br><br>app.<span class="hljs-title function_">use</span>(<br>  <span class="hljs-title function_">session</span>(&#123;<br>    <span class="hljs-attr">secret</span>: <span class="hljs-string">&quot;this is session&quot;</span>, <span class="hljs-comment">// 服务器生成 session 的签名</span><br>    <span class="hljs-attr">resave</span>: <span class="hljs-literal">true</span>, <br>    <span class="hljs-attr">saveUninitialized</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">//强制将为初始化的 session 存储</span><br>    <span class="hljs-attr">cookie</span>: &#123;<br>      <span class="hljs-attr">maxAge</span>: <span class="hljs-number">1000</span> * <span class="hljs-number">60</span> * <span class="hljs-number">10</span>,<span class="hljs-comment">// 过期时间</span><br>      <span class="hljs-attr">secure</span>: <span class="hljs-literal">false</span>, <span class="hljs-comment">// 为 true 时候表示只有 https 协议才能访问cookie</span><br>    &#125;,<br>    <span class="hljs-attr">rolling</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">//为 true 表示 超时前刷新，cookie 会重新计时； 为 false 表示在超时前刷新多少次，都是按照第一次刷新开始计时。</span><br>    <span class="hljs-attr">store</span>: <span class="hljs-title class_">MongoStore</span>.<span class="hljs-title function_">create</span>(&#123;<br>      <span class="hljs-attr">mongoUrl</span>: <span class="hljs-string">&#x27;mongodb://127.0.0.1:27017/kerwin_session&#x27;</span>,<br>      <span class="hljs-attr">ttl</span>: <span class="hljs-number">1000</span> * <span class="hljs-number">60</span> * <span class="hljs-number">10</span> <span class="hljs-comment">// 过期时间</span><br>  &#125;),<br><br>  &#125;)<br>);<br><br>app.<span class="hljs-title function_">use</span>(<span class="hljs-function">(<span class="hljs-params">req,res,next</span>)=&gt;</span>&#123;<br>  <span class="hljs-keyword">if</span>(req.<span class="hljs-property">url</span>===<span class="hljs-string">&quot;/login&quot;</span>)&#123;<br>    <span class="hljs-title function_">next</span>()<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>  <span class="hljs-keyword">if</span>(req.<span class="hljs-property">session</span>.<span class="hljs-property">user</span>)&#123;<br>      req.<span class="hljs-property">session</span>.<span class="hljs-property">garbage</span> = <span class="hljs-title class_">Date</span>();<br>      <span class="hljs-title function_">next</span>();<br>  &#125;<span class="hljs-keyword">else</span>&#123;<br>     res.<span class="hljs-title function_">redirect</span>(<span class="hljs-string">&quot;/login&quot;</span>)   <br>  &#125;<br>&#125;)<br><br></code></pre></td></tr></table></figure><h6 id="2-JSON-Web-Token-JWT"><a href="#2-JSON-Web-Token-JWT" class="headerlink" title="2. JSON Web Token (JWT)"></a>2. JSON Web Token (JWT)</h6><h6 id="（1）介绍"><a href="#（1）介绍" class="headerlink" title="（1）介绍"></a>（1）介绍</h6><p><img src="image-20220415082822828.png" alt="image-20220415082822828"></p><p>我为什么要保存这可恶的session呢， 只让每个客户端去保存该多好？</p><p><img src="image-20220415083015066.png" alt="image-20220415083015066"></p><p>当然， 如果一个人的token 被别人偷走了， 那我也没办法， 我也会认为小偷就是合法用户， 这其实和一个人的session id 被别人偷走是一样的。</p><p>这样一来， 我就不保存session id 了， 我只是生成token , 然后验证token ， 我用我的CPU计算时间获取了我的session 存储空间 ！</p><p>解除了session id这个负担， 可以说是无事一身轻， 我的机器集群现在可以轻松地做水平扩展， 用户访问量增大， 直接加机器就行。 这种无状态的感觉实在是太好了！</p><p>缺点：</p><blockquote><ol><li>占带宽，正常情况下要比 session_id 更大，需要消耗更多流量，挤占更多带宽，假如你的网站每月有 10 万次的浏览器，就意味着要多开销几十兆的流量。听起来并不多，但日积月累也是不小一笔开销。实际上，许多人会在 JWT 中存储的信息会更多；</li><li>无法在服务端注销，那么久很难解决劫持问题；</li><li>性能问题，JWT 的卖点之一就是加密签名，由于这个特性，接收方得以验证 JWT 是否有效且被信任。对于有着严格性能要求的 Web 应用，这并不理想，尤其对于单线程环境。</li></ol></blockquote><p>注意：</p><blockquote><p>CSRF攻击的原因是浏览器会自动带上cookie，而不会带上token；</p><p>以CSRF攻击为例：</p><p>cookie：用户点击了链接，cookie未失效，导致发起请求后后端以为是用户正常操作，于是进行扣款操作；<br>token：用户点击链接，由于浏览器不会自动带上token，所以即使发了请求，后端的token验证不会通过，所以不会进行扣款操作；</p></blockquote><h6 id="（2）实现"><a href="#（2）实现" class="headerlink" title="（2）实现"></a>（2）实现</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//jsonwebtoken 封装</span><br><span class="hljs-keyword">const</span> jsonwebtoken = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;jsonwebtoken&quot;</span>)<br><span class="hljs-keyword">const</span> secret = <span class="hljs-string">&quot;kerwin&quot;</span><br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">JWT</span> = &#123;<br>    <span class="hljs-title function_">generate</span>(<span class="hljs-params">value,exprires</span>)&#123;<br>        <span class="hljs-keyword">return</span> jsonwebtoken.<span class="hljs-title function_">sign</span>(value,secret,&#123;<span class="hljs-attr">expiresIn</span>:exprires&#125;)<br>    &#125;,<br>    <span class="hljs-title function_">verify</span>(<span class="hljs-params">token</span>)&#123;<br>        <span class="hljs-keyword">try</span>&#123;<br>            <span class="hljs-keyword">return</span> jsonwebtoken.<span class="hljs-title function_">verify</span>(token,secret)<br>        &#125;<span class="hljs-keyword">catch</span>(e)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-variable constant_">JWT</span><br></code></pre></td></tr></table></figure><h5 id="6-token-存储在-localStorage-里，当过期时过期的-token-怎么处理？"><a href="#6-token-存储在-localStorage-里，当过期时过期的-token-怎么处理？" class="headerlink" title="6. token 存储在 localStorage 里，当过期时过期的 token 怎么处理？"></a>6. token 存储在 localStorage 里，当过期时过期的 token 怎么处理？</h5><ul><li>当前端进行页面跳转或者需要鉴权的操作时，会发送请求到后台，而 token 会跟随请求头一起发送，后台通过请求头接收到 token 时会进行判断，若是过期了，应该返回一个 401 的状态码给前端，前端接收到以后，应该重定向到登录页要求用户重新登陆。axios 拦截器。</li></ul><h5 id="7-如何使用原生-Node-js-操做-cookie？"><a href="#7-如何使用原生-Node-js-操做-cookie？" class="headerlink" title="7. 如何使用原生 Node.js 操做 cookie？"></a>7. 如何使用原生 Node.js 操做 cookie？</h5><ul><li>获取 cookie： req.headers.cookie</li><li>设置 cookie： res.writeHead(200, { ‘Set-Cookie’: ‘myCookie&#x3D;test’, ‘Content-Type’: ‘text&#x2F;plain’ })</li></ul><h5 id="8-nextTick-和-setImmediate-的区别是什么？"><a href="#8-nextTick-和-setImmediate-的区别是什么？" class="headerlink" title="8. nextTick 和 setImmediate 的区别是什么？"></a>8. nextTick 和 setImmediate 的区别是什么？</h5><ul><li>nextTick 和 setImmediate 都是延迟加载。但是 nextTick 是放在当前队列的最后一个执行，setImmediate 是在下一个队列的队首执行</li></ul><h5 id="9-koa-和-express-的区别"><a href="#9-koa-和-express-的区别" class="headerlink" title="9. koa 和 express 的区别"></a>9. koa 和 express 的区别</h5><ul><li>最大的区别在于语法，experss 的异步采用的是回调函数的形式，而 koa1 支持 generator + yeild，koa2 支持 await&#x2F;async，无疑更加优雅。</li><li>中间件的区别，koa 采用洋葱模型，进去顺序执行，出去反向执行，支持 context 传递数据 express 本身无洋葱模型，需要引入插件，不支持 context express 的中间件中执行异步函数，执行顺序不会按照洋葱模型，异步的执行结果有可能被放到最后，response 之前。 这是由于，其中间件执行机制，递归回调中没有等待中间件中的异步函数执行完毕，就是没有 await 中间件异步函数</li><li>集成度区别 express 内置了很多中间件，集成度高，使用省心， koa 轻量简洁，容易定制</li></ul><h5 id="10-koa-中间件的实现原理"><a href="#10-koa-中间件的实现原理" class="headerlink" title="10. koa 中间件的实现原理"></a>10. koa 中间件的实现原理</h5><ol><li>每个中间件默认接受两个参数，第一个参数是 Context 对象，第二个参数是 next 函数。只要调用 next 函数，就可以把执行权转交给下一个中间件。</li><li>如果中间件内部没有调用 next 函数，那么执行权就不会传递下去。</li><li>多个中间件会形成一个栈结构，以“先进后出”的顺序执行。整个过程就像，先是入栈，然后出栈的操作。</li></ol><h5 id="11-图片上传到服务器的过程"><a href="#11-图片上传到服务器的过程" class="headerlink" title="11. 图片上传到服务器的过程"></a>11. 图片上传到服务器的过程</h5><p>Multer 是一个 node.js 中间件，用于处理 <code>multipart/form-data</code> 类型的表单数据，它主要用于上传文件。</p><p><strong>注意</strong>: Multer 不会处理任何非 <code>multipart/form-data</code> 类型的表单数据。</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">npm install <span class="hljs-comment">--save multer</span><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//前后端分离-前端</span><br><br><span class="hljs-keyword">const</span> params = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FormData</span>()<br>params.<span class="hljs-title function_">append</span>(<span class="hljs-string">&#x27;kerwinfile&#x27;</span>, file.<span class="hljs-property">file</span>)<br>params.<span class="hljs-title function_">append</span>(<span class="hljs-string">&#x27;username&#x27;</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">username</span>)<br><span class="hljs-keyword">const</span> config = &#123;<br><span class="hljs-attr">headers</span>: &#123;<br><span class="hljs-string">&quot;Content-Type&quot;</span>:<span class="hljs-string">&quot;multipart/form-data&quot;</span><br>&#125;<br>&#125;<br>http.<span class="hljs-title function_">post</span>(<span class="hljs-string">&#x27;/api/upload&#x27;</span>, params, config).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;<br><span class="hljs-variable language_">this</span>.<span class="hljs-property">imgpath</span> = <span class="hljs-string">&#x27;http://localhost:3000&#x27;</span> + res.<span class="hljs-property">data</span><br>&#125;)<br></code></pre></td></tr></table></figure><p>Multer 会添加一个 <code>body</code> 对象 以及 <code>file</code> 或 <code>files</code> 对象 到 express 的 <code>request</code> 对象中。 <code>body</code> 对象包含表单的文本域信息，<code>file</code> 或 <code>files</code> 对象包含对象表单上传的文件信息。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//前后端分离-后端</span><br>router.<span class="hljs-title function_">post</span>(<span class="hljs-string">&#x27;/upload&#x27;</span>, upload.<span class="hljs-title function_">single</span>(<span class="hljs-string">&#x27;kerwinfile&#x27;</span>),<span class="hljs-keyword">function</span>(<span class="hljs-params">req, res, next</span>) &#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(req.<span class="hljs-property">file</span>)<br>&#125;)<br></code></pre></td></tr></table></figure><h5 id="12-什么是服务端渲染，服务端渲染的优点？"><a href="#12-什么是服务端渲染，服务端渲染的优点？" class="headerlink" title="12. 什么是服务端渲染，服务端渲染的优点？"></a>12. 什么是服务端渲染，服务端渲染的优点？</h5><ul><li>服务端渲染：页面渲染过程是在服务端完成，最终的 HTML 字符串，直接通过请求发送给客户端。</li><li>服务器端渲染的优势就是利于 SEO 优化，首屏加载快，因为客户端接收到的是完整的 HTML 页面。</li></ul><h5 id="13-Node-js-优缺点以及适用场景"><a href="#13-Node-js-优缺点以及适用场景" class="headerlink" title="13. Node.js 优缺点以及适用场景"></a>13. Node.js 优缺点以及适用场景</h5><ul><li>优点<ul><li>Node.js 采用事件驱动、异步编程，为网络服务而设计。简单易学，可以很快上手做后端设计。</li><li>Node.js 非阻塞模式的 IO 处理给 Node.js 带来在相对低系统资源耗用下的高性能与出众的负载能力，非常适合用作依赖其它 IO 资源的中间层服务。</li><li>Node.js 轻量高效，可以认为是数据密集型分布式部署环境下的实时应用系统的完美解决方案。</li></ul></li><li>缺点<ul><li>单线程，可靠性低，一旦这个进程崩掉，那么整个 web 服务就崩掉了。</li><li>开源组件库质量参差不齐，更新快，向下不兼容</li><li>不适合做企业级应用开发，特别是复杂业务逻辑的，代码不好维护，事务支持不是很好。</li></ul></li><li>适用场景<ul><li>大量 Ajax 请求的应用，例如个性化应用，每个用户看到的页面都不一样，需要在页面加载的时候发起 Ajax 请求，NodeJS 能响应大量的并发请求。</li><li>实时 ：如在线聊天，实时通知推送等等</li><li>工具类应用：海量的工具，小到前端压缩部署，大到桌面图形界面应用程序</li><li>总而言之，NodeJS 适合运用在高并发、I&#x2F;O 密集、少量业务逻辑的场景。</li></ul></li></ul><h4 id="七-Vue高频面试题"><a href="#七-Vue高频面试题" class="headerlink" title="七. Vue高频面试题"></a>七. Vue高频面试题</h4><h5 id="1-解释单向数据流和双向数据绑定"><a href="#1-解释单向数据流和双向数据绑定" class="headerlink" title="1.  解释单向数据流和双向数据绑定"></a>1.  解释单向数据流和双向数据绑定</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs JS">对于 <span class="hljs-title class_">Vue</span> 来说，组件之间的数据传递具有单向数据流这样的特性称为单向数据流，单向数据流（<span class="hljs-title class_">Unidirectional</span> data flow）方式使用一个上传数据流和一个下传数据流进行双向数据通信，两个数据流之间相互独立，单向数据流指只能从一个方向来修改状态。<br><br>而双向数据绑定即为当数据发生变化的时候，视图也就发生变化，当视图发生变化的时候，数据也会跟着同步变化，两个数据流之间互为影响。<br></code></pre></td></tr></table></figure><h5 id="2-Object-defineProperty有什么缺点"><a href="#2-Object-defineProperty有什么缺点" class="headerlink" title="2. Object.defineProperty有什么缺点"></a>2. Object.defineProperty有什么缺点</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs JS"><span class="hljs-number">1</span>、无法监听es6的<span class="hljs-title class_">Set</span>、<span class="hljs-title class_">Map</span> 变化；<br><span class="hljs-number">2</span>、无法监听<span class="hljs-title class_">Class</span>类型的数据；<br><span class="hljs-number">3</span>、属性的新加或者删除也无法监听；<br><span class="hljs-number">4</span>、数组元素的增加和删除也无法监听。<br><br></code></pre></td></tr></table></figure><h5 id="3-对MVC，MVP，MVVM的理解"><a href="#3-对MVC，MVP，MVVM的理解" class="headerlink" title="3. 对MVC，MVP，MVVM的理解"></a>3. 对MVC，MVP，MVVM的理解</h5><p><img src="../../../../Web前端/面试题/笔记/笔记.assets/image-20230215110550866.png" alt="image-20230215110550866" style="zoom:50%;" /><img src="image-20230215110625108.png" alt="image-20230215110625108"></p><img src="image-20230215110625108.png" alt="image-20230215110625108" style="zoom:50%;" /><img src="前端面试题/image-20230215110650930.png" alt="image-20230215110650930" style="zoom:50%;" /><img src="image-20230215110703001.png" alt="image-20230215110703001" style="zoom:50%;" /><h5 id="4-生命周期"><a href="#4-生命周期" class="headerlink" title="4. 生命周期"></a>4. 生命周期</h5><img src="前端面试题/image-20230215104416987.png" alt="image-20230215104416987" style="zoom: 80%;" /><h5 id="5-你知道Vue响应式数据原理吗？Proxy-与-Object-defineProperty-优劣对比？"><a href="#5-你知道Vue响应式数据原理吗？Proxy-与-Object-defineProperty-优劣对比？" class="headerlink" title="5. 你知道Vue响应式数据原理吗？Proxy 与 Object.defineProperty 优劣对比？"></a>5. 你知道Vue响应式数据原理吗？Proxy 与 Object.defineProperty 优劣对比？</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs JS"><span class="hljs-comment">// 响应式原理</span><br><br>vue的响应式实现主要是利用了<span class="hljs-title class_">Object</span>.<span class="hljs-property">defineProperty</span>的方法里面的setter 与getter方法的观察者模式来实现。在组件初始化时会给每一个data属性注册getter和setter，然后再<span class="hljs-keyword">new</span> 一个自己的<span class="hljs-title class_">Watcher</span>对象，此时watcher会立即调用组件的render函数去生成虚拟<span class="hljs-variable constant_">DOM</span>。在调用render的时候，就会需要用到data的属性值，此时会触发getter函数，将当前的<span class="hljs-title class_">Watcher</span>函数注册进sub里。当data属性发生改变之后，就会遍历sub里所有的watcher对象，通知它们去重新渲染组件。<br><br><span class="hljs-comment">// proxy的优势如下：</span><br><br><span class="hljs-title class_">Proxy</span> 可以直接监听对象而非属性，可以直接监听数组的变化；<br><span class="hljs-title class_">Proxy</span> 有多达 <span class="hljs-number">13</span> 种拦截方法,不限于 apply、ownKeys、deleteProperty、has 等等是 <span class="hljs-title class_">Object</span>.<span class="hljs-property">defineProperty</span> 不具备的；<br><span class="hljs-title class_">Proxy</span> 返回的是一个新对象,我们可以只操作新的对象达到目的,而 <span class="hljs-title class_">Object</span>.<span class="hljs-property">defineProperty</span> 只能遍历对象属性直接修改；<br><br><br><span class="hljs-comment">// Object.defineProperty 的优势如下:</span><br><br>兼容性好，支持 <span class="hljs-title class_">IE9</span>，而 <span class="hljs-title class_">Proxy</span> 的存在浏览器兼容性问题,而且无法用 <span class="hljs-title function_">polyfill</span>(垫片)来弥补<br></code></pre></td></tr></table></figure><h5 id="6-Composition-API-的出现带来哪些新的开发体验，为啥需要这个？"><a href="#6-Composition-API-的出现带来哪些新的开发体验，为啥需要这个？" class="headerlink" title="6. Composition API 的出现带来哪些新的开发体验，为啥需要这个？"></a>6. Composition API 的出现带来哪些新的开发体验，为啥需要这个？</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs JS"><span class="hljs-number">1</span>：在<span class="hljs-title class_">Compostion</span> <span class="hljs-variable constant_">API</span> 中时根据逻辑相关组织代码的，提高可读性和可维护性，类似于react的hook写法。<br><span class="hljs-number">2</span>：更好的重用逻辑代码，在<span class="hljs-title class_">Options</span> <span class="hljs-variable constant_">API</span>中通过<span class="hljs-title class_">MIxins</span>重用逻辑代码，容易发生命名冲突且关系不清。<br><span class="hljs-number">3</span>：解决在生命周期函数经常包含不相关的逻辑，但又不得不把相关逻辑分离到了几个不同方法中的问题，如在mounted中设置定时器，但需要在destroyed中来清除定时器，将同一功能的代码拆分到不同的位置，造成后期代码维护的困难。<br></code></pre></td></tr></table></figure><h5 id="7-对比-jQuery，Vue-有什么不同"><a href="#7-对比-jQuery，Vue-有什么不同" class="headerlink" title="7. 对比 jQuery，Vue 有什么不同"></a>7. 对比 jQuery，Vue 有什么不同</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JS">jQuery 专注视图层，通过直接操作 <span class="hljs-variable constant_">DOM</span> 去实现页面的一些逻辑渲染；<span class="hljs-title class_">Vue</span> 专注于数据层，通过数据的双向绑定，最终表现在 <span class="hljs-variable constant_">DOM</span> 层面，减少了 <span class="hljs-variable constant_">DOM</span> 操作。<span class="hljs-title class_">Vue</span> 使用了组件化思想，使得项目子集职责清晰，提高了开发效率，方便重复利用，便于协同开发<br></code></pre></td></tr></table></figure><h5 id="8-如何再Vue的单文件组件里的样式定义全局CSS？"><a href="#8-如何再Vue的单文件组件里的样式定义全局CSS？" class="headerlink" title="8. 如何再Vue的单文件组件里的样式定义全局CSS？"></a>8. 如何再Vue的单文件组件里的样式定义全局CSS？</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JS">在style标签上不加上scoped的属性，默认为全局css样式<br></code></pre></td></tr></table></figure><h5 id="9-说一下-root，-parent，-refs"><a href="#9-说一下-root，-parent，-refs" class="headerlink" title="9. 说一下$root，$parent，$refs"></a>9. 说一下$root，$parent，$refs</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JS">$root，和$parent都能访问父组件的属性和方法，区别在于如果存在多级子组件，通过parent 访问得到的是它最近一级的父组件，通过root 访问得到的是根父组件。通过在子组件标签定义 ref 属性，在父组件中可以使用$refs 访问子组件实例。<br></code></pre></td></tr></table></figure><h5 id="10-Vue-中怎么自定义指令"><a href="#10-Vue-中怎么自定义指令" class="headerlink" title="10. Vue 中怎么自定义指令"></a>10. Vue 中怎么自定义指令</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs JS">通过directive来自定义指令，自定义指令分为全局指令和局部指令，自定义指令也有几个的钩子函数，常用的有bind和update，当 bind 和 update 时触发相同行为，而不关心其它的钩子时可以简写。<br><br><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">directive</span>(<span class="hljs-string">&#x27;focus&#x27;</span>, &#123;<br>  <span class="hljs-comment">// 当被绑定的元素插入到 DOM 中时……</span><br>  <span class="hljs-attr">inserted</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">el</span>) &#123;<br>    <span class="hljs-comment">// 聚焦元素</span><br>    el.<span class="hljs-title function_">focus</span>()<br>  &#125;<br>&#125;)<br><br><br><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">directive</span>(<span class="hljs-string">&#x27;color-swatch&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">el, binding</span>) &#123;<br>  el.<span class="hljs-property">style</span>.<span class="hljs-property">backgroundColor</span> = binding.<span class="hljs-property">value</span><br>&#125;)<br><br><br></code></pre></td></tr></table></figure><h5 id="11-Vue-中怎么自定义过滤器-vue3不支持"><a href="#11-Vue-中怎么自定义过滤器-vue3不支持" class="headerlink" title="11. Vue 中怎么自定义过滤器 (vue3不支持)"></a>11. Vue 中怎么自定义过滤器 (vue3不支持)</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs JS">通过filter来定义过滤器，过滤器分为全局和局部过滤器，过滤器的主体为一个普通的函数，来对数据进行处理，可以传递参数。当有局部和全局两个名称相同的过滤器时候，会以就近原则进行调用，即：局部过滤器优先于全局过滤器被调用。<br><br>&lt;!-- 在双花括号中 --&gt;<br>&#123;&#123; message | capitalize &#125;&#125;<br><br>&lt;!-- 在 <span class="hljs-string">`v-bind`</span> 中 --&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-bind:id</span>=<span class="hljs-string">&quot;rawId | formatId&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><br><br><span class="hljs-attr">filters</span>: &#123;<br>  <span class="hljs-attr">capitalize</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) &#123;<br>    <span class="hljs-keyword">if</span> (!value) <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&#x27;</span><br>    value = value.<span class="hljs-title function_">toString</span>()<br>    <span class="hljs-keyword">return</span> value.<span class="hljs-title function_">charAt</span>(<span class="hljs-number">0</span>).<span class="hljs-title function_">toUpperCase</span>() + value.<span class="hljs-title function_">slice</span>(<span class="hljs-number">1</span>)<br>  &#125;<br>&#125;<br><br><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">filter</span>(<span class="hljs-string">&#x27;capitalize&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) &#123;<br>  <span class="hljs-keyword">if</span> (!value) <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&#x27;</span><br>  value = value.<span class="hljs-title function_">toString</span>()<br>  <span class="hljs-keyword">return</span> value.<span class="hljs-title function_">charAt</span>(<span class="hljs-number">0</span>).<span class="hljs-title function_">toUpperCase</span>() + value.<span class="hljs-title function_">slice</span>(<span class="hljs-number">1</span>)<br>&#125;)<br></code></pre></td></tr></table></figure><h5 id="12-Vue-等单页面应用的优缺点"><a href="#12-Vue-等单页面应用的优缺点" class="headerlink" title="12. Vue 等单页面应用的优缺点"></a>12. Vue 等单页面应用的优缺点</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs JS"><span class="hljs-comment">// 优点</span><br><span class="hljs-number">1</span>单页应用的内容的改变不需要重新加载整个页面，web应用更具响应性和更令人着迷。<br><br><span class="hljs-number">2</span>、单页应用没有页面之间的切换，就不会出现“白屏现象”,也不会出现假死并有“闪烁”现象<br><br><span class="hljs-number">3</span>、单页应用相对服务器压力小，服务器只用出数据就可以，不用管展示逻辑和页面合成，吞吐能力会提高几倍。<br><br><span class="hljs-number">4</span>、良好的前后端分离。后端不再负责模板渲染、输出页面工作，后端<span class="hljs-variable constant_">API</span>通用化，即同一套后端程序代码，不用修改就可以用于<span class="hljs-title class_">Web</span>界面、手机、平板等多种客户端。<br><br><span class="hljs-comment">// 缺点</span><br><span class="hljs-number">1</span>、首次加载耗时比较多。<br><br><span class="hljs-number">2</span>、<span class="hljs-variable constant_">SEO</span>问题，不利于百度，<span class="hljs-number">360</span>等搜索引擎收录。<br><br><span class="hljs-number">3</span>、容易造成<span class="hljs-title class_">Css</span>命名冲突。<br><br><span class="hljs-number">4</span>、前进、后退、地址栏、书签等，都需要程序进行管理，页面的复杂度很高，需要一定的技能水平和开发成本高。<br></code></pre></td></tr></table></figure><h5 id="13-Vue-router-使用params与query传参有什么区别"><a href="#13-Vue-router-使用params与query传参有什么区别" class="headerlink" title="13. Vue-router 使用params与query传参有什么区别"></a>13. Vue-router 使用params与query传参有什么区别</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs JS"><span class="hljs-comment">// 用法上</span><br><span class="hljs-number">1</span>：query要用path来引入，params要用name来引入，接收参数都是类似的，分别是<span class="hljs-variable language_">this</span>.<span class="hljs-property">$route</span>.<span class="hljs-property">query</span>和<span class="hljs-variable language_">this</span>.<span class="hljs-property">$route</span>.<span class="hljs-property">params</span>。<br><br><span class="hljs-comment">// 展示上</span><br><br><span class="hljs-number">2</span>：params是路由的一部分,必须要有。query是拼接在url后面的参数<br><br><span class="hljs-comment">// 命名的路由，并加上参数，让路由建立 url /users/eduardo</span><br>router.<span class="hljs-title function_">push</span>(&#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;user&#x27;</span>, <span class="hljs-attr">params</span>: &#123; <span class="hljs-attr">username</span>: <span class="hljs-string">&#x27;eduardo&#x27;</span> &#125; &#125;)<br><br><span class="hljs-comment">// 带查询参数，结果是 /register?plan=private</span><br>router.<span class="hljs-title function_">push</span>(&#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/register&#x27;</span>, <span class="hljs-attr">query</span>: &#123; <span class="hljs-attr">plan</span>: <span class="hljs-string">&#x27;private&#x27;</span> &#125; &#125;)<br><br><span class="hljs-comment">// 带 hash，结果是 /about#team</span><br>router.<span class="hljs-title function_">push</span>(&#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/about&#x27;</span>, <span class="hljs-attr">hash</span>: <span class="hljs-string">&#x27;#team&#x27;</span> &#125;)<br><br></code></pre></td></tr></table></figure><h5 id="14-Vue中-keep-alive-的作用"><a href="#14-Vue中-keep-alive-的作用" class="headerlink" title="14. Vue中 keep-alive 的作用"></a>14. Vue中 keep-alive 的作用</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JS">keep-alive 是 <span class="hljs-title class_">Vue</span> 内置的一个组件，可以使被包含的组件保留状态，或避免重新渲染。一旦使用keepalive包裹组件，此时mouted，created等钩子函数只会在第一次进入组件时调用，当再次切换回来时将不会调用。此时如果我们还想在每次切换时做一些事情，就需要用到另外的周期函数，actived和deactived，这两个钩子函数只有被keepalive包裹后才会调用。<br></code></pre></td></tr></table></figure><h5 id="15-Vue如何实现单页面应用"><a href="#15-Vue如何实现单页面应用" class="headerlink" title="15. Vue如何实现单页面应用"></a>15. Vue如何实现单页面应用</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs JS">通常的url 地址由以下内容构成：协议名 域名 端口号 路径 参数 哈希值，当哈希值改变，页面不会发生跳转，单页面应用就是利用了这一点，给<span class="hljs-variable language_">window</span>注册onhashchange事件，当哈希值改变时通过location.<span class="hljs-property">hash</span>就能获得相应的哈希值，然后就能跳到相应的页面。<br><br><span class="hljs-number">1.</span>hash通过监听浏览器的<span class="hljs-title function_">onhashchange</span>()事件变化，查找对应的路由规则<br><br><span class="hljs-number">2.</span>history原理： 利用<span class="hljs-variable constant_">H5</span>的 history中新增的两个<span class="hljs-variable constant_">API</span> <span class="hljs-title function_">pushState</span>() 和 <span class="hljs-title function_">replaceState</span>() 和一个事件onpopstate监听<span class="hljs-variable constant_">URL</span>变化<br></code></pre></td></tr></table></figure><h5 id="16-说出至少4种Vue当中的指令和它的用法？"><a href="#16-说出至少4种Vue当中的指令和它的用法？" class="headerlink" title="16. 说出至少4种Vue当中的指令和它的用法？"></a>16. 说出至少4种Vue当中的指令和它的用法？</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs JS">v-<span class="hljs-keyword">if</span>(判断是否隐藏，用来判断元素是否创建)<br>v-<span class="hljs-title function_">show</span>(元素的显示隐藏，类似css中的display的block和hidden)<br>v-<span class="hljs-keyword">for</span>(把数据遍历出来)<br>v-<span class="hljs-title function_">bind</span>(绑定属性)<br>v-<span class="hljs-title function_">model</span>(实现双向绑定)<br></code></pre></td></tr></table></figure><h5 id="17-如何实现一个路径渲染多个组件？"><a href="#17-如何实现一个路径渲染多个组件？" class="headerlink" title="17. 如何实现一个路径渲染多个组件？"></a>17. 如何实现一个路径渲染多个组件？</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs JS">可以通过命名视图(router-view)，它容许同一界面中拥有多个单独命名的视图，而不是只有一个单独的出口。如果 router-view 没有设置名字，那么默认为 <span class="hljs-keyword">default</span>。通过设置components即可同时渲染多个组件。<br><br>&lt;router-view <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;view left-sidebar&quot;</span> name=<span class="hljs-string">&quot;LeftSidebar&quot;</span>&gt;&lt;/router-view&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">router-view</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;view main-content&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">router-view</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">router-view</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;view right-sidebar&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;RightSidebar&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">router-view</span>&gt;</span></span><br><br><br><span class="hljs-keyword">const</span> router = <span class="hljs-title function_">createRouter</span>(&#123;<br>  <span class="hljs-attr">history</span>: <span class="hljs-title function_">createWebHashHistory</span>(),<br>  <span class="hljs-attr">routes</span>: [<br>    &#123;<br>      <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/&#x27;</span>,<br>      <span class="hljs-attr">components</span>: &#123;<br>        <span class="hljs-attr">default</span>: <span class="hljs-title class_">Home</span>,<br>        <span class="hljs-comment">// LeftSidebar: LeftSidebar 的缩写</span><br>        <span class="hljs-title class_">LeftSidebar</span>,<br>        <span class="hljs-comment">// 它们与 `&lt;router-view&gt;` 上的 `name` 属性匹配</span><br>        <span class="hljs-title class_">RightSidebar</span>,<br>      &#125;,<br>    &#125;,<br>  ],<br>&#125;)<br></code></pre></td></tr></table></figure><h5 id="18-如何实现多个路径共享一个组件？"><a href="#18-如何实现多个路径共享一个组件？" class="headerlink" title="18. 如何实现多个路径共享一个组件？"></a>18. 如何实现多个路径共享一个组件？</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs JS">只需将多个路径的component字段的值设置为同一个组件即可。<br><br><span class="hljs-keyword">const</span> routes = [<br>  &#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-attr">component</span>: <span class="hljs-title class_">Home</span> &#125;,<br>  &#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/home&#x27;</span>, <span class="hljs-attr">component</span>: <span class="hljs-title class_">Home</span> &#125;,<br>]<br></code></pre></td></tr></table></figure><h5 id="19-如何监测动态路由的变化"><a href="#19-如何监测动态路由的变化" class="headerlink" title="19. 如何监测动态路由的变化"></a>19. 如何监测动态路由的变化</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JS">可以通过watch方法来对$route进行监听，或者通过导航守卫的钩子函数beforeRouteUpdate来监听它的变化。<br></code></pre></td></tr></table></figure><h5 id="20-vue-router-中的-router-link上-v-slot属性怎么用？"><a href="#20-vue-router-中的-router-link上-v-slot属性怎么用？" class="headerlink" title="20. vue-router 中的 router-link上 v-slot属性怎么用？"></a>20. vue-router 中的 router-link上 v-slot属性怎么用？</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs JS">router-link 通过一个作用域插槽暴露底层的定制能力。这是一个更高阶的 <span class="hljs-variable constant_">API</span>，主要面向库作者，但也可以为开发者提供便利，多数情况用在一个类似 <span class="hljs-title class_">NavLink</span> 这样的自定义组件里。<br><br>有时我们可能想把激活的 <span class="hljs-keyword">class</span> 应用到一个外部元素而不是 &lt;a&gt; 标签本身，这时你可以在一个 router-link 中包裹该元素并使用 v-slot 属性来创建链接：<br><br>&lt;router-link<br>  to=<span class="hljs-string">&quot;/foo&quot;</span><br>  custom<br>  v-slot=<span class="hljs-string">&quot;&#123; href, route, navigate, isActive, isExactActive &#125;&quot;</span><br>&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span></span></span><br><span class="hljs-tag"><span class="language-xml">    <span class="hljs-attr">:class</span>=<span class="hljs-string">&quot;[isActive &amp;&amp; &#x27;router-link-active&#x27;, isExactActive &amp;&amp; &#x27;router-link-exact-active&#x27;]&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">  &gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">:href</span>=<span class="hljs-string">&quot;href&quot;</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;navigate&quot;</span>&gt;</span>&#123;&#123; route.fullPath &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br>&lt;/router-link&gt;<br><br></code></pre></td></tr></table></figure><h5 id="21-Vue-如何去除url中的"><a href="#21-Vue-如何去除url中的" class="headerlink" title="21. Vue 如何去除url中的 #"></a>21. Vue 如何去除url中的 <code>#</code></h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs JS">将路由模式改为history<br><br>由于我们的应用是一个单页的客户端应用，如果没有适当的服务器配置，用户在浏览器中直接访问 <span class="hljs-attr">https</span>:<span class="hljs-comment">//example.com/user/id，就会得到一个 404 错误。这就尴尬了。</span><br><br>不用担心：要解决这个问题，你需要做的就是在你的服务器上添加一个简单的回退路由。如果 <span class="hljs-variable constant_">URL</span> 不匹配任何静态资源，它应提供与你的应用程序中的 index.<span class="hljs-property">html</span> 相同的页面。<br><br><span class="hljs-keyword">var</span> history = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;connect-history-api-fallback&#x27;</span>);<br>app.<span class="hljs-title function_">use</span>(<span class="hljs-title function_">history</span>(&#123;<br><span class="hljs-attr">index</span>: <span class="hljs-string">&#x27;/index.html&#x27;</span><br>&#125;)); <span class="hljs-comment">//注意放在所有的接口后面</span><br></code></pre></td></tr></table></figure><h5 id="22-route-和-router-的区别"><a href="#22-route-和-router-的区别" class="headerlink" title="22.  $route 和 $router 的区别"></a>22.  $route 和 $router 的区别</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JS">$route用来获取路由的信息的，它是路由信息的一个对象，里面包含路由的一些基本信息，包括name、meta、path、hash、query、params、fullPath、matched、redirectedFrom等。而$router主要是用来操作路由的，它是<span class="hljs-title class_">VueRouter</span>的实例，包含了一些路由的跳转方法push，go, replace，钩子函数等<br></code></pre></td></tr></table></figure><h5 id="23-Vue-路由守卫"><a href="#23-Vue-路由守卫" class="headerlink" title="23. Vue 路由守卫"></a>23. Vue 路由守卫</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs JS">vue-router 提供的导航守卫主要用来对路由的跳转进行监控，控制它的跳转或取消，路由守卫有全局的, 单个路由独享的, 或者组件级的。导航钩子有<span class="hljs-number">3</span>个参数：<br><br><span class="hljs-number">1</span>、<span class="hljs-attr">to</span>:即将要进入的目标路由对象；<br><span class="hljs-number">2</span>、<span class="hljs-attr">from</span>:当前导航即将要离开的路由对象；<br><span class="hljs-number">3</span>、next ：调用该方法后，才能进入下一个钩子函数（afterEach）。<br><br>router.<span class="hljs-title function_">beforeEach</span>(<span class="hljs-keyword">async</span> (to, <span class="hljs-keyword">from</span>) =&gt; &#123;<br>   <span class="hljs-keyword">if</span> (<br>     <span class="hljs-comment">// 检查用户是否已登录</span><br>     !isAuthenticated &amp;&amp;<br>     <span class="hljs-comment">// ❗️ 避免无限重定向</span><br>     to.<span class="hljs-property">name</span> !== <span class="hljs-string">&#x27;Login&#x27;</span><br>   ) &#123;<br>     <span class="hljs-comment">// 将用户重定向到登录页面</span><br>     <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Login&#x27;</span> &#125;<br>   &#125;<br> &#125;)<br></code></pre></td></tr></table></figure><h5 id="24-Vue路由实现的底层原理"><a href="#24-Vue路由实现的底层原理" class="headerlink" title="24. Vue路由实现的底层原理"></a>24. Vue路由实现的底层原理</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs JS">在<span class="hljs-title class_">Vue</span>中利用数据劫持defineProperty在原型prototype上初始化了一些getter,分别是router代表当前<span class="hljs-title class_">Router</span>的实例 、 route 代表当前<span class="hljs-title class_">Router</span>的信息。在install中也全局注册了router-view,router-link,其中的<span class="hljs-title class_">Vue</span>.<span class="hljs-property">util</span>.<span class="hljs-property">defineReactive</span>, 这是<span class="hljs-title class_">Vue</span>里面观察者劫持数据的方法，劫持_route，当_route触发setter方法的时候，则会通知到依赖的组件。<br><br>接下来在init中，会挂载判断是路由的模式，是history或者是hash,点击行为按钮，调用hashchange或者popstate的同时更_route,_route的更新会触发route-view的重新渲染。<br></code></pre></td></tr></table></figure><h5 id="25-路由懒加载"><a href="#25-路由懒加载" class="headerlink" title="25. 路由懒加载"></a>25. 路由懒加载</h5><p>Vue Router 支持开箱即用的<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import#Dynamic_Imports">动态导入</a>，这意味着你可以用动态导入代替静态导入：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 将</span><br><span class="hljs-comment">// import UserDetails from &#x27;./views/UserDetails.vue&#x27;</span><br><span class="hljs-comment">// 替换成</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">UserDetails</span> = (<span class="hljs-params"></span>) =&gt; <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;./views/UserDetails.vue&#x27;</span>)<br><br><span class="hljs-keyword">const</span> router = <span class="hljs-title function_">createRouter</span>(&#123;<br>  <span class="hljs-comment">// ...</span><br>  <span class="hljs-attr">routes</span>: [&#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/users/:id&#x27;</span>, <span class="hljs-attr">component</span>: <span class="hljs-title class_">UserDetails</span> &#125;],<br>&#125;)<br></code></pre></td></tr></table></figure><h5 id="26-用过插槽吗？用的是具名插槽还是匿名插槽"><a href="#26-用过插槽吗？用的是具名插槽还是匿名插槽" class="headerlink" title="26. 用过插槽吗？用的是具名插槽还是匿名插槽"></a>26. 用过插槽吗？用的是具名插槽还是匿名插槽</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs JS">用过，都使用过。插槽相当于预留了一个位置，可以将我们书写在组件内的内容放入，写一个插槽就会将组件内的内容替换一次，两次则替换两次。为了自定义插槽的位置我们可以给插槽取名，它会根据插槽名来插入内容，一一对应。<br><br>举例来说，这里有一个 &lt;<span class="hljs-title class_">FancyButton</span>&gt; 组件，可以像这样使用：<br>template<br>&lt;<span class="hljs-title class_">FancyButton</span>&gt;<br>  <span class="hljs-title class_">Click</span> me! &lt;!-- 插槽内容 --&gt;<br>&lt;/<span class="hljs-title class_">FancyButton</span>&gt;<br><br><br>而 &lt;<span class="hljs-title class_">FancyButton</span>&gt; 的模板是这样的：<br><br>template<br>&lt;button <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;fancy-btn&quot;</span>&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">slot</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span></span> &lt;!-- 插槽出口 --&gt;<br>&lt;/button&gt;<br><br></code></pre></td></tr></table></figure><h5 id="27-Vue-loader解释一下"><a href="#27-Vue-loader解释一下" class="headerlink" title="27. Vue-loader解释一下"></a>27. Vue-loader解释一下</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JS">解析和转换 .<span class="hljs-property">vue</span> 文件，提取出其中的逻辑代码 script、样式代码 style、以及 <span class="hljs-variable constant_">HTML</span> 模版 template，再分别把它们交给对应的 <span class="hljs-title class_">Loader</span> 去处理。<br></code></pre></td></tr></table></figure><h5 id="28-Vue和React中diff算法区别"><a href="#28-Vue和React中diff算法区别" class="headerlink" title="28. Vue和React中diff算法区别"></a>28. Vue和React中diff算法区别</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs JS">vue和react的diff算法，都是忽略跨级比较，只做同级比较。vue diff时调动patch函数，参数是vnode和oldVnode，分别代表新旧节点。<br><br><span class="hljs-number">1.</span>vue对比节点。当节点元素相同，但是classname不同，认为是不同类型的元素，删除重建，而react认为是同类型节点，只是修改节点属性。<br><br><span class="hljs-number">2.</span>vue的列表对比，采用的是两端到中间比对的方式，而react采用的是从左到右依次对比的方式。当一个集合只是把最后一个节点移到了第一个，react会把前面的节点依次移动，而vue只会把最后一个节点移到第一个。总体上，vue的方式比较高效。<br></code></pre></td></tr></table></figure><h5 id="29-请你说一下-Vue-中-create-和-mount-的区别"><a href="#29-请你说一下-Vue-中-create-和-mount-的区别" class="headerlink" title="29. 请你说一下 Vue 中 create 和 mount 的区别"></a>29. 请你说一下 Vue 中 create 和 mount 的区别</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JS">create为组件初始化阶段，在此阶段主要完成数据观测(data observer)，属性和方法的运算， watch/event 事件回调。然而，挂载阶段还没开始，此时还未生成真实的<span class="hljs-variable constant_">DOM</span>，也就无法获取和操作<span class="hljs-variable constant_">DOM</span>元素。而mount主要完成从虚拟<span class="hljs-variable constant_">DOM</span>到真实<span class="hljs-variable constant_">DOM</span>的转换挂载，此时html已经渲染出来了，所以可以直接操作dom节点。<br></code></pre></td></tr></table></figure><h5 id="30-axios是什么？怎么使用？描述使用它实现登录功能的流程"><a href="#30-axios是什么？怎么使用？描述使用它实现登录功能的流程" class="headerlink" title="30. axios是什么？怎么使用？描述使用它实现登录功能的流程?"></a>30. axios是什么？怎么使用？描述使用它实现登录功能的流程?</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs JS">axios 是请求后台资源的模块。 通过npm install axios -S来安装，在大多数情况下我们需要封装拦截器，在实现登录的过程中我们一般在请求拦截器中来加入token，在响应请求器中通过判断后端返回的状态码来对返回的数据进行不同的处理。如果发送的是跨域请求，需在配置文件中 config/index.<span class="hljs-property">js</span> 进行代理配置。<br><br><br><span class="hljs-comment">// Add a request interceptor</span><br>axios.<span class="hljs-property">interceptors</span>.<span class="hljs-property">request</span>.<span class="hljs-title function_">use</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">config</span>) &#123;<br>    <span class="hljs-comment">// Do something before request is sent</span><br>    <span class="hljs-keyword">return</span> config;<br>  &#125;, <span class="hljs-keyword">function</span> (<span class="hljs-params">error</span>) &#123;<br>    <span class="hljs-comment">// Do something with request error</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(error);<br>  &#125;);<br><br><span class="hljs-comment">// Add a response interceptor</span><br>axios.<span class="hljs-property">interceptors</span>.<span class="hljs-property">response</span>.<span class="hljs-title function_">use</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">response</span>) &#123;<br>    <span class="hljs-comment">// Any status code that lie within the range of 2xx cause this function to trigger</span><br>    <span class="hljs-comment">// Do something with response data</span><br>    <span class="hljs-keyword">return</span> response;<br>  &#125;, <span class="hljs-keyword">function</span> (<span class="hljs-params">error</span>) &#123;<br>    <span class="hljs-comment">// Any status codes that falls outside the range of 2xx cause this function to trigger</span><br>    <span class="hljs-comment">// Do something with response error</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(error);<br>  &#125;);<br><br></code></pre></td></tr></table></figure><h5 id="31-computed和watch的区别？watch实现原理？watch有几种写法？"><a href="#31-computed和watch的区别？watch实现原理？watch有几种写法？" class="headerlink" title="31. computed和watch的区别？watch实现原理？watch有几种写法？"></a>31. computed和watch的区别？watch实现原理？watch有几种写法？</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs JS">计算属性computed : <br><br><span class="hljs-number">1.</span> 支持缓存，只有依赖数据发生改变，才会重新进行计算<br><span class="hljs-number">2.</span> 不支持异步，当computed内有异步操作时无效，无法监听数据的变化<br><span class="hljs-number">3.</span>computed 属性值会默认走缓存，计算属性是基于它们的响应式依赖进行缓存的，也就是基于data中声明过或者父组件传递的props中的数据通过计算得到的值<br><span class="hljs-number">4.</span> 如果一个属性是由其他属性计算而来的，这个属性依赖其他属性，是一个多对一或者一对一，一般用computed<br><span class="hljs-number">5.</span>如果computed属性属性值是函数，那么默认会走get方法；函数的返回值就是属性的属性值；在computed中的，属性都有一个get和一个set方法，当数据变化时，调用set方法。<br><br><span class="hljs-attr">computed</span>: &#123;<br>    <span class="hljs-comment">// 一个计算属性的 getter</span><br>    <span class="hljs-title function_">publishedBooksMessage</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-comment">// `this` 指向当前组件实例</span><br>      <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">author</span>.<span class="hljs-property">books</span>.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span> ? <span class="hljs-string">&#x27;Yes&#x27;</span> : <span class="hljs-string">&#x27;No&#x27;</span><br>    &#125;<br>  &#125;<br><br><br><br>侦听属性watch：<br><br><span class="hljs-number">1.</span> 不支持缓存，数据变，直接会触发相应的操作；<br><span class="hljs-number">2.</span>watch支持异步；<br><span class="hljs-number">3.</span>监听的函数接收两个参数，第一个参数是最新的值；第二个参数是输入之前的值；<br><span class="hljs-number">4.</span> 当一个属性发生变化时，需要执行对应的操作；一对多；<br><span class="hljs-number">5.</span> 监听数据必须是data中声明过或者父组件传递过来的props中的数据，当数据变化时，触发其他操作，函数有两个参数，<br>immediate：组件加载立即触发回调函数执行，<br><span class="hljs-attr">deep</span>: 深度监听，为了发现对象内部值的变化，复杂类型的数据时使用，例如数组中的对象内容的改变，注意监听数组的变动不需要这么做。<br><br><span class="hljs-attr">watch</span>: &#123;<br>    <span class="hljs-comment">// 每当 question 改变时，这个函数就会执行</span><br>    <span class="hljs-title function_">question</span>(<span class="hljs-params">newQuestion, oldQuestion</span>) &#123;<br>      <span class="hljs-keyword">if</span> (newQuestion.<span class="hljs-title function_">includes</span>(<span class="hljs-string">&#x27;?&#x27;</span>)) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getAnswer</span>()<br>      &#125;<br>    &#125;<br>  &#125;,<br><span class="hljs-attr">watch</span>: &#123;<br>    <span class="hljs-attr">someObject</span>: &#123;<br>      <span class="hljs-title function_">handler</span>(<span class="hljs-params">newValue, oldValue</span>) &#123;<br>        <span class="hljs-comment">// 注意：在嵌套的变更中，</span><br>        <span class="hljs-comment">// 只要没有替换对象本身，</span><br>        <span class="hljs-comment">// 那么这里的 `newValue` 和 `oldValue` 相同</span><br>      &#125;,<br>      <span class="hljs-attr">deep</span>: <span class="hljs-literal">true</span><br>    &#125;<br>  &#125;<br><br></code></pre></td></tr></table></figure><h5 id="32-Vue-forceUpdate的原理"><a href="#32-Vue-forceUpdate的原理" class="headerlink" title="32. Vue $forceUpdate的原理"></a>32. Vue $forceUpdate的原理</h5><p><strong>1、作用：</strong></p><p>迫使 <code>Vue</code> 实例重新渲染。注意它仅仅影响实例本身和插入插槽内容的子组件，而不是所有子组件。</p><p><strong>2、内部原理：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Vue</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">$forceUpdate</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">const</span> <span class="hljs-attr">vm</span>: <span class="hljs-title class_">Component</span> = <span class="hljs-variable language_">this</span><br>    <span class="hljs-keyword">if</span> (vm.<span class="hljs-property">_watcher</span>) &#123;<br>        vm.<span class="hljs-property">_watcher</span>.<span class="hljs-title function_">update</span>()<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>实例需要重新渲染是在依赖发生变化的时候会通知watcher，然后通知watcher来调用update方法，就是这么简单。</p><h5 id="33-v-for-key"><a href="#33-v-for-key" class="headerlink" title="33. v-for key"></a>33. v-for key</h5><ul><li>key是为Vue中的vnode标记的唯一id,通过这个key,我们的diff操作可以更准确、更快速</li><li>diff算法的过程中,先会进行新旧节点的首尾交叉对比,当无法匹配的时候会用新节点的key与旧节点进行比对,然后超出差异.</li></ul><blockquote><p>diff程可以概括为：oldCh和newCh各有两个头尾的变量StartIdx和EndIdx，它们的2个变量相互比较，一共有4种比较方式。如果4种比较都没匹配，如果设置了key，就会用key进行比较，在比较的过程中，变量会往中间靠，一旦StartIdx&gt;EndIdx表明oldCh和newCh至少有一个已经遍历完了，就会结束比较,这四种比较方式就是首、尾、旧尾新头、旧头新尾.</p><p>准确: 如果不加key,那么vue会选择复用节点(Vue的就地更新策略),导致之前节点的状态被保留下来,会产生一系列的bug. 快速: key的唯一性可以被Map数据结构充分利用,相比于遍历查找的时间复杂度<code>O(n)</code>,<code>Map</code>的时间复杂度仅仅为<code>O(1)</code></p></blockquote><h5 id="34-为什么要设置key值，可以用index吗？为什么不能？"><a href="#34-为什么要设置key值，可以用index吗？为什么不能？" class="headerlink" title="34. 为什么要设置key值，可以用index吗？为什么不能？"></a>34. 为什么要设置key值，可以用index吗？为什么不能？</h5><p>vue中列表循环需加:key&#x3D;”唯一标识” 唯一标识可以是item里面id index等，因为vue组件高度复用增加Key可以标识组件的唯一性，为了更好地区别各个组件 key的作用主要是为了高效的更新虚拟DOM</p><h5 id="35-diff复杂度原理及具体过程画图"><a href="#35-diff复杂度原理及具体过程画图" class="headerlink" title="35. diff复杂度原理及具体过程画图"></a>35. diff复杂度原理及具体过程画图</h5><p>diff算法是一种通过同层的树节点进行比较的高效算法，避免了对树进行逐层搜索遍历，所以时间复杂度只有 O(n)。</p><p><img src="image-20230216133653028.png" alt="image-20230216133653028"></p><p>diff算法有两个比较显著的特点：</p><p>1、比较只会在同层级进行, 不会跨层级比较。</p><p>2、在diff比较的过程中，循环从两边向中间收拢。</p><p>diff流程： 首先定义 oldStartIdx、newStartIdx、oldEndIdx 以及 newEndIdx 分别是新老两个 VNode 的两边的索引。</p><p>接下来是一个 while 循环，在这过程中，oldStartIdx、newStartIdx、oldEndIdx 以及 newEndIdx 会逐渐向中间靠拢。while 循环的退出条件是直到老节点或者新节点的开始位置大于结束位置。</p><p>while 循环中会遇到四种情况：</p><p>情形一：当新老 VNode 节点的 start 是同一节点时，直接 patchVnode 即可，同时新老 VNode 节点的开始索引都加 1。</p><p>情形二：当新老 VNode 节点的 end 是同一节点时，直接 patchVnode 即可，同时新老 VNode 节点的结束索引都减 1。</p><p>情形三：当老 VNode 节点的 start 和新 VNode 节点的 end 是同一节点时，这说明这次数据更新后 oldStartVnode 已经跑到了 oldEndVnode 后面去了。这时候在 patchVnode 后，还需要将当前真实 dom 节点移动到 oldEndVnode 的后面，同时老 VNode 节点开始索引加 1，新 VNode 节点的结束索引减 1。</p><p>情形四：当老 VNode 节点的 end 和新 VNode 节点的 start 是同一节点时，这说明这次数据更新后 oldEndVnode 跑到了 oldStartVnode 的前面去了。这时候在 patchVnode 后，还需要将当前真实 dom 节点移动到 oldStartVnode 的前面，同时老 VNode 节点结束索引减 1，新 VNode 节点的开始索引加 1。</p><p>while 循环的退出条件是直到老节点或者新节点的开始位置大于结束位置。</p><p>情形一：如果在循环中，oldStartIdx大于oldEndIdx了，那就表示oldChildren比newChildren先循环完毕，那么newChildren里面剩余的节点都是需要新增的节点，把[newStartIdx, newEndIdx]之间的所有节点都插入到DOM中</p><p>情形二：如果在循环中，newStartIdx大于newEndIdx了，那就表示newChildren比oldChildren先循环完毕，那么oldChildren里面剩余的节点都是需要删除的节点，把[oldStartIdx, oldEndIdx]之间的所有节点都删除</p><h5 id="36-Vue组件中的Data为什么是函数，根组件却是对象呢？"><a href="#36-Vue组件中的Data为什么是函数，根组件却是对象呢？" class="headerlink" title="36. Vue组件中的Data为什么是函数，根组件却是对象呢？"></a>36. Vue组件中的Data为什么是函数，根组件却是对象呢？</h5><p>综上可知，如果data是一个函数的话，这样每复用一次组件，就会返回一份新的data，类似于给每个组件实例创建一个私有的数据空间，让各个组件实例维护各自的数据。而单纯的写成对象形式，就使得所有组件实例共用了一份data，就会造成一个变了全都会变的结果。</p><p>所以说vue组件的data必须是函数。这都是因为js的特性带来的，跟vue本身设计无关。</p><h5 id="37-Vue的组件通信"><a href="#37-Vue的组件通信" class="headerlink" title="37. Vue的组件通信"></a>37. Vue的组件通信</h5><p>1、props和$emit</p><p>父组件向子组件传递数据是通过prop传递的，子组件传递数据给父组件是通过$emit触发事件</p><p>2、$attrs和$listeners</p><p>3、中央事件总线 bus</p><p>上面两种方式处理的都是父子组件之间的数据传递，而如果两个组件不是父子关系呢？这种情况下可以使用中央事件总线的方式。新建一个Vue事件bus对象，然后通过bus.$emit触发事件，bus.$on监听触发的事件。</p><p>4、provide和inject</p><p>父组件中通过provider来提供变量，然后在子组件中通过inject来注入变量。不论子组件有多深，只要调用了inject那么就可以注入provider中的数据。而不是局限于只能从当前父组件的prop属性来获取数据，只要在父组件的生命周期内，子组件都可以调用。</p><p>5、v-model</p><p>父组件通过v-model传递值给子组件时，会自动传递一个value的prop属性，在子组件中通过this.$emit(‘input’,val)自动修改v-model绑定的值</p><p>6、$parent和$children</p><p>7、boradcast和dispatch</p><p>8、vuex处理组件之间的数据交互 如果业务逻辑复杂，很多组件之间需要同时处理一些公共的数据，这个时候才有上面这一些方法可能不利于项目的维护，vuex的做法就是将这一些公共的数据抽离出来，然后其他组件就可以对这个公共数据进行读写操作，这样达到了解耦的目的。</p><h5 id="38-什么情况下使用-Vuex"><a href="#38-什么情况下使用-Vuex" class="headerlink" title="38. 什么情况下使用 Vuex"></a>38. 什么情况下使用 Vuex</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JS">如果应用够简单，最好不要使用 <span class="hljs-title class_">Vuex</span>，一个简单的 store 模式即可，需要构建一个中大型单页应用时，使用<span class="hljs-title class_">Vuex</span>能更好地在组件外部管理状态<br></code></pre></td></tr></table></figure><img src="image-20230216130149318.png" alt="image-20230216130149318" style="zoom:67%;" /><h5 id="39-Vuex可以直接修改state的值吗？"><a href="#39-Vuex可以直接修改state的值吗？" class="headerlink" title="39. Vuex可以直接修改state的值吗？"></a>39. Vuex可以直接修改state的值吗？</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JS">可以直接修改，但是极其不推荐，state的修改必须在mutation来修改，否则无法被devtool所监测，无法监测数据的来源，无法保存状态快照，也就无法实现时间漫游/回滚之类的操作。<br></code></pre></td></tr></table></figure><h5 id="40-为什么Vuex的mutation不能做异步操作"><a href="#40-为什么Vuex的mutation不能做异步操作" class="headerlink" title="40. 为什么Vuex的mutation不能做异步操作"></a>40. 为什么Vuex的mutation不能做异步操作</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JS"><span class="hljs-title class_">Vuex</span>中所有的状态更新的唯一途径都是mutation，异步操作通过 <span class="hljs-title class_">Action</span> 来提交 mutation实现，这样使得我们可以方便地跟踪每一个状态的变化，从而让我们能够实现一些工具帮助我们更好地了解我们的应用。每个mutation执行完成后都会对应到一个新的状态变更，这样devtools就可以打个快照存下来，否则无法被devtools所监测。如果mutation支持异步操作，就没有办法知道状态是何时更新的，无法很好的进行状态的追踪，给调试带来困难。<br></code></pre></td></tr></table></figure><h5 id="41-怎么修改Vuex中的状态？Vuex中有哪些方法"><a href="#41-怎么修改Vuex中的状态？Vuex中有哪些方法" class="headerlink" title="41. 怎么修改Vuex中的状态？Vuex中有哪些方法"></a>41. 怎么修改Vuex中的状态？Vuex中有哪些方法</h5><ul><li>通过<strong>this.$store.state.属性</strong> 的方法来访问状态</li><li>通过<strong>this.$store.commit(‘mutation中的方法’)</strong> 来修改状态</li></ul><h5 id="42-Vuex的缺点"><a href="#42-Vuex的缺点" class="headerlink" title="42. Vuex的缺点"></a>42. Vuex的缺点</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JS">如果您不打算开发大型单页应用，使用 <span class="hljs-title class_">Vuex</span> 可能是繁琐冗余的，并且state中的值会伴随着浏览器的刷新而初始化，无缓存。<br></code></pre></td></tr></table></figure><h5 id="43-什么是-Vue-nextTick-？"><a href="#43-什么是-Vue-nextTick-？" class="headerlink" title="43. 什么是 Vue.nextTick()？"></a>43. 什么是 Vue.nextTick()？</h5><p>1、$nextTick 是在下次DOM更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的DOM，意思是 等你dom加载完毕以后再去调用nextTick()里面的数据内容</p><h5 id="44-nextTick知道吗、实现的原理是什么？是宏任务还是微任务？"><a href="#44-nextTick知道吗、实现的原理是什么？是宏任务还是微任务？" class="headerlink" title="44. nextTick知道吗、实现的原理是什么？是宏任务还是微任务？"></a>44. nextTick知道吗、实现的原理是什么？是宏任务还是微任务？</h5><p>微任务</p><p>原理：</p><p>nextTick方法主要是使用了宏任务和微任务，定义了一个异步方法，多次调用nextTick会将方法存入队列中，通过这个异步方法清空队列。</p><p>作用： nextTick用于下次Dom更新循环结束之后执行延迟回调，在修改数据之后使用nextTick用于下次Dom更新循环结束之后执行延迟回调，在修改数据之后使用nextTick用于下次Dom更新循环结束之后执行延迟回调，在修改数据之后使用nextTick,则可以在回调中获取更新后的DOM。</p><h5 id="45-虚拟-dom-为什么会提高性能？"><a href="#45-虚拟-dom-为什么会提高性能？" class="headerlink" title="45. 虚拟 dom 为什么会提高性能？"></a>45. 虚拟 dom 为什么会提高性能？</h5><p>虚拟DOM其实就是一个JavaScript对象。通过这个JavaScript对象来描述真实DOM，真实DOM的操作，一般都会对某块元素的整体重新渲染，采用虚拟DOM的话，当数据变化的时候，只需要局部刷新变化的位置就好了 ,</p><p>虚拟<code>dom</code>相当于在<code>js</code>和真实<code>dom</code>中间加了一个缓存，利用<code>dom diff</code>算法避免了没有必要的<code>dom</code>操作，从而提高性能</p><p><strong>具体实现步骤如下</strong></p><ul><li>用 <code>JavaScript</code> 对象结构表示 <code>DOM</code> 树的结构；然后用这个树构建一个真正的 <code>DOM</code> 树，插到文档当中</li><li>当状态变更的时候，重新构造一棵新的对象树。然后用新的树和旧的树进行比较，记录两棵树差异</li><li>把2所记录的差异应用到步骤1所构建的真正的<code>DOM</code>树上，视图就更新</li></ul><h5 id="46-你做过哪些Vue的性能优化？"><a href="#46-你做过哪些Vue的性能优化？" class="headerlink" title="46. 你做过哪些Vue的性能优化？"></a>46. 你做过哪些Vue的性能优化？</h5><p>1、首屏加载优化</p><p>2、路由懒加载</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js">&#123;      <br>  <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/&#x27;</span>,      <br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;home&#x27;</span>,      <br>  <span class="hljs-attr">component</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;./views/home/index.vue&#x27;</span>),      <br>  <span class="hljs-attr">meta</span>: &#123; <span class="hljs-attr">isShowHead</span>: <span class="hljs-literal">true</span> &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>3、开启服务器 Gzip</p><p>开启 Gzip 就是一种压缩技术，需要前端提供压缩包，然后在服务器开启压缩，文件在服务器压缩后传给浏览器，浏览器解压后进行再进行解析。首先安装 webpack 提供的<code>compression-webpack-plugin</code>进行压缩,然后在 vue.config.js：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title class_">CompressionWebpackPlugin</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;compression-webpack-plugin&#x27;</span>)<br><span class="hljs-keyword">const</span> productionGzipExtensions = [<span class="hljs-string">&#x27;js&#x27;</span>, <span class="hljs-string">&#x27;css&#x27;</span>]......<span class="hljs-attr">plugins</span>: [      <br>  <span class="hljs-keyword">new</span> <span class="hljs-title class_">CompressionWebpackPlugin</span>(<br>    &#123;        <br>      <span class="hljs-attr">algorithm</span>: <span class="hljs-string">&#x27;gzip&#x27;</span>,        <br>      <span class="hljs-attr">test</span>:     <span class="hljs-keyword">new</span> <span class="hljs-title class_">RegExp</span>(<span class="hljs-string">&#x27;\\.(&#x27;</span> + productionGzipExtensions.<span class="hljs-title function_">join</span>(<span class="hljs-string">&#x27;|&#x27;</span>) +                 <span class="hljs-string">&#x27;)$&#x27;</span>),            <br>      <span class="hljs-attr">threshold</span>: <span class="hljs-number">10240</span>,        <br>      <span class="hljs-attr">minRatio</span>: <span class="hljs-number">0.8</span>      <br>       &#125;<br>)]....<br></code></pre></td></tr></table></figure><p>4、启动 CDN 加速</p><p>我们继续采用 cdn 的方式来引入一些第三方资源，就可以缓解我们服务器的压力，原理是将我们的压力分给其他服务器点。</p><p>5、代码层面优化</p><ul><li><p>computed 和 watch 区分使用场景</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gcode">computed： 是计算属性，依赖其它属性值，并且 computed 的值有缓存，只有它依赖的属性值发生改变，下一次获取 computed 的值时才会重新计算 computed 的值。当我们需要进行数值计算，并且依赖于其它数据时，应该使用 computed，因为可以利用 computed 的缓存特性，避免每次获取值时，都要重新计算；<br>  watch：类似于某些数据的监听回调 ，每当监听的数据变化时都会执行回调进行后续操作；当我们需要在数据变化时执行异步或开销较大的操作时，应该使用 watch，使用 watch 选项允许我们执行异步操作 <span class="hljs-comment">( 访问一个 API )</span>，限制我们执行该操作的频率，并在我们得到最终结果前，设置中间状态。这些都是计算属性无法做到的。<br></code></pre></td></tr></table></figure></li><li><p>v-if 和 v-show 区分使用场景 v-if 适用于在运行时很少改变条件，不需要频繁切换条件的场景；v-show 则适用于需要非常频繁切换条件的场景。这里要说的优化点在于减少页面中 dom 总数，我比较倾向于使用 v-if，因为减少了 dom 数量。</p></li><li><p>v-for 遍历必须为 item 添加 key，且避免同时使用 v-if v-for 遍历必须为 item 添加 key，循环调用子组件时添加 key，key 可以唯一标识一个循环个体，可以使用例如 item.id 作为 key 避免同时使用 v-if，v-for 比 v-if 优先级高，如果每一次都需要遍历整个数组，将会影响速度。</p></li></ul><p>6、Webpack 对图片进行压缩</p><p>7、避免内存泄漏</p><p>8、减少 ES6 转为 ES5 的冗余代码</p><h5 id="47-Vue的常用修饰符"><a href="#47-Vue的常用修饰符" class="headerlink" title="47. Vue的常用修饰符"></a>47. Vue的常用修饰符</h5><p><strong>一、v-model修饰符</strong></p><p>1、.lazy：</p><p>输入框改变，这个数据就会改变，lazy这个修饰符会在光标离开input框才会更新数据：</p><p><img src="%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/1472868-20200422095359145-2129658851.png" alt="img"></p><p>2、.trim：</p><p>输入框过滤首尾的空格：</p><p><img src="%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/1472868-20200422095421707-831592670.png" alt="img"></p><p>3、.number：</p><p>先输入数字就会限制输入只能是数字，先字符串就相当于没有加number，注意，不是输入框不能输入字符串，是这个数据是数字：<img src="%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/1472868-20200422095441517-895479507.png" alt="img"></p><p><strong>二、事件修饰符</strong></p><p>4、.stop：</p><p>阻止事件冒泡，相当于调用了event.stopPropagation()方法：</p><p><img src="%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/1472868-20200422095722262-891576888.png" alt="img"></p><p>5、.prevent：</p><p>阻止默认行为，相当于调用了event.preventDefault()方法，比如表单的提交、a标签的跳转就是默认事件：</p><p><img src="%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/1472868-20200422095520346-1148774494.png" alt="img"></p><p>6、.self：</p><p>只有元素本身触发时才触发方法，就是只有点击元素本身才会触发。比如一个div里面有个按钮，div和按钮都有事件，我们点击按钮，div绑定的方法也会触发，如果div的click加上self，只有点击到div的时候才会触发，变相的算是阻止冒泡：</p><p><img src="%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/1472868-20200422095746426-1272980881.png" alt="img"></p><p>7、.once：</p><p>事件只能用一次，无论点击几次，执行一次之后都不会再执行</p><p><img src="%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/1472868-20200422095802227-1462269056.png" alt="img"></p><p>8、.capture：</p><p>事件的完整机制是捕获-目标-冒泡，事件触发是目标往外冒泡</p><p>9、.sync</p><p>对prop进行双向绑定</p><p>10、.keyCode：</p><p>监听按键的指令，具体可以查看vue的键码对应表</p><h5 id="48-Vue-中-template-的编译过程"><a href="#48-Vue-中-template-的编译过程" class="headerlink" title="48. Vue 中 template 的编译过程"></a>48. Vue 中 template 的编译过程</h5><p>vue template模板编译的过程经过parse()生成ast(抽象语法树),optimize对静态节点优化，generate()生成render字符串 之后调用new Watcher()函数，用来监听数据的变化，render 函数就是数据监听的回调所调用的，其结果便是重新生成 vnode。 当这个 render 函数字符串在第一次 mount、或者绑定的数据更新的时候，都会被调用，生成 Vnode。 如果是数据的更新，那么 Vnode 会与数据改变之前的 Vnode 做 diff，对内容做改动之后，就会更新到 我们真正的 DOM</p><h5 id="49-谈谈你对Vue3-0有什么了解？"><a href="#49-谈谈你对Vue3-0有什么了解？" class="headerlink" title="49. 谈谈你对Vue3.0有什么了解？"></a>49. 谈谈你对Vue3.0有什么了解？</h5><h6 id="六大亮点"><a href="#六大亮点" class="headerlink" title="六大亮点"></a>六大亮点</h6><ol><li>性能比vue2.x快1.2~2倍</li><li>支持tree-shaking，按需编译，体积比vue2.x更小</li><li>支持组合API</li><li>更好的支持TS</li><li>更先进的组件</li></ol><h6 id="性能比vue2-x快1-2-2倍如何实现的呢"><a href="#性能比vue2-x快1-2-2倍如何实现的呢" class="headerlink" title="性能比vue2.x快1.2~2倍如何实现的呢"></a>性能比vue2.x快1.2~2倍如何实现的呢</h6><p>1.diff算法更快</p><p>vue2.0是需要全局去比较每个节点的，若发现有节点发生变化后，就去更新该节点</p><p>vue3.0是在创建虚拟dom中，会根据DOM的的内容会不会发生内容变化，添加静态标记， 谁有flag！比较谁。</p><p>2、静态提升</p><p>vue2中无论元素是否参与更新，每次都会重新创建，然后再渲染 vue3中对于不参与更新的元素，会做静态提升，只被创建一次，在渲染时直接复用即可</p><p>3、事件侦听缓存</p><p>默认情况下，onclick为动态绑定，所以每次都会追踪它的变化，但是因为是同一函数，没有必要追踪变化，直接缓存复用即可</p><p>在之前会添加静态标记8 会把点击事件当做动态属性 会进行diff算法比较， 但是在事件监听缓存之后就没有静态标记了，就会进行缓存复用</p><h6 id="为什么vue3-0体积比vue2-x小"><a href="#为什么vue3-0体积比vue2-x小" class="headerlink" title="为什么vue3.0体积比vue2.x小"></a>为什么vue3.0体积比vue2.x小</h6><p>在vue3.0中创建vue项目 除了vue-cli，webpack外还有 一种创建方法是Vite Vite是作者开发的一款有意取代webpack的工具，其实现原理是利用ES6的import会发送请求去加载文件的特性，拦截这些请求，做一些预编译，省去webpack冗长的打包时间</p><h5 id="50-vue3-0组合API"><a href="#50-vue3-0组合API" class="headerlink" title="50. vue3.0组合API"></a>50. vue3.0组合API</h5><p>说一说vue3.0的组合API跟之前vue2.0在完成业务逻辑上的区别：</p><p>在vue2.0中： 主要是往data 和method里面添加内容，一个业务逻辑需要什么data和method就往里面添加，而组合API就是 有一个自己的方法，里面有自己专注的data 和method。</p><img src="image-20230217100400438.png" alt="image-20230217100400438" style="zoom:67%;" /><img src="image-20230217100411590.png" alt="image-20230217100411590" style="zoom:67%;" /><img src="image-20230217100430825.png" alt="image-20230217100430825" style="zoom:67%;" /><p>再说一下组合API的本质是什么： 首先composition API（组合API） 和 Option API（vue2.0中的data和method）可以共用 composition API（组合API）本质就是把内容添加到Option API中进行使用</p><h5 id="51-ref和reactive的简单理解"><a href="#51-ref和reactive的简单理解" class="headerlink" title="51. ref和reactive的简单理解"></a>51. ref和reactive的简单理解</h5><p>1.ref和reactive都是vue3的监听数据的方法，本质是proxy 2.ref 基本类型复杂类型都可以监听(我们一般用ref监听基本类型)，reactive只能监听对象（arr，json） 3.ref底层还是reactive，ref是对reactive的二次包装， ref定义的数据访问的时候要多一个.value</p><h5 id="52-Vuex和redux有什么区别？他们的共同思想。"><a href="#52-Vuex和redux有什么区别？他们的共同思想。" class="headerlink" title="52. Vuex和redux有什么区别？他们的共同思想。"></a>52. Vuex和redux有什么区别？他们的共同思想。</h5><h6 id="Redux和Vuex区别"><a href="#Redux和Vuex区别" class="headerlink" title="Redux和Vuex区别"></a>Redux和Vuex区别</h6><ul><li>Vuex改进了Redux中的Action和Reducer函数，以mutations变化函数取代Reducer，无需switch，只需在对应的mutation函数里改变state值就可以</li><li>Vuex由于Vue自动重新渲染的特性，无需订阅重新渲染函数，只要生成新的state就可以</li><li>Vuex数据流的顺序是:View调用store.commit提交对应的请求到Store中对应的mutation函数 – store改变(vue检测到数据变化自动渲染)</li></ul><h6 id="共同思想"><a href="#共同思想" class="headerlink" title="共同思想"></a>共同思想</h6><ul><li>单一的数据源</li><li>变化可以预测</li><li><code>本质上:</code>Redux和Vuex都是对MVVM思想的服务，将数据从视图中抽离的一种方案</li><li><code>形式上:</code>Vuex借鉴了Redux，将store作为全局的数据中心，进行数据管理</li></ul><h5 id="53-简单说一下-微信小程序-与-Vue-的区别"><a href="#53-简单说一下-微信小程序-与-Vue-的区别" class="headerlink" title="53. 简单说一下 微信小程序 与 Vue 的区别"></a>53. 简单说一下 微信小程序 与 Vue 的区别</h5><p>1、生命周期：</p><p><code>小程序</code>的钩子函数要简单得多 。 <code>vue</code>的钩子函数在跳转新页面时，钩子函数都会触发，但是<code>小程序</code>的钩子函数，页面不同的跳转方式，触发的钩子并不一样。</p><p>在页面加载请求数据时，两者钩子的使用有些类似，<code>vue</code>一般会在<code>created</code>或者<code>mounted</code>中请求数据，而在<code>小程序</code>，会在<code>onLoad</code>或者<code>onShow</code>中请求数据。</p><p>2、数据绑定：</p><p>vue动态绑定一个变量的值为元素的某个属性的时候，会在变量前面加上冒号：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;img :src=<span class="hljs-string">&quot;imgSrc&quot;</span>/&gt;<br></code></pre></td></tr></table></figure><p>小程序 绑定某个变量的值为元素属性时，会用两个大括号括起来，如果不加括号，为被认为是字符串</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;image src=<span class="hljs-string">&quot;&#123;&#123;imgSrc&#125;&#125;&quot;</span>&gt;&lt;/image&gt;<br></code></pre></td></tr></table></figure><p>3、列表循环</p><p>4、显示与隐藏元素</p><p><code>vue</code>中，使用<code>v-if</code> 和<code>v-show</code>控制元素的显示和隐藏</p><p><code>小程序</code>中，使用<code>wx-if</code>和<code>hidden</code>控制元素的显示和隐藏</p><p>5、事件处理</p><p><code>vue</code>：使用<code>v-on:event</code>绑定事件，或者使用<code>@event</code>绑定事件</p><p><code>小程序</code>中，全用<code>bindtap(bind+event)</code>，或者<code>catchtap(catch+event)</code>绑定事件</p><p>6、数据的双向绑定</p><p>在<code>vue</code>中,只需要再<code>表单</code>元素上加上<code>v-model</code>,然后再绑定<code>data</code>中对应的一个值，当表单元素内容发生变化时，<code>data</code>中对应的值也会相应改变 。</p><p>当表单内容发生变化时，会触发表单元素上绑定的方法，然后在该方法中，通过<code>this.setData(&#123;key:value&#125;)</code>来将表单上的值赋值给<code>data</code>中的对应值 。</p><p>7、绑定事件传参</p><p>在<code>vue</code>中，绑定事件传参挺简单，只需要在触发事件的方法中，把需要传递的数据作为形参传入就可以了</p><p>在<code>小程序</code>中，不能直接在绑定事件的方法中传入参数，需要将参数作为属性值，绑定到元素上的<code>data-</code>属性上，然后在方法中，通过<code>e.currentTarget.dataset.*</code>的方式获取</p><p>8、父子组件通信</p><p>父组件向子组件传递数据，只需要在子组件通过<code>v-bind</code>传入一个值，在子组件中，通过<code>props</code>接收，即可完成数据的传递</p><p>父组件向子组件通信和<code>vue</code>类似，但是<code>小程序</code>没有通过<code>v-bind</code>，而是直接将值赋值给一个变量 在子组件<code>properties</code>中，接收传递的值</p><h5 id="54-如果你是leader，做管理系统项目-Vue和React-怎么选择？"><a href="#54-如果你是leader，做管理系统项目-Vue和React-怎么选择？" class="headerlink" title="54. 如果你是leader，做管理系统项目 Vue和React 怎么选择？"></a>54. 如果你是leader，做管理系统项目 Vue和React 怎么选择？</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs JS">评估项目成员的水平，如果成员js基础较好、编码能力较强则选择<span class="hljs-title class_">React</span>，否则<span class="hljs-title class_">Vue</span>。<br>评估系统的大小，如果想构建生态系统，则选择<span class="hljs-title class_">React</span>，如果要求而快，简单和“能用就行<span class="hljs-string">&quot;,则选择Vue。</span><br><span class="hljs-string">评估系统运行环境，如果你想要一个同时适用于Web端和原生APP的框架，请选择React(RN)。</span><br></code></pre></td></tr></table></figure><h4 id="八-React高频面试题"><a href="#八-React高频面试题" class="headerlink" title="八. React高频面试题"></a>八. React高频面试题</h4><h5 id="1-类组件和函数组件的区别"><a href="#1-类组件和函数组件的区别" class="headerlink" title="1. 类组件和函数组件的区别"></a>1. 类组件和函数组件的区别</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/*            </span><br><span class="hljs-comment">            （1）语法上：函数组件是一个函数，返回一个jsx元素，而类组件是用es6语法糖class定义，继承component这个类</span><br><span class="hljs-comment">            （2）类组件中可以通过state进行状态管理，而在函数组件中不能使用setState()，在react16.8以后，函数组件可以通过hooks中的useState来模拟类组件中的状态管理；</span><br><span class="hljs-comment">            （3）类组件中有一系列的生命周期钩子函数，在函数组件中也需要借助hooks来使用生命周期函数；</span><br><span class="hljs-comment">            （4）类组件能够捕获最新的值（永远保持一致），这是因为当实例的props属性发生修改时，class组件能够直接通过this捕获到组件最新的props；而函数式组件是捕获渲染所使用的值，已经因为javascript闭包的特性，之前的props参数保存在内存之中，无法从外部进行修改。</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h5 id="2-React-事件绑定原理"><a href="#2-React-事件绑定原理" class="headerlink" title="2. React 事件绑定原理"></a>2. React 事件绑定原理</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/*</span><br><span class="hljs-comment">        一、react并没有使用原生的浏览器事件，而是在基于Virtual DOM的基础上实现了合成事件，采用小驼峰命名法，默认的事件传播方式是冒泡，如果想改为捕获的话，直接在事件名后面加上Capture即可；事件对象event也不是原生事件对象，而是合成对象，但通过nativeEvent属性可以访问原生事件对象；</span><br><span class="hljs-comment">        二、react合成事件主要分为以下三个过程：</span><br><span class="hljs-comment">        1、事件注册</span><br><span class="hljs-comment">        在该阶段主要做了两件事：document上注册、存储事件回调。所有事件都会注册到document上，拥有统一的回调函数dispatchEvent来执行事件分发，类似于document.addEventListener(&quot;click&quot;,dispatchEvent)。</span><br><span class="hljs-comment">      register:</span><br><span class="hljs-comment">          addEventListener-click</span><br><span class="hljs-comment">          addEventListener-change</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">      listenerBank:</span><br><span class="hljs-comment">           &#123;</span><br><span class="hljs-comment">                click: &#123;key1: fn1, key2: fn2&#125;,</span><br><span class="hljs-comment">                change: &#123;key1: fn3, key3: fn4&#125;</span><br><span class="hljs-comment">           &#125;</span><br><span class="hljs-comment">    2、事件合成</span><br><span class="hljs-comment">        事件触发后，会执行一下过程：</span><br><span class="hljs-comment">        （1）进入统一的事件分发函数dispatchEvent；</span><br><span class="hljs-comment">    （2）找到触发事件的 ReactDOMComponent；</span><br><span class="hljs-comment">    （3）开始事件的合成；</span><br><span class="hljs-comment">            —— 根据当前事件类型生成指定的合成对象</span><br><span class="hljs-comment">                —— 封装原生事件和冒泡机制</span><br><span class="hljs-comment">                —— 查找当前元素以及他所有父级</span><br><span class="hljs-comment">                —— 在listenerBank根据key值查找事件回调并合成到 event(合成事件结束)</span><br><span class="hljs-comment">   3、批处理</span><br><span class="hljs-comment">           批量处理合成事件内的回调函数</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h5 id="3-React中的-setState-缺点是什么呢"><a href="#3-React中的-setState-缺点是什么呢" class="headerlink" title="3. React中的 setState 缺点是什么呢"></a>3. React中的 setState 缺点是什么呢</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/*</span><br><span class="hljs-comment">        setState执行的时候可以简单的认为，隶属于原生js执行的空间，那么就是属于同步，被react处理过的空间属于异步，这其实也是一种性能的优化，如果多次使用setState修改值，那么在异步中会先进行合并，再进行渲染，降低了操作dom的次数，具体如下：</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">        （1）setState 在合成事件和钩子函数中是“异步”的，在原生事件和 `setTimeout` 中都是同步的。</span><br><span class="hljs-comment">        （2）setState的“异步”并不是说内部由异步代码实现，其实本身执行的过程和代码都是同步的，只是合成事件和钩子函数的调用顺序在更新之前，导致在合成事件和钩子函数中没法立马拿到更新后的值，形式了所谓的“异步”，当然可以通过第二个参数 setState(partialState, callback) 中的callback拿到更新后的结果。</span><br><span class="hljs-comment">        （3）setState 的批量更新优化也是建立在“异步”（合成事件、钩子函数）之上的，在原生事件和setTimeout 中不会批量更新，在“异步”中如果对同一个值进行多次 setState， setState 的批量更新策略会对其进行覆盖，取最后一次的执行，如果是同时 setState 多个不同的值，在更新时会对其进行合并批量更新。</span><br><span class="hljs-comment">        （4）正是由于setState存在异步的机制，如果setState修改值的时候依赖于state本身的值，有时候并不可靠，这时候我们需要传入一个回调函数作为其入参，这个回调函数的第一个参数为更新前的state值。</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h5 id="4-React-组件中-props-和-state-有什么区别？"><a href="#4-React-组件中-props-和-state-有什么区别？" class="headerlink" title="4. React 组件中 props 和 state 有什么区别？"></a>4. React 组件中 props 和 state 有什么区别？</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/*</span><br><span class="hljs-comment">        1、props是从外部传入组件的参数，一般用于父组件向子组件通信，在组件之间通信使用；state一般用于组件内部的状态维护，更新组建内部的数据，状态，更新子组件的props等</span><br><span class="hljs-comment">        2、props不可以在组件内部修改，只能通过父组件进行修改；state在组件内部通过setState修改；</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h5 id="5-虚拟DOM的优劣如何？实现原理？"><a href="#5-虚拟DOM的优劣如何？实现原理？" class="headerlink" title="5. 虚拟DOM的优劣如何？实现原理？"></a>5. 虚拟DOM的优劣如何？实现原理？</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/*</span><br><span class="hljs-comment">        虚拟dom是用js模拟一颗dom树,放在浏览器内存中，相当于在js和真实dom中加了一个缓存，利用dom diff算法避免了没有必要的dom操作，从而提高性能。</span><br><span class="hljs-comment">        优点：</span><br><span class="hljs-comment">        （1）虚拟DOM具有批处理和高效的Diff算法,最终表现在DOM上的修改只是变更的部分，可以保证非常高效的渲染,优化性能；</span><br><span class="hljs-comment">        （2）虚拟DOM不会立马进行排版与重绘操作，对虚拟DOM进行频繁修改，最后一次性比较并修改真实DOM中需要改的部分；</span><br><span class="hljs-comment">        （3）虚拟 DOM 有效降低大面积真实 DOM 的重绘与排版，因为最终与真实 DOM 比较差异，可以只渲染局部；</span><br><span class="hljs-comment">        缺点：</span><br><span class="hljs-comment">        （1）首次渲染大量DOM时，由于多了一层虚拟DOM的计算，会比innerHTML插入慢；</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">      </span><br><span class="hljs-comment"></span><br><span class="hljs-comment">        虚拟DOM的组成——ReactElementelement对象结构：</span><br><span class="hljs-comment">        （1）type：元素的类型，可以是原生html类型（字符串），或者自定义组件（函数或class）</span><br><span class="hljs-comment">        （2）key：组件的唯一标识，用于Diff算法，下面会详细介绍</span><br><span class="hljs-comment">        （3）ref：用于访问原生dom节点</span><br><span class="hljs-comment">        （4）props：传入组件的props，chidren是props中的一个属性，它存储了当前组件的孩子节点，可以是数组（多个孩子节点）或对象（只有一个孩子节点）</span><br><span class="hljs-comment">        （5）owner：当前正在构建的Component所属的Component</span><br><span class="hljs-comment">        （6）self：（非生产环境）指定当前位于哪个组件实例</span><br><span class="hljs-comment">        （7）_source：（非生产环境）指定调试代码来自的文件(fileName)和代码行数(lineNumber)</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h5 id="6-diff-和-Key-之间的联系"><a href="#6-diff-和-Key-之间的联系" class="headerlink" title="6. diff 和 Key 之间的联系"></a>6. diff 和 Key 之间的联系</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/*</span><br><span class="hljs-comment">            diff算法即差异查找算法，对于DOM结构即为tree的差异查找算法，只有在React更新阶段才会有Diff算法的运用；react的diff运算为了降低时间复杂度，是按层比较新旧两个虚拟dom树的。diff运算的主要流程见下：</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">            1、tree diff : 新旧两棵dom树，逐层对比的过程就是 tree diff, 当整棵DOM树逐层对比完毕，则所有需要被按需更新的元素，必然能够被找到。</span><br><span class="hljs-comment">        2、component diff ： 在进行tree diff的时候，每一层中，都有自己的组件，组件级别的对比，叫做 component diff。如果对比前后，组件的类型相同，则暂时认为此组件不需要更新；如果对比前后，组件的类型不同，则需要移除旧组件，创建新组件，并渲染到页面上。</span><br><span class="hljs-comment">        React只会匹配类型相同的组件，也就是说如果&lt;A&gt;被&lt;B&gt;替换，那么React将直接删除A组件然后创建一个B组件；如果某组件A转移到同层B组件上，那么这个A组件会先被销毁，然后在B组件下重新生成，以A为根节点的树整个都被重新创建，这会比较耗费性能，但实际上我们很少跨层移动dom节点，一般都是同层横向移动；</span><br><span class="hljs-comment">        3、element diff ：在进行组件对比的时候，如果两个组件类型相同，则需要进行元素级别的对比，这叫做element diff。</span><br><span class="hljs-comment">        对于列表渲染，react会在创建时要求为每一项输入一个独一无二的key，这样就能进行高效的diff运算了。比如我们要在b和c节点中间插入一个节点f，jquery会将f这个节点后面的每一个节点都进行更新，比如c更新成f，d更新成c，e更新成d，这样操作的话就会特别多，而加了key的react咋不会频繁操作dom，而是优先采用移动的方式，找到正确的位置去插入新节点；所以我们不能省略key值，因为在对比两个新旧的子元素是，是通过key值来精确地判断两个节点是否为同一个，如果没有key的话则是见到谁就更新谁，非常耗费性能。</span><br><span class="hljs-comment">            当我们通过this.setState()改变数据的时候，React会将其标记为脏节点，在事件循环的最后才会重新渲染所有的脏节点以及脏节点的子树；另外我们可以使用shouldComponentUpdate这个生命周期来选择性的渲染子树，可以基于组件之前的状态或者下一个状态来决定它是否需要重新渲染，这样的话可以组织重新渲染大的子树。</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h5 id="7-React组件通信如何实现"><a href="#7-React组件通信如何实现" class="headerlink" title="7. React组件通信如何实现"></a>7. React组件通信如何实现</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/*</span><br><span class="hljs-comment">        react本身:</span><br><span class="hljs-comment">                (1)props——父组件向子组件通过props传参</span><br><span class="hljs-comment">                (2)实例方法——在父组件中可以用 refs 引用子组件，之后就可以调用子组件的实例方法了</span><br><span class="hljs-comment">                (3)回调函数——用于子组件向父组件通信，子组件调用props传递过来的方法</span><br><span class="hljs-comment">                (4)状态提升——两个子组件可以通过父组件定义的参数进行传参</span><br><span class="hljs-comment">                (5)Context上下文——一般用作全局主题</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">            状态管理:</span><br><span class="hljs-comment">                (1) mobx/redux/dva——通过在view中触发action，改变state，进而改变其他组件的view</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h5 id="8-React中refs的作用是什么？"><a href="#8-React中refs的作用是什么？" class="headerlink" title="8. React中refs的作用是什么？"></a>8. React中refs的作用是什么？</h5><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-comment">// ref是React提供的用来操纵React组件实例或者DOM元素的接口。主要用来做文本框的聚焦、触发强制动画等；</span><br><span class="hljs-comment">// 类组件</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Foo</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;<br>      <span class="hljs-title function_">constructor</span>(<span class="hljs-params">props</span>) &#123;<br>        <span class="hljs-variable language_">super</span>(props)<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">myRef</span> = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">createRef</span>()<br>      &#125;<br>      <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>            <span class="hljs-keyword">return</span> <br>                  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">                <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&#123;</span> <span class="hljs-attr">this.myRef</span> &#125; /&gt;</span></span><br><span class="language-xml">                <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span> = <span class="hljs-string">&#123;()</span>=&gt;</span>this.handle()&#125;&gt;聚焦<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">               <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>      &#125;<br>      <span class="hljs-title function_">handle</span>(<span class="hljs-params"></span>) &#123;<br>          <span class="hljs-comment">// 通过current属性访问到当前元素</span><br>            <span class="hljs-variable language_">this</span>.<span class="hljs-property">myRef</span>.<span class="hljs-property">current</span>.<span class="hljs-title function_">focus</span>()<br>      &#125;<br>&#125;<br><span class="hljs-comment">// 函数组件</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Foo</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> inputEl = <span class="hljs-title function_">useRef</span>(<span class="hljs-literal">null</span>)<br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">handle</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>        inputEl.<span class="hljs-property">current</span>.<span class="hljs-title function_">focus</span>()<br>  &#125;<br>  <span class="hljs-keyword">return</span> <br>          <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">                <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&#123;</span> <span class="hljs-attr">inputEl</span> &#125;/&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span> = <span class="hljs-string">&#123;handle&#125;</span>&gt;</span>聚焦<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>&#125;<br></code></pre></td></tr></table></figure><h5 id="9-请列举react生命周期函数。"><a href="#9-请列举react生命周期函数。" class="headerlink" title="9. 请列举react生命周期函数。"></a>9. 请列举react生命周期函数。</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/*</span><br><span class="hljs-comment">第一阶段：装载阶段3</span><br><span class="hljs-comment">    constructor()</span><br><span class="hljs-comment">    render()</span><br><span class="hljs-comment">    componentDidMount()</span><br><span class="hljs-comment">第二阶段：更新阶段2</span><br><span class="hljs-comment">    [shouldComponentUpdate()]</span><br><span class="hljs-comment">    render()</span><br><span class="hljs-comment">    componentDidUpdate()</span><br><span class="hljs-comment">第三阶段：卸载阶段1</span><br><span class="hljs-comment">    componentWillUnmount()</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">constructor生命周期：</span><br><span class="hljs-comment">    (1)当react组件实例化时，是第一个运行的生命周期；</span><br><span class="hljs-comment">    (2)在这个生命周期中，不能使用this.setState()；</span><br><span class="hljs-comment">    (3)在这个生命周期中，不能使用副作用(调接口、dom操作、定时器、长连接等)；</span><br><span class="hljs-comment">    (4)不能把props和state交叉赋值；</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">componentDidMount生命周期：</span><br><span class="hljs-comment">    (1)相当于是vue中的mounted；</span><br><span class="hljs-comment">    (2)它表示DOM结构在浏览器中渲染已完成；</span><br><span class="hljs-comment">    (3)在这里可以使用任何的副作用；</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">shouldComponentUpdate(nextProps,nextState)生命周期：</span><br><span class="hljs-comment">    (1)相当于一个开关，如果返回true则更新机制正常执行，如果为false则更新机制停止；</span><br><span class="hljs-comment">    (2)在vue中是没有的；</span><br><span class="hljs-comment">    (3)存在的意义：可以用于性能优化，但是不常用，最新的解决方案是使用PureComponent；</span><br><span class="hljs-comment">    (4)理论上，这个生命周期的作用，用于精细地控制声明式变量的更新问题，如果变化的声明式变量参与了视图渲染则返回true，如果被变化的声明式变量没有直接或间接参与视图渲染，则返回false；</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">componentDidUpdate生命周期：</span><br><span class="hljs-comment">    (1)相当于vue中的updated()；</span><br><span class="hljs-comment">    (2)它表示DOM结构渲染更新已完成，只发生在更新阶段；</span><br><span class="hljs-comment">    (3)在这里，可以执行大多数的副作用，但是不建议；</span><br><span class="hljs-comment">    (4)在这里，可以使用this.setState()，但是要有终止条件判断。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">componentWillUnmount生命周期：</span><br><span class="hljs-comment">    (1)一般在这里清除定时器、长连接等其他占用内存的构造器；</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">render生命周期：</span><br><span class="hljs-comment">    (1)render是类组件中唯一必须有的生命周期，同时必须有return（return 返回的jsx默认只能是单一根节点，但是在fragment的语法支持下，可以返回多个兄弟节点）；</span><br><span class="hljs-comment">    (2)Fragment碎片写法: &lt;React.Fragment&gt;&lt;/React.Fragment&gt; 简写成&lt;&gt;&lt;/&gt;；</span><br><span class="hljs-comment">    (3)return之前，可以做任意的业务逻辑，但是不能使用this.setState()，会造成死循环；</span><br><span class="hljs-comment">    (4)render()在装载阶段和更新阶段都会运行；</span><br><span class="hljs-comment">    (5)当render方法返回null的时候，不会影响生命周期函数的正常执行。</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h5 id="10-A-组件嵌套-B-组件，生命周期执行顺序"><a href="#10-A-组件嵌套-B-组件，生命周期执行顺序" class="headerlink" title="10. A 组件嵌套 B 组件，生命周期执行顺序"></a>10. A 组件嵌套 B 组件，生命周期执行顺序</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    父组件创建阶段的生命周期钩子函数 constructor</span><br><span class="hljs-comment">    父组件创建阶段的生命周期钩子函数 render</span><br><span class="hljs-comment">    子组件创建阶段的生命周期钩子函数 constructor</span><br><span class="hljs-comment">    子组件创建阶段的生命周期钩子函数 render</span><br><span class="hljs-comment">    子组件创建阶段的生命周期钩子函数 componentDidMount</span><br><span class="hljs-comment">    父组件创建阶段的生命周期钩子函数 componentDidMount</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h5 id="11-新出来两个钩子函数？和砍掉的will系列有啥区别？"><a href="#11-新出来两个钩子函数？和砍掉的will系列有啥区别？" class="headerlink" title="11. 新出来两个钩子函数？和砍掉的will系列有啥区别？"></a>11. 新出来两个钩子函数？和砍掉的will系列有啥区别？</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// react16 中废弃了三个钩子</span><br>componentWillMount                     <span class="hljs-comment">// 组件将要挂载的钩子</span><br>componentWillReceiveProps        <span class="hljs-comment">// 组件将要接收一个新的参数时的钩子</span><br>componentWillUpdate                    <span class="hljs-comment">// 组件将要更新的钩子</span><br><br><span class="hljs-comment">// 新增了方法</span><br>getDerivedStateFromProps        <span class="hljs-comment">// 静态方法</span><br>getSnapshotBeforeUpdate<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">        在16.8版本以后，react将diff运算改进为Fiber，这样的话当我们调用setState方法进行更新的时候，在reconciler 层中js运算会按照节点为单位拆分成一个个小的工作单元，在render前可能会中断或恢复，就有可能导致在render前这些生命周期在进行一次更新时存在多次执行的情况，此时如果我们在里面使用ref操作dom的话，就会造成页面频繁重绘，影响性能。</span><br><span class="hljs-comment">        所以废弃了这几个will系列的勾子，增加了 getDerivedStateFromProps这个静态方法，这样的话我们就不能在其中使用this.refs以及this上的方法了；getSnapshotBeforeUpdate 这个方法已经到了commit阶段，只会执行一次，给想读取 dom 的用户一些空间。</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h5 id="12-React-hooks-用过吗，为什么要用？"><a href="#12-React-hooks-用过吗，为什么要用？" class="headerlink" title="12. React hooks 用过吗，为什么要用？"></a>12. React hooks 用过吗，为什么要用？</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/*</span><br><span class="hljs-comment">        Hooks 是React在16.8版本中出的一个新功能，本质是一种函数，可以实现组件逻辑复用，让我们在函数式组件中使用类组件中的状态、生命周期等功能，hooks的名字都是以use开头。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">        react：</span><br><span class="hljs-comment">        1、useState——创建状态</span><br><span class="hljs-comment">                接收一个参数作为初始值；返回一个数组，第一个值为状态，第二个值为改变状态的函数</span><br><span class="hljs-comment">        2、useEffect——副作用（数据获取、dom操作影响页面——在渲染结束之后执行</span><br><span class="hljs-comment">                (1)第一个参数为函数，第二个参数为依赖列表，只有依赖更新时才会执行函数；返回一个函数，当页面刷新的时候先执行返回函数再执行参数函数</span><br><span class="hljs-comment">                (2)如果不接受第二个参数，那么在第一次渲染完成之后和每次更新渲染页面的时候，都会调用useEffect的回调函数</span><br><span class="hljs-comment">    3、useRef</span><br><span class="hljs-comment">        返回一个可变的ref对象，此索引在整个生命周期中保持不变。可以用来获取元素或组件的实例，用来做输入框的聚焦或者动画的触发。    </span><br><span class="hljs-comment">    4、useMemo——优化函数组件中的功能函数——在渲染期间执行</span><br><span class="hljs-comment">       （1）接收一个函数作为参数，同样接收第二个参数作为依赖列表，返回值可以是任何，函数、对象等都可以</span><br><span class="hljs-comment">       （2）这种优化有助于避免在每次渲染时都进行高开销的计算，仅会在某个依赖项改变时才重新计算            </span><br><span class="hljs-comment">        5、useContext——获取上下文注入的值    </span><br><span class="hljs-comment">                (1)接受一个context 对象，并返回该对象&lt;MyContext.Provider&gt; 元素的 value值；</span><br><span class="hljs-comment">                        const value = useContext(MyContext)；        </span><br><span class="hljs-comment">        6、useLayoutEffect——有DOM操作的副作用——</span><br><span class="hljs-comment">        简单来说就是调用时机不同，`useLayoutEffect`和原来`componentDidMount`&amp;`componentDidUpdate`一致，在react完成DOM更新后马上**同步**调用的代码，会阻塞页面渲染。而`useEffect`是会在整个页面渲染完才会调用的代码。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">官方建议优先使用`useEffect`</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">&gt; However, **we recommend starting with useEffect first** and only trying useLayoutEffect if that causes a problem.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">在实际使用时如果想避免**页面抖动**（在`useEffect`里修改DOM很有可能出现）的话，可以把需要操作DOM的代码放在`useLayoutEffect`里。在这里做点dom操作，这些dom修改会和 react 做出的更改一起被一次性渲染到屏幕上，只有一次回流、重绘的代价。</span><br><span class="hljs-comment">        7、useCallback——与useMemo类似</span><br><span class="hljs-comment">                useMemo与useCallback相同，接收一个函数作为参数，也同样接收第二个参数作为依赖列表；useCallback是对传过来的回调函数优化，返回的是一个函数</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">react-router:</span><br><span class="hljs-comment">        被route包裹的组件，可以直接使用props进行路由相关操作，但是没有被route包裹的组件只能用withRouter高阶组件修饰或者使用hooks进行操作</span><br><span class="hljs-comment">        1、useHistory——跳转路由</span><br><span class="hljs-comment">        2、useLocation——得到url对象</span><br><span class="hljs-comment">        3、useParams——得到url上的参数</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">react-redux:</span><br><span class="hljs-comment">        1、useSelector——共享状态——从redux的store中提取数据</span><br><span class="hljs-comment">        2、useDispatch——共享状态——返回edux的store中对dispatch的引用    </span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> getCinemaList = <span class="hljs-title function_">useMemo</span>(<span class="hljs-function">() =&gt;</span> cinemaList.<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">item</span>=&gt;</span>item.<span class="hljs-property">name</span>.<span class="hljs-title function_">toUpperCase</span>().<span class="hljs-title function_">includes</span>(mytext.<span class="hljs-title function_">toUpperCase</span>()) || <br>    item.<span class="hljs-property">address</span>.<span class="hljs-title function_">toUpperCase</span>().<span class="hljs-title function_">includes</span>(mytext.<span class="hljs-title function_">toUpperCase</span>())<br>    ), [cinemaList,mytext])<br></code></pre></td></tr></table></figure><h5 id="13-hooks-的使用有什么注意事项"><a href="#13-hooks-的使用有什么注意事项" class="headerlink" title="13. hooks 的使用有什么注意事项"></a>13. hooks 的使用有什么注意事项</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/*</span><br><span class="hljs-comment">        （1）只能在React函数式组件或自定义Hook中使用Hook。</span><br><span class="hljs-comment">        （2）不要在循环，条件或嵌套函数中调用Hook，必须始终在React函数的顶层使用Hook。这是因为React需要利用调用顺序来正确更新相应的状态，以及调用相应的钩子函数。一旦在循环或条件分支语句中调用Hook，就容易导致调用顺序的不一致性，从而产生难以预料到的后果。</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h5 id="14-Hooks-会取代-render-props-和高阶组件吗？"><a href="#14-Hooks-会取代-render-props-和高阶组件吗？" class="headerlink" title="14. Hooks 会取代 render props 和高阶组件吗？"></a>14. Hooks 会取代 <code>render props</code> 和高阶组件吗？</h5><p><a href="https://zh-hans.reactjs.org/docs/hooks-faq.html#do-hooks-replace-render-props-and-higher-order-components">官方简答</a></p><blockquote><ul><li>可以取代，但没必要</li><li>在Hook的渐进策略中也有提到，没有计划从React中移除class，在新的代码中同时使用Hook和class，所以这些方案目前还是可以有勇武之地</li></ul></blockquote><p><strong>what</strong></p><blockquote><ul><li>为什么要把这3种技术拿过来对比？</li></ul><blockquote><p>都在处理同一个问题，*<strong>逻辑复用*</strong></p></blockquote><ul><li><a href="https://zh-hans.reactjs.org/docs/higher-order-components.html">高阶组件HOC</a>—不是 <em>React API</em> 的一部分，是基于 <em>React</em> 的<strong>组合特性</strong>形成的设计模式。</li></ul><blockquote><p>高阶组件是参数为组件，返回值为新组件的<strong>函数</strong>（将组件转换为另一个组件，纯函数，无副作用）</p></blockquote><ul><li><a href="https://zh-hans.reactjs.org/docs/render-props.html#gatsby-focus-wrapper">Render Props</a></li></ul><blockquote><p>是指一种在 <em>React</em> 组件之间使用一个值为函数的 <em>prop</em> 共享代码的 <strong>简单技术？</strong></p></blockquote><ul><li><a href="https://zh-hans.reactjs.org/docs/hooks-intro.html">Hooks</a></li></ul><blockquote><p>React16.8新增的特性，是一些可以让你在函数组件里“钩入”React state及生命周期等特性的函数，</p></blockquote></blockquote><p><strong>why</strong></p><blockquote><p>虽然 *<strong>HOC*</strong> &amp; *<strong>Render Props*</strong> 能处理逻辑复用的问题，但是却存在各自的问题。</p><p>*<strong>HOC*</strong> 存在的问题</p><blockquote><ul><li>写法破坏了原来组件的结构，DevTools中组件会形成“嵌套地狱”</li><li>不要在 <strong>render</strong> 方法中使用 <strong>HOC</strong> 每次调用render函数会创建一个新的高阶组件导致该组件及其子组件的状态丢失</li><li>需要修复静态方法，即拷贝原组件的静态方法到高级组件中</li><li>如需传递Ref则需要通过React.forwardRef创建组件</li></ul></blockquote><p>*<strong>Render Props*</strong> 存在的问题</p><blockquote><ul><li>同样的写法会破坏原来组件的结构，DevTools中组件会形成“嵌套地狱”</li><li>与React.PureComponent组件使用有冲突</li></ul></blockquote><p>*<strong>Hook*</strong> 目前最优雅的实现，React为共享状态逻辑提供最好的原生途径</p><blockquote><ul><li>没有破坏性改动，完全可选，100%向后兼容</li><li>解决复杂组件，中逻辑状态、副作用和各种生命周期函数中逻辑代码混在一起，难以拆分，甚至形成bug的问题</li><li>处理class组件中</li></ul></blockquote></blockquote><p><strong>when</strong></p><blockquote><ul><li>在函数组件中意识到要向其添加一些state—useState</li><li>有副作用的行为时</li></ul></blockquote><p><strong>where</strong></p><blockquote><ul><li>只能在函数最外层调用Hook，不要在循环、条件判断或者子函数中调用</li><li>只能在函数组件或者自定义Hook中调用Hook</li></ul></blockquote><h5 id="15-列举重新渲染-render-的情况"><a href="#15-列举重新渲染-render-的情况" class="headerlink" title="15. 列举重新渲染 render 的情况"></a>15. 列举重新渲染 render 的情况</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>() <br><span class="hljs-variable language_">this</span>.<span class="hljs-title function_">forceUpdate</span>()<br><span class="hljs-comment">// 接受到新的props</span><br><span class="hljs-comment">// 通过状态管理，mobx、redux等</span><br><span class="hljs-comment">// 改变上下文</span><br></code></pre></td></tr></table></figure><h5 id="16-如何避免组件的重新渲染？"><a href="#16-如何避免组件的重新渲染？" class="headerlink" title="16. 如何避免组件的重新渲染？"></a>16. 如何避免组件的重新渲染？</h5><blockquote><p>当porps&#x2F;state改变时组件会执行render函数也就是重新渲染</p><ul><li>class组件中 使用shouldComponentUpdate钩子函数</li><li>PureComponent默认有避免重新渲染的功能</li><li>函数组件使用高阶组件memo处理</li></ul></blockquote><h5 id="17-渲染一个react组件的过程"><a href="#17-渲染一个react组件的过程" class="headerlink" title="17. 渲染一个react组件的过程"></a>17. 渲染一个react组件的过程</h5><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-comment">/*</span><br><span class="hljs-comment">        1、babel编译</span><br><span class="hljs-comment">        当我们对代码进行编译的时候，babel会将我们在组件中编写的jsx代码转化为React.createElement的表达式，createElement方法有三个参数，分别为type(元素类型）、attributes(元素所有属性)、children(元素所有子节点)；</span><br><span class="hljs-comment">        2、生成element</span><br><span class="hljs-comment">        当render方法被触发以后，createElement方法会执行，返回一个element对象，这个对象描述了真实节点的信息，其实就是虚拟dom节点；</span><br><span class="hljs-comment">        3、生成真实节点(初次渲染)</span><br><span class="hljs-comment">        这时候我们会判断element的类型，如果是null、false则实例一个ReactDOMEmptyComponent对象; 是string、number类型的话则实例一个ReactDOMTextComponent对象； 如果element是对象的话，会进一步判断type元素类型，是原生dom元素，则实例化ReactDOMComponent； 如果是自定义组件，则实例化ReactCompositeComponentWrapper；</span><br><span class="hljs-comment">        在这些类生成实例对象的时候，在其内部会调用 mountComponent方法，这个方法里面有一系列浏览器原生dom方法，可以将element渲染成真实的dom并插入到文档中；</span><br><span class="hljs-comment">        4、生命周期</span><br><span class="hljs-comment">        componentDidMount：会在组件挂载后(插入DOM树中) 立即调用。一般可以在这里请求数据；</span><br><span class="hljs-comment">        componentDidUpdate：会在数据更新后立即调用，首次渲染不会执行此方法；可以在其中直接调用 setState，但必须用if语句进行判断，防止死循环；</span><br><span class="hljs-comment">        conponentWillUnmount：会在组件卸载及销毁之前调用，在此方法中执行必要的清理操作，如清除timer；</span><br><span class="hljs-comment">        static getDerivedStateFromProps(prps,state)：这个生命周期函数代替了componentWillMount和componentWillUpdate生命周期；props和state发生改变则调用，在初始化挂载及后续更新时都会被调用，返回一个对象来更新state，如果返回null则不更新任何内容；</span><br><span class="hljs-comment">        shouldComponentUpdate(nextProps,nextState)：这个生命周期函数的返回值用来判断React组件是否因为当前 state 或 props 更改而重新渲染，默认返回值是true；这个方法在初始化渲染或使用forceUpdate()时不会调用；当将旧的state的值原封不动赋值给新的state（即不改变state的值，但是调用了setState）和 无数据交换的父组件的重新渲染都会导致组件重新渲染，这时候都可以通过shouldComponentUpdate来优化。</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h5 id="18-类组件怎么做性能优化？函数组件怎么做性能优化？"><a href="#18-类组件怎么做性能优化？函数组件怎么做性能优化？" class="headerlink" title="18. 类组件怎么做性能优化？函数组件怎么做性能优化？"></a>18. 类组件怎么做性能优化？函数组件怎么做性能优化？</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/*</span><br><span class="hljs-comment">类组件：</span><br><span class="hljs-comment">    （1）使用shouldComponentUpdate：这个生命周期可以让我们决定当前状态或属性的改变是否重新渲染组件，默认返回ture，返回false时不会执行render，在初始化渲染或使用forceUpdate()时不会调用；如果在shouldComponentUpdate比较的值是引用类型的话，可能达不到我们想要的效果，因为引用类型指向同一个地址；</span><br><span class="hljs-comment">        当将旧的state的值原封不动赋值给新的state（即不改变state的值，但是调用了setState）和 无数据交换的父组件的重新渲染都会导致组件重新渲染，这时候都可以通过shouldComponentUpdate来优化；</span><br><span class="hljs-comment">    （2）React.PureComponent：基本上和Component用法一致，不同之处在于 PureComponent不需要开发者自己设置shouldComponentUpdate，因为PureComponent自带通过props和state的浅对比来实现 shouldComponentUpate；但是如果props和state对象包含复杂的数据结构，它可能会判断错误(表现为对象深层的数据已改变，视图却没有更新）；</span><br><span class="hljs-comment">    （3）使用Immutable：immutable是一种持久化数据，一旦被创建就不会被修改，修改immutable对象的时候返回新的immutable；也就是说在使用旧数据创建新数据的时候，会保证旧数据同时可用且不变；为了避免深度复制所有节点的带来的性能损耗，immutable使用了结构共享，即如果对象树中的一个节点发生变化，只修改这个节点和受他影响的父节点，其他节点仍然共享；</span><br><span class="hljs-comment">    （4）bind函数：在react中改变this的指向有三种方法，a)constructor中用bind绑定; b)使用时通过bind绑定; 3)使用箭头函数；选择第一种只在组件初始化的时候执行一次，第二种组件在每次render都要重新绑定，第三种在每次render时候都会生成新的箭头函数，所以选择第一种；</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">函数组件：</span><br><span class="hljs-comment">    （1）useCallback：接收一个函数作为参数，接收第二个参数作为依赖列表，返回值为函数，有助于避免在每次渲染时都进行高开销的计算，仅会在某个依赖项改变时才重新计算；可以使用useCallback把要传递给子组件的函数包裹起来，这样父组件刷新的时候，传递给子组件的函数指向不会发生改变，可以减少子组件的渲染次数；</span><br><span class="hljs-comment">            const handleUseCallback=useCallback(handleClick,[])</span><br><span class="hljs-comment">            &lt;Child handleClick=&#123;handleUseCallback&#125; /&gt;</span><br><span class="hljs-comment">    （2）useMemo：useMemo的使用和useCallback差不多，只是useCallback返回的是一个函数，useMemo返回值可以是函数、对象等都可以；</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">两者都可使用：</span><br><span class="hljs-comment">    （1）React.memo：React.memo 功能同React.PureComponent，但React.memo是高阶组件，既可以用在类组件中也可以用在函数组件中；memo还可以接收第二个参数，是一个可定制化的比较函数，其返回值与 shouldComponentUpdate的相反；</span><br><span class="hljs-comment">    （2）使用key：在列表渲染时使用key，这样当组件发生增删改、排序等操作时，diff运算后可以根据key值直接调整DOM顺序，避免不必要的渲染而避免性能的浪费；</span><br><span class="hljs-comment">    （3）不要滥用props：尽量只传需要的数据，避免多余的更新，尽量避免使用&#123;…props&#125;；</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h5 id="19-React-按需加载"><a href="#19-React-按需加载" class="headerlink" title="19. React 按需加载"></a>19. React 按需加载</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 1、使用React.lazy， 但是React.lazy技术还不支持服务端渲染</span><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">OtherComponent</span> = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">lazy</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;./OtherComponent&#x27;</span>))<br><span class="hljs-comment">// 2、使用Loadable Components这个库</span><br><span class="hljs-keyword">import</span> loadable <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@loadable/component&#x27;</span><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">OtherComponent</span> = <span class="hljs-title function_">loadable</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;./OtherComponent&#x27;</span>))<br></code></pre></td></tr></table></figure><h5 id="20-纯函数有什么特点，副作用函数特点"><a href="#20-纯函数有什么特点，副作用函数特点" class="headerlink" title="20. 纯函数有什么特点，副作用函数特点"></a>20. 纯函数有什么特点，副作用函数特点</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/*</span><br><span class="hljs-comment">        纯函数与外界交换数据只有一个唯一渠道——参数和返回值；函数从函数外部接受的所有输入信息都通过参数传递到该函数内部；函数输出到函数外部的所有信息都通过返回值传递到该函数外部。</span><br><span class="hljs-comment">        纯函数的优点：无状态，线程安全；纯函数相互调用组装起来的函数，还是纯函数；应用程序或者运行环境可以对纯函数的运算结果进行缓存，运算加快速度。</span><br><span class="hljs-comment">        函数副作用是指当调用函数时，除了返回函数值之外，还对主调用函数产生附加的影响。比如调接口、修改全局变量、抛出一个异常或以一个错误终止、打印到终端或读取用户输入、读取或写入一个文件等，所以说副作用是编程中最关键的部分，因为我们需要跟用户、跟数据进行交互。</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h5 id="21-React-中的StrictMode-严格模式-是什么？"><a href="#21-React-中的StrictMode-严格模式-是什么？" class="headerlink" title="21 React 中的StrictMode(严格模式)是什么？"></a>21 React 中的StrictMode(严格模式)是什么？</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    React的StrictMode是一种辅助组件，用&lt;StrictMode /&gt;包装组件，可以帮助我们编写更好的react组件，不会渲染出任何可见的ui；仅在开发模式下运行，它们不会影响生产构建，可以做以下检查：</span><br><span class="hljs-comment">    （1）验证内部组件是否遵循某些推荐做法，如果没有，会在控制台给出警告；</span><br><span class="hljs-comment">    （2）验证是否使用的已经废弃的方法，如果有，会在控制台给出警告；</span><br><span class="hljs-comment">    （3）通过识别潜在的风险预防一些副作用。</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h5 id="22-如何在-React-的-Props-上应用验证？"><a href="#22-如何在-React-的-Props-上应用验证？" class="headerlink" title="22. 如何在 React 的 Props 上应用验证？"></a>22. 如何在 React 的 Props 上应用验证？</h5><blockquote><p>使用PropTypes进行类型检查</p></blockquote><p><a href="https://zh-hans.reactjs.org/docs/typechecking-with-proptypes.html#gatsby-focus-wrapper">PropTypes</a>自React v15.5起，请使用这个库<a href="https://www.npmjs.com/package/prop-types">prop-types</a></p><p>What &amp; Why &amp; When</p><blockquote><ul><li>随着应用的不断增长，也是为了使程序设计更加严谨，我们通常需要对数据的类型（值）进行一些必要的验证</li><li>出于性能方面的考虑，propTypes仅在开发模式下进行检测,在程序运行时就能检测出错误，不能使用到用户交互提醒用户操作错误等</li><li>也可以使用<a href="https://flow.org/">Flow</a>或者<a href="https://www.typescriptlang.org/">TypeScript</a>做类型检查，后期建议用typescript进行替代更好</li></ul></blockquote><p>Where</p><blockquote><ul><li>class组件</li><li>函数组件</li><li><a href="https://zh-hans.reactjs.org/docs/react-api.html#reactmemo">React.memo</a>高阶组件 *<strong>可自行扩展*</strong></li><li><a href="https://zh-hans.reactjs.org/docs/react-api.html#reactforwardref">React.forwardRef</a>组件 *<strong>可自行扩展*</strong></li></ul></blockquote><p>How</p><blockquote><p>我们在组件类下添加一个静态属性 propTypes (属性名不能更改)，它的值也是一个对象，用来设置组件中props的验证规则，key 是要验证的属性名称，value 是验证规则。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 类组件</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">PropTypes</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;prop-types&#x27;</span>;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Greeting</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;<br>  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> (<br>      <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Hello, &#123;this.props.name&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br>    );<br>  &#125;<br>&#125;<br><span class="hljs-comment">// 指定 props 的默认值：</span><br><span class="hljs-title class_">Greeting</span>.<span class="hljs-property">defaultProps</span> = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Stranger&#x27;</span><br>&#125;;<br><span class="hljs-comment">// 类组件在这里做检测</span><br><span class="hljs-title class_">Greeting</span>.<span class="hljs-property">propTypes</span> = &#123;<br>  <span class="hljs-comment">// v15.4 and below</span><br>  <span class="hljs-comment">// name: React.PropTypes.string</span><br>  <span class="hljs-attr">name</span>: <span class="hljs-title class_">PropTypes</span>.<span class="hljs-property">string</span><br>&#125;;<br><br><span class="hljs-comment">// 函数组件</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">HelloWorldComponent</span>(<span class="hljs-params">&#123; name &#125;</span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>Hello, &#123;name&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  )<br>&#125;<br><span class="hljs-comment">// 函数组件在这里做检测</span><br><span class="hljs-title class_">HelloWorldComponent</span>.<span class="hljs-property">propTypes</span> = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-title class_">PropTypes</span>.<span class="hljs-property">string</span><br>&#125;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">HelloWorldComponent</span><br></code></pre></td></tr></table></figure><h5 id="23-什么是高阶组件、受控组件及非受控组件？都有啥区别"><a href="#23-什么是高阶组件、受控组件及非受控组件？都有啥区别" class="headerlink" title="23. 什么是高阶组件、受控组件及非受控组件？都有啥区别"></a>23. 什么是高阶组件、受控组件及非受控组件？都有啥区别</h5><p>*<strong>定义*</strong></p><blockquote><ul><li><a href="https://zh-hans.reactjs.org/docs/higher-order-components.html">高阶组件HOC</a>—不是 <em>React API</em> 的一部分，是基于 <em>React</em> 的<strong>组合特性</strong>形成的设计模式。</li></ul><blockquote><p>高阶组件是参数为组件，返回值为新组件的<strong>函数</strong>（将组件转换为另一个组件，纯函数，无副作用）</p></blockquote><ul><li><a href="https://zh-hans.reactjs.org/docs/forms.html#controlled-components">受控组件</a></li></ul><blockquote><p>在表单元素中，state是唯一数据源，渲染表单的React组件控制着用户输入过程中表单发生的操作。被React以这种方式控制取值的表单输入元素叫做受控组件</p></blockquote><ul><li><a href="https://zh-hans.reactjs.org/docs/uncontrolled-components.html">非受控组件</a></li></ul><blockquote><p>表单数据由DOM节点来处理，而不是用state来管理数据，一般可以使用ref来从DOM节点中获取表单数据</p></blockquote></blockquote><p>*<strong>区别*</strong></p><blockquote><ul><li>受控组件和非受控组件是表单中的组件，高阶组件相当于对某个组件注入一些属性方法</li><li>高阶组件是解决代码复用性问题产生的技术</li><li>受控组件必须要有一个value，结合onChange来控制这个value，取值为event.target.value&#x2F;event.target.checked</li><li>非受控组件相当于操作DOM，一般有个defaultValue，通过onBlur触发响应方法</li></ul></blockquote><h5 id="24-请你说说React的路由是什么？"><a href="#24-请你说说React的路由是什么？" class="headerlink" title="24. 请你说说React的路由是什么？"></a>24. 请你说说React的路由是什么？</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/*</span><br><span class="hljs-comment">        路由分为前端路由和后端路由，后端路由是服务器根据用户发起的请求而返回不同内容，前端路由是客户端根据不同的URL去切换组件；在web应用前端开发中，路由系统是最核心的部分，当页面的URL发生改变时，页面的显示结果可以根据URL的变化而变化，但是页面不会刷新。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">        react生态中路由通常是使用react-router来进行配置，其主要构成为：</span><br><span class="hljs-comment">（1）Router——对应路由的两种模式，包括&lt;BrowsersRouter&gt;与&lt;HashRouter&gt;；</span><br><span class="hljs-comment">（2）route matching组件——控制路径对应的显示组件，可以进行同步加载和异步加载，&lt;Route&gt;；</span><br><span class="hljs-comment">（3）navigation组件——用做路由切换和跳转，&lt;Link&gt;；</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">        BrowserRouter与HashRouter的区别：</span><br><span class="hljs-comment">（1）底层原理不一样：BrowserRouter使用的是H5的history API，不兼容IE9及以下版本；HashRouter使用的是URL的哈希值；</span><br><span class="hljs-comment">（2）path表现形式不一样：BrowserRouter的路径中没有#,例如：localhost:3000/demo/test；HashRouter的路径包含#,例如：localhost:3000/#/demo/test；</span><br><span class="hljs-comment">（3）刷新后对路由state参数的影响：BrowserRouter没有任何影响，因为state保存在history对象中；HashRouter刷新后会导致路由state参数的丢失；</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h5 id="25-React路由懒加载的实现"><a href="#25-React路由懒加载的实现" class="headerlink" title="25. React路由懒加载的实现"></a>25. React路由懒加载的实现</h5><ul><li>*<strong>原理*</strong></li></ul><blockquote><ul><li>webpack代码分割</li><li>React利用 React.lazy与import()实现了渲染时的动态加载</li><li>利用Suspense来处理异步加载资源时页面应该如何显示的问题</li></ul></blockquote><ul><li><em>1.React.lazy</em></li></ul><blockquote><ul><li>通过lazy() api来动态import需要懒加载的组件</li><li>import的组件目前只支持export default的形式导出</li><li>Suspense来包裹懒加载的组件进行加载，可以设置fallback现实加载中效果</li><li>React.lazy可以结合Router来对模块进行懒加载。</li></ul></blockquote><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">BrowserRouter</span> <span class="hljs-keyword">as</span> <span class="hljs-title class_">Router</span>, <span class="hljs-title class_">Route</span>, <span class="hljs-title class_">Switch</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-router-dom&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">Suspense</span>, lazy &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-title class_">Home</span> = <span class="hljs-title function_">lazy</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;./routes/Home&#x27;</span>))<br><span class="hljs-keyword">const</span> <span class="hljs-title class_">AnyComponent</span> = <span class="hljs-title function_">lazy</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;./routes/AnyComponent&#x27;</span>))<br><br>...<br><span class="hljs-keyword">return</span> (<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Router</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">Suspense</span> <span class="hljs-attr">fallback</span>=<span class="hljs-string">&#123;</span>&lt;<span class="hljs-attr">div</span>&gt;</span>Loading...<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>&#125;&gt;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Switch</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">Route</span> <span class="hljs-attr">exact</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;/&quot;</span> <span class="hljs-attr">component</span>=<span class="hljs-string">&#123;Home&#125;/</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">Route</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;/anyManage&quot;</span> <span class="hljs-attr">component</span>=<span class="hljs-string">&#123;AnyComponent&#125;/</span>&gt;</span></span><br><span class="language-xml">        ...</span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">Switch</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">Suspense</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">Router</span>&gt;</span></span><br></code></pre></td></tr></table></figure><ul><li><em>2.react-loadable</em></li></ul><blockquote><p>react-loadable是以组件级别来分割代码的，这意味着，我们不仅可以根据路由按需加载，还可以根据组件按需加载，使用方式和路由分割一样，只用修改组件的引入方式即可</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 路由懒加载（异步组件）</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">Loadable</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-loadable&#x27;</span>;<br><span class="hljs-comment">//通用过场组件</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">LoadingComponent</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>loading<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  )<br>&#125;<br>...<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> (loader, loading=<span class="hljs-title class_">LoadingComponent</span>) =&gt; &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Loadable</span>(&#123;<br>    loader,<br>    loading<br>  &#125;)<br>&#125;<br><br><span class="hljs-comment">//Route中调用</span><br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">BrowserRouter</span>, <span class="hljs-title class_">Route</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-router-dom&#x27;</span><br><span class="hljs-keyword">const</span> loadable <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./loadable&#x27;</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-title class_">AnyComponent</span> = <span class="hljs-title function_">loadable</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;./AnyComponent&#x27;</span>))<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">Routes</span> = (<span class="hljs-params"></span>) =&gt; (<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">BrowserRouter</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">Route</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;/home&quot;</span> <span class="hljs-attr">component</span>=<span class="hljs-string">&#123;AnyComponent&#125;/</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">BrowserRouter</span>&gt;</span></span><br>);<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">Routes</span>;<br></code></pre></td></tr></table></figure><ul><li><em>3.webpack配置中使用lazyload-loader</em></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// webpack 配置中</span><br><span class="hljs-attr">module</span>: &#123;<br> <span class="hljs-attr">rules</span>: [<br> &#123;<br> <span class="hljs-attr">test</span>: <span class="hljs-regexp">/.(js|jsx)$/</span>,,<br> <span class="hljs-attr">use</span>: [<br> <span class="hljs-string">&#x27;babel-loader&#x27;</span>,<br> <span class="hljs-string">&#x27;lazyload-loader&#x27;</span><br> ]<br>&#125;,<br><br><span class="hljs-comment">// 业务代码中</span><br><span class="hljs-comment">// 使用lazy! 前缀 代表需要懒加载的Router</span><br> <span class="hljs-keyword">import</span> <span class="hljs-title class_">Shop</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;lazy!./src/view/Shop&#x27;</span>;<br> <span class="hljs-comment">// Router 正常使用</span><br> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Route</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;/shop&quot;</span> <span class="hljs-attr">component</span>=<span class="hljs-string">&#123;Shop&#125;</span> /&gt;</span></span><br></code></pre></td></tr></table></figure><ul><li><em>4.import()</em> webpack v2+</li></ul><blockquote><p>符合ECMAScript提议的import()语法，该提案与普通 import 语句或 require 函数的类似，但返回一个 Promise 对象</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">component</span>(<span class="hljs-params"></span>) &#123;<br> <span class="hljs-keyword">return</span> <span class="hljs-keyword">import</span>( <span class="hljs-comment">/* webpackChunkName: &quot;lodash&quot; */</span> <span class="hljs-string">&#x27;lodash&#x27;</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">_</span> =&gt;</span> &#123;<br> <span class="hljs-keyword">var</span> element = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;div&#x27;</span>);<br> element.<span class="hljs-property">innerHTML</span> = _.<span class="hljs-title function_">join</span>([<span class="hljs-string">&#x27;Hello&#x27;</span>, <span class="hljs-string">&#x27;webpack&#x27;</span>], <span class="hljs-string">&#x27; &#x27;</span>);<br> <span class="hljs-keyword">return</span> element;<br> &#125;).<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> <span class="hljs-string">&#x27;An error occurred while loading the component&#x27;</span>);<br>&#125;<br><span class="hljs-comment">// 或者使用async</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">getComponent</span>(<span class="hljs-params"></span>) &#123;<br> <span class="hljs-keyword">var</span> element = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;div&#x27;</span>);<br> <span class="hljs-keyword">const</span> _ = <span class="hljs-keyword">await</span> <span class="hljs-keyword">import</span>(<span class="hljs-comment">/* webpackChunkName: &quot;lodash&quot; */</span> <span class="hljs-string">&#x27;lodash&#x27;</span>);<br> element.<span class="hljs-property">innerHTML</span> = _.<span class="hljs-title function_">join</span>([<span class="hljs-string">&#x27;Hello&#x27;</span>, <span class="hljs-string">&#x27;webpack&#x27;</span>], <span class="hljs-string">&#x27; &#x27;</span>);<br> <span class="hljs-keyword">return</span> element;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><em>5.requre.ensure</em> webpack v1 v2</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">require</span>.<span class="hljs-title function_">ensure</span>([], <span class="hljs-keyword">function</span>(<span class="hljs-params"><span class="hljs-built_in">require</span></span>)&#123;<br> <span class="hljs-keyword">var</span> list = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./list&#x27;</span>);<br> list.<span class="hljs-title function_">show</span>();<br>，<span class="hljs-string">&#x27;list&#x27;</span>);<br>&lt;!-- <span class="hljs-title class_">Router</span> --&gt;<br><span class="hljs-keyword">const</span> <span class="hljs-title class_">Foo</span> = <span class="hljs-built_in">require</span>.<span class="hljs-title function_">ensure</span>([], <span class="hljs-function">() =&gt;</span> &#123;<br> <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;Foo&quot;</span>);<br>&#125;, <span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;<br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&quot;We failed to load chunk: &quot;</span> + err);<br>&#125;, <span class="hljs-string">&quot;chunk-name&quot;</span>);<br><span class="hljs-comment">//react-router2 or 3</span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Route</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;/foo&quot;</span> <span class="hljs-attr">getComponent</span>=<span class="hljs-string">&#123;Foo&#125;</span> /&gt;</span></span><br></code></pre></td></tr></table></figure><h5 id="26-React-router-dom内部是怎么样实现的，怎么做路由守卫？"><a href="#26-React-router-dom内部是怎么样实现的，怎么做路由守卫？" class="headerlink" title="26. React-router-dom内部是怎么样实现的，怎么做路由守卫？"></a>26. React-router-dom内部是怎么样实现的，怎么做路由守卫？</h5><h6 id="内部实现"><a href="#内部实现" class="headerlink" title="内部实现"></a>内部实现</h6><ul><li>总</li></ul><blockquote><p>react-router-dom利用了Context API，通过上下文对象将当前路由信息对象注入到 <em>Router</em> 组件中，所以 <em>Router</em> 组件中 <em>render()</em> 渲染的内容就是 <em>ContextAPI</em> 提供的 <em>Provider</em> 组件，然后接收 <em>Router</em> 组件中的当前路由信息对象。 这样 <em>Router</em> 组件下的所有组件都能通过上下文拿到当前路由信息对象，即其中的<em>Switch</em> 、 <em>Route</em> 、 <em>Link</em> 、<em>Redirect</em> 等组件都可以拿到当前路由信息对象，然后通过改变当前路由信息来实现动态切换 <em>Route</em> 组件的渲染。</p></blockquote><ul><li>分</li></ul><blockquote><ul><li>RouterContext：react-router使用context实现跨组件间数据传递，所以react-router定义了一个routerContext作为数据源，</li><li>Router：BrowserRouter和HashRouter将当前路由注入到上下文中，同时路由信息包含location、match、history</li><li>Route：路由规则，获取RouterContext的信息(location对象)，获取path和component属性，判断path和当前的location是否匹配，如果匹配，则渲染component，否则返回null，不渲染任何内容</li><li>Switch：遍历所有子元素(Route)，判断Route的path和location是否匹配，如果匹配，则渲染，否则不渲染</li><li>Redireact：未能配则重定向到指定页面</li><li>Link&#x2F;NavLink: Link组件本质就是a标签，它修改了a标签的默认行为，当点击Link时，会导航到对应的路由，导致locaiton对象的改变，出发组件的更新</li><li>withRouter：对传入的组件进行加强，功能就是获取routerContext上面的信息，然后作为props传给需要加强的组件</li></ul></blockquote><h6 id="怎么做路由守卫"><a href="#怎么做路由守卫" class="headerlink" title="怎么做路由守卫"></a>怎么做路由守卫</h6><ul><li>路由里设置meta元字符实现路由拦截</li></ul><blockquote><ul><li>React Router 4.0之前也像vue中一样有个钩子函数 <em>onEnter</em> 可实现</li><li>ReactRouter 4.0开始自己实现如下</li></ul></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// routerMap.js中</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">Index</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./page/index&#x27;</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> [<br>  &#123; <span class="hljs-attr">path</span>:<span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;App&#x27;</span>, <span class="hljs-attr">component</span>:<span class="hljs-title class_">Index</span>, <span class="hljs-attr">auth</span>: <span class="hljs-literal">true</span> &#125;,<br>  ...<br>]<br><br><span class="hljs-comment">//入口文件 app.js中</span><br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">BrowserRouter</span> <span class="hljs-keyword">as</span> <span class="hljs-title class_">Router</span>, <span class="hljs-title class_">Switch</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react-router-dom&quot;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-title class_">FrontendAuth</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./FrontendAuth&quot;</span>;<br><span class="hljs-keyword">import</span> routerMap <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./routerMap&quot;</span>;<br>...<br><br><span class="hljs-keyword">return</span> (<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Router</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Switch</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">FrontendAuth</span> <span class="hljs-attr">routerConfig</span>=<span class="hljs-string">&#123;routerMap&#125;</span> /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">Switch</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">Router</span>&gt;</span></span><br>)<br><br><span class="hljs-comment">// 高阶组件FrontendAuth 处理路由跳转，即路由守卫功能</span><br><br><span class="hljs-comment">//FrontendAuth.js</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; <span class="hljs-title class_">Component</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">Route</span>, <span class="hljs-title class_">Redirect</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react-router-dom&quot;</span>;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">FrontendAuth</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Component</span> &#123;<br>  <span class="hljs-comment">// eslint-disable-next-line no-useless-constructor</span><br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">props</span>) &#123;<br>    <span class="hljs-variable language_">super</span>(props);<br>  &#125;<br>  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">const</span> &#123; routerConfig, location &#125; = <span class="hljs-variable language_">this</span>.<span class="hljs-property">props</span>;<br>    <span class="hljs-keyword">const</span> &#123; pathname &#125; = location;<br>    <span class="hljs-keyword">const</span> isLogin = sessionStorage.<span class="hljs-title function_">getItem</span>(<span class="hljs-string">&quot;username&quot;</span>);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(pathname, isLogin);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(location);<br>    <span class="hljs-comment">// 如果该路由不用进行权限校验，登录状态下登陆页除外</span><br>    <span class="hljs-comment">// 因为登陆后，无法跳转到登陆页</span><br>    <span class="hljs-comment">// 这部分代码，是为了在非登陆状态下，访问不需要权限校验的路由</span><br>    <span class="hljs-keyword">const</span> targetRouterConfig = routerConfig.<span class="hljs-title function_">find</span>(<br>      <span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> item.<span class="hljs-property">path</span> === pathname<br>    );<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(targetRouterConfig);<br>    <span class="hljs-keyword">if</span> (targetRouterConfig &amp;&amp; !targetRouterConfig.<span class="hljs-property">auth</span> &amp;&amp; !isLogin) &#123;<br>      <span class="hljs-keyword">const</span> &#123; component &#125; = targetRouterConfig;<br>      <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Route</span> <span class="hljs-attr">exact</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&#123;pathname&#125;</span> <span class="hljs-attr">component</span>=<span class="hljs-string">&#123;component&#125;</span> /&gt;</span></span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (isLogin) &#123;<br>      <span class="hljs-comment">// 如果是登陆状态，想要跳转到登陆，重定向到主页</span><br>      <span class="hljs-keyword">if</span> (pathname === <span class="hljs-string">&quot;/login&quot;</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Redirect</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&quot;/&quot;</span> /&gt;</span></span>;<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 如果路由合法，就跳转到相应的路由</span><br>        <span class="hljs-keyword">if</span> (targetRouterConfig) &#123;<br>          <span class="hljs-keyword">return</span> (<br>            <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Route</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&#123;pathname&#125;</span> <span class="hljs-attr">component</span>=<span class="hljs-string">&#123;targetRouterConfig.component&#125;</span> /&gt;</span></span><br>          );<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          <span class="hljs-comment">// 如果路由不合法，重定向到 404 页面</span><br>          <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Redirect</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&quot;/404&quot;</span> /&gt;</span></span>;<br>        &#125;<br>      &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// 非登陆状态下，当路由合法时且需要权限校验时，跳转到登陆页面，要求登陆</span><br>      <span class="hljs-keyword">if</span> (targetRouterConfig &amp;&amp; targetRouterConfig.<span class="hljs-property">auth</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Redirect</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&quot;/login&quot;</span> /&gt;</span></span>;<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 非登陆状态下，路由不合法时，重定向至 404</span><br>        <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Redirect</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&quot;/404&quot;</span> /&gt;</span></span>;<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">FrontendAuth</span>;<br></code></pre></td></tr></table></figure><ul><li>总结一下，实现路由守卫需要考虑到以下的问题：</li></ul><blockquote><ul><li>未登录情况下，访问不需要权限校验的合法页面：允许访问</li><li>未登录情况下，访问需要权限校验的页面：禁止访问，跳转至登陆页</li><li>未登录情况下，访问所有的非法页面：禁止访问，跳转至 404</li><li>登陆情况下，访问登陆页面：禁止访问，跳转至主页</li><li>登陆情况下，访问除登陆页以外的合法页面：允许访问</li><li>登陆情况下，访问所有的非法页面：禁止访问，跳转至 404</li></ul></blockquote><h5 id="27-React有哪些性能优化的手段？"><a href="#27-React有哪些性能优化的手段？" class="headerlink" title="27. React有哪些性能优化的手段？"></a>27. React有哪些性能优化的手段？</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    1、使用纯组件；</span><br><span class="hljs-comment">    2、使用 React.memo 进行组件记忆（React.memo 是一个高阶组件），对于相同的输入，不重复执行；</span><br><span class="hljs-comment">    3、如果是类组件，使用 shouldComponentUpdate（这是在重新渲染组件之前触发的其中一个生命周期事件）生命周期事件，可以利用此事件来决定何时需要重新渲染组件；</span><br><span class="hljs-comment">    4、路由懒加载；</span><br><span class="hljs-comment">    5、使用 React Fragments 避免额外标记；</span><br><span class="hljs-comment">    6、不要使用内联函数定义（如果我们使用内联函数，则每次调用“render”函数时都会创建一个新的函数实例）；</span><br><span class="hljs-comment">    7、避免在Willxxx系列的生命周期中进行异步请求，操作dom等；</span><br><span class="hljs-comment">    8、如果是类组件，事件函数在Constructor中绑定bind改变this指向；</span><br><span class="hljs-comment">    9、避免使用内联样式属性；</span><br><span class="hljs-comment">    10、优化 React 中的条件渲染；</span><br><span class="hljs-comment">    11、不要在 render 方法中导出数据；</span><br><span class="hljs-comment">    12、列表渲染的时候加key；</span><br><span class="hljs-comment">    13、在函数组件中使用useCallback和useMemo来进行组件优化，依赖没有变化的话，不重复执行；</span><br><span class="hljs-comment">    14、类组件中使用immutable对象；</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h5 id="28-描述-Flux-与-MVC？"><a href="#28-描述-Flux-与-MVC？" class="headerlink" title="28. 描述 Flux 与 MVC？"></a>28. 描述 Flux 与 MVC？</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/*</span><br><span class="hljs-comment">        传统的 MVC 模式在分离数据(Model)、UI(View和逻辑(Controller)方面工作得很好，但是 MVC 架构经常遇到两个主要问题:</span><br><span class="hljs-comment">        数据流不够清晰——跨视图发生的级联更新常常会导致混乱的事件网络，难于调试。</span><br><span class="hljs-comment">        缺乏数据完整性——模型数据可以在任何地方发生突变，从而在整个UI中产生不可预测的结果。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">        使用 Flux 模式的复杂用户界面不再遭受级联更新，任何给定的React 组件都能够根据 store 提供的数据重建其状态。Flux 模式还通过限制对共享数据的直接访问来加强数据完整性。</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h5 id="29-Redux遵循的三个原则是什么？"><a href="#29-Redux遵循的三个原则是什么？" class="headerlink" title="29. Redux遵循的三个原则是什么？"></a>29. Redux遵循的三个原则是什么？</h5><blockquote><p>*<strong>单一数据源*</strong></p><ul><li>整个应用的state被存储在一棵object tree中，并且整个 object tree 只存在于唯一一个 store 中</li></ul><p>*<strong>State是只读的*</strong></p><ul><li>唯一改变state的方法就是触发 action，action是一个描述已发生事件的普通对象</li><li>这样确保视图和网络请求不能直接修改state</li></ul><p>*<strong>使用纯函数来执行修改*</strong></p><ul><li>为了描述action如何改变state tree，你需要编写reducers</li></ul></blockquote><h5 id="30-react中使用setState不能立刻获取值，怎么办"><a href="#30-react中使用setState不能立刻获取值，怎么办" class="headerlink" title="30. react中使用setState不能立刻获取值，怎么办"></a>30. react中使用setState不能立刻获取值，怎么办</h5><blockquote><p>setState 只在合成事件和钩子函数中是异步的，在原生事件和 setTimeout 中都是同步</p><ul><li>①addeventListener添加的事件或者dom事件中触发</li><li>②setState接收的参数还可以是一个函数，在这个函数中可以拿先前的状态，并通过这个函数的返回值得到下一个状态。</li></ul></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(<span class="hljs-function">(<span class="hljs-params">preState</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">return</span> &#123;<br>    <span class="hljs-attr">xxx</span>: preState.<span class="hljs-property">xxx</span> + yyy<br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><blockquote><ul><li>③async&#x2F;await 异步调用处理</li></ul></blockquote><h5 id="31-聊聊-Redux-和-Vuex-的设计思想"><a href="#31-聊聊-Redux-和-Vuex-的设计思想" class="headerlink" title="31. 聊聊 Redux 和 Vuex 的设计思想"></a>31. 聊聊 Redux 和 Vuex 的设计思想</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/*</span><br><span class="hljs-comment">        Flux的核心思想就是数据和逻辑永远单向流动，由三大部分组成 dispatcher(负责分发事件), store(负责保存数据，同时响应事件并更新数据)和 view(负责订阅store中的数据，并使用这些数据渲染相应的页面)，Redux和Vuex是flux思想的具体实现，都是用来做状态管理的工具，Redux主要在react中使用，Vuex主要在vue中使用。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">        Redux设计和使用的三大原则：</span><br><span class="hljs-comment">      （1）单一的数据源：整个应用的 state被储存在唯一一个 store中；</span><br><span class="hljs-comment">      （2）状态是只读的：Store.state不能直接修改（只读），必须调用dispatch(action) =&gt; store.reducer =&gt; return newState；action是一个对象，有type（操作类型）和payload（新值）属性；</span><br><span class="hljs-comment">      （3）状态修改均由纯函数完成：在Redux中，通过纯函数reducer来确定状态的改变，因为reducer是纯函数，所以相同的输入，一定会得到相同的输出，同时也不支持异步；返回值是一个全新的state；</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">        vuex由State + Muatations(commit) + Actions(dispatch) 组成：</span><br><span class="hljs-comment">      （1）全局只有一个Store实例（单一数据源）；</span><br><span class="hljs-comment">      （2）Mutations必须是同步事务，不同步修改的话，会很难调试，不知道改变什么时候发生，也很难确定先后顺序，A、B两个mutation，调用顺序可能是A -&gt; B，但是最终改变 State的结果可能是B -&gt; A；</span><br><span class="hljs-comment">      （3）Actions负责处理异步事务，然后在异步回调中触发一个或多个mutations，也可以在业务代码中处理异步事务，然后在回调中同样操作；</span><br><span class="hljs-comment">      （4）模块化通过module方式来处理，这个跟Redux-combineReducer类似，在应用中可以通过namespaceHelper来简化使用；</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h5 id="32-redux本来是同步的，为什么它能执行异步代码？中间件的实现原理是什么？"><a href="#32-redux本来是同步的，为什么它能执行异步代码？中间件的实现原理是什么？" class="headerlink" title="32. redux本来是同步的，为什么它能执行异步代码？中间件的实现原理是什么？"></a>32. redux本来是同步的，为什么它能执行异步代码？中间件的实现原理是什么？</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/*</span><br><span class="hljs-comment">        当我们需要修改store中值的时候，我们是通过 dispatch(action)将要修改的值传到reducer中的，这个过程是同步的，如果我们要进行异步操作的时候，就需要用到中间件；中间件其实是提供了一个分类处理action的机会，在 middleware 中，我们可以检阅每一个流过的action，并挑选出特定类型的 action进行相应操作，以此来改变 action；</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">         applyMiddleware 是个三级柯里化的函数。它将陆续的获得三个参数：第一个是 middlewares 数组，第二个是 Redux 原生的 createStore，最后一个是 reducer；然后applyMiddleware会将不同的中间件一层一层包裹到原生的 dispatch 之上；</span><br><span class="hljs-comment">         redux-thunk 中间件的作用就是让我们可以异步执行redux，首先检查参数 action 的类型，如果是函数的话，就执行这个 action这个函数，并把 dispatch, getState, extraArgument 作为参数传递进去，否则就调用next让下一个中间件继续处理action。</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-comment">// redux-thunk部分源码</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">createThunkMiddleware</span>(<span class="hljs-params">extraArgument</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">&#123; dispatch, getState &#125;</span>) =&gt;</span> <span class="hljs-function"><span class="hljs-params">next</span> =&gt;</span> <span class="hljs-function"><span class="hljs-params">action</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> action === <span class="hljs-string">&#x27;function&#x27;</span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-title function_">action</span>(dispatch, getState, extraArgument)<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">next</span>(action)<br>  &#125;<br>&#125;<br><span class="hljs-keyword">const</span> thunk = <span class="hljs-title function_">createThunkMiddleware</span>()<br>thunk.<span class="hljs-property">withExtraArgument</span> = createThunkMiddleware<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> thunk<br></code></pre></td></tr></table></figure><h5 id="33-redux中sages和thunk中间件的区别，优缺点"><a href="#33-redux中sages和thunk中间件的区别，优缺点" class="headerlink" title="33. redux中sages和thunk中间件的区别，优缺点"></a>33. redux中sages和thunk中间件的区别，优缺点</h5><ul><li>区别</li></ul><blockquote><ul><li>redux-thunk异步采取 async&#x2F;await redux-saga采取generate函数</li></ul></blockquote><ul><li>优缺点</li></ul><blockquote><ul><li>redux-thunk</li></ul><blockquote><p>优点： 库小，代码就几行 缺点：代码臃肿，reducer不再是纯粹函数，直接返回对象，违背了当初的设计原则；action的形式不统一，异步操作太为分散，分散在了各个action中</p></blockquote><ul><li>redux-saga</li></ul><blockquote><p>优点： 将异步与reducer区分开了，更加优雅，适合大量APi请求，而且每个请求之间存在复杂的以来关系 缺点：学习曲线比较陡，理解async await；而且库也比较大，即使发布的最小也有25kb,gzip压缩后也有7KB,React压缩后才45kb</p></blockquote></blockquote><h5 id="34-redux-和-mobx-的区别"><a href="#34-redux-和-mobx-的区别" class="headerlink" title="34. redux 和 mobx 的区别"></a>34. redux 和 mobx 的区别</h5><blockquote><ul><li>①Redux的编程范式是函数式的而Mobx是面向对象的</li><li>②因此数据上来说Redux理想的是immutable的，每次都返回一个新的数据，而Mobx从始至终都是一份引用。因此Redux是支持数据回溯的</li><li>③然而和Redux相比，使用Mobx的组件可以做到精确更新，这一点得益于Mobx的observable；对应的，Redux是用dispatch进行广播，通过Provider和connect来比对前后差别控制更新粒度，有时需要自己写SCU；Mobx更加精细一点</li><li>④Mobx-react vs React-rdux：</li></ul><blockquote><p>redux,采取Provider和connect方式，mobx采取Provider和inject、observer</p></blockquote></blockquote><h5 id="35-什么是-immutable？为什么要使用它？"><a href="#35-什么是-immutable？为什么要使用它？" class="headerlink" title="35. 什么是 immutable？为什么要使用它？"></a>35. 什么是 immutable？为什么要使用它？</h5><blockquote><p>immutable是一种持久化数据。一旦被创建就不会被修改。修改immutable对象的时候返回新的immutable。但是原数据不会改变。</p><p>在Rudux中因为深拷贝对性能的消耗太大了（用到了递归，逐层拷贝每个节点）。 但当你使用immutable数据的时候：只会拷贝你改变的节点，从而达到了节省性能。 总结：immutable的不可变性让纯函数更强大，每次都返回新的immutable的特性让程序员可以对其进行链式操作，用起来更方便。</p><p>因为在react中，react的生命周期中的setState()之后的shouldComponentUpdate()阶段默认返回true，所以会造成本组件和子组件的多余的render，重新生成virtual dom，并进行virtual dom diff，所以解决办法是我们在本组件或者子组件中的shouldComponentUpdate()函数中比较，当不需要render时，不render。</p><p>当state中的值是对象时，我们必须使用深拷贝和深比较！</p><p>如果不进行深拷贝后再setState，会造成this.state和nextState指向同一个引用，所以shouldComponentUpdate()返回值一定是false，造成state值改了，而组件未渲染（这里不管shouldComponentUpdate中使用的是深比较还是浅比较）。所以必须深拷贝。</p><p>如果不在shouldComponentUpdate中进行深比较，会造成即使state中的对象值没有改变，因为是不同的对象，而在shouldComponentUpdate返回true，造成不必要的渲染。</p><p>所以只能是深拷贝和深比较。</p></blockquote><h4 id="九-小程序高频面试题"><a href="#九-小程序高频面试题" class="headerlink" title="九. 小程序高频面试题"></a>九. 小程序高频面试题</h4><h5 id="1-简述微信小程序原理"><a href="#1-简述微信小程序原理" class="headerlink" title="1. 简述微信小程序原理"></a>1. 简述微信小程序原理</h5><blockquote><p>微信小程序采用 <code>JavaScript</code>、<code>WXML</code>、<code>WXSS</code> 三种技术进行开发,本质就是一个单页面应用，所有的页面渲染和事件处理，都在一个页面内进行，但又可以通过微信客户端调用原生的各种接口微信的架构，是数据驱动的架构模式，它的 <code>UI</code> 和数据是分离的，所有的页面更新，都需要通过对数据的更改来实现 小程序分为两个部分 <code>webview</code> 和 <code>appService</code> 。其中 <code>webview</code> 主要用来展现 <code>UI</code> ，<code>appService</code> 有来处理业务逻辑、数据及接口调用。它们在两个进程中运行，通过系统层 <code>JSBridge</code> 实现通信，实现 <code>UI</code> 的渲染、事件的处理</p></blockquote><h5 id="2-简单描述下微信小程序的相关文件类型"><a href="#2-简单描述下微信小程序的相关文件类型" class="headerlink" title="2. 简单描述下微信小程序的相关文件类型"></a>2. 简单描述下微信小程序的相关文件类型</h5><blockquote><p>微信小程序项目结构主要有四个文件类型</p></blockquote><ul><li><code>WXML</code>（WeiXin Markup Language）是框架设计的一套标签语言，结合基础组件、事件系统，可以构建出页面的结构。内部主要是微信自己定义的一套组件</li><li><code>WXSS</code> (WeiXin Style Sheets)是一套样式语言，用于描述 <code>WXML</code> 的组件样式</li><li><code>js</code> 逻辑处理，网络请求</li><li><code>json</code> 小程序设置，如页面注册，页面标题及<code>tabBar</code></li></ul><blockquote><p>主要文件</p></blockquote><ul><li><code>app.json</code> 必须要有这个文件，如果没有这个文件，项目无法运行，因为微信框架把这个作为配置文件入口，整个小程序的全局配置。包括页面注册，网络设置，以及小程序的 <code>window</code> 背景色，配置导航条样式，配置默认标题</li><li><code>app.js</code> 必须要有这个文件，没有也是会报错！但是这个文件创建一下就行 什么都不需要写以后我们可以在这个文件中监听并处理小程序的生命周期函数、声明全局变量</li><li><code>app.wxss</code> 可选</li></ul><h5 id="3-小程序的双向绑定和vue哪里不一样"><a href="#3-小程序的双向绑定和vue哪里不一样" class="headerlink" title="3. 小程序的双向绑定和vue哪里不一样"></a>3. 小程序的双向绑定和vue哪里不一样</h5><ol><li>小程序直接修改 <code>this.data</code> 的属性是不可以同步到视图的，必须调用：</li></ol> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setData</span>(&#123;<br>    <span class="hljs-comment">// 这里设置</span><br>&#125;)<br></code></pre></td></tr></table></figure><ol start="2"><li>在vue中,只需要再表单元素上加上v-model,然后再绑定data中对应的一个值，当表单元素内容发生变化时，data中对应的值也会相应改变，这是vue非常nice的一点。 但是在小程序中，却没有这个功能。那怎么办呢？当表单内容发生变化时，会触发表单元素上绑定的方法，然后在该方法中，通过this.setData({key:value})来将表单上的值赋值给data中的对应值。下面是代码，可以感受一下:</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;input bindinput=<span class="hljs-string">&quot;bindReason&quot;</span> placeholder=<span class="hljs-string">&quot;填写理由&quot;</span> <span class="hljs-keyword">class</span>=<span class="hljs-string">&#x27;reason&#x27;</span> value=<span class="hljs-string">&#x27;&#123;&#123;reason&#125;&#125;&#x27;</span> name=<span class="hljs-string">&quot;reason&quot;</span> /&gt;  <br>  <span class="hljs-title class_">Page</span>(&#123;  <br>  <span class="hljs-attr">data</span>:&#123;  <br>  <span class="hljs-attr">reason</span>:<span class="hljs-string">&#x27;&#x27;</span>  <br>  &#125;,  <br>  <span class="hljs-title function_">bindReason</span>(<span class="hljs-params">e</span>) &#123;  <br>  <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setData</span>(&#123;  <br>  <span class="hljs-attr">reason</span>: e.<span class="hljs-property">detail</span>.<span class="hljs-property">value</span>  <br>  &#125;)  <br>  &#125;  <br>  &#125;)<br></code></pre></td></tr></table></figure><p>当页面表单元素很多的时候，更改值就是一件体力活了。和小程序一比较，vue的v-model简直爽的不要不要的。</p><ol start="3"><li>取值</li></ol><ul><li><p>vue中，通过this.reason取值</p></li><li><p>小程序中，通过this.data.reason取值</p></li></ul><h5 id="4-如何自定义小程序的navigationBar"><a href="#4-如何自定义小程序的navigationBar" class="headerlink" title="4. 如何自定义小程序的navigationBar"></a>4. 如何自定义小程序的navigationBar</h5><ul><li><p>思路</p><blockquote><p>隐藏原生样式 获取胶囊按钮、状态栏相关数据以供后续计算 根据不同机型计算出该机型的导航栏高度，进行适配 编写新的导航栏 引用到页面</p></blockquote></li></ul><p>参考<a href="https://zhuanlan.zhihu.com/p/117244248">这里</a></p><h5 id="5-说说小程序中wx-if和hidden的区别"><a href="#5-说说小程序中wx-if和hidden的区别" class="headerlink" title="5. 说说小程序中wx:if和hidden的区别"></a>5. 说说小程序中wx:if和hidden的区别</h5><blockquote><p>相同点：</p></blockquote><p>wx:if 与 hidden 都用来控制小程序元素的显示</p><blockquote><p>不同点</p></blockquote><p>wx:if：</p><ul><li>1、条件为 true 时显示</li><li>2、当元素显示时渲染</li><li>3、元素变为不显示时销毁元素</li></ul><p>hidden：</p><ul><li>1、条件为 false 时显示</li><li>2、当元素显示时渲染</li><li>3、元素变为不显示时保留元素</li><li>4、相当于使用了dispaly</li></ul><p>总结： 1、当元素频繁切换是否显示时使用 hidden ，因为 wx:if 会频繁地销毁渲染元素 2、当元素不频繁切换是否显示时使用 wx:if，因为 wx:if 会避免页面加载时渲染过多，导致页面加载缓慢</p><h5 id="6-小程序的-wxss-和-css-有哪些不一样的地方"><a href="#6-小程序的-wxss-和-css-有哪些不一样的地方" class="headerlink" title="6. 小程序的 wxss 和 css 有哪些不一样的地方"></a>6. 小程序的 wxss 和 css 有哪些不一样的地方</h5><blockquote><p><code>WXSS</code> 和 <code>CSS</code> 类似，不过在 <code>CSS</code> 的基础上做了一些补充和修改</p></blockquote><ul><li>尺寸单位 <code>rpx</code></li></ul><p><code>rpx</code> 是响应式像素,可以根据屏幕宽度进行自适应。规定屏幕宽为 <code>750rpx</code>。如在 <code>iPhone6</code> 上，屏幕宽度为 <code>375px</code>，共有 <code>750</code> 个物理像素，则 <code>750rpx = 375px = 750</code> 物理像素</p><ul><li>使用 <code>@import</code> 标识符来导入外联样式。<code>@import</code> 后跟需要导入的外联样式表的相对路径，用;表示语句结束</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/** index.wxss **/</span><br><span class="hljs-keyword">@import</span> <span class="hljs-string">&#x27;./base.wxss&#x27;</span>;<br><br><span class="hljs-selector-class">.container</span>&#123;<br>    <span class="hljs-attribute">color</span>: red;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="7-小程序页面间有哪些传递数据的方法"><a href="#7-小程序页面间有哪些传递数据的方法" class="headerlink" title="7. 小程序页面间有哪些传递数据的方法"></a>7. 小程序页面间有哪些传递数据的方法</h5><ul><li>使用全局变量实现数据传递</li></ul><p>在 <code>app.js</code> 文件中定义全局变量 <code>globalData</code>， 将需要存储的信息存放在里面</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// app.js</span><br><br><span class="hljs-title class_">App</span>(&#123;<br>     <span class="hljs-comment">// 全局变量</span><br>  <span class="hljs-attr">globalData</span>: &#123;<br>    <span class="hljs-attr">userInfo</span>: <span class="hljs-literal">null</span><br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p>使用的时候，直接使用 <code>getApp()</code> 拿到存储的信息</p><ul><li>使用 <code>wx.navigateTo</code> 与 <code>wx.redirectTo</code> 的时候，可以将部分数据放在 <code>url</code> 里面，并在新页面 <code>onLoad</code> 的时候初始化</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//pageA.js</span><br><br><span class="hljs-comment">// Navigate</span><br>wx.<span class="hljs-title function_">navigateTo</span>(&#123;<br>  <span class="hljs-attr">url</span>: <span class="hljs-string">&#x27;../pageD/pageD?name=raymond&amp;gender=male&#x27;</span>,<br>&#125;)<br><br><span class="hljs-comment">// Redirect</span><br>wx.<span class="hljs-title function_">redirectTo</span>(&#123;<br>  <span class="hljs-attr">url</span>: <span class="hljs-string">&#x27;../pageD/pageD?name=raymond&amp;gender=male&#x27;</span>,<br>&#125;)<br><br><br><span class="hljs-comment">// pageB.js</span><br>...<br><span class="hljs-title class_">Page</span>(&#123;<br>  <span class="hljs-attr">onLoad</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">option</span>)&#123;<span class="hljs-comment">//option里面可以拿到路由参数</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(option.<span class="hljs-property">name</span> + <span class="hljs-string">&#x27;is&#x27;</span> + option.<span class="hljs-property">gender</span>)<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setData</span>(&#123;<br>      <span class="hljs-attr">option</span>: option<br>    &#125;)<br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p>需要注意的问题：</p><p><code>wx.navigateTo</code> 和 <code>wx.redirectTo</code> 不允许跳转到 <code>tab</code> 所包含的页面</p><p><code>onLoad</code> 只执行一次</p><ul><li>使用本地缓存 <code>Storage</code> 相关</li></ul><h5 id="8-小程序的生命周期函数"><a href="#8-小程序的生命周期函数" class="headerlink" title="8. 小程序的生命周期函数"></a>8. 小程序的生命周期函数</h5><ul><li><code>onLoad</code> 页面加载时触发。一个页面只会调用一次，可以在 <code>onLoad</code> 的参数中获取打开当前页面路径中的参数,建议在此调接口</li><li><code>onShow()</code> 页面显示&#x2F;切入前台时触发，不建议在此调接口</li><li><code>onReady()</code> 页面初次渲染完成时触发。一个页面只会调用一次，代表页面已经准备妥当，可以和视图层进行交互</li><li><code>onHide()</code> 页面隐藏&#x2F;切入后台时触发。 如 <code>navigateTo</code> 或底部 <code>tab</code> 切换到其他页面，小程序切入后台等</li><li><code>onUnload()</code> 页面卸载时触发。如 <code>redirectTo</code> 或 <code>navigateBack</code> 到其他页面时</li></ul><p>详见 <a href="https://link.zhihu.com/?target=https://developers.weixin.qq.com/miniprogram/dev/framework/app-service/page.html%23%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0">生命周期回调函数</a></p><h5 id="9-哪些方法可以用来提高微信小程序的应用速度"><a href="#9-哪些方法可以用来提高微信小程序的应用速度" class="headerlink" title="9. 哪些方法可以用来提高微信小程序的应用速度"></a>9. 哪些方法可以用来提高微信小程序的应用速度</h5><p>1、提高页面加载速度</p><p>2、用户行为预测</p><p>3、减少默认 <code>data</code> 的大小</p><p>4、组件化方案</p><h5 id="10-微信小程序的优劣势"><a href="#10-微信小程序的优劣势" class="headerlink" title="10. 微信小程序的优劣势"></a>10. 微信小程序的优劣势</h5><blockquote><p>优势</p></blockquote><ul><li>即用即走，不用安装，省流量，省安装时间，不占用桌面</li><li>依托微信流量，天生推广传播优势</li><li>开发成本比 <code>App</code> 低</li></ul><blockquote><p>缺点</p></blockquote><ul><li>用户留存，即用即走是优势，也存在一些问题</li><li>入口相对传统 <code>App</code> 要深很多</li><li>限制较多,页面大小不能超过2M。不能打开超过10个层级的页面</li></ul><h5 id="11-怎么解决小程序的异步请求问题"><a href="#11-怎么解决小程序的异步请求问题" class="headerlink" title="11. 怎么解决小程序的异步请求问题"></a>11. 怎么解决小程序的异步请求问题</h5><blockquote><p>小程序支持大部分 <code>ES6</code> 语法</p></blockquote><ul><li>在返回成功的回调里面处理逻辑</li><li><code>Promise</code> 异步</li></ul><h5 id="12-小程序关联微信公众号如何确定用户的唯一性"><a href="#12-小程序关联微信公众号如何确定用户的唯一性" class="headerlink" title="12. 小程序关联微信公众号如何确定用户的唯一性"></a>12. 小程序关联微信公众号如何确定用户的唯一性</h5><blockquote><p>如果开发者拥有多个移动应用、网站应用、和公众帐号（包括小程序），可通过 <code>unionid</code> 来区分用户的唯一性，因为只要是同一个微信开放平台帐号下的移动应用、网站应用和公众帐号（包括小程序），用户的 <code>unionid</code> 是唯一的。换句话说，同一用户，对同一个微信开放平台下的不同应用，<code>unionid</code> 是相同的</p></blockquote><h5 id="13-如何实现下拉刷新"><a href="#13-如何实现下拉刷新" class="headerlink" title="13. 如何实现下拉刷新"></a>13. 如何实现下拉刷新</h5><ul><li>首先在全局 <code>config</code> 中的 <code>window</code> 配置 <code>enablePullDownRefresh</code></li><li>在 <code>Page</code> 中定义 <code>onPullDownRefresh</code> 钩子函数,到达下拉刷新条件后，该钩子函数执行，发起请求方法</li><li>请求返回后，调用 <code>wx.stopPullDownRefresh</code> 停止下拉刷新</li></ul><p>参考 <a href="https://link.zhihu.com/?target=https://juejin.im/post/5a781c756fb9a063606eb742">这里</a></p><h5 id="14-bindtap-和-catchtap-的区别是什么"><a href="#14-bindtap-和-catchtap-的区别是什么" class="headerlink" title="14. bindtap 和 catchtap 的区别是什么"></a>14. bindtap 和 catchtap 的区别是什么</h5><p>相同点：首先他们都是作为点击事件函数，就是点击时触发。在这个作用上他们是一样的，可以不做区分</p><p>不同点：他们的不同点主要是bindtap是不会阻止冒泡事件的，catchtap是阻止冒泡的</p><h5 id="15-简述微信支付的业务流程"><a href="#15-简述微信支付的业务流程" class="headerlink" title="15. 简述微信支付的业务流程"></a>15. 简述微信支付的业务流程</h5><ul><li><p>步骤1：用户在商户APP中选择商品，提交订单，选择微信支付。</p></li><li><p>步骤2：商户后台收到用户支付单，调用微信支付统一下单接口。参见<a href="https://pay.weixin.qq.com/wiki/doc/api/app/app.php?chapter=9_1">统一下单API</a>。</p></li><li><p>步骤3：统一下单接口返回正常的prepay_id，再按签名规范重新生成签名后，将数据传输给APP。参与签名的字段名为<code>appid</code>，<code>partnerid</code>，<code>prepayid</code>，<code>noncestr</code>，<code>timestamp</code>，<code>package</code>。注意：package的值格式为<code>Sign=WXPay</code></p></li><li><p>步骤4：商户APP调起微信支付。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js">wx.<span class="hljs-title function_">requestPayment</span>(&#123;<br>  <span class="hljs-attr">timeStamp</span>: <span class="hljs-string">&#x27;&#x27;</span>,<br>  <span class="hljs-attr">nonceStr</span>: <span class="hljs-string">&#x27;&#x27;</span>,<br>  <span class="hljs-attr">package</span>: <span class="hljs-string">&#x27;&#x27;</span>,<br>  <span class="hljs-attr">signType</span>: <span class="hljs-string">&#x27;MD5&#x27;</span>,<br>  <span class="hljs-attr">paySign</span>: <span class="hljs-string">&#x27;&#x27;</span>,<br>  success (res) &#123; &#125;,<br>  fail (res) &#123; &#125;<br>&#125;)<br></code></pre></td></tr></table></figure></li><li><p>步骤5：商户后台接收支付通知。<code>api</code>参见<a href="https://pay.weixin.qq.com/wiki/doc/api/app/app.php?chapter=9_7">支付结果通知API</a></p></li><li><p>步骤6：商户后台查询支付结果。，<code>api</code>参见<a href="https://pay.weixin.qq.com/wiki/doc/api/app/app.php?chapter=9_2">查询订单API</a>（查单实现可参考：<a href="https://pay.weixin.qq.com/wiki/doc/api/app/app.php?chapter=23_9&index=1">支付回调和查单实现指引</a>） 详情参考<a href="https://pay.weixin.qq.com/wiki/doc/api/app/app.php?chapter=8_3">这里</a></p></li></ul><h5 id="16-什么是小程序自定义组件样式隔离-他有哪几种隔离模式？"><a href="#16-什么是小程序自定义组件样式隔离-他有哪几种隔离模式？" class="headerlink" title="16. 什么是小程序自定义组件样式隔离,他有哪几种隔离模式？"></a>16. 什么是小程序自定义组件样式隔离,他有哪几种隔离模式？</h5><p>默认情况下，自定义组件的样式只受到自定义组件 wxss 的影响。除非以下两种情况：</p><ul><li><code>app.wxss</code> 或页面的 <code>wxss</code> 中使用了标签名选择器（或一些其他特殊选择器）来直接指定样式，这些选择器会影响到页面和全部组件。通常情况下这是不推荐的做法。</li><li>指定特殊的样式隔离选项 <code>styleIsolation</code> 。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Component</span>(&#123;<br>  <span class="hljs-attr">options</span>: &#123;<br>    <span class="hljs-attr">styleIsolation</span>: <span class="hljs-string">&#x27;isolated&#x27;</span><br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p><a href="https://developers.weixin.qq.com/s/xPQhJcm37e7h">在开发者工具中预览效果</a></p><p><code>styleIsolation</code> 选项从基础库版本 <a href="https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html">2.6.5</a> 开始支持。它支持以下取值：</p><ul><li><code>isolated</code> 表示启用样式隔离，在自定义组件内外，使用 class 指定的样式将不会相互影响（一般情况下的默认值）；</li><li><code>apply-shared</code> 表示页面 wxss 样式将影响到自定义组件，但自定义组件 wxss 中指定的样式不会影响页面；</li><li><code>shared</code> 表示页面 wxss 样式将影响到自定义组件，自定义组件 wxss 中指定的样式也会影响页面和其他设置了 <code>apply-shared</code> 或 <code>shared</code> 的自定义组件。（这个选项在插件中不可用。）</li></ul><h5 id="17-在小程序中又哪些方法让图片宽高比例保持不变？"><a href="#17-在小程序中又哪些方法让图片宽高比例保持不变？" class="headerlink" title="17. 在小程序中又哪些方法让图片宽高比例保持不变？"></a>17. 在小程序中又哪些方法让图片宽高比例保持不变？</h5><ul><li><p>使用mode：widthFix</p><blockquote><p><code>widthFix</code>：宽度不变，高度自动变化，保持原图宽高比不变。 首先我们先设置image的mode为<code>widthFix</code>，然后给图片加一个固定<code>rpx</code>的宽度，比如：<code>730rpx</code>。 这样图片也可以自适应了。。因为小程序的<code>rpx</code>本身就是一个自适应显示的单位</p></blockquote></li></ul><h5 id="18-小程序组件传参-父子，子父"><a href="#18-小程序组件传参-父子，子父" class="headerlink" title="18. 小程序组件传参(父子，子父)"></a>18. 小程序组件传参(父子，子父)</h5><ul><li><p>父传子</p><blockquote><p>自定义属性，属性的值来自声明式变量 子组件通过props接收</p></blockquote></li><li><p>子传父</p><blockquote><p>自定义事件，父组件通过事件接收子组件传过来的值 自定义封装组件的例子：</p></blockquote></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;component-tag-name inner-text=<span class="hljs-string">&quot;Some text&quot;</span>&gt;&lt;/component-tag-name&gt;<br><span class="hljs-title class_">Component</span>(&#123;<br>  <span class="hljs-attr">properties</span>: &#123;<br>    <span class="hljs-comment">// 这里定义了 innerText 属性，属性值可以在组件使用时指定</span><br>    <span class="hljs-attr">innerText</span>: &#123;<br>      <span class="hljs-attr">type</span>: <span class="hljs-title class_">String</span>,<br>      <span class="hljs-attr">value</span>: <span class="hljs-string">&#x27;default value&#x27;</span>,<br>    &#125;<br>  &#125;,<br>  <span class="hljs-attr">data</span>: &#123;<br>    <span class="hljs-comment">// 这里是一些组件内部数据</span><br>    <span class="hljs-attr">someData</span>: &#123;&#125;<br>  &#125;,<br>  <span class="hljs-attr">methods</span>: &#123;<br>    <span class="hljs-comment">// 这里是一个自定义方法</span><br>    <span class="hljs-attr">customMethod</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;&#125;<br>  &#125;<br>&#125;)<br><br><br><br>&lt;component-tag-name <span class="hljs-attr">bind</span>:myevent=<span class="hljs-string">&quot;onMyEvent&quot;</span> /&gt;<br><span class="hljs-title class_">Component</span>(&#123;<br>  <span class="hljs-attr">properties</span>: &#123;&#125;,<br>  <span class="hljs-attr">methods</span>: &#123;<br>    <span class="hljs-attr">onTap</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>      <span class="hljs-keyword">var</span> myEventDetail = &#123;&#125; <span class="hljs-comment">// detail对象，提供给事件监听函数</span><br>      <span class="hljs-keyword">var</span> myEventOption = &#123;&#125; <span class="hljs-comment">// 触发事件的选项</span><br>      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">triggerEvent</span>(<span class="hljs-string">&#x27;myevent&#x27;</span>, myEventDetail, myEventOption)<br>    &#125;<br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><h5 id="19-小程序组件生命周期"><a href="#19-小程序组件生命周期" class="headerlink" title="19. 小程序组件生命周期"></a>19. 小程序组件生命周期</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Component</span>(&#123;<br>  <span class="hljs-attr">lifetimes</span>: &#123;<br>    <span class="hljs-attr">attached</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-comment">// 在组件实例进入页面节点树时执行</span><br>    &#125;,<br>    <span class="hljs-attr">detached</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-comment">// 在组件实例被从页面节点树移除时执行</span><br>    &#125;,<br>  &#125;,<br>  <span class="hljs-comment">// 以下是旧式的定义方式，可以保持对 &lt;2.2.3 版本基础库的兼容</span><br>  <span class="hljs-attr">attached</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// 在组件实例进入页面节点树时执行</span><br>  &#125;,<br>  <span class="hljs-attr">detached</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// 在组件实例被从页面节点树移除时执行</span><br>  &#125;,<br>  <span class="hljs-comment">// ...</span><br>&#125;)<br></code></pre></td></tr></table></figure><p><img src="image-20230221093255673.png" alt="image-20230221093255673"></p><h5 id="20-小程序页面生命周期"><a href="#20-小程序页面生命周期" class="headerlink" title="20. 小程序页面生命周期"></a>20. 小程序页面生命周期</h5><ul><li>1、小程序注册完成后，加载页面，触发<code>onLoad</code>方法，一个页面只会调用一次。</li><li>2、页面载入后触发<code>onShow</code>方法，显示页面，每次打开页面都会调用一次。</li><li>3、首次显示页面，会触发<code>onReady</code>方法，渲染页面元素和样式，一个页面只会调用一次。</li><li>4、当小程序后台运行或跳转到其他页面时，触发<code>onHide</code>方法。</li><li>5、当小程序有后台进入到前台运行或重新进入页面时，触发<code>onShow</code>方法。</li><li>6、当使用重定向方法<code>wx.redirectTo(OBJECT)</code>或关闭当前页返回上一页<code>wx.navigateBack()</code>，触发<code>onUnload</code></li></ul><h5 id="21-小程序怎么样实现路由传参"><a href="#21-小程序怎么样实现路由传参" class="headerlink" title="21. 小程序怎么样实现路由传参"></a>21. 小程序怎么样实现路由传参</h5><ul><li><p>wx.navigateTo</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">wx.<span class="hljs-title function_">navigateTo</span>(&#123;<br>  <span class="hljs-attr">url</span>: <span class="hljs-string">&#x27;../placeIntroduce/placeIntroduce?placeId=2&#x27;</span>,<span class="hljs-comment">//在路径后面拼接</span><br>&#125;)<br>  另外一个页面通过<span class="hljs-title function_">onload</span>(options)这个生命周期获取到placeId<br></code></pre></td></tr></table></figure></li></ul><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs stylus">  <br>- wx<span class="hljs-selector-class">.redirectTo</span><br>  <br>  ```js<br>wx<span class="hljs-selector-class">.redirectTo</span> （非 tabBar 的页面的路径，不能返回来，不限层）<br>  wx<span class="hljs-selector-class">.redirectTo</span> (&#123;<br>  url: <span class="hljs-string">&#x27;../placeIntroduce/placeIntroduce?placeId=2&#x27;</span>,<span class="hljs-comment">//在路径后面拼接</span><br></code></pre></td></tr></table></figure><h5 id="22-小程序中的路由跳转switchTab-navigateTo-redirectTo的区别"><a href="#22-小程序中的路由跳转switchTab-navigateTo-redirectTo的区别" class="headerlink" title="22. 小程序中的路由跳转switchTab navigateTo redirectTo的区别"></a>22. 小程序中的路由跳转switchTab navigateTo redirectTo的区别</h5><ul><li>wx.navigateTo()：保留当前页面，跳转到应用内的某个页面。但是不能跳到 <code>tabbar</code> 页面</li><li>wx.redirectTo()：关闭当前页面，跳转到应用内的某个页面。但是不允许跳转到 <code>tabbar</code> 页面</li><li>wx.switchTab()：跳转到 <code>abBar</code> 页面，并关闭其他所有非 <code>tabBar</code> 页面</li><li>wx.navigateBack()关闭当前页面，返回上一页面或多级页面。可通过 <code>getCurrentPages()</code> 获取当前的页面栈，决定需要返回几层</li><li>wx.reLaunch()：关闭所有页面，打开到应用内的某个页面</li></ul><h5 id="23-小程序tabbar实现原理"><a href="#23-小程序tabbar实现原理" class="headerlink" title="23. 小程序tabbar实现原理"></a>23. 小程序tabbar实现原理</h5><ul><li><p>要实现tabbar的导航条其实很简单，我们要实现全局的tabbar只需要在app.json文件中定义即可，局部的就在局部的tabbar文件中实现。</p><blockquote><p>来看看app.json代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br><span class="hljs-attr">pages</span>: [<br><span class="hljs-string">&#x27;pages/index/index&#x27;</span>,<br><span class="hljs-string">&quot;pages/search/search&quot;</span>,<br><span class="hljs-string">&#x27;pages/news/news&#x27;</span>,<br><span class="hljs-string">&#x27;pages/attention/attention&#x27;</span>,<br><span class="hljs-string">&#x27;pages/collect/collect&#x27;</span>,<br><span class="hljs-string">&#x27;pages/comment/comment&#x27;</span>,<br><span class="hljs-string">&#x27;pages/my/my&#x27;</span>,<br><span class="hljs-string">&quot;pages/detail/detail&quot;</span>,<br><span class="hljs-string">&quot;pages/chat/chat&quot;</span>,<br>],<br><span class="hljs-attr">window</span>: &#123;<br><span class="hljs-attr">backgroundTextStyle</span>: <span class="hljs-string">&#x27;light&#x27;</span>,<br><span class="hljs-attr">navigationBarBackgroundColor</span>: <span class="hljs-string">&#x27;#fff&#x27;</span>,<br><span class="hljs-attr">navigationBarTitleText</span>: <span class="hljs-string">&#x27;小红书&#x27;</span>,<br><span class="hljs-attr">navigationBarTextStyle</span>: <span class="hljs-string">&#x27;black&#x27;</span>,<br><span class="hljs-attr">enablePullDownRefresh</span>: <span class="hljs-literal">true</span><br>&#125;,<br><span class="hljs-attr">tabBar</span>: &#123;<br><span class="hljs-string">&quot;list&quot;</span>: [<br> &#123;<br>   <span class="hljs-string">&quot;pagePath&quot;</span>: <span class="hljs-string">&quot;pages/index/index&quot;</span>,<br>   <span class="hljs-string">&quot;text&quot;</span>: <span class="hljs-string">&quot;首页&quot;</span>,<br>   <span class="hljs-string">&quot;iconPath&quot;</span>: <span class="hljs-string">&quot;assets/tabbar/1.png&quot;</span>,<br>   <span class="hljs-string">&quot;selectedIconPath&quot;</span>: <span class="hljs-string">&quot;assets/tabbar/2.png&quot;</span><br> &#125;,<br> &#123;<br>   <span class="hljs-string">&quot;pagePath&quot;</span>: <span class="hljs-string">&quot;pages/news/news&quot;</span>,<br>   <span class="hljs-string">&quot;text&quot;</span>: <span class="hljs-string">&quot;消息&quot;</span>,<br>   <span class="hljs-string">&quot;iconPath&quot;</span>: <span class="hljs-string">&quot;assets/tabbar/news1.png&quot;</span>,<br>   <span class="hljs-string">&quot;selectedIconPath&quot;</span>: <span class="hljs-string">&quot;assets/tabbar/news2.png&quot;</span><br> &#125;,<br> &#123;<br>   <span class="hljs-string">&quot;pagePath&quot;</span>: <span class="hljs-string">&quot;pages/my/my&quot;</span>,<br>   <span class="hljs-string">&quot;text&quot;</span>: <span class="hljs-string">&quot;我的&quot;</span>,<br>   <span class="hljs-string">&quot;iconPath&quot;</span>: <span class="hljs-string">&quot;assets/tabbar/3.png&quot;</span>,<br>   <span class="hljs-string">&quot;selectedIconPath&quot;</span>: <span class="hljs-string">&quot;assets/tabbar/4.png&quot;</span><br> &#125;<br>]<br>&#125;,<br><span class="hljs-attr">permission</span>: &#123;<br><span class="hljs-string">&quot;scope.userLocation&quot;</span>: &#123;<br> <span class="hljs-string">&quot;desc&quot;</span>: <span class="hljs-string">&quot;为了更好的为你服务，请允许访问你的地址&quot;</span><br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>参考<a href="https://www.cnblogs.com/izhaofu/p/6278589.html">这里</a></p></blockquote></li></ul><h5 id="24-小程序性能为什么那么好，为什么能做到即用即走的效果"><a href="#24-小程序性能为什么那么好，为什么能做到即用即走的效果" class="headerlink" title="24. 小程序性能为什么那么好，为什么能做到即用即走的效果"></a>24. 小程序性能为什么那么好，为什么能做到即用即走的效果</h5><ul><li>因为是轻量级的，代码包体积限制在2M以内，如果超过2M还可以进行分包，提高性能优化</li><li>运行在微信端,很多功能只需要使用API来实现，就可以实现跟APP的一样的功能</li><li>是基于微信宿主环境的，微信客户端提供双线程去执行wxml, wxss, js文件，让小程序可以快速的一下将数据渲染出来呈现在用户的面前</li></ul><h4 id="十-网络面试真题"><a href="#十-网络面试真题" class="headerlink" title="十. 网络面试真题"></a>十. 网络面试真题</h4><h5 id="1-url从输入到渲染页面的全过程"><a href="#1-url从输入到渲染页面的全过程" class="headerlink" title="1. url从输入到渲染页面的全过程"></a>1. url从输入到渲染页面的全过程</h5><ul><li>浏览器构建HTTP Request请求， DNS解析URL地址、生成HTTP请求报文、构建TCP连接、使用IP协议选择传输路线</li><li>将请求通过网络传输到服务端 从客户机到服务器需要通过许多网络设备，一般包括集线器、交换器、路由器等</li><li>服务器构建HTTP Response响应，响应客户端的请求</li><li>将响应体的数据通过网络传输返回给客户端</li><li>浏览器渲染页面 解析HTML、CSS、JS，生成RenderTree渲染页面</li></ul><h5 id="2-tcp三次握手，四次挥手，可靠传输原理"><a href="#2-tcp三次握手，四次挥手，可靠传输原理" class="headerlink" title="2. tcp三次握手，四次挥手，可靠传输原理"></a>2. tcp三次握手，四次挥手，可靠传输原理</h5><h6 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h6><ul><li><p>第一次握手：客户端发送syn报文，并发送seq为x序列号给服务端，等待服务端的确认。</p></li><li><p>第二次握手：服务端发送syn+ack报文，并发送seq为Y的序列号，在确认序列号为x+1</p></li><li><p>第三次握手：客户端发送ack报文，并发送seq序列号为z，在确认序列号为y+1</p><p>四次挥手</p></li><li><p>第一次挥手：先由客户端向服务器端发送一个FIN，请求关闭数据传输。</p></li><li><p>第二次挥手：当服务器接收到客户端的FIN时，向客户端发送一个ACK，其中ack的值等于FIN+SEQ</p></li><li><p>第三次挥手：然后服务器向客户端发送一个FIN，告诉客户端应用程序关闭。</p></li><li><p>第四次挥手：当客户端收到服务器端的FIN是，回复一个ACK给服务器端。其中ack的值等于FIN+SEQ</p></li></ul><h5 id="3-http200-和-302-的区别"><a href="#3-http200-和-302-的区别" class="headerlink" title="3. http200 和 302 的区别"></a>3. <code>http200</code> 和 <code>302</code> 的区别</h5><ul><li>http_200的意思是 成功处理了请求</li><li>http_302的意思是（临时移动）服务器目前从不同位置的网页响应请求， 但请求者应继续使用原有位置来进行以后的请求。</li></ul><h5 id="4-你知道哪些http首部字段？"><a href="#4-你知道哪些http首部字段？" class="headerlink" title="4. 你知道哪些http首部字段？"></a>4. 你知道哪些http首部字段？</h5><table><thead><tr><th>首部字段名</th><th>说明</th></tr></thead><tbody><tr><td>Cache-Control</td><td>控制缓存的行为</td></tr><tr><td>Connection</td><td>逐跳首部、连接的管理</td></tr><tr><td>Date</td><td>创建报文的日期时间</td></tr><tr><td>Program</td><td>报文指令</td></tr><tr><td>Trailer</td><td>报文末端的首部一览</td></tr><tr><td>Transfer-Encoding</td><td>指定报文主体的传输编码方式</td></tr><tr><td>Upgrade</td><td>升级为其他协议</td></tr><tr><td>Via</td><td>代理服务器的相关信息</td></tr><tr><td>Warning</td><td>错误通知</td></tr><tr><td>Authorization</td><td>Web认证信息</td></tr></tbody></table><h5 id="5-说一下http缓存策略，有什么区别，分别解决了什么问题？"><a href="#5-说一下http缓存策略，有什么区别，分别解决了什么问题？" class="headerlink" title="5. 说一下http缓存策略，有什么区别，分别解决了什么问题？"></a>5. 说一下http缓存策略，有什么区别，分别解决了什么问题？</h5><p>浏览器每次发起请求时，先在本地缓存中查找结果以及缓存标识，根据缓存标识来判断是否使用本地缓存, 如果缓存有效，则使用本地缓存。<br>向服务器发起请求并携带缓存标识。根据是否需向服务器发起HTTP请求， 将缓存过程划分为两个部分：强制缓存和协商缓存，强缓优先于协商缓存。</p><ul><li>强缓存，服务器通知浏览器一个缓存时间，在缓存时间内，下次请求，直接用缓存，不在时间内，执行比较缓存策略。</li><li>协商缓存，让客户端与服务器之间能实现缓存文件是否更新的验证、提升缓存的复用率， 将缓存信息中的Etag和Last-Modified,通过请求发送给服务器，由服务器校验，返回304状态码时，浏览器直接使用缓存。</li><li>解决问题<br>1.减少了冗余的数据传输<br>2.减少了服务器的负担，大大提升了网站的性能<br>3.加快了客户端加载网页的速度<br><img src="watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3h1ODM4MjA5NDkw,size_16,color_FFFFFF,t_70.jpeg" alt="avatar"></li></ul><h5 id="6-为什么浏览器要限制TCP的最大个数"><a href="#6-为什么浏览器要限制TCP的最大个数" class="headerlink" title="6. 为什么浏览器要限制TCP的最大个数"></a>6. 为什么浏览器要限制TCP的最大个数</h5><ul><li><p>建立一个tcp连接需要：1，socket文件描述符；2，IP地址；3，端口；4，内存</p></li><li><p>1、内存资源： 一个tcp连接最小占用内存为4096+4096 &#x3D; 8k， 那么对于一个8G内存的机器，在不考虑其他限制下， 最多支持的并发量为：810241024&#x2F;8 约等于100万， 在实际中，由于linux kernel对一些资源的限制， 加上程序的业务处理，所以，8G内存是很难达到100万连接的</p></li><li><p>2、CPU资源</p></li></ul><h5 id="7-HTTP2-0的特点"><a href="#7-HTTP2-0的特点" class="headerlink" title="7. HTTP2.0的特点"></a>7. HTTP2.0的特点</h5><p>  HTTP2.0大幅度的提高了web性能，在HTTP1.1完全语意兼容的基础上，进一步减少了网络的延迟。</p><p>  1、二进制分帧</p><p>  2、多路复用</p><p>  3、首部压缩</p><p>  4、流量控制</p><p>  5、请求优先级</p><p>  6、服务器推送</p><h5 id="8-说一下HTTP2-多路复用原理，以及多路复用优势？"><a href="#8-说一下HTTP2-多路复用原理，以及多路复用优势？" class="headerlink" title="8. 说一下HTTP2 多路复用原理，以及多路复用优势？"></a>8. 说一下HTTP2 多路复用原理，以及多路复用优势？</h5><p><img src="image-20230221094228708.png" alt="image-20230221094228708"></p><p>HTTP&#x2F;1.1中的消息是“管道串形化”的：只有等一个消息完成之后，才能进行下一条消息；而HTTP&#x2F;2中多个消息交织在了一起，这无疑提高了“通信”的效率。这就是多路复用：<strong>在一个HTTP的连接上，多路“HTTP消息”同时工作</strong>。</p><h5 id="9-简述https原理，以及与http的区别"><a href="#9-简述https原理，以及与http的区别" class="headerlink" title="9. 简述https原理，以及与http的区别"></a>9. 简述https原理，以及与http的区别</h5><ul><li><p>HTTP协议工作在80端口，HTTPS协议工作在443端口</p></li><li><p>HTTPS需要申请证书（用于验证服务器身份）</p></li><li><p>HTTP在TCP三次握手建立连接之后即可开始传输数据；HTTPS协议则需要在建立TCP连接之后客户端与服务器在进行SSL加密，确定对话密钥，完成加密后才开始传输数据。</p></li><li><p>HTTPS协议传输是密文，HTTP协议传输是明文</p></li></ul><h5 id="10-CDN-是什么？描述下-CDN-原理？为什么要用-CDN"><a href="#10-CDN-是什么？描述下-CDN-原理？为什么要用-CDN" class="headerlink" title="10. CDN 是什么？描述下 CDN 原理？为什么要用 CDN?"></a>10. CDN 是什么？描述下 CDN 原理？为什么要用 CDN?</h5><p>  CDN的全称是Content Delivery Network，即内容分发网络 共有云厂商在全世界各地都遍布不计其数都数据中心和服务器， CDN服务简单来讲就是这些厂商将你的服务器上面的文档分发到他们不同地区的服务器的当中， 每个地区可以称为一个节点，这样用户在访问你的网址时， 浏览器发送的请求就会优先绕去离客户最近的节点来获取数据， 这样方便客户更快的速度访问网站。 CDN是构建在现有网络基础之上的智能虚拟网络，依靠部署在各地的边缘服务器， 通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容， 降低网络拥塞，提高用户访问响应速度和命中率。CDN的关键技术主要有内容存储和分发技术。</p><h5 id="11-为什么form表单提交没有跨域问题，但ajax有跨域问题"><a href="#11-为什么form表单提交没有跨域问题，但ajax有跨域问题" class="headerlink" title="11.  为什么form表单提交没有跨域问题，但ajax有跨域问题"></a>11.  为什么form表单提交没有跨域问题，但ajax有跨域问题</h5><p>  浏览器的策略本质是：一个域名下面的JS，没有经过允许是不能读取另一个域名的内容，但是浏览器不阻止你向另外一个域名发送请求。 所以form表单提交没有跨域问题，提交form表单到另外一个域名，原来页面是无法获取新页面的内容，或者说form提交后不需要返回，但是ajax是需要返回的。 而ajax是想要读取响应内容，浏览器是不允许你这么做的。 浏览器的安全策略限制的是js脚本，并不限制src，form表单提交之类的请求， 就是说form表单提交不存在安全问题，ajax提交跨域存在安全问题。</p><h4 id="十一-高频算法-排序算法"><a href="#十一-高频算法-排序算法" class="headerlink" title="十一. 高频算法-排序算法"></a>十一. 高频算法-排序算法</h4><h5 id="1-冒泡排序"><a href="#1-冒泡排序" class="headerlink" title="1. 冒泡排序"></a>1. 冒泡排序</h5><blockquote><p>冒泡排序比较所有相邻的两个项，如果第一个比第二个大，则交换它们。元素项向上移动至 正确的顺序，就好像气泡升至表面一样，冒泡排序因此得名。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">bubbleSort</span>(<span class="hljs-params">array</span>) &#123;<br>    <span class="hljs-keyword">const</span> &#123;<br>        length<br>    &#125; = array;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; length; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; length - <span class="hljs-number">1</span>; j++) &#123;<br>            <span class="hljs-keyword">if</span> (array[j] &gt; array[j + <span class="hljs-number">1</span>]) &#123;<br>                <span class="hljs-title function_">swap</span>(array, j, j + <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> array;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">swap</span>(<span class="hljs-params">array, a, b</span>) &#123;<br>    <span class="hljs-keyword">const</span> temp = array[a];<br>    array[a] = array[b];<br>    array[b] = temp;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="2-选择排序"><a href="#2-选择排序" class="headerlink" title="2. 选择排序"></a>2. 选择排序</h5><blockquote><p>选择排序算法是一种原址比较排序算法。选择排序大致的思路是找到数据结构中的最小值并 将其放置在第一位，接着找到第二小的值并将其放在第二位，以此类推。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">selectionSort</span>(<span class="hljs-params">array</span>) &#123;<br>    <span class="hljs-keyword">const</span> &#123;<br>        length<br>    &#125; = array;<br>    <span class="hljs-keyword">let</span> indexMin;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; length - <span class="hljs-number">1</span>; i++) &#123;<br>        indexMin = i;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = i; j &lt; length; j++) &#123;<br>            <span class="hljs-keyword">if</span> (array[indexMin] &gt; array[j]) &#123;<br>                indexMin = j;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (i !== indexMin) &#123;<br>            <span class="hljs-title function_">swap</span>(array, i, indexMin);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> array;<br>&#125;;<br></code></pre></td></tr></table></figure><h5 id="3-插入排序"><a href="#3-插入排序" class="headerlink" title="3. 插入排序"></a>3. 插入排序</h5><blockquote><p>插入排序每次排一个数组项，以此方式构建最后的排序数组。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">insertionSort</span>(<span class="hljs-params">array</span>) &#123;<br>    <span class="hljs-keyword">const</span> &#123;<br>        length<br>    &#125; = array;<br>    <span class="hljs-keyword">let</span> temp;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; length; i++) &#123;<br>        <span class="hljs-keyword">let</span> j = i;<br>        temp = array[i];<br>        <span class="hljs-keyword">while</span> (j &gt; <span class="hljs-number">0</span> &amp;&amp; array[j - <span class="hljs-number">1</span>] &gt; temp) &#123;<br>            array[j] = array[j - <span class="hljs-number">1</span>];<br>            j--;<br>        &#125;<br>        array[j] = temp;<br>    &#125;<br>    <span class="hljs-keyword">return</span> array;<br>&#125;;<br></code></pre></td></tr></table></figure><h5 id="4-归并排序"><a href="#4-归并排序" class="headerlink" title="4. 归并排序"></a>4. 归并排序</h5><blockquote><p>归并排序是一种分而治之算法。其思想是将原始数组切分成较小的数组，直到每个小数组只 有一个位置，接着将小数组归并成较大的数组，直到最后只有一个排序完毕的大数组。</p></blockquote><img src="../../../../Web前端/JS3/%E7%AC%94%E8%AE%B0/%E7%AC%94%E8%AE%B0.assets/image-20221209111002284.png" alt="image-20221209111002284" style="zoom:67%;" /><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">mergeSort</span>(<span class="hljs-params">array</span>) &#123;<br>    <span class="hljs-keyword">if</span> (array.<span class="hljs-property">length</span> &gt; <span class="hljs-number">1</span>) &#123; <br>        <span class="hljs-keyword">const</span> &#123;<br>            length<br>        &#125; = array;<br>        <span class="hljs-keyword">const</span> middle = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(length / <span class="hljs-number">2</span>); <br>        <span class="hljs-keyword">const</span> left = <span class="hljs-title function_">mergeSort</span>(array.<span class="hljs-title function_">slice</span>(<span class="hljs-number">0</span>, middle)); <br>        <span class="hljs-keyword">const</span> right = <span class="hljs-title function_">mergeSort</span>(array.<span class="hljs-title function_">slice</span>(middle, length)); <br>        array = <span class="hljs-title function_">merge</span>(left, right); <br>    &#125;<br>    <span class="hljs-keyword">return</span> array;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">merge</span>(<span class="hljs-params">left, right </span>) &#123;<br>    <span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; <br>    <span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">const</span> result = [];<br>    <span class="hljs-keyword">while</span> (i &lt; left.<span class="hljs-property">length</span> &amp;&amp; j &lt; right.<span class="hljs-property">length</span>) &#123; <br>        result.<span class="hljs-title function_">push</span>(<br>            left[i] &lt; right[j] ? left[i++] : right[j++]<br>        ); <br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result)<br>        <span class="hljs-comment">//先push ，再++</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> result.<span class="hljs-title function_">concat</span>(i &lt; left.<span class="hljs-property">length</span> ? left.<span class="hljs-title function_">slice</span>(i) : right.<span class="hljs-title function_">slice</span>(j)); <br>&#125;<br></code></pre></td></tr></table></figure><h5 id="5-快速排序"><a href="#5-快速排序" class="headerlink" title="5. 快速排序"></a>5. 快速排序</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">quickSort</span>(<span class="hljs-params">arr</span>)&#123;<br>    <span class="hljs-keyword">const</span> &#123;length&#125; = arr<br>    <span class="hljs-keyword">if</span>(length&lt;<span class="hljs-number">2</span>)&#123;<br>        <span class="hljs-keyword">return</span> arr<br>    &#125;<br><br>    <span class="hljs-keyword">let</span> base = arr[<span class="hljs-number">0</span>]<br>    <span class="hljs-keyword">let</span> min = arr.<span class="hljs-title function_">slice</span>(<span class="hljs-number">1</span>).<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">item</span>=&gt;</span>item&lt;=base)<br>    <span class="hljs-keyword">let</span> max = arr.<span class="hljs-title function_">slice</span>(<span class="hljs-number">1</span>).<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">item</span>=&gt;</span>item&gt;base)<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">quickSort</span>(min).<span class="hljs-title function_">concat</span>([base]).<span class="hljs-title function_">concat</span>(<span class="hljs-title function_">quickSort</span>(max))<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="6-计数排序"><a href="#6-计数排序" class="headerlink" title="6. 计数排序"></a>6. 计数排序</h5><blockquote><p>计数排序使用一个用来存储每个元素在原始 数组中出现次数的临时数组。在所有元素都计数完成后，临时数组已排好序并可迭代以构建排序 后的结果数组。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">countingSort</span>(<span class="hljs-params">array</span>) &#123;<br>    <span class="hljs-keyword">if</span> (array.<span class="hljs-property">length</span> &lt; <span class="hljs-number">2</span>) &#123; <br>        <span class="hljs-keyword">return</span> array;<br>    &#125;<br>    <span class="hljs-keyword">const</span> maxValue = <span class="hljs-title function_">findMaxValue</span>(array);<br>    <span class="hljs-keyword">const</span> counts = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(maxValue + <span class="hljs-number">1</span>); <br>    array.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">element</span> =&gt;</span> &#123;<br>        <span class="hljs-keyword">if</span> (!counts[element]) &#123; <br>            counts[element] = <span class="hljs-number">0</span>;<br>        &#125;<br>        counts[element]++; <br>    &#125;);<br>    <span class="hljs-keyword">let</span> sortedIndex = <span class="hljs-number">0</span>;<br>    counts.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">count, i</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">while</span> (count &gt; <span class="hljs-number">0</span>) &#123; <br>            array[sortedIndex++] = i; <br>            count--; <br>        &#125;<br>    &#125;);<br>    <span class="hljs-keyword">return</span> array;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">findMaxValue</span>(<span class="hljs-params">array</span>) &#123;<br>    <span class="hljs-keyword">let</span> max = array[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; array.<span class="hljs-property">length</span>; i++) &#123;<br>        <span class="hljs-keyword">if</span> (array[i] &gt; max) &#123;<br>            max = array[i];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> max;<br>&#125;<br><br><span class="hljs-title function_">countingSort</span>([<span class="hljs-number">5</span>,<span class="hljs-number">7</span>,<span class="hljs-number">4</span>,<span class="hljs-number">9</span>,<span class="hljs-number">1</span>])<br></code></pre></td></tr></table></figure><h5 id="7-桶排序"><a href="#7-桶排序" class="headerlink" title="7.  桶排序"></a>7.  桶排序</h5><blockquote><p>桶排序（也被称为箱排序）也是分布式排序算法，它将元素分为不同的桶（较小的数组）， 再使用一个简单的排序算法，例如插入排序（用来排序小数组的不错的算法），来对每个桶进行 排序。然后，它将所有的桶合并为结果数组。</p></blockquote><p><img src="image-20221213091612715.png" alt="image-20221213091612715"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">insertSort</span>(<span class="hljs-params">arr</span>) &#123;<br>    <span class="hljs-keyword">const</span> &#123;<br>        length<br>    &#125; = arr<br>    <span class="hljs-keyword">let</span> temp; <span class="hljs-comment">//存 当前这一轮对应索引的元素值</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; length; i++) &#123;<br>        temp = arr[i]<br>        <span class="hljs-keyword">let</span> j = i;<br>        <span class="hljs-keyword">while</span> (j &gt; <span class="hljs-number">0</span> &amp;&amp; arr[j - <span class="hljs-number">1</span>] &gt; temp) &#123;<br>            arr[j] = arr[j - <span class="hljs-number">1</span>]<br>            j--<br>        &#125;<br><br>        arr[j] = temp<br>    &#125;<br><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr)<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">bucketSort</span>(<span class="hljs-params">array, bucketSize = <span class="hljs-number">3</span></span>) &#123; <br>    <span class="hljs-keyword">if</span> (array.<span class="hljs-property">length</span> &lt; <span class="hljs-number">2</span>) &#123;<br>        <span class="hljs-keyword">return</span> array;<br>    &#125;<br>    <span class="hljs-keyword">const</span> buckets = <span class="hljs-title function_">createBuckets</span>(array, bucketSize); <br>    <span class="hljs-comment">//分桶装</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">sortBuckets</span>(buckets); <br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">createBuckets</span>(<span class="hljs-params">array, bucketSize</span>) &#123;<br>    <span class="hljs-keyword">let</span> minValue = array[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">let</span> maxValue = array[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; array.<span class="hljs-property">length</span>; i++) &#123; <br>        <span class="hljs-keyword">if</span> (array[i] &lt; minValue) &#123;<br>            minValue = array[i];<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (array[i] &gt; maxValue) &#123;<br>            maxValue = array[i];<br>        &#125;<br>    &#125;<span class="hljs-comment">//一次循环找到最小最大值</span><br>    <span class="hljs-keyword">const</span> bucketCount = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>((maxValue - minValue) / bucketSize) + <span class="hljs-number">1</span>; <span class="hljs-comment">// 最后一个索引+1</span><br>    <span class="hljs-keyword">const</span> buckets = [];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; bucketCount; i++) &#123;<br>        buckets[i] = [];<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; array.<span class="hljs-property">length</span>; i++) &#123; <br>        <span class="hljs-keyword">const</span> bucketIndex = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>((array[i] - minValue) / bucketSize); <br>        buckets[bucketIndex].<span class="hljs-title function_">push</span>(array[i]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> buckets;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">sortBuckets</span>(<span class="hljs-params">buckets</span>) &#123;<br>    <span class="hljs-keyword">const</span> sortedArray = []; <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; buckets.<span class="hljs-property">length</span>; i++) &#123; <br>        <span class="hljs-keyword">if</span> (buckets[i] != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-title function_">insertSort</span>(buckets[i]); <br>            sortedArray.<span class="hljs-title function_">push</span>(...buckets[i]); <br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> sortedArray;<br>&#125;<br><br><span class="hljs-title function_">bucketSort</span>([<span class="hljs-number">5</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">6</span>,<span class="hljs-number">1</span>,<span class="hljs-number">7</span>,<span class="hljs-number">10</span>,<span class="hljs-number">9</span>,<span class="hljs-number">8</span>])<br></code></pre></td></tr></table></figure><h5 id="8-基数排序"><a href="#8-基数排序" class="headerlink" title="8. 基数排序"></a>8. 基数排序</h5><blockquote><p>基数排序也是一个分布式排序算法，它根据数字的有效位或基数（这也是它为什么叫基数排 序）将整数分布到桶中。基数是基于数组中值的记数制的。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">35</span>, <span class="hljs-number">2</span>, <span class="hljs-number">26</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">8</span>, <span class="hljs-number">34</span>, <span class="hljs-number">1</span>, <span class="hljs-number">56</span>, <span class="hljs-number">99</span>, <span class="hljs-number">33</span>];<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">radixSort</span> = (<span class="hljs-params">arr = []</span>) =&gt; &#123;<br>    <span class="hljs-keyword">const</span> base = <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">let</span> divider = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">let</span> maxVal = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (divider === <span class="hljs-number">1</span> || divider &lt;= maxVal) &#123;<br>        <span class="hljs-keyword">const</span> buckets = [...<span class="hljs-title class_">Array</span>(<span class="hljs-number">10</span>)].<span class="hljs-title function_">map</span>(<span class="hljs-function">() =&gt;</span> []);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> val <span class="hljs-keyword">of</span> arr) &#123;<br>            buckets[<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>((val / divider) % base)].<span class="hljs-title function_">push</span>(val);<br>            maxVal = val &gt; maxVal ? val : maxVal;<br>        &#125;<br><br>        arr = [].<span class="hljs-title function_">concat</span>(...buckets);<br><br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr)<br>        divider *= base;<br>    &#125;;<br>    <span class="hljs-keyword">return</span> arr;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="十二-高频算法-搜索算法"><a href="#十二-高频算法-搜索算法" class="headerlink" title="十二. 高频算法-搜索算法"></a>十二. 高频算法-搜索算法</h4><h5 id="1-顺序搜索"><a href="#1-顺序搜索" class="headerlink" title="1. 顺序搜索"></a>1. 顺序搜索</h5><blockquote><p>顺序或线性搜索是最基本的搜索算法。它的机制是，将每一个数据结构中的元素和我们要找 的元素做比较。顺序搜索是最低效的一种搜索算法。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">sequentialSearch</span>(<span class="hljs-params">array, value</span>) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; array.<span class="hljs-property">length</span>; i++) &#123;<br>        <span class="hljs-keyword">if</span> (value===array[i]) &#123; <br>            <span class="hljs-keyword">return</span> i;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span><br>&#125;<br><br><span class="hljs-title function_">sequentialSearch</span>([<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>],<span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure><h5 id="2-二分搜索"><a href="#2-二分搜索" class="headerlink" title="2.二分搜索"></a>2.二分搜索</h5><img src="../../../../Web前端/JS3/%E7%AC%94%E8%AE%B0/%E7%AC%94%E8%AE%B0.assets/image-20221214083405056.png" alt="image-20221214083405056" style="zoom:80%;float:left;" /><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> <span class="hljs-title class_">Arr</span> = [<span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">4</span>, <span class="hljs-number">2</span>, <span class="hljs-number">9</span>];<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">binarySearch</span>(<span class="hljs-params">find, arr, low, high</span>) &#123;<br>    arr = <span class="hljs-title function_">quickSort</span>(arr);<br>    <span class="hljs-keyword">if</span> (low &lt;= high) &#123;<br>        <span class="hljs-keyword">if</span> (arr[low] == find) &#123;<br>            <span class="hljs-keyword">return</span> low;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (arr[high] == find) &#123;<br>            <span class="hljs-keyword">return</span> high;<br>        &#125;<br>        <span class="hljs-keyword">var</span> mid = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">ceil</span>((high + low) / <span class="hljs-number">2</span>);<br>        <span class="hljs-keyword">if</span> (arr[mid] == find) &#123;<br>            <span class="hljs-keyword">return</span> mid;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (arr[mid] &gt; find) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-title function_">binarySearch</span>(find, arr, low, mid - <span class="hljs-number">1</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-title function_">binarySearch</span>(find, arr, mid + <span class="hljs-number">1</span>, high);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-title function_">binarySearch</span>(<span class="hljs-number">9</span>, <span class="hljs-title class_">Arr</span>, <span class="hljs-number">0</span>, <span class="hljs-title class_">Arr</span>.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><h5 id="3-内插搜索"><a href="#3-内插搜索" class="headerlink" title="3.内插搜索"></a>3.内插搜索</h5><blockquote><p>内插搜索是改良版的二分搜索。二分搜索总是检查 mid 位置上的值，而内插搜索可能会根 据要搜索的值检查数组中的不同地方。</p></blockquote><img src="../../../../Web前端/JS3/%E7%AC%94%E8%AE%B0/%E7%AC%94%E8%AE%B0.assets/image-20221214090414035.png" alt="image-20221214090414035" style="zoom:80%;float:left;" /><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">4</span>, <span class="hljs-number">2</span>, <span class="hljs-number">9</span>];<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">InsertionSearch</span>(<span class="hljs-params">arr, val, start, end</span>) &#123;<br>    arr = <span class="hljs-title function_">quickSort</span>(arr);<br>    <span class="hljs-keyword">var</span> end = end || arr.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">var</span> start = start || <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">if</span> (start &lt;= end &amp;&amp; val&gt;=arr[start] &amp;&amp; val&lt;=arr[end]) &#123;<br>        <span class="hljs-keyword">var</span> mid = start + <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>((val - arr[start]) / (arr[end] - arr[start]) * (end - start))<br>        <span class="hljs-keyword">if</span> (arr[mid] == val) &#123;<br>            <span class="hljs-keyword">return</span> mid;<br>        &#125;<br><br><br>        <span class="hljs-keyword">if</span> (arr[mid] &gt; val) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-title class_">InsertionSearch</span>(arr, val, start, mid - <span class="hljs-number">1</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-title class_">InsertionSearch</span>(arr, val, mid + <span class="hljs-number">1</span>, end);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span><br>&#125;<br><br><span class="hljs-title class_">InsertionSearch</span>(arr, <span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure><h4 id="十三-高频算法-随机算法"><a href="#十三-高频算法-随机算法" class="headerlink" title="十三. 高频算法-随机算法"></a>十三. 高频算法-随机算法</h4><blockquote><p>迭代数组，从最后一位开始并将当前位置和一个随机位置进行交换。这个随机位 置比当前位置小。这样，这个算法可以保证随机过的位置不会再被随机一次</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">shuffle</span>(<span class="hljs-params">array</span>) &#123;<br> <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = array.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>; i &gt; <span class="hljs-number">0</span>; i--) &#123;<br> <span class="hljs-keyword">const</span> randomIndex = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() * (i + <span class="hljs-number">1</span>));<br> <span class="hljs-title function_">swap</span>(array, i, randomIndex);<br> &#125;<br> <span class="hljs-keyword">return</span> array;<br>&#125; <br></code></pre></td></tr></table></figure><h4 id="十四-高频算法-算法设计"><a href="#十四-高频算法-算法设计" class="headerlink" title="十四. 高频算法-算法设计"></a>十四. 高频算法-算法设计</h4><h5 id="1-分而治之"><a href="#1-分而治之" class="headerlink" title="1.分而治之"></a>1.分而治之</h5><blockquote><p>分而 治之是算法设计中的一种方法。它将一个问题分成多个和原问题相似的小问题，递归解决小问题， 再将解决方式合并以解决原来的问题。</p></blockquote><p>分而治之算法可以分成三个部分。</p><p> (1) 分解原问题为多个子问题（原问题的多个小实例）。 </p><p> (2) 解决子问题，用返回解决子问题的方式的递归算法。递归算法的基本情形可以用来解决子 问题。</p><p> (3) 组合这些子问题的解决方式，得到原问题的解。</p><h5 id="2-动态规划"><a href="#2-动态规划" class="headerlink" title="2.动态规划"></a>2.动态规划</h5><blockquote><p>动态规划（dynamic programming，DP）是一种将复杂问题分解成更小的子问题来解决的优 化技术。</p></blockquote><p>用动态规划解决问题时，要遵循三个重要步骤：</p><p> (1) 定义子问题；</p><p> (2) 实现要反复执行来解决子问题的部分； </p><p>(3) 识别并求解出基线条件。</p><h6 id="2-1-背包问题"><a href="#2-1-背包问题" class="headerlink" title="2-1 背包问题"></a>2-1 背包问题</h6><blockquote><p>背包问题是一个组合优化问题。它可以描述如下：给定一个固定大小、能够携重量 W 的背 包，以及一组有价值和重量的物品，找出一个最佳解决方案，使得装入背包的物品总重量不超过 W，且总价值最大。</p></blockquote><img src="../../../../Web前端/JS3/%E7%AC%94%E8%AE%B0/%E7%AC%94%E8%AE%B0.assets/image-20221220150040895.png" alt="image-20221220150040895" style="zoom:67%;float:left;" /><img src="../../../../Web前端/JS3/%E7%AC%94%E8%AE%B0/%E7%AC%94%E8%AE%B0.assets/image-20221220154547224.png" alt="image-20221220154547224" style="zoom:67%;float:left;" /><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">knapSack</span>(<span class="hljs-params">weights, values, W</span>) &#123;<br>    <span class="hljs-keyword">var</span> n = weights.<span class="hljs-property">length</span>;<br>    <span class="hljs-keyword">var</span> f = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(n)<br>    f[-<span class="hljs-number">1</span>] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(W + <span class="hljs-number">1</span>).<span class="hljs-title function_">fill</span>(<span class="hljs-number">0</span>)<span class="hljs-comment">//第-1个物品，</span><br>    <span class="hljs-comment">//负一行的出现可以大大减少了在双层循环的分支判定。</span><br>    <span class="hljs-comment">// console.log(f)</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123; <br>        f[i] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(W).<span class="hljs-title function_">fill</span>(<span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> j = <span class="hljs-number">0</span>; j &lt;= W; j++) &#123; <br>            <span class="hljs-keyword">if</span> (j &lt; weights[i]) &#123; <br>                f[i][j] = f[i - <span class="hljs-number">1</span>][j]<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                f[i][j] = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(f[i - <span class="hljs-number">1</span>][j], f[i - <span class="hljs-number">1</span>][j - weights[i]] + values[i]); <span class="hljs-comment">//case 3</span><br>            &#125;<span class="hljs-comment">//即使i = 0 也不怕，i-1 为-1 有-1行不怕</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> f[n - <span class="hljs-number">1</span>][W]<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="2-2-最长公共子序列"><a href="#2-2-最长公共子序列" class="headerlink" title="2-2 最长公共子序列"></a>2-2 最长公共子序列</h6><blockquote><p>找出两个字符 串序列的最长子序列的长度。最长子序列是指，在两个字符串序列中以相同顺序出现，但不要求 连续（非字符串子串）的字符串序列。</p></blockquote><img src="../../../../Web前端/JS3/%E7%AC%94%E8%AE%B0/%E7%AC%94%E8%AE%B0.assets/image-20221221131801017.png" alt="image-20221221131801017" style="zoom:67%;float:left" /><img src="../../../../Web前端/JS3/%E7%AC%94%E8%AE%B0/%E7%AC%94%E8%AE%B0.assets/image-20221221131809239.png" alt="image-20221221131809239" style="zoom:67%;float:left" /><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">LCS</span>(<span class="hljs-params">str1, str2</span>) &#123;<br>    <span class="hljs-keyword">var</span> m = str1.<span class="hljs-property">length</span><br>    <span class="hljs-keyword">var</span> n = str2.<span class="hljs-property">length</span><br>    <span class="hljs-keyword">var</span> dp = [<span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(n + <span class="hljs-number">1</span>).<span class="hljs-title function_">fill</span>(<span class="hljs-number">0</span>)] <span class="hljs-comment">//第一行全是0</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) &#123; <span class="hljs-comment">//一共有m+1行</span><br>        dp[i] = [<span class="hljs-number">0</span>] <span class="hljs-comment">//第一列全是0</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++) &#123; <span class="hljs-comment">//一共有n+1列</span><br>            <span class="hljs-keyword">if</span> (str1[i - <span class="hljs-number">1</span>] === str2[j - <span class="hljs-number">1</span>]) &#123;<br>                <span class="hljs-comment">//注意这里，str1的第一个字符是在第二列中，因此要减1，str2同理</span><br>                dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span> <span class="hljs-comment">//对角＋1</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                dp[i][j] = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(dp[i - <span class="hljs-number">1</span>][j], dp[i][j - <span class="hljs-number">1</span>])<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[m][n];<br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">LCS</span>(<span class="hljs-string">&quot;abcadf&quot;</span>, <span class="hljs-string">&quot;acbaed&quot;</span>))<br></code></pre></td></tr></table></figure><h5 id="3-贪心算法"><a href="#3-贪心算法" class="headerlink" title="3. 贪心算法"></a>3. 贪心算法</h5><blockquote><p>在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，他所做出的仅是在某种意义上的局部最优解。贪心算法不是对所有问题都能得到整体最优解，但对范围相当广泛的许多问题他能产生整体最优解或者是整体最优解的近似解。</p></blockquote><img src="../../../../Web前端/JS3/%E7%AC%94%E8%AE%B0/%E7%AC%94%E8%AE%B0.assets/image-20221226122030597.png" alt="image-20221226122030597" style="zoom:50%;float:left" /><img src="../../../../Web前端/JS3/%E7%AC%94%E8%AE%B0/%E7%AC%94%E8%AE%B0.assets/image-20221226122115470.png" alt="image-20221226122115470" style="zoom: 50%;float:left;" /><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">tanx</span>(<span class="hljs-params">capacity, weights, values</span>) &#123;<br>    <span class="hljs-keyword">var</span> list = [];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>, len = weights.<span class="hljs-property">length</span>; i &lt; len; i++) &#123;<br>        list.<span class="hljs-title function_">push</span>(&#123;<br>            <span class="hljs-attr">num</span>: i + <span class="hljs-number">1</span>, <span class="hljs-comment">//第几件商品</span><br>            <span class="hljs-attr">w</span>: weights[i], <span class="hljs-comment">//重量</span><br>            <span class="hljs-attr">v</span>: values[i],<br>            <span class="hljs-attr">rate</span>: values[i] / weights[i]<br>        &#125;);<br>    &#125;<br><br>    list.<span class="hljs-title function_">sort</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">a, b</span>) &#123;<br>        <span class="hljs-keyword">return</span> b.<span class="hljs-property">rate</span>-a.<span class="hljs-property">rate</span><br>    &#125;);<br>    <span class="hljs-comment">// console.log(list)</span><br><br>    <span class="hljs-keyword">var</span> selects = [];<br>    <span class="hljs-keyword">var</span> total = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>, len = list.<span class="hljs-property">length</span>; i &lt; len; i++) &#123;<br>        <span class="hljs-keyword">var</span> item = list[i];<br><br>        <span class="hljs-keyword">if</span> (item[<span class="hljs-string">&#x27;w&#x27;</span>] &lt;= capacity) &#123;<br>            selects.<span class="hljs-title function_">push</span>(&#123;<br>                <span class="hljs-attr">num</span>: item.<span class="hljs-property">num</span>,<br>                <span class="hljs-attr">rate</span>: <span class="hljs-number">1</span>, <span class="hljs-comment">//完整的商品记录为1</span><br>                <span class="hljs-attr">v</span>: item.<span class="hljs-property">v</span>,<br>                <span class="hljs-attr">w</span>: item.<span class="hljs-property">w</span><br>            &#125;);<br><br>            total = total + item.<span class="hljs-property">v</span>;<br>            capacity = capacity - item.<span class="hljs-property">w</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (capacity &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">//选取不完整的商品</span><br>            <span class="hljs-keyword">var</span> rate = capacity / item[<span class="hljs-string">&#x27;w&#x27;</span>];<br>            <span class="hljs-keyword">var</span> v = item.<span class="hljs-property">v</span> * rate;<br>            selects.<span class="hljs-title function_">push</span>(&#123;<br>                <span class="hljs-attr">num</span>: item.<span class="hljs-property">num</span>,<br>                <span class="hljs-attr">rate</span>: rate,<br>                <span class="hljs-attr">v</span>: item.<span class="hljs-property">v</span> * rate,<br>                <span class="hljs-attr">w</span>: item.<span class="hljs-property">w</span> * rate<br>            &#125;);<br>            total = total + v;<br>            <span class="hljs-keyword">break</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> &#123;<br>        selects,<br>        total<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="十五-手写代码-amp-场景题"><a href="#十五-手写代码-amp-场景题" class="headerlink" title="十五. 手写代码&amp;场景题"></a>十五. 手写代码&amp;场景题</h4><h5 id="1-手写Promise"><a href="#1-手写Promise" class="headerlink" title="1.手写Promise"></a>1.手写Promise</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * @作者: kerwin</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">KerwinPromise</span>(<span class="hljs-params">executor</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> = <span class="hljs-string">&quot;pending&quot;</span>;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">result</span> = <span class="hljs-literal">undefined</span>;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">cb</span> = []<br>    <span class="hljs-keyword">var</span> _this = <span class="hljs-variable language_">this</span>;<br><br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">resolve</span>(<span class="hljs-params">res</span>) &#123;<br>        <span class="hljs-keyword">if</span> (_this.<span class="hljs-property">status</span> !== <span class="hljs-string">&quot;pending&quot;</span>) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-comment">// console.log(_this)</span><br>        _this.<span class="hljs-property">status</span> = <span class="hljs-string">&quot;fulfilled&quot;</span><br>        _this.<span class="hljs-property">result</span> = res;<br><br>        _this.<span class="hljs-property">cb</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> &#123;<br>            item.<span class="hljs-property">successCB</span> &amp;&amp; item.<span class="hljs-title function_">successCB</span>(_this.<span class="hljs-property">result</span>)<br>        &#125;);<br>    &#125;<br><br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">reject</span>(<span class="hljs-params">res</span>) &#123;<br>        <span class="hljs-keyword">if</span> (_this.<span class="hljs-property">status</span> !== <span class="hljs-string">&quot;pending&quot;</span>) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-comment">// console.log(&quot;reject&quot;)</span><br>        _this.<span class="hljs-property">status</span> = <span class="hljs-string">&quot;rejected&quot;</span><br>        _this.<span class="hljs-property">result</span> = res;<br>        _this.<span class="hljs-property">cb</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> &#123;<br>            item.<span class="hljs-property">failCB</span> &amp;&amp; item.<span class="hljs-title function_">failCB</span>(_this.<span class="hljs-property">result</span>)<br>        &#125;);<br>    &#125;<br>    <span class="hljs-title function_">executor</span>(resolve, reject)<br>&#125;<br><br><span class="hljs-title class_">KerwinPromise</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">then</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">successCB, failCB</span>) &#123;<br><br>    <span class="hljs-keyword">if</span>(!successCB)&#123;<br>        successCB = <span class="hljs-function"><span class="hljs-params">value</span>=&gt;</span>value<br>    &#125;<br>    <span class="hljs-keyword">if</span>(!failCB)&#123;<br>        failCB = <span class="hljs-function"><span class="hljs-params">error</span>=&gt;</span>error<br>    &#125;<br><br>    <span class="hljs-comment">// successCB()</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">KerwinPromise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> === <span class="hljs-string">&quot;fulfilled&quot;</span>) &#123;<br>            <span class="hljs-keyword">var</span> result = successCB &amp;&amp; <span class="hljs-title function_">successCB</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">result</span>)<br>            <span class="hljs-comment">// console.log(result);</span><br><br>            <span class="hljs-keyword">if</span> (result <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">KerwinPromise</span>) &#123;<br>                result.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;<br>                    <span class="hljs-comment">// console.log(res)</span><br>                    <span class="hljs-title function_">resolve</span>(res);<br>                &#125;, <span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;<br>                    <span class="hljs-comment">// console.log(err)</span><br>                    <span class="hljs-title function_">reject</span>(err)<br>                &#125;)<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-title function_">resolve</span>(result);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> === <span class="hljs-string">&quot;rejected&quot;</span>) &#123;<br>            <span class="hljs-keyword">var</span> result = failCB &amp;&amp; <span class="hljs-title function_">failCB</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">result</span>)<br><br>            <span class="hljs-keyword">if</span> (result <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">KerwinPromise</span>) &#123;<br>                result.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;<br>                    <span class="hljs-comment">// console.log(res)</span><br>                    <span class="hljs-title function_">resolve</span>(res);<br>                &#125;, <span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;<br>                    <span class="hljs-comment">// console.log(err)</span><br>                    <span class="hljs-title function_">reject</span>(err)<br>                &#125;)<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-title function_">reject</span>(result);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> === <span class="hljs-string">&quot;pending&quot;</span>) &#123;<br>            <span class="hljs-comment">//收集回调</span><br>            <span class="hljs-variable language_">this</span>.<span class="hljs-property">cb</span>.<span class="hljs-title function_">push</span>(&#123;<br>                <span class="hljs-attr">successCB</span>: <span class="hljs-function">() =&gt;</span> &#123;<br>                    <span class="hljs-keyword">var</span> result = successCB &amp;&amp; <span class="hljs-title function_">successCB</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">result</span>)<br><br>                    <span class="hljs-keyword">if</span> (result <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">KerwinPromise</span>) &#123;<br>                        result.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;<br>                            <span class="hljs-comment">// console.log(res)</span><br>                            <span class="hljs-title function_">resolve</span>(res);<br>                        &#125;, <span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;<br>                            <span class="hljs-comment">// console.log(err)</span><br>                            <span class="hljs-title function_">reject</span>(err)<br>                        &#125;)<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        <span class="hljs-title function_">resolve</span>(result);<br>                    &#125;<br>                &#125;,<br>                <span class="hljs-attr">failCB</span>: <span class="hljs-function">() =&gt;</span> &#123;<br>                    <span class="hljs-keyword">var</span> result = failCB &amp;&amp; <span class="hljs-title function_">failCB</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">result</span>)<br>                    <span class="hljs-keyword">if</span> (result <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">KerwinPromise</span>) &#123;<br>                        result.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;<br>                            <span class="hljs-comment">// console.log(res)</span><br>                            <span class="hljs-title function_">resolve</span>(res);<br>                        &#125;, <span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;<br>                            <span class="hljs-comment">// console.log(err)</span><br>                            <span class="hljs-title function_">reject</span>(err)<br>                        &#125;)<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        <span class="hljs-title function_">reject</span>(result);<br>                    &#125;<br>                &#125;<br>            &#125;)<br>        &#125;<br>    &#125;)<br>&#125;<br><br><span class="hljs-title class_">KerwinPromise</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">catch</span>= <span class="hljs-keyword">function</span>(<span class="hljs-params">failCB</span>)&#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">then</span>(<span class="hljs-literal">undefined</span>,failCB)<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="2-手写实现发布-x2F-订阅模式"><a href="#2-手写实现发布-x2F-订阅模式" class="headerlink" title="2.手写实现发布&#x2F;订阅模式"></a>2.手写实现发布&#x2F;订阅模式</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Subject</span> &#123; <span class="hljs-comment">//定义被观察者</span><br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">observers</span> = []<br>  &#125;<br><br>  <span class="hljs-title function_">addObserver</span>(<span class="hljs-params">observer</span>) &#123; <span class="hljs-comment">//订阅</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">observers</span>.<span class="hljs-title function_">push</span>(observer)<br>  &#125;<br><br>  <span class="hljs-title function_">removerObserver</span>(<span class="hljs-params">observer</span>) &#123;<span class="hljs-comment">//取消订阅</span><br>    <span class="hljs-keyword">let</span> index = <span class="hljs-variable language_">this</span>.<span class="hljs-property">observers</span>.<span class="hljs-title function_">indexOf</span>(observer)<br>    <span class="hljs-keyword">if</span> (index !== -<span class="hljs-number">1</span>) &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">observers</span>.<span class="hljs-title function_">splice</span>(index, <span class="hljs-number">1</span>)<br>    &#125;<br><br>  &#125;<br><br>  <span class="hljs-title function_">notify</span>(<span class="hljs-params"></span>) &#123;  <span class="hljs-comment">//通知</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">observers</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">observer</span> =&gt;</span> &#123;<br>      observer.<span class="hljs-title function_">update</span>()<br>    &#125;)<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Observer</span> &#123; <span class="hljs-comment">// 定义观察者</span><br>  <span class="hljs-title function_">update</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;subject更新了&#x27;</span>);<br>  &#125;<br>  <span class="hljs-title function_">subscribeTo</span>(<span class="hljs-params">subject</span>) &#123;<br>    subject.<span class="hljs-title function_">addObserver</span>(<span class="hljs-variable language_">this</span>)<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> subject = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Subject</span>() <span class="hljs-comment">//被观察者</span><br><span class="hljs-keyword">let</span> observer1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Observer</span>()  <span class="hljs-comment">//观察者</span><br>observer1.<span class="hljs-title function_">subscribeTo</span>(subject) <span class="hljs-comment">//观察者进行订阅</span><br><span class="hljs-keyword">let</span> observer2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Observer</span>()  <span class="hljs-comment">//观察者</span><br>observer2.<span class="hljs-title function_">subscribeTo</span>(subject) <span class="hljs-comment">//观察者进行订阅</span><br>subject.<span class="hljs-title function_">notify</span>()<br></code></pre></td></tr></table></figure><h5 id="3-手写代码，监测数组变化，并返回数组长度"><a href="#3-手写代码，监测数组变化，并返回数组长度" class="headerlink" title="3. 手写代码，监测数组变化，并返回数组长度"></a>3. 手写代码，监测数组变化，并返回数组长度</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//手写代码，监测数组变化，并返回数组长度</span><br><span class="hljs-comment">// 获取Array的原型，并创建一个新的对象指向这个原型</span><br>    <span class="hljs-comment">// const arrayMethods = Object.create(Array.prototype)</span><br>    <span class="hljs-comment">// 创建一个新的原型，这就是改造之后的数组原型</span><br>    <span class="hljs-keyword">const</span> <span class="hljs-title class_">ArrayProto</span> = []<br>    <span class="hljs-comment">// 重新构建Array原型里面的虽有方法</span><br>    <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getOwnPropertyNames</span>(<span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>).<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">method</span> =&gt;</span> &#123;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>[method] === <span class="hljs-string">&quot;function&quot;</span>) &#123;<br>        <span class="hljs-title class_">ArrayProto</span>[method] = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;我已经监听到数组触发了&quot;</span> + method + <span class="hljs-string">&quot;事件&quot;</span>)<br>          <span class="hljs-keyword">let</span> len = <span class="hljs-variable language_">this</span>.<span class="hljs-property">length</span><br>          <span class="hljs-keyword">let</span> result = <span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>[method].<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, <span class="hljs-variable language_">arguments</span>)<br>          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(len, <span class="hljs-variable language_">this</span>.<span class="hljs-property">length</span>);<br>          <span class="hljs-keyword">if</span> (len !== <span class="hljs-variable language_">this</span>.<span class="hljs-property">length</span>) <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">length</span><br>          <span class="hljs-keyword">return</span> result<br>        &#125;<br>      &#125;<br>    &#125;)<br>    <span class="hljs-keyword">let</span> list = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br>    <span class="hljs-comment">// 将数组的原型链指向新构造的原型</span><br>    list.<span class="hljs-property">__proto__</span> = <span class="hljs-title class_">ArrayProto</span><br>    <span class="hljs-comment">// 执行push事件</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(list.<span class="hljs-title function_">push</span>(<span class="hljs-number">2</span>), list.<span class="hljs-title function_">pop</span>(<span class="hljs-number">2</span>), list.<span class="hljs-title function_">slice</span>(<span class="hljs-number">2</span>), list.<span class="hljs-title function_">unshift</span>(<span class="hljs-number">2</span>));<br></code></pre></td></tr></table></figure><h5 id="4-手写ajax"><a href="#4-手写ajax" class="headerlink" title="4. 手写ajax"></a>4. 手写ajax</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//1.创建对象</span><br><span class="hljs-keyword">let</span>  xhq = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>()<br><span class="hljs-comment">//2.初始话http请求参数</span><br>xhq.<span class="hljs-title function_">open</span>(methode, url, <span class="hljs-literal">true</span>)<br><span class="hljs-comment">//3.发送请求</span><br>xhq.<span class="hljs-title function_">send</span>(&#123;<br>    <span class="hljs-attr">username</span>:<span class="hljs-string">&#x27;wzx&#x27;</span><br>&#125;)<br><span class="hljs-comment">//4.监听请求状态,执行对应的回调函数</span><br>xhq.<span class="hljs-property">onreadystatechange</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">if</span> ( xhq.<span class="hljs-property">readystate</span> == <span class="hljs-number">4</span> &amp;&amp; xhq.<span class="hljs-property">status</span> == <span class="hljs-number">200</span> ) &#123;<br>        <span class="hljs-comment">// success 回调</span><br>        <span class="hljs-title function_">success</span>(xhq.<span class="hljs-property">responseText</span>)<br>    &#125;  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (xhq.<span class="hljs-property">readyState</span> == <span class="hljs-number">4</span> &amp;&amp; xhq.<span class="hljs-property">status</span> !== <span class="hljs-number">200</span>) &#123;<br>        <span class="hljs-comment">// error 回调</span><br>        <span class="hljs-title function_">error</span>()<br>    &#125;<br>&#125;<br><br><br><span class="hljs-comment">//-----------完整实现-----------</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">sendAjax</span>(<span class="hljs-params">obj</span>) &#123;<br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">splicStr</span>(<span class="hljs-params">data</span>) &#123;<span class="hljs-comment">// get方式传入时，将内容进行data内容进行拼接</span><br>        <span class="hljs-keyword">var</span> str = <span class="hljs-string">&#x27;&#x27;</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i <span class="hljs-keyword">in</span> data) &#123;<br>            str = i + <span class="hljs-string">&#x27;=&#x27;</span> + data[i]<br>        &#125;<br>        <span class="hljs-keyword">return</span> str<br>    &#125;<br><br><span class="hljs-comment">// 原生ajax实现 步骤分析</span><br><span class="hljs-comment">// 一、声明XMLHttpRequest, 为了兼容IE5、6需要使用ActiveXObject()</span><br>    <span class="hljs-keyword">let</span> xhq = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>() <span class="hljs-comment">// 创建对象</span><br><span class="hljs-comment">// 二、初始化HTTP请求参数， 只初始化并不会发送</span><br>    <span class="hljs-keyword">if</span> (obj.<span class="hljs-property">method</span>.<span class="hljs-title function_">toUpperCase</span>() === <span class="hljs-string">&#x27;GET&#x27;</span>) &#123; <span class="hljs-comment">// get方法</span><br>        xhq.<span class="hljs-title function_">open</span>(obj.<span class="hljs-property">method</span>, obj.<span class="hljs-property">url</span> + <span class="hljs-string">&#x27;?&#x27;</span> + <span class="hljs-title function_">splicStr</span>(obj.<span class="hljs-property">data</span>),  <span class="hljs-keyword">typeof</span> obj.<span class="hljs-property">async</span> === <span class="hljs-string">&#x27;boolean&#x27;</span>? obj.<span class="hljs-property">async</span> : <span class="hljs-literal">true</span>) <span class="hljs-comment">// 路径拼接</span><br>        xhq.<span class="hljs-title function_">send</span>()<span class="hljs-comment">// 三、发送此次请求</span><br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (obj.<span class="hljs-property">method</span>.<span class="hljs-title function_">toUpperCase</span>() === <span class="hljs-string">&#x27;POST&#x27;</span>) &#123; <span class="hljs-comment">// post方法</span><br>        xhq.<span class="hljs-title function_">open</span>(obj.<span class="hljs-property">method</span>, obj.<span class="hljs-property">url</span>, <span class="hljs-keyword">typeof</span> obj.<span class="hljs-property">async</span> === <span class="hljs-string">&#x27;boolean&#x27;</span>? obj.<span class="hljs-property">async</span> : <span class="hljs-literal">true</span>)<br>        xhq.<span class="hljs-title function_">setRequestHeader</span>(<span class="hljs-string">&quot;content-type&quot;</span>,<span class="hljs-string">&quot;application/json&quot;</span>) <span class="hljs-comment">// 以表单提交</span><br>        xhq.<span class="hljs-title function_">send</span>(obj.<span class="hljs-property">data</span>)<span class="hljs-comment">// 三、发送此次请求</span><br>    &#125;<br><span class="hljs-comment">//四、监听发送</span><br>    xhq.<span class="hljs-property">onreadystatechange</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">if</span> ( xhq.<span class="hljs-property">readyState</span> == <span class="hljs-number">4</span> &amp;&amp; xhq.<span class="hljs-property">status</span> == <span class="hljs-number">200</span> ) &#123;<br>            <span class="hljs-comment">// success 回调</span><br>            <span class="hljs-title function_">success</span>(xhq.<span class="hljs-property">responseText</span>)<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (xhq.<span class="hljs-property">readyState</span> == <span class="hljs-number">4</span> &amp;&amp; xhq.<span class="hljs-property">status</span> !== <span class="hljs-number">200</span>) &#123;<br>            <span class="hljs-comment">// error 回调</span><br>            <span class="hljs-title function_">error</span>()<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-title function_">sendAjax</span>(&#123;<br>    <span class="hljs-attr">url</span>: <span class="hljs-string">&#x27;your url&#x27;</span>,<br>    <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;post&#x27;</span>,<br>    <span class="hljs-attr">async</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-attr">data</span>: &#123;<br>        <span class="hljs-attr">username</span>: <span class="hljs-string">&#x27;xiong&#x27;</span>,<br>        <span class="hljs-attr">pwd</span>: <span class="hljs-string">&#x27;123&#x27;</span><br>    &#125;,<br>    <span class="hljs-attr">success</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">data</span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data)<br>    &#125;,<br>    <span class="hljs-attr">error</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;发生了错误&#x27;</span>)<br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><h5 id="5-手写深拷贝"><a href="#5-手写深拷贝" class="headerlink" title="5.手写深拷贝"></a>5.手写深拷贝</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//1</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">deepCopy</span>(<span class="hljs-params">obj</span>)&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(obj))<br>&#125;<br><br><span class="hljs-comment">//2</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">deepCopy</span>(<span class="hljs-params">obj</span>)&#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span> obj ==<span class="hljs-string">&#x27;object&#x27;</span>)&#123;<span class="hljs-comment">//判断是否为复杂数据源类型</span><br>        <span class="hljs-keyword">var</span> result = obj.<span class="hljs-property">constructor</span> == <span class="hljs-title class_">Array</span>?[]:&#123;&#125;  <span class="hljs-comment">//数组还是对象</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i <span class="hljs-keyword">in</span> obj)&#123;<br>            result[i]= <span class="hljs-keyword">typeof</span> obj[i] ==<span class="hljs-string">&#x27;object&#x27;</span>? <span class="hljs-title function_">deepCopy</span>(obj[i]):obj[i]<br>        &#125;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-comment">//简单数据类型 </span><br>        <span class="hljs-keyword">var</span> result = obj;<br>    &#125;<br>    <span class="hljs-keyword">return</span> result<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="6-Antd-树组件-点击变成输入框-输入完还能保存"><a href="#6-Antd-树组件-点击变成输入框-输入完还能保存" class="headerlink" title="6. Antd-树组件-点击变成输入框-输入完还能保存"></a>6. Antd-树组件-点击变成输入框-输入完还能保存</h5><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; useState &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">Tree</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;antd&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;./DemoTree.css&#x27;</span><br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">Demo</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>  <span class="hljs-keyword">const</span> [valueobj,setValObj]=<span class="hljs-title function_">useState</span>(&#123;&#125;)<br>  <span class="hljs-keyword">const</span> [id,setId]=<span class="hljs-title function_">useState</span>(&#123;&#125;)<br>  <span class="hljs-keyword">const</span> treeData = [<br>    &#123;<br>      <span class="hljs-attr">title</span>:<span class="hljs-string">&#x27;0-0&#x27;</span>,<br>      <span class="hljs-attr">key</span>: <span class="hljs-string">&#x27;0-0&#x27;</span>,<br>      <span class="hljs-attr">children</span>: [<br>        &#123;<br>          <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;0-0-0&#x27;</span>,<br>          <span class="hljs-attr">key</span>: <span class="hljs-string">&#x27;0-0-0&#x27;</span>,<br>          <span class="hljs-attr">children</span>: [<br>            &#123; <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;0-0-0-0&#x27;</span>, <span class="hljs-attr">key</span>: <span class="hljs-string">&#x27;0-0-0-0&#x27;</span> &#125;,<br>            &#123; <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;0-0-0-1&#x27;</span>, <span class="hljs-attr">key</span>: <span class="hljs-string">&#x27;0-0-0-1&#x27;</span> &#125;,<br>            &#123; <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;0-0-0-2&#x27;</span>, <span class="hljs-attr">key</span>: <span class="hljs-string">&#x27;0-0-0-2&#x27;</span> &#125;,<br>          ],<br>        &#125;,<br>        &#123;<br>          <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;0-0-1&#x27;</span>,<br>          <span class="hljs-attr">key</span>: <span class="hljs-string">&#x27;0-0-1&#x27;</span>,<br>          <span class="hljs-attr">children</span>: [<br>            &#123; <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;0-0-1-0&#x27;</span>, <span class="hljs-attr">key</span>: <span class="hljs-string">&#x27;0-0-1-0&#x27;</span> &#125;,<br>            &#123; <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;0-0-1-1&#x27;</span>, <span class="hljs-attr">key</span>: <span class="hljs-string">&#x27;0-0-1-1&#x27;</span> &#125;,<br>            &#123; <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;0-0-1-2&#x27;</span>, <span class="hljs-attr">key</span>: <span class="hljs-string">&#x27;0-0-1-2&#x27;</span> &#125;,<br>          ],<br>        &#125;,<br>        &#123;<br>          <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;0-0-2&#x27;</span>,<br>          <span class="hljs-attr">key</span>: <span class="hljs-string">&#x27;0-0-2&#x27;</span>,<br>        &#125;,<br>      ],<br>    &#125;,<br>    &#123;<br>      <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;0-1&#x27;</span>,<br>      <span class="hljs-attr">key</span>: <span class="hljs-string">&#x27;0-1&#x27;</span>,<br>      <span class="hljs-attr">children</span>: [<br>        &#123; <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;0-1-0-0&#x27;</span>, <span class="hljs-attr">key</span>: <span class="hljs-string">&#x27;0-1-0-0&#x27;</span> &#125;,<br>        &#123; <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;0-1-0-1&#x27;</span>, <span class="hljs-attr">key</span>: <span class="hljs-string">&#x27;0-1-0-1&#x27;</span> &#125;,<br>        &#123; <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;0-1-0-2&#x27;</span>, <span class="hljs-attr">key</span>: <span class="hljs-string">&#x27;0-1-0-2&#x27;</span> &#125;,<br>      ],<br>    &#125;,<br>    &#123;<br>      <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;0-2&#x27;</span>,<br>      <span class="hljs-attr">key</span>: <span class="hljs-string">&#x27;0-2&#x27;</span>,<br>    &#125;<br>  ];<br>  <span class="hljs-keyword">const</span> [checkedKeys, setCheckedKeys] = <span class="hljs-title function_">useState</span>([<span class="hljs-string">&#x27;0-0-0&#x27;</span>]);<br>  <span class="hljs-keyword">const</span> [selectedKeys, setSelectedKeys] = <span class="hljs-title function_">useState</span>([]);<br><br><br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">onCheck</span> = (<span class="hljs-params">checkedKeysValue</span>) =&gt; &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;onCheck&#x27;</span>, checkedKeysValue);<br>    <span class="hljs-title function_">setCheckedKeys</span>(checkedKeysValue);<br>  &#125;;<br><br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">onSelect</span> = (<span class="hljs-params">selectedKeysValue, info</span>) =&gt; &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;onSelect&#x27;</span>, info.<span class="hljs-property">node</span>.<span class="hljs-property">key</span>,info.<span class="hljs-property">node</span>);<br>    <span class="hljs-title function_">setSelectedKeys</span>(selectedKeysValue);<br>    <span class="hljs-title function_">setId</span>(info.<span class="hljs-property">node</span>)<br>  &#125;;<br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">recursionTreeData</span> = (<span class="hljs-params">treeData</span>) =&gt; &#123;<br>    <span class="hljs-keyword">let</span> nodeData = [];<br>    treeData.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> &#123;<br>        <span class="hljs-keyword">if</span>(item.<span class="hljs-property">children</span>)&#123;<br>            item.<span class="hljs-property">children</span> = <span class="hljs-title function_">recursionTreeData</span>(item.<span class="hljs-property">children</span>);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(id.<span class="hljs-property">key</span>===item.<span class="hljs-property">key</span>)&#123;<br>          item.<span class="hljs-property">isStop</span>=!item.<span class="hljs-property">isStop</span><br>          item.<span class="hljs-property">title</span>=valueobj[item.<span class="hljs-property">key</span>]<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>          <span class="hljs-comment">// console.log(item.title)</span><br>          item.<span class="hljs-property">title</span>=valueobj[item.<span class="hljs-property">key</span>]?valueobj[item.<span class="hljs-property">key</span>]:item.<span class="hljs-property">key</span><br>        &#125;<br>        item.<span class="hljs-property">title</span> = (<br>                <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">                    <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>&#123;item.title&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="language-xml">                    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&#x27;text&#x27;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&#123;item.isStop?&#123;display:</span>&#x27;<span class="hljs-attr">block</span>&#x27;&#125;<span class="hljs-attr">:</span>&#123;<span class="hljs-attr">display:</span>&#x27;<span class="hljs-attr">none</span>&#x27;&#125;&#125;</span></span><br><span class="hljs-tag"><span class="language-xml">                     <span class="hljs-attr">onBlur</span>=<span class="hljs-string">&#123;(ev)</span>=&gt;</span>&#123;</span><br><span class="language-xml">                      valueobj[item.key] = ev.target.value</span><br><span class="language-xml"></span><br><span class="language-xml">                      console.log(valueobj)</span><br><span class="language-xml">                      setValObj(&#123;...valueobj&#125;)</span><br><span class="language-xml"></span><br><span class="language-xml">                       ev.target.style.display=&quot;none&quot;</span><br><span class="language-xml">                     &#125;&#125;/&gt; </span><br><span class="language-xml">                <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>        );<br>        nodeData.<span class="hljs-title function_">push</span>(item);<br>    &#125;);<br>    <span class="hljs-keyword">return</span> nodeData;<br>&#125;;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Tree</span></span></span><br><span class="hljs-tag"><span class="language-xml">      <span class="hljs-attr">checkable</span></span></span><br><span class="hljs-tag"><span class="language-xml">      <span class="hljs-attr">checkedKeys</span>=<span class="hljs-string">&#123;checkedKeys&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">      <span class="hljs-attr">onCheck</span>=<span class="hljs-string">&#123;onCheck&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">      <span class="hljs-attr">onSelect</span>=<span class="hljs-string">&#123;onSelect&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">      <span class="hljs-attr">select7edKeys</span>=<span class="hljs-string">&#123;selectedKeys&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">      <span class="hljs-attr">treeData</span>=<span class="hljs-string">&#123;recursionTreeData(treeData)&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">    /&gt;</span></span><br>  );<br>&#125;;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">Demo</span><br></code></pre></td></tr></table></figure><h5 id="7-场景"><a href="#7-场景" class="headerlink" title="7. 场景"></a>7. 场景</h5><p><strong>经过两个月“选课系统“开发，测试，上线，”选课系统“服务于学校教学的第一站，参与选课学校的学生上午8点集中开测。市场反馈有如下情况：</strong></p><p><strong>1）打开网站出现502</strong></p><p><strong>2）登录进不去系统</strong></p><p><strong>3）提交数据一致反复</strong></p><p><strong>4）有时出现白屏现象</strong></p><p><strong>对于市场反馈情况谈谈你的认识？</strong></p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs tex">首先，502错误，意思是worker进程忙不过来，参与选课的学生上午8点集中开测，在短时间内访问人数过多导致积累了大量的请求，后台服务器忙不过来。解决方法贵公司可以看看CPU和内存满没满，没满就多开一些worker，满了就多加一些机子。也可能是数据库响应缓慢，然后人多了数据库是否能撑住也是一个考虑，多用一些缓存吧。<br><br>第二个问题，结合502报错来看，登录不进系统的原因估计也是短时间内访问人数过多导致服务器崩了。<br><br>提交数据一直反复就相对复杂了，可能出现的使用场景也有很多。<br>比如说我们在提交表单的时候，有可能是网络延迟或内存不足，导致点击一次提交按钮，页面没有反应，结果强迫症就犯了，就疯狂的点提交恨不得把手机屏幕点烂来。也有可能是有些毛孩子，点完提交按钮立马点击刷新页面，或直接返回上层页面想卡bug<br>对于这种情况，我以前工作的做法就是设置蒙版层，不管你怎么点，只要你点提交，我就给你弹出蒙版层。其实这个问题最根本的原因是程序没有进行重复判断，导致数据库重复写入。前端后端都可以添加一个重复判断逻辑，判断后台数据库中是否已经存在当前提交的数据，避免重复添加。但是这种判断只解决了两次表单依次提交的问题，如果不同用户同时提交表单，数据就不一定会正确了。这种问题就是我们常说的并发问题，并发问题的解决方案也有很多，比如：加锁排队处理等。<br><br>最后提到解决白屏问题，我个人在白屏优化实践上尝试过SSR、路由懒加载、还有骨架屏等一些方案，每个方案都个有自己的优劣，需要根据实际的业务场景进行取舍。<br>SSR服务端渲染，这个方案可以让页面直接在服务端渲染，但是不利于前后端分离，开发的效率也比客户端渲染低，同时也加大了服务器的压力。<br>当打包构建应用时，JavaScript 包会变得非常大，影响页面加载。如果我们能把不同路由对应的组件分割成不同的代码块，然后当路由被访问的时候才加载对应组件，这样就会更加高效。<br>使用骨架屏的话，存在与业务深度耦合，页面复杂度变高的问题。当应对需求变更时，骨架屏结构成本，工具实现成本，配置成本，项目的维护成本，都比较高。<br></code></pre></td></tr></table></figure><h4 id="十六-综合题目"><a href="#十六-综合题目" class="headerlink" title="十六. 综合题目"></a>十六. 综合题目</h4><h5 id="1-项目研发流程中作为前端开发一般扮演的啥角色？"><a href="#1-项目研发流程中作为前端开发一般扮演的啥角色？" class="headerlink" title="1. 项目研发流程中作为前端开发一般扮演的啥角色？"></a>1. 项目研发流程中作为前端开发一般扮演的啥角色？</h5><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs tex">前端开发一般扮演着一个“团队核心废物”的角色。为什么这么说，首先在项目的研发中，UI小姐姐总感觉前端开发的页面满足不了她们的设计理念，说你没品味；后端小哥哥觉得前端开发就像只会写写样式的js交互工程师，像极了一个破美工的；测试小哥哥拿着测试报告说：这锅谁他娘的来背一下。还记得当年那个请你根据手机壳的颜色，来实现APP启动的颜色的产品经理嘛？这些对前端开发的误会难道不能折射出前端是团队里最应该学会沟通的人嘛？<br>界面有问题需要和UI沟通,数据有问题需要和后台沟通,功能有问题需要和产品沟通,测试的时候给你提bug你还需要和测试沟通……毕竟前端是最接近用户的人,用户对一个网站,软件最直观的感受是反映到前端；交互体验更是前端项目的核心点。<br>和UI的沟通,在工作中我们不应该是被动的实现UI的设计,而是应该合理化的提出自己的想法,不然日后返工浪费的是双方的时间。比如通用组件的设计，每次页面的提示弹窗设计，再比如你需要做一个图表,用到了echarts,你完全可以让UI基于echarts去设计样式,而不是让她在那里自由发挥，因为你永远不知道设计师的脑子里装了多少创意,这样节省的是两个人的时间,不会出现他做好样式而你实现不了的尴尬。<br>和后端联调接口前，先要对业务需求了解透彻，需要哪些数据，有时候明明后台来处理某个事件很简单,后台非要你来做,这就需要我们对一个需求,一个任务的要有清晰认识了,如果对任务含糊不清,自己都没搞明白,你只能受后台摆布了.最后可能也会因为任务没有完成而备受责难了。有理有据,后台开发人员是不会说什么的,否则,后台会很不耐烦的,甚至骂你的可能都有,本身做后台比较难,尤其在查询数据,取数据,封装数据方面都比较难处理。<br>面对产品经理的需求，前端应该深刻理解需求，毕竟工作性质影响了一个人的思维逻辑，前端能站在一个产品经理的角度去思考每一个需求，便显得尤其重要。不放过每一个细节也很重要。产品经理在设计一个产品的时候，都是从大方向去想问题的，大方向没有错就行了，细节脱离不了大方向。这是他们想的。但是对于程序来说，却万万不能。因为一个细节的逻辑往往决定了整个大方向。<br>举个例子：有一个需求，用户的作品需要提交审核，经过审核才可以让所有人看到。当产品经理交这个需求给你的时候，你能察觉到什么问题了吗？这里面有几个细节：1.用户提交审核后，用户可以不可以再编辑作品；2.作品是否会多次审核；3.需不需要记录审核历史；4.用户作品是否需要有版本的控制，如要产生版本，版本又是如何产生的；5.审核通过后，用户可以不可以再修改作品，若不可以，那么是不是其他人就看不见用户作品等等。<br>我认为前端开发是团队里最应该学会沟通的人，一个好的前端开发模式可以推动整个项目的进步的，尽管有时可能会被误解成废物，但是这何尝不是大家公认的核心呢？<br></code></pre></td></tr></table></figure><h5 id="2-项目中让你印象深刻的问题"><a href="#2-项目中让你印象深刻的问题" class="headerlink" title="2. 项目中让你印象深刻的问题"></a>2. 项目中让你印象深刻的问题</h5><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tex">之前用vue做了一个动态官网项目，后期客户要求seo，百度上之前搜索不到官网地址，后来在项目的入口文件index.html页面加上了，固定的meta标签，加上name名为keywords、description的meta标签。以上做了个简单的seo优化，这个项目有几个官网，但是其中只有一个官网要求seo，也就是在百度能够搜索到，当时为了应急，就写死了，但是，其它的网站也就会受到干扰了，也就是对于一个项目对应几个官网，写死的meta标签做seo是不科学的。<br>如果这个项目要解决seo优化，可以用服务端渲染（ssr），如果项目刚开始就考虑到seo，采用服务端渲染，那么就用服务端渲染就得了。但是一般来讲，项目做到后期才会考虑到seo的问题，这时再去搞服务端渲染，相当于重头写项目，非常耗费人力物力。<br>所以先只考虑在首页加入 meta 标签提供一些元数据，使用简单、具有表意性的 title 以及使用 h5 提供的具有语义化的标签（不要一堆 div），生成对 search engine 友好的 sitemap，使用合理的 html 结构（比如按标题、内容、页脚这样的顺序、或者将重要的内容放在 html 前，其他放在后）<br></code></pre></td></tr></table></figure><h5 id="3-项目开发中有遇到什么挑战没？"><a href="#3-项目开发中有遇到什么挑战没？" class="headerlink" title="3. 项目开发中有遇到什么挑战没？"></a>3. 项目开发中有遇到什么挑战没？</h5><blockquote><p>1.问题描述：1）简单介绍这个项目规模、背景2）什么情况下遇到什么样的问题</p><p>2.你处理这个问题的过程及结果：1）遇到问题你如何思考；2）你如何执行的；3）处理结果如何</p><p>3.通过处理这个问题，你学到了什么或者说通过这个问题，你看到了你们什么不足，后续动作（采用什么样的方式，在以后的项目中避免再出现这类问题）</p></blockquote><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs tex">1.（使用缓存处理）<br>    在做Vue开发移动端APP时，有个页面比较常见，左边是对所有菜谱品类的展示，右边是对对应菜谱的展示，一开始在开发的时候没注意，就直接在mounted()前面使用async,里面使用await调了两边接口后，又通过watch监听了品类索引变化，调了一遍接口。后面发现每次切换品类时，页面都有一闪而过的感觉，发现每次都调了一遍接口，这对性能消耗挺大。所以就尝试的走了Vuex做缓存处理。当时解决这个缓存问题用了一些巧妙的方法，首先缓存的数据，采用的是对象形式，不是数组。这样写起来更快，因为用品类的下标直接做缓存数据的key值，非常好写。不过后面又有点坑，就是我监听的是引用数据类型，不管是vue还是react，引用数据类型发生变化时，页面可能不会更新。后面又在mutation中对vuex中的数据更新时，做了一下深复制，就做好了缓存处理。因为我是根据判断这个对象中有没有数据去调接口的，如果存在，就不调接口。现在做了缓存没错，那如果以后后台的数据发生了变化的话，那我这里也不调接口了，后台数据就没有在页面上实现更新，所以在跳出这个页面的时候还要清下缓存。清缓存要在生命周期结束的时候清，如果碰到了动态组件把APP页面下的 Tap 栏包住的时候， Keep-alive。就不能用 destroyed 生命周期清除，要用 deactivated 生命周期去清除。这样才有始有终，完成缓存处理。<br><br>2.（解决关键词高亮问题----&gt;原理和字符串敏感词替换一样，但是用在关键词高亮上算是一个技术亮点吧）<br>    用户配置一堆关键词，在页面上将这些关键词高亮，也许你会觉得这有什么难度？用正则匹配一下出来高亮不就行了吗？但是，一开始，用户的词不多，我确实使用的是遍历，时间复杂度为n2。后来用户会配置100w量级的词，使用遍历就会使页面卡死崩溃。解决的方法就是：优化性能，高亮分三步，生成字典树，遍历页面文字，取出文字进行匹配。使用字典树代替遍历，整个页面100w量级的词绘制可以实现在1秒以内。<br><br>3.（封装自定义组件）<br>    在一个小程序项目需求中，要求页面头部tab栏切换的同时，对应tab栏品类的页面也要展示出来。你可能会觉得这个需求用个taroUI组件库中的tabs标签页组件不就可以完成吗？但是这个需求想满足用户的沉浸式体验，切换页面时需要有独特丝滑的专场特效。所以当时面临的问题就是，使用的UI库的组件默认样式生硬，满足不了需求。我当时是对小程序原生swiper组件进行了二次封装，主要实现了几点自定义需求：头部Tab栏品类样式使用flex动态布局，实现品类数量可变；使用 slot 插槽来动态渲染 Tab区块中的内容，配合原生swiper组件使用定义插槽；小程序原生组件&lt;swiper&gt;是有默认高度的，必须手动设置其高度，这里使用wx.getSystemInfo来动态获取屏幕尺寸。自己封装组件，踩了不少坑，但从中我学习到了：使用小程序的原生组件，并修改其默认的样式；学会使用 slot 插槽，实现组件内容的差异化；学会了使用小程序原生 api 获取手机信息，用 js 改变组件样式等等<br><br>4.（遇到了难用的轮子）<br>    在写XXX小程序项目中需要实现音频播放的功能，官方已经推荐使用新的API了，然而这个小程序官方文档文档写得并不好，很多时候我们会遇到一些需求，或者改变而这些需求文档里又写得非常模糊，这就比较头疼了。小程序官方文档更新十分频繁，坑非常多。所以很多时候，我就要去不断地从文档的字里行间猜测，并结合源码一步一步地去跟踪，去尝试解决这个音频播放问题。但有时候确实超出了我的能力范围，那么我就会把我的问题提炼成一个小demo，到知乎、segmentfault思否去问，或者提问一些同样用这个轮子的作者，最终找到了新API的使用规范。<br></code></pre></td></tr></table></figure><p><strong>注意</strong>：这个时候你就要说你最擅长的，一定是你最擅长的点，告诉他这个问题怎么解决，一定是你最懂的，而且经得起推敲的解决方案。<strong>你要准备的不仅仅是你的项目中有哪些难点，更重要的是和这个难点相关的知识都要准备充分。</strong>所以，<strong>你的答案并不是这个项目中最难的点，而是一个最能让你回答好整套相关问题的难点</strong>。</p><h5 id="4-谈谈对前后端分离的理解。"><a href="#4-谈谈对前后端分离的理解。" class="headerlink" title="4. 谈谈对前后端分离的理解。"></a>4. 谈谈对前后端分离的理解。</h5><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tex">在我看来，前后端分离给开发工作带来了很多好处，在以前，没有这个概念的时候，一种经典的设计模式MVC模式。前端开发很不盛行，几乎很多后端程序员就兼顾了前端开发工作，前后端耦合性极强，在jsp时代，前端写好的页面最后要和后端实现交互，需要程序员手动的更改代码，这是很大的一个工作量，这种事情交给前端还是后端？谁都不愿意做吧！<br>前后端分离过后，通过预先定义好接口规范，前端后端独立部署独立开发，后端只需要提供接口供调用即可，解耦效果是真的强，这对工作效率的提升是巨大的，对于后期的维护只需要前后端单独完成即可！<br>   <br></code></pre></td></tr></table></figure><h5 id="5-项目负责什么"><a href="#5-项目负责什么" class="headerlink" title="5. 项目负责什么"></a>5. 项目负责什么</h5><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs tex">1. 这个项目的列表展示与详情页是我负责的。我对于后端传递的数据进行了怎样的处理，在异步请求中选择了一定的异步分割处理数据，拆分一次性阻塞主线程的时间，可以减少用户的等待，页面滚动时选择节流，减少无效的axios请求等等，对自己模块所负责的内容，进行梳理。<br><br>2. 这个项目的登录，注册，模块是我负责的。我对不同角色的鉴权是怎么实现的。。。<br><br>3. 这个项目的表单提交页是我负责的。。。。用了什么UI组件。。。<br></code></pre></td></tr></table></figure><h5 id="6-流程-amp-规范"><a href="#6-流程-amp-规范" class="headerlink" title="6. 流程&amp;规范"></a>6. 流程&amp;规范</h5><h6 id="1-对接UI与交互"><a href="#1-对接UI与交互" class="headerlink" title="1) 对接UI与交互"></a>1) 对接UI与交互</h6><blockquote><p><img src="clipboard.png" alt="image"></p></blockquote><p><strong>(1)原型</strong></p><ul><li><p>axure （发音：Ack-sure）<br><code>生成的html代码,页面代码杂乱，代码冗余量较大，不利于后期的优化</code></p></li><li><p>墨刀<br><code>https://free.modao.cc/app/ltnSwMXEFqjon7QtRssBgKkPXZmL3os#screen=s6A4B80F6FE1540952810987</code></p></li><li><p>蓝湖</p><p><code>https://lanhuapp.com/</code></p></li></ul><p><strong>(2)标注图</strong> </p><blockquote><p><img src="clipboard-1586613161283.png" alt="image"></p></blockquote><p><strong>(3)谁来切图</strong></p><p><code>UI? 前端？后端？</code></p><h6 id="2-对接后端"><a href="#2-对接后端" class="headerlink" title="2) 对接后端"></a>2) 对接后端</h6><p><strong>(1) 亲嘴对接</strong></p><p><strong>(2) 接口文档</strong></p><blockquote><p><img src="clipboard-1586613164273.png" alt="image"></p></blockquote><h6 id="3-多环境"><a href="#3-多环境" class="headerlink" title="3)多环境"></a>3)多环境</h6><table><thead><tr><th>英文缩写</th><th>英文</th><th>中文</th></tr></thead><tbody><tr><td>DEV</td><td>development</td><td>开发</td></tr><tr><td>SIT</td><td>System Integrate Test</td><td>系统整合测试（内测）</td></tr><tr><td>UAT</td><td>User Acceptance Test</td><td>用户验收测试</td></tr><tr><td>PET</td><td>Performance Evaluation Test</td><td>性能评估测试（压测）</td></tr><tr><td>PROD</td><td>production</td><td>产品&#x2F;正式&#x2F;生产</td></tr></tbody></table><blockquote><p><img src="%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/clipboard-1586613167025.png" alt="image"><br><img src="clipboard-1586613169073.png" alt="image"><br><strong>保证pre的版本和pro环境的版本一致</strong>，如果pro环境出现bug,我们只需要在pre环境fix bug,从1.0.0 &#x3D;&#x3D;&gt;1.0.0.1 ,不会影响开发进度以及测试进度(不用单独创建分支修改)</p></blockquote><h5 id="7-工作中能够持续学习么？"><a href="#7-工作中能够持续学习么？" class="headerlink" title="7. 工作中能够持续学习么？"></a>7. 工作中能够持续学习么？</h5><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tex">工作中当然可以持续学习，我认为每次对自己的总结就是很好学习机会，可以是工作上的总结，生活上的总结，某一件小事的总结都可以学习。<br>总结自己掌握的前端知识体系，总结知识体系的过程是一个查缺补漏的过程。遇到没掌握或者了解不深的知识点，务必去了解、搞清楚，否则就不算掌握。还可以，总结自己做过的项目中有哪些难点，或者技术架构。涉及到的所有技术点都可以挖一下，看看有没有某个点是自己描述不清的。<br>有空闲时间，会去leetcode社区上找点算法题，可以去bestofjs社区看看社区又出了什么比较前沿的技术，框架 。还可以去Github上看看别人写的代码，或者翻翻Vue，React源码研究研究。<br></code></pre></td></tr></table></figure><h5 id="8-为什么辞职"><a href="#8-为什么辞职" class="headerlink" title="8. 为什么辞职"></a>8. 为什么辞职</h5><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tex">在上一家公司，我也想过要早些辞职，但是考虑某个未完成的重要项目、或是继任者短期内还不能胜任角色所以晚了一些。主要离职的原因是在上一家公司待的时间比较长了，公司的各种业务已经非常熟练了，感觉工作成了流水线般的生产工具，技术达到了一定的瓶颈，我觉得我应该跳出舒适圈去接触更多的新技术与新的业务从而扩展自己的技术广度。我觉得贵公司的技术要求与我非常符合，有一些我自己非常熟练或精通的技术，更重要的事有一些我之前只是自己业余时间研究过但一直没有几乎用于实战的技术。我相信贵公司的岗位对我虽然有一定的挑战信但是会给我带来更多的提升机会。同时我上一家公司中用的React加koa框架做的项目也有很多设计上的亮点，我也可以将上一家优秀完整的项目开发流程与管理经验，项目设计思路与贵公司分享。完成互利互惠共同成长。<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>常见问题</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>移动端适配</title>
    <link href="/2024/03/06/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%80%82%E9%85%8D/"/>
    <url>/2024/03/06/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%80%82%E9%85%8D/</url>
    
    <content type="html"><![CDATA[<h1 id="前端开发移动端适配"><a href="#前端开发移动端适配" class="headerlink" title="前端开发移动端适配"></a>前端开发移动端适配</h1><h2 id="1-区分css逻辑像素（px）、物理像素（pt）、设备像素比"><a href="#1-区分css逻辑像素（px）、物理像素（pt）、设备像素比" class="headerlink" title="1.区分css逻辑像素（px）、物理像素（pt）、设备像素比"></a>1.区分css逻辑像素（px）、物理像素（pt）、设备像素比</h2><table><thead><tr><th>设备名称</th><th>css逻辑像素px</th><th>物理像素pt</th><th>设备像素比&#x3D;逻辑像素&#x2F;物理像素</th></tr></thead><tbody><tr><td>iphone4</td><td>320 x 480</td><td>640 x 960</td><td>1&#x2F;2</td></tr><tr><td>iphone6</td><td>375 x 667</td><td>750 x 1334</td><td>1&#x2F;2</td></tr><tr><td>iphone12pro</td><td>390 x 844</td><td></td><td></td></tr></tbody></table><ul><li><p>CSS 像素（逻辑像素）是 Web 编程的概念，指的是 CSS 样式代码中使用的逻辑像素。比如 iPhone 6 的 CSS 像素数为 375 x 667px。</p><p>在同样一个设备上，每1个CSS像素所代表的物理像素是<em><strong>可以变化</strong></em>的(即CSS像素的第一方面的相对性);</p><p>在不同的设备之间，每1个CSS像素所代表的物理像素是<em><strong>可以变化</strong></em>的(即CSS像素的第二方面的相对性);</p></li><li><p>pt（point，磅）：是一个物理长度单位，指的是72分之一英寸。设备像素（物理像素），顾名思义，显示屏是由一个个物理像素点组成的，通过控制每个像素点的颜色，使屏幕显示出不同的图像，屏幕从工厂出来那天起，它上面的物理像素点就<em><strong>固定不变</strong></em>了，单位pt。pt在css单位中属于真正的绝对单位，1pt &#x3D; 1&#x2F;72(inch),inch及英寸，而1英寸等于2.54厘米。</p></li></ul><p>注意！！！！</p><p><strong>在前端开发中，要首先了解清楚设计稿是按照逻辑像素来设计的还是按照物理像素来设计的。</strong></p><br><h2 id="2-区分-px-、-em-、-rem-、-vh-、-vw"><a href="#2-区分-px-、-em-、-rem-、-vh-、-vw" class="headerlink" title="2.区分 px 、 em 、 rem 、 vh 、 vw"></a>2.区分 px 、 em 、 rem 、 vh 、 vw</h2><table><thead><tr><th>名称</th><th>备注</th></tr></thead><tbody><tr><td>px</td><td>css中的像素单位，也是逻辑像素。电脑端常直接用px做单位</td></tr><tr><td>em</td><td>em相对单位，相对父级fontSize大小，很少用，因为都是相对比自己的父级，整个页面很难统一</td></tr><tr><td>rem</td><td>rem相对单位，相对于根节点fontSize大小，即相对于html{fontSize：**}，常用于移动端适配。</td></tr><tr><td>vh</td><td>视口高度相对单位，1vh &#x3D; 视口高度&#x2F;100</td></tr><tr><td>vw</td><td>视口度相对单位，1vh &#x3D; 视口宽度&#x2F;100</td></tr></tbody></table><br><h2 id="3-移动端利用rem做等比缩放"><a href="#3-移动端利用rem做等比缩放" class="headerlink" title="3.移动端利用rem做等比缩放"></a>3.移动端利用rem做等比缩放</h2><p>为了方便计算，常设置根节点字体大小如下公式：</p><p><code>根节点字体大小 = （视口宽度/设计稿宽度）* 100 + &quot;px&quot;</code>，此时假设设备宽度逻辑像素为375px，则设为3.75rem即可。</p><p><code>document.documentElement.style.fontSize = (document.documentElement.clientWidth / 375) * 100 + &quot;px&quot;;</code> 假设为iphone6设计稿</p><p>例子：</p><p>1.假设设计稿为css逻辑像素</p><img src="image-20240306210557970.png" alt="image-20240306210557970" style="zoom:50%;" /><p>假设上图为设计稿更加iphone6尺寸设计得来，</p><p>设计稿单位为css逻辑像素。则：<br>document.documentElement.style.fontSize &#x3D; (document.documentElement.clientWidth &#x2F; 375) * 100 + “px”</p><p>此时上面三块分别设置宽度为1rem、2rem、0.75rem即可自适配。</p><br><img src="image-20240306211028215.png" alt="image-20240306211028215" style="zoom:50%;" /><p>如上图，设计稿根据物理像素设定。则</p><p>document.documentElement.style.fontSize &#x3D; (document.documentElement.clientWidth &#x2F; 750) * 100 + “px”</p><p>此时上面三块分别设置宽度为2rem、4rem、1.5rem即可自适配。</p><p>如下如所示，任何设备都是按比例缩放</p><p><img src="image-20240306211630212.png" alt="image-20240306211630212"></p>]]></content>
    
    
    <categories>
      
      <category>css</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Vue组件传值</title>
    <link href="/2024/03/06/Vue%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%80%BC/"/>
    <url>/2024/03/06/Vue%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%80%BC/</url>
    
    <content type="html"><![CDATA[<h1 id="VUE组件间传值"><a href="#VUE组件间传值" class="headerlink" title="VUE组件间传值"></a>VUE组件间传值</h1><h2 id="1-父传子（靠属性）"><a href="#1-父传子（靠属性）" class="headerlink" title="1.父传子（靠属性）"></a>1.父传子（靠属性）</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//vue2</span><br><br><span class="hljs-comment">//父组件</span><br>&lt;template&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>这是父组件<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">ChildComponents</span> <span class="hljs-attr">:title</span>=<span class="hljs-string">&quot;fatherDate&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">ChildComponents</span>&gt;</span>  //父组件通过属性传值</span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>&lt;/template&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">import</span> &#123; ref, reactive &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue&quot;</span>;</span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">import</span> <span class="hljs-title class_">ChildComponents</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./ChildComponents.vue&quot;</span>;</span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-attr">components</span>: &#123; <span class="hljs-title class_">ChildComponents</span> &#125;,</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">return</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-attr">fatherDate</span>: <span class="hljs-string">&quot;111&quot;</span>,</span></span><br><span class="language-javascript"><span class="language-xml">    &#125;;</span></span><br><span class="language-javascript"><span class="language-xml">  &#125;</span></span><br><span class="language-javascript"><span class="language-xml">&#125;;</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><br><span class="hljs-comment">//子组件</span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">    这是子组件</span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>接收的父组件传过来的值&#123;&#123; this.title &#125;&#125; <span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>   </span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">import</span> &#123; ref, reactive &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue&quot;</span>;</span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-attr">props</span>: &#123;   <span class="hljs-comment">//子组件通过props接受父组件传过来的值</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-attr">title</span>: &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-attr">type</span>: <span class="hljs-title class_">String</span>,</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-attr">default</span>: <span class="hljs-string">&quot;&quot;</span>,</span></span><br><span class="language-javascript"><span class="language-xml">    &#125;,</span></span><br><span class="language-javascript"><span class="language-xml">  &#125;</span></span><br><span class="language-javascript"><span class="language-xml">&#125;;</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">scoped</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;scss&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span></span><br><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//vue3--setup 是 Vue3 中引入的一个新的选项，详见***</span><br><br><span class="hljs-comment">//父组件</span><br>&lt;template&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">ChildComponents</span> <span class="hljs-attr">foo</span>=<span class="hljs-string">&quot;这是title1&quot;</span> /&gt;</span>  //属性传值</span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>&lt;/template&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">import</span> &#123; ref, reactive &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue&quot;</span>;</span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">import</span> <span class="hljs-title class_">ChildComponents</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./ChildComponents.vue&quot;</span>;</span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;&quot;</span>,</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-attr">components</span>: &#123;</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-title class_">ChildComponents</span>,  <span class="hljs-comment">//局部注册</span></span></span><br><span class="language-javascript"><span class="language-xml">  &#125;,</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">const</span> data = <span class="hljs-title function_">reactive</span>(&#123;&#125;);</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">return</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      data</span></span><br><span class="language-javascript"><span class="language-xml">    &#125;;</span></span><br><span class="language-javascript"><span class="language-xml">  &#125;,</span></span><br><span class="language-javascript"><span class="language-xml">&#125;;</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><br><span class="hljs-comment">//子组件</span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml">  &#123;&#123; foo &#125;&#125;</span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-attr">props</span>: &#123;    <span class="hljs-comment">//props接受值，这种写法和vue2差不多</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-attr">foo</span>: &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-attr">type</span>: <span class="hljs-title class_">String</span>,</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-attr">default</span>: <span class="hljs-string">&quot;&quot;</span>,</span></span><br><span class="language-javascript"><span class="language-xml">    &#125;,</span></span><br><span class="language-javascript"><span class="language-xml">  &#125;,</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>) &#123;&#125;,</span></span><br><span class="language-javascript"><span class="language-xml">&#125;;</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//vue3--setup内置写法</span><br><br><span class="hljs-comment">//子组件</span><br>&lt;script setup&gt;<br><span class="hljs-keyword">const</span> props = <span class="hljs-title function_">defineProps</span>(&#123;   <span class="hljs-comment">//利用defineProps来接受props</span><br>  <span class="hljs-attr">foo</span>: &#123;<br>    <span class="hljs-attr">type</span>: <span class="hljs-title class_">String</span>,<br>    <span class="hljs-attr">default</span>: <span class="hljs-string">&quot;&quot;</span>,<br>  &#125;,<br>&#125;);<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><h2 id="2-子传父（靠事件）"><a href="#2-子传父（靠事件）" class="headerlink" title="2.子传父（靠事件）"></a>2.子传父（靠事件）</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//vue2</span><br><br><span class="hljs-comment">//子组件</span><br>&lt;template&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">    子组件--</span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;handleClick1&quot;</span>&gt;</span>子组件要传值到父组件了<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>&lt;/template&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">import</span> &#123; ref, reactive &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue&quot;</span>;</span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;&quot;</span>,</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-attr">components</span>: &#123;&#125;,</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-attr">props</span>: &#123;</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-attr">title</span>: &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-attr">type</span>: <span class="hljs-title class_">String</span>,</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-attr">default</span>: <span class="hljs-string">&quot;&quot;</span>,</span></span><br><span class="language-javascript"><span class="language-xml">    &#125;,</span></span><br><span class="language-javascript"><span class="language-xml">  &#125;,</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">return</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-attr">sonData</span>: <span class="hljs-number">222</span>,</span></span><br><span class="language-javascript"><span class="language-xml">    &#125;;</span></span><br><span class="language-javascript"><span class="language-xml">  &#125;,</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-attr">methods</span>: &#123;</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-title function_">handleClick1</span>(<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-variable language_">this</span>.$emit(<span class="hljs-string">&quot;fatherEvent&quot;</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">sonData</span>);   <span class="hljs-comment">//通过emit创建父组件事件名，和需要传递的数据，注意是用this.$emit</span></span></span><br><span class="language-javascript"><span class="language-xml">    &#125;,</span></span><br><span class="language-javascript"><span class="language-xml">  &#125;,</span></span><br><span class="language-javascript"><span class="language-xml">&#125;;</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><br><span class="hljs-comment">//父组件</span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>这是父组件--子组件传过来的值为&#123;&#123; this.fatherInfo &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">ChildComponents</span> @<span class="hljs-attr">fatherEvent</span>=<span class="hljs-string">&quot;getMsg&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">ChildComponents</span>&gt;</span>   //通过执行事件函数，在函数中接受子组件传递的数据</span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">import</span> &#123; ref, reactive &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue&quot;</span>;</span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">import</span> <span class="hljs-title class_">ChildComponents</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./ChildComponents.vue&quot;</span>;</span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;&quot;</span>,</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-attr">components</span>: &#123; <span class="hljs-title class_">ChildComponents</span> &#125;,</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">return</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-attr">fatherInfo</span>: <span class="hljs-string">&quot;&quot;</span>,</span></span><br><span class="language-javascript"><span class="language-xml">    &#125;;</span></span><br><span class="language-javascript"><span class="language-xml">  &#125;,</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-attr">computed</span>: &#123;&#125;,</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-attr">methods</span>: &#123;</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-title function_">getMsg</span>(<span class="hljs-params">value</span>) &#123;     <span class="hljs-comment">//此时value即为子组件传递过来的值</span></span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value);</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-variable language_">this</span>.<span class="hljs-property">fatherInfo</span> = value;</span></span><br><span class="language-javascript"><span class="language-xml">    &#125;,</span></span><br><span class="language-javascript"><span class="language-xml">  &#125;,</span></span><br><span class="language-javascript"><span class="language-xml">&#125;;</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//vue3在选项api中，使用方法和vue2一样，this.$emit</span><br><br><span class="hljs-comment">//在组合式api中，不能使用this.$emit，可以使用setup（props，context）的第二个参数context来访问emit方法，具体又分为两种</span><br><span class="hljs-comment">//方法一：直接通过context访问emit</span><br>&lt;script&gt;<br>...<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  ...<br>  <span class="hljs-title function_">setup</span>(<span class="hljs-params">props, context</span>) &#123;<br>    <span class="hljs-keyword">const</span> data = <span class="hljs-title function_">reactive</span>(&#123;<br>      <span class="hljs-attr">info1</span>: <span class="hljs-number">1111</span>,<br>    &#125;);<br>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleclick</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>      context.<span class="hljs-title function_">emit</span>(<span class="hljs-string">&quot;fatherEvent&quot;</span>, data.<span class="hljs-property">info1</span>);  <span class="hljs-comment">//通过context访问emit</span><br>    &#125;;<br>    ...<br>  &#125;,<br>&#125;;<br>&lt;/script&gt;<br><br><span class="hljs-comment">//方法二：结构出emit方法</span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">import</span> &#123; reactive &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue&quot;</span>;</span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">  ...</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-title function_">setup</span>(<span class="hljs-params">props, &#123; emit &#125;</span>) &#123;   <span class="hljs-comment">//利用解构，将emit方法解构出来</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">const</span> data = <span class="hljs-title function_">reactive</span>(&#123;</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-attr">info1</span>: <span class="hljs-number">1111</span>,</span></span><br><span class="language-javascript"><span class="language-xml">    &#125;);</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleclick</span> = (<span class="hljs-params"></span>) =&gt; &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-title function_">emit</span>(<span class="hljs-string">&quot;fatherEvent&quot;</span>, data.<span class="hljs-property">info1</span>);</span></span><br><span class="language-javascript"><span class="language-xml">    &#125;;</span></span><br><span class="language-javascript"><span class="language-xml">    ...</span></span><br><span class="language-javascript"><span class="language-xml">  &#125;,</span></span><br><span class="language-javascript"><span class="language-xml">&#125;;</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><br><span class="hljs-comment">//在内置setup中，通过defineEmits([&#x27;eventName&#x27;])来创建emit方法</span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">const</span> emit = <span class="hljs-title function_">defineEmits</span>([<span class="hljs-string">&quot;fatherEvent&quot;</span>]);   <span class="hljs-comment">//defineEmits</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleclick</span> = (<span class="hljs-params"></span>) =&gt; &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-title function_">emit</span>(<span class="hljs-string">&quot;fatherEvent&quot;</span>, <span class="hljs-number">111</span>);</span></span><br><span class="language-javascript"><span class="language-xml">    &#125;;</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h1 id="3-兄弟组件之间通信（中间人模式：子传父，父传子）"><a href="#3-兄弟组件之间通信（中间人模式：子传父，父传子）" class="headerlink" title="3.兄弟组件之间通信（中间人模式：子传父，父传子）"></a>3.兄弟组件之间通信（中间人模式：子传父，父传子）</h1><p>中间人模式就是通过多次使用子传父、父传子实现兄弟组件之间的通信。</p><h1 id="4-refs"><a href="#4-refs" class="headerlink" title="4.refs"></a>4.refs</h1><p>在使用选项式API时，我们可以通过this.$refs.name的方式获取指定元素或者组件，但是组合式API中就无法使用哪种方式获取。如果我们想要通过ref的方式获取组件或者元素，需要定义一个同名的Ref对象，在组件挂载后就可以访问了</p><p>this.$refs.name方法（vue2，vue3选项式）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//vue2</span><br>&lt;template&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">Son</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;son&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Son</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>&lt;/template&gt;<br><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Son</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./son.vue&#x27;</span></span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span>&#123;</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;father&#x27;</span>,</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-attr">components</span>:&#123;</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-title class_">Son</span></span></span><br><span class="language-javascript"><span class="language-xml">  &#125;,</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-title function_">mounted</span>(<span class="hljs-params"></span>)&#123;</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">$refs</span>.<span class="hljs-property">son</span>) <span class="hljs-comment">/*组件实例*/</span></span></span><br><span class="language-javascript"><span class="language-xml">  &#125;</span></span><br><span class="language-javascript"><span class="language-xml">&#125;</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>组合式api，需要定义一个同名的Ref对象，在组件挂载后就可以访问了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//父组件</span><br>&lt;template&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;parent list-group&quot;</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;list-group-item&quot;</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;i in childRefs?.list&quot;</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">&quot;i&quot;</span>&gt;</span></span><br><span class="language-xml">      &#123;&#123; i &#125;&#125;</span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span><br>  &lt;!-- 子组件 ref的值与&lt;script&gt;中的保持一致 --&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">child-components</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;childRefs&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">child-components</span>&gt;</span></span><br>  &lt;!-- 父组件 --&gt;<br>&lt;/template&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">import</span> &#123; ref &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">import</span> <span class="hljs-title class_">ChildComponents</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./child.vue&#x27;</span></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">const</span> childRefs = <span class="hljs-title function_">ref</span>(<span class="hljs-literal">null</span>)  <span class="hljs-comment">//与此一致</span></span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><br><span class="hljs-comment">//子组件</span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;child-wrap input-group&quot;</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">input</span></span></span><br><span class="hljs-tag"><span class="language-xml">      <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;value&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">      <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">      <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;form-control&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">      <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;请输入&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">    /&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;input-group-append&quot;</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;handleAdd&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;btn btn-primary&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span>&gt;</span></span><br><span class="language-xml">        添加</span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">import</span> &#123; ref, defineExpose &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">const</span> list = <span class="hljs-title function_">ref</span>([<span class="hljs-string">&#x27;JavaScript&#x27;</span>, <span class="hljs-string">&#x27;HTML&#x27;</span>, <span class="hljs-string">&#x27;CSS&#x27;</span>])</span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">const</span> value = <span class="hljs-title function_">ref</span>(<span class="hljs-string">&#x27;&#x27;</span>)</span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-comment">// add 触发后的事件处理函数</span></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">const</span> <span class="hljs-title function_">handleAdd</span> = (<span class="hljs-params"></span>) =&gt; &#123;</span></span><br><span class="language-javascript"><span class="language-xml">  list.<span class="hljs-property">value</span>.<span class="hljs-title function_">push</span>(value.<span class="hljs-property">value</span>)</span></span><br><span class="language-javascript"><span class="language-xml">  value.<span class="hljs-property">value</span> = <span class="hljs-string">&#x27;&#x27;</span></span></span><br><span class="language-javascript"><span class="language-xml">&#125;</span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-title function_">defineExpose</span>(&#123; list &#125;)</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h2 id="5-provide-x2F-inject-提供-x2F-注入"><a href="#5-provide-x2F-inject-提供-x2F-注入" class="headerlink" title="5.provide&#x2F;inject(提供&#x2F;注入)"></a>5.provide&#x2F;inject(提供&#x2F;注入)</h2><ul><li>父组件使用 provide 注入数据</li><li>子组件使用 inject 使用数据</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/*父组件*/</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span>&#123;<br> <span class="hljs-attr">provide</span>: &#123;<br>   <span class="hljs-keyword">return</span>&#123;<br>     <span class="hljs-attr">provideName</span>: <span class="hljs-string">&#x27;父组件信息&#x27;</span><br>   &#125;<br> &#125;<br>&#125;<br><br><span class="hljs-comment">/*子组件*/</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span>&#123;<br>  <span class="hljs-attr">inject</span>: [<span class="hljs-string">&#x27;provideName&#x27;</span>],<br>  created () &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">provideName</span>) <span class="hljs-comment">// =&gt; &quot;父组件信息&quot;</span><br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>这个方法的好处</p><ul><li>父组件不需要知道哪个组件使用它提供出去的数据</li><li>子附件不需要知道这个数据从哪里来</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//vue3中用法</span><br><span class="hljs-comment">//父组件</span><br>&lt;template&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Test</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Test</span>&gt;</span></span><br>&lt;/template&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">import</span> &#123; provide &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue&quot;</span></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Test</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./index.vue&#x27;</span></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-attr">components</span>: &#123;<span class="hljs-title class_">Test</span>&#125;,</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-title function_">provide</span>(<span class="hljs-string">&#x27;fromFather&#x27;</span>, <span class="hljs-string">&#x27;父组件传递的信息&#x27;</span>)</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">return</span> &#123;&#125;</span></span><br><span class="language-javascript"><span class="language-xml">  &#125;</span></span><br><span class="language-javascript"><span class="language-xml">&#125;</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><br><span class="hljs-comment">//子组件</span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">slot</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>我是父组件注入的数据：&#123;&#123;fatherData&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">import</span> &#123; inject &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue&quot;</span></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">//我来去父组件注入的数据</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">let</span> fatherData = <span class="hljs-title function_">inject</span>(<span class="hljs-string">&#x27;fromFather&#x27;</span>)</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">return</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      fatherData</span></span><br><span class="language-javascript"><span class="language-xml">    &#125;</span></span><br><span class="language-javascript"><span class="language-xml">  &#125;</span></span><br><span class="language-javascript"><span class="language-xml">&#125;</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><br></code></pre></td></tr></table></figure><h2 id="6-vuex"><a href="#6-vuex" class="headerlink" title="6.vuex"></a>6.vuex</h2><p>vuex相当于一个公共管理的仓库</p><p>vuex详见官网<a href="https://vuex.vuejs.org/zh/guide/">https://vuex.vuejs.org/zh/guide/</a></p><p>vuex的实现步骤：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//store index.js</span><br><span class="hljs-comment">//主要有以下几个  state，mutations，getters，actions，modules</span><br><br><span class="hljs-keyword">import</span> &#123; createStore &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vuex&quot;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">createStore</span>(&#123;<br>  <span class="hljs-attr">state</span>: &#123;<br>    <span class="hljs-attr">isLogin</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-comment">//搜索关键词</span><br>    <span class="hljs-attr">searchKeywords</span>: <span class="hljs-string">&quot;&quot;</span>,<br>    <span class="hljs-comment">//搜索返回结果</span><br>    <span class="hljs-attr">searchResult</span>: &#123;<br>      <span class="hljs-attr">title</span>: <span class="hljs-string">&quot;&quot;</span>,<br>      <span class="hljs-attr">pagenum</span>: <span class="hljs-number">0</span>,<br>      <span class="hljs-attr">grade</span>: <span class="hljs-number">0</span>,<br>      <span class="hljs-attr">abstract</span>: <span class="hljs-string">&quot;&quot;</span>,<br>    &#125;,<br>    <span class="hljs-comment">//详情数据</span><br>    <span class="hljs-attr">listdetail</span>: &#123;<br>      <span class="hljs-attr">title</span>: <span class="hljs-string">&quot;&quot;</span>,<br>      <span class="hljs-attr">pdfurl</span>: <span class="hljs-string">&quot;&quot;</span>,<br>      <span class="hljs-attr">keywords</span>: <span class="hljs-string">&quot;&quot;</span>,<br>      <span class="hljs-attr">searchnums</span>: <span class="hljs-number">0</span>,<br>      <span class="hljs-attr">resultlist</span>: &#123;<br>        <span class="hljs-attr">source</span>: <span class="hljs-string">&quot;&quot;</span>,<br>        <span class="hljs-attr">abstract</span>: <span class="hljs-string">&quot;&quot;</span>,<br>      &#125;,<br>    &#125;,<br>  &#125;,<br>  <span class="hljs-attr">getters</span>: &#123;&#125;,<br>  <span class="hljs-attr">mutations</span>: &#123;<br>    <span class="hljs-title class_">ChangeIslogin</span>(state) &#123;<br>      state.<span class="hljs-property">isLogin</span> = !state.<span class="hljs-property">isLogin</span>;<br>    &#125;,<br>    <span class="hljs-comment">//搜索的关键词</span><br>    <span class="hljs-title class_">Searchinfo</span>(state, info) &#123;<br>      state.<span class="hljs-property">searchKeywords</span> = info;<br>    &#125;,<br>    <span class="hljs-comment">// 查看详情页面的文章标题</span><br>    <span class="hljs-title function_">previewinfo</span>(<span class="hljs-params">state, info</span>) &#123;<br>      state.<span class="hljs-property">listdetail</span>.<span class="hljs-property">title</span> = info;<br>    &#125;,<br>  &#125;,<br>  <span class="hljs-attr">actions</span>: &#123;&#125;,<br>  <span class="hljs-attr">modules</span>: &#123;&#125;,<br>&#125;);<br><br><br><span class="hljs-comment">//获取store中的值  this.$store.state.***(vue2 和选项是api)  或者store.state（组合式api）</span><br><span class="hljs-comment">//设置store的值，dispatch分发mutation（同步），action（异步）</span><br></code></pre></td></tr></table></figure><h2 id="7-bus事件总线（vue2有，vue3没有）"><a href="#7-bus事件总线（vue2有，vue3没有）" class="headerlink" title="7.bus事件总线（vue2有，vue3没有）"></a>7.bus事件总线（vue2有，vue3没有）</h2><ul><li><p>创建一个公共的bus.js文件</p></li><li><p>暴露出Vue实例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Vue</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue&quot;</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>()<br></code></pre></td></tr></table></figure></li></ul><p><em>在需要组件通信的组件中都引入该文件</em></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;template&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>我是通信组件A<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">el-button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;changeName&quot;</span>&gt;</span>修改姓名<span class="hljs-tag">&lt;/<span class="hljs-name">el-button</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>&lt;/template<br><br>&lt;script&gt;<br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">EventBus</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;../bus.js&quot;</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span>&#123;<br>  <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">return</span>&#123;&#125;<br>  &#125;,<br>  <span class="hljs-attr">methods</span>:&#123;<br>    <span class="hljs-title function_">changeName</span>(<span class="hljs-params"></span>)&#123;<br>      <span class="hljs-title class_">EventBus</span>.$emit(<span class="hljs-string">&quot;editName&quot;</span>, <span class="hljs-string">&#x27;111！&#x27;</span>)<br>    &#125;<br>  &#125;<br>&#125;<br>&lt;/script&gt;<br><br></code></pre></td></tr></table></figure><p><em>另外一个组件中同样引入bus.js文件，通过$on监听事件回调</em></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;template&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>我是通信组件B<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>&lt;/template<br><br>&lt;script&gt;<br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">EventBus</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;../bus.js&quot;</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span>&#123;<br>  <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">return</span>&#123;&#125;<br>  &#125;,<br>  <span class="hljs-attr">mounted</span>:&#123;<br>    <span class="hljs-title class_">EventBus</span>.$on(<span class="hljs-string">&#x27;editName&#x27;</span>,<span class="hljs-function">(<span class="hljs-params">name</span>)=&gt;</span>&#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(name) <span class="hljs-comment">// =&gt; 贩卖前端仔，点点关注！</span><br>    &#125;)<br>  &#125;<br>&#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><h2 id="8-v-model"><a href="#8-v-model" class="headerlink" title="8.v-model"></a>8.v-model</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//app.vue</span><br>&lt;script setup&gt;<br><span class="hljs-keyword">import</span> &#123; ref &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">MyComponent</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./MyComponent.vue&#x27;</span><br>  <br><span class="hljs-keyword">const</span> title = <span class="hljs-title function_">ref</span>(<span class="hljs-string">&#x27;v-model argument example&#x27;</span>)<br>&lt;/script&gt;<br><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>&#123;&#123; title &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">MyComponent</span> <span class="hljs-attr">v-model:title</span>=<span class="hljs-string">&quot;title&quot;</span> /&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><br><span class="hljs-comment">//MyComponent.vue</span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">const</span> title = <span class="hljs-title function_">defineModel</span>(<span class="hljs-string">&#x27;title&#x27;</span>)</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;title&quot;</span> /&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p><img src="image-20240306180307925.png" alt="image-20240306180307925"></p>]]></content>
    
    
    <categories>
      
      <category>vue</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>vue反向代理</title>
    <link href="/2024/03/05/vue%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/"/>
    <url>/2024/03/05/vue%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="vue反向代理"><a href="#vue反向代理" class="headerlink" title="vue反向代理"></a>vue反向代理</h1><h2 id="什么是跨域"><a href="#什么是跨域" class="headerlink" title="什么是跨域"></a>什么是跨域</h2><p>JS采用的是同源策略； </p><p>同源策略是指浏览器的一项安全策略，浏览器只允许js代码请求和当前所在服务器域名，端口号协议相同的<a href="https://so.csdn.net/so/search?q=%E6%95%B0%E6%8D%AE%E6%8E%A5%E5%8F%A3&spm=1001.2101.3001.7020">数据接口</a>上的数据，这就是同源策略。也就是说当协议，域名，端口任意一个不同时，都会产生跨域问题。</p><br><h2 id="vue利用反向代理解决跨域问题，如何解决？"><a href="#vue利用反向代理解决跨域问题，如何解决？" class="headerlink" title="vue利用反向代理解决跨域问题，如何解决？"></a>vue利用反向代理解决跨域问题，如何解决？</h2><p><strong>反向代理（Reverse Proxy）实际运行方式是指以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个服务器</strong></p><p>实现方法如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//vue.config.js</span><br><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>    <span class="hljs-attr">devServer</span>:&#123;<br>    <span class="hljs-comment">//设置代理</span><br>        <span class="hljs-attr">proxy</span>:&#123;<br>            <span class="hljs-string">&#x27;/api&#x27;</span>:&#123;<br>                <span class="hljs-attr">target</span>:<span class="hljs-string">&#x27;http://localhost:3000&#x27;</span>,<span class="hljs-comment">//要跳转的位置</span><br>                <span class="hljs-attr">pathRewrite</span>:&#123;       <span class="hljs-comment">//路径重写；</span><br>                    <span class="hljs-string">&#x27;^/api&#x27;</span>:<span class="hljs-string">&#x27;&#x27;</span><br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果是用vite构建的项目，则在vite.config.js中配置跨域</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//vite.config.js</span><br><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-attr">proxy</span>: &#123;<br>    <span class="hljs-string">&#x27;/api&#x27;</span>: &#123; <span class="hljs-comment">// 这里的&#x27;/api&#x27;表示所有以&quot;/api&quot;开头的URL都会被转发至target地址</span><br>      <span class="hljs-attr">target</span>: <span class="hljs-string">&#x27;http://example.com&#x27;</span>, <span class="hljs-comment">// 指定要转发的目标服务器地址</span><br>      <span class="hljs-attr">changeOrigin</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 支持跨域</span><br>      <span class="hljs-attr">rewrite</span>: <span class="hljs-function">(<span class="hljs-params">path</span>) =&gt;</span> path.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/^\/api/</span>, <span class="hljs-string">&#x27;&#x27;</span>) <span class="hljs-comment">// 重写路径，去除前面的&quot;/api&quot;部分</span><br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>前端页面发送请求到代理的地址：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">axios</span>(&#123;<br>    <span class="hljs-attr">method</span>:<span class="hljs-string">&quot;POST&quot;</span>,<br>    <span class="hljs-attr">url</span>:<span class="hljs-string">&quot;/api&quot;</span>,<br>    <span class="hljs-attr">data</span>:&#123;<br>        <span class="hljs-attr">id</span>:<span class="hljs-number">1</span><br>    &#125;<br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">res</span>)=&gt;</span>&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res.<span class="hljs-property">data</span>)<br>&#125;)<br></code></pre></td></tr></table></figure><br><p>遇到的问题如下：在某一天开发过程中，我忘记下pathRewrite部分代码，然后前端发请求的时候一直代理不成功，一直往本地发请求，如下所示：</p><p>情况描述：当在反向代理部分未设置pathRewrite 或 pathRewrite设置的为本身时，如<code>pathRewrite：&#123;&quot;^/api&quot;:&quot;/api&quot;&#125;</code>,会导致代理不成功，往本地发请求。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//前端发请求的函数</span><br><span class="hljs-keyword">const</span> handleclick = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">1111</span>);<br>      axios.<span class="hljs-title function_">get</span>(<span class="hljs-string">&quot;/api&quot;</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res.<span class="hljs-property">data</span>.<span class="hljs-property">status</span>));<br>    &#125;;<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//vue.config.js</span><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-title function_">defineConfig</span>(&#123;<br>  <span class="hljs-attr">transpileDependencies</span>: <span class="hljs-literal">true</span>,<br>  <span class="hljs-attr">lintOnSave</span>: <span class="hljs-literal">false</span>,<br>  <span class="hljs-attr">devServer</span>: &#123;<br>    <span class="hljs-attr">proxy</span>: &#123;<br>      <span class="hljs-string">&quot;/api&quot;</span>: &#123;<br>        <span class="hljs-attr">target</span>: <span class="hljs-string">&quot;http://www.baidu.com&quot;</span>,<br>      &#125;,<br>    &#125;,<br>  &#125;,<br>&#125;);<br></code></pre></td></tr></table></figure><p>期望的是向“<a href="http://www.baidu.com/api%E2%80%9D%E5%8F%91%E8%AF%B7%E6%B1%82%EF%BC%8C%E4%BD%86%E6%98%AF%E5%AE%9E%E9%99%85%E5%8F%91%E9%80%81%E7%9A%84%E8%AF%B7%E6%B1%82%E5%9C%B0%E5%9D%80%E4%B8%BA%E2%80%9Clocalhost%EF%BC%9A8080/api%E2%80%9D">http://www.baidu.com/api”发请求，但是实际发送的请求地址为“localhost：8080/api”</a></p><p><img src="image-20240305153352885.png" alt="image-20240305153352885"></p><p>将反向代理部分的pathRewrite添加上则一切正常</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//vue.config.js</span><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-title function_">defineConfig</span>(&#123;<br>  <span class="hljs-attr">transpileDependencies</span>: <span class="hljs-literal">true</span>,<br>  <span class="hljs-attr">lintOnSave</span>: <span class="hljs-literal">false</span>,<br>  <span class="hljs-attr">devServer</span>: &#123;<br>    <span class="hljs-attr">proxy</span>: &#123;<br>      <span class="hljs-string">&quot;/api&quot;</span>: &#123;<br>        <span class="hljs-attr">target</span>: <span class="hljs-string">&quot;http://www.baidu.com&quot;</span>,<br>        <span class="hljs-attr">pathRewrite</span>: &#123;   <span class="hljs-comment">//路径重写</span><br>          <span class="hljs-string">&quot;^/api&quot;</span>: <span class="hljs-string">&quot;&quot;</span>,<br>        &#125;,<br>      &#125;,<br>    &#125;,<br>  &#125;,<br>&#125;);<br><br><span class="hljs-comment">//路径重写的意思：假如此时前端向“/api/login”发请求，则会代理到“http://www.baidu.com/login”</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>vue</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>leetcode-day4</title>
    <link href="/2024/01/18/leetcode-day4/"/>
    <url>/2024/01/18/leetcode-day4/</url>
    
    <content type="html"><![CDATA[<p>题目 题号5</p><p><img src="image-20240518210848085.png" alt="image-20240518210848085"></p><p>分析：</p><p>回文字符串如图可以分为两种情况</p><p>第一种情况：有中心点，则依次判断其左右两边的值是否相等，即（left,right）&#x3D; (i-1,i+1)</p><p>第二种情况：没有中心点，则设置 （left，right）&#x3D; (i,i+1)</p><p>然后遍历字符串中的每个值，每个值都要判断上面两种情况。</p><p><img src="image-20240518211030072.png" alt="image-20240518211030072"></p><p>代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> longestPalindrome = <span class="hljs-keyword">function</span>(<span class="hljs-params">s</span>) &#123;<br>    <span class="hljs-keyword">let</span> start = <span class="hljs-number">0</span> <span class="hljs-comment">//回文子串开始位置</span><br>    <span class="hljs-keyword">if</span>(s.<span class="hljs-property">length</span> &lt; <span class="hljs-number">2</span>)&#123;<br>        <span class="hljs-keyword">return</span> s<br>    &#125;<br>    <span class="hljs-keyword">let</span> maxlength = <span class="hljs-number">1</span>  <span class="hljs-comment">//最长回文字符串的长度，如果是空字符串的情况已经包含在上面</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>;i &lt; s.<span class="hljs-property">length</span>;i++)&#123;  <span class="hljs-comment">//遍历，每个字符都要判断两种情况</span><br>        <span class="hljs-title function_">maxlengthStr</span>(i-<span class="hljs-number">1</span>,i+<span class="hljs-number">1</span>)<br>        <span class="hljs-title function_">maxlengthStr</span>(i,i+<span class="hljs-number">1</span>)<br>    &#125;<br>    <span class="hljs-keyword">return</span> s.<span class="hljs-title function_">substring</span>(start,start+maxlength)<br><br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">maxlengthStr</span>(<span class="hljs-params">left,right</span>)&#123;<br>        <span class="hljs-keyword">while</span>(left &gt;= <span class="hljs-number">0</span> &amp;&amp; right &lt;= s.<span class="hljs-property">length</span> &amp;&amp; s[left]===s[right])&#123;  <span class="hljs-comment">//当左右的值相等且没超出范围就一直往两边扩散循环</span><br>            <span class="hljs-keyword">if</span>(maxlength &lt; right - left + <span class="hljs-number">1</span>)&#123;  <span class="hljs-comment">//如果当前回文长度超过已有最大值，更新最大值和最长回文开始位置。</span><br>                maxlength = right - left + <span class="hljs-number">1</span><br>                start = left<br>            &#125;<br>            left--<br>            right++<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>leetcode-day3</title>
    <link href="/2024/01/16/leetcode-day3/"/>
    <url>/2024/01/16/leetcode-day3/</url>
    
    <content type="html"><![CDATA[<p>题目 题号：3</p><p><img src="image-20240516190407671.png" alt="image-20240516190407671"></p><p>分析：<strong>1.双指针  2.滑动窗口</strong></p><p>用数组来保存滑动窗口的值，如果右指针当前值在滑动窗口中存在，则依次删除<strong>滑动窗口</strong>的第一个元素，直到滑动窗口中不含右指针对应的元素。</p><p>代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> lengthOfLongestSubstring = <span class="hljs-keyword">function</span>(<span class="hljs-params">s</span>) &#123;<br><span class="hljs-keyword">let</span> maxlength = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">let</span> left = <span class="hljs-number">0</span>,right = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">let</span> arr = []<br>    <span class="hljs-keyword">if</span>(s.<span class="hljs-property">length</span> === <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    &#125;<br>    <span class="hljs-keyword">while</span>(right &lt; s.<span class="hljs-property">length</span>)&#123;<br>        <span class="hljs-keyword">if</span>(arr.<span class="hljs-title function_">indexOf</span>(s[right])===-<span class="hljs-number">1</span>)&#123;  <span class="hljs-comment">//没有重复的，右指针移动</span><br>            arr.<span class="hljs-title function_">push</span>(s[right])<br>            right++<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;   <span class="hljs-comment">//如果有重复的，从前面删除，一直删除到没有与该元素重复的为止</span><br>            <span class="hljs-keyword">while</span>(arr.<span class="hljs-title function_">indexOf</span>(s[right]) &gt; -<span class="hljs-number">1</span>)&#123;<br>                arr.<span class="hljs-title function_">shift</span>()<br>                left++<br>            &#125;<br>        &#125;<br>        maxlength = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(right-left,maxlength)<br>    &#125;<br>    <span class="hljs-keyword">return</span> maxlength<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>leetcode-day2</title>
    <link href="/2024/01/15/leetcode-day2/"/>
    <url>/2024/01/15/leetcode-day2/</url>
    
    <content type="html"><![CDATA[<p>题目：题号2</p><p><img src="image-20240515162014362.png" alt="image-20240515162014362"></p><p>分析：用链表来存储数组，链头为个位，链尾为最高位。要求和，方法:创建一个新的链表来存储和的值，对应位相加，先判断是否需要进位，再往链表中添加节点。最后当链表遍历完以后，还需判断最高位相加是否需要进位。</p><p>代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * function ListNode(val, next) &#123;</span><br><span class="hljs-comment"> *     this.val = (val===undefined ? 0 : val)</span><br><span class="hljs-comment"> *     this.next = (next===undefined ? null : next)</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">ListNode</span>&#125; <span class="hljs-variable">l1</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">ListNode</span>&#125; <span class="hljs-variable">l2</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">ListNode</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> addTwoNumbers = <span class="hljs-keyword">function</span>(<span class="hljs-params">l1, l2</span>) &#123;<br>    <span class="hljs-keyword">let</span> head = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>()   <span class="hljs-comment">//头节点</span><br>    <span class="hljs-keyword">let</span> curr = head<span class="hljs-comment">//当前节点</span><br>    <span class="hljs-keyword">let</span> num = <span class="hljs-number">0</span>   <span class="hljs-comment">//进位？</span><br>    <span class="hljs-keyword">while</span>(l1 !== <span class="hljs-literal">null</span> || l2!== <span class="hljs-literal">null</span>)&#123;<br>        <span class="hljs-keyword">let</span> sum = <span class="hljs-number">0</span>  <br>        <span class="hljs-keyword">if</span>(l1 !== <span class="hljs-literal">null</span>)&#123;<br>            sum += l1.<span class="hljs-property">val</span><br>            l1 = l1.<span class="hljs-property">next</span><br>        &#125;<br>        <span class="hljs-keyword">if</span>(l2 !== <span class="hljs-literal">null</span>)&#123;<br>            sum += l2.<span class="hljs-property">val</span><br>            l2 = l2.<span class="hljs-property">next</span><br>        &#125;<br>        sum += num    <br>        <span class="hljs-keyword">if</span>(sum &gt;= <span class="hljs-number">10</span>)&#123;<br>            num = <span class="hljs-number">1</span>   <span class="hljs-comment">//进位</span><br>            sum = sum - <span class="hljs-number">10</span>  <span class="hljs-comment">//余数</span><br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            num = <span class="hljs-number">0</span><br>        &#125;<br>        curr.<span class="hljs-property">next</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(sum)<br>        curr = curr.<span class="hljs-property">next</span>      <span class="hljs-comment">//当前节点逐渐移动</span><br>    &#125;<br>    <span class="hljs-keyword">if</span>(num &gt; <span class="hljs-number">0</span>)&#123;   <br>        curr.<span class="hljs-property">next</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(num)  <span class="hljs-comment">//如果最高位相加大于10，也得进位</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> head.<span class="hljs-property">next</span><br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>leetcode-day1</title>
    <link href="/2024/01/14/leetcode-day1/"/>
    <url>/2024/01/14/leetcode-day1/</url>
    
    <content type="html"><![CDATA[<p>题目：</p><p>给定一个整数数组 <code>nums</code> 和一个整数目标值 <code>target</code>，请你在该数组中找出<strong>和为目标值target</strong> 的那 <strong>两个</strong> 整数，并返回它们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</p><p>你可以按任意顺序返回答案。</p><p><img src="image-20240514210350082.png" alt="image-20240514210350082"></p><p>思路：</p><p>1.遍历一遍nums，每次target-当前值，定义差值为value。</p><p>2.用Map结构存储值，Map中存的格式是 {num[i],i}，即键存的是nums中的值，值存的是nums中的索引，这样做的原因是Map.has()方法找到是Map中的键值。</p><p>3.利用Map.has(value)方法，查找差值是否在Map中，在就返回[Map.get(value),i]，不在就把当前值和其索引存到Map中。</p><p>代码：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">twoSum</span>(<span class="hljs-params">nums: <span class="hljs-built_in">number</span>[], target: <span class="hljs-built_in">number</span></span>): <span class="hljs-built_in">number</span>[] &#123;<br>    <span class="hljs-keyword">let</span> myMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>()<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>;i &lt; nums.<span class="hljs-property">length</span>;i++)&#123;<br>        <span class="hljs-keyword">let</span> value = target - nums[i] <br>        <span class="hljs-keyword">if</span>(myMap.<span class="hljs-title function_">has</span>(value))&#123;<br>            <span class="hljs-keyword">let</span> <span class="hljs-attr">resArr</span>:<span class="hljs-built_in">number</span>[] = [myMap.<span class="hljs-title function_">get</span>(value),i]  <span class="hljs-comment">//差值在map中，就找到map中存的差值在nums中的索引</span><br>            <span class="hljs-keyword">return</span> resArr<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            myMap.<span class="hljs-title function_">set</span>(nums[i],i)   <span class="hljs-comment">//差值不在map中就把当前值存到map中</span><br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>附：Map是一种用于存储键值对的集合,Map的使用方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> mymap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>()  <br>mymap.<span class="hljs-title function_">set</span>(key,value)<br>mymap.<span class="hljs-title function_">get</span>(key)    <br>mymap.<span class="hljs-title function_">has</span>(key)<br>mymap.<span class="hljs-title function_">delete</span>(key)<br><span class="hljs-keyword">let</span> mapsize = mymap.<span class="hljs-property">size</span><br>mymap.<span class="hljs-title function_">clear</span>()<br><span class="hljs-keyword">let</span> mapvalues= <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(map.<span class="hljs-title function_">values</span>())<br><span class="hljs-keyword">let</span> mapkeys = <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(map.<span class="hljs-title function_">keys</span>())<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>react利用lazy和suspense实现组件懒加载</title>
    <link href="/2023/09/26/react%E5%88%A9%E7%94%A8lazy%E5%92%8Csuspense%E5%AE%9E%E7%8E%B0%E7%BB%84%E4%BB%B6%E6%87%92%E5%8A%A0%E8%BD%BD/"/>
    <url>/2023/09/26/react%E5%88%A9%E7%94%A8lazy%E5%92%8Csuspense%E5%AE%9E%E7%8E%B0%E7%BB%84%E4%BB%B6%E6%87%92%E5%8A%A0%E8%BD%BD/</url>
    
    <content type="html"><![CDATA[<h1 id="react利用lazy和suspense实现组件懒加载"><a href="#react利用lazy和suspense实现组件懒加载" class="headerlink" title="react利用lazy和suspense实现组件懒加载"></a>react利用lazy和suspense实现组件懒加载</h1><p>背景：react默认的引入了该组件，就会加载该组件</p><p>Head组件</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;head&quot;</span>);<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> () =&gt; &#123;<br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>hello head<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;<br>&#125;;<br><br></code></pre></td></tr></table></figure><p>App组件</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> &#123; useState &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-title class_">Myhead</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./head.jsx&quot;</span>;  <span class="hljs-comment">//引入head组件，默认的不显示，当点击按钮以后再显示该组件</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [isshow, setIsshow] = <span class="hljs-title function_">useState</span>(<span class="hljs-literal">false</span>);<br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleclick</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-title function_">setIsshow</span>(<span class="hljs-literal">true</span>);<br>  &#125;;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;handleclick&#125;</span>&gt;</span>点击显示head<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>  </span><br><span class="language-xml">      &#123;isshow &amp;&amp; <span class="hljs-tag">&lt;<span class="hljs-name">Myhead</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Myhead</span>&gt;</span>&#125;</span><br><span class="language-xml">      hello app</span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br><span class="hljs-comment">//问题，引入head组件就会对其进行加载，造成性能浪费，为了优化性能，需要在需要显示Head组件的时候再加载Head组件</span><br></code></pre></td></tr></table></figure><p><strong>使用lazy和suspense解决</strong></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> &#123; useState &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br><span class="hljs-keyword">import</span> &#123; lazy, <span class="hljs-title class_">Suspense</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br><span class="hljs-comment">//按需引入</span><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">Myhead</span> = <span class="hljs-title function_">lazy</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&quot;./head.jsx&quot;</span>)); <span class="hljs-comment">//lazy()里面需要返回的是一个promise对象！！！！</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [isshow, setIsshow] = <span class="hljs-title function_">useState</span>(<span class="hljs-literal">false</span>);<br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleclick</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-title function_">setIsshow</span>(<span class="hljs-literal">true</span>);<br>  &#125;;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;handleclick&#125;</span>&gt;</span>点击显示head<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Suspense</span> <span class="hljs-attr">fallback</span>=<span class="hljs-string">&#123;</span>&lt;<span class="hljs-attr">div</span>&gt;</span>loading...<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>&#125;&gt;  //利用suspense包裹</span><br><span class="language-xml">        &#123;isshow &amp;&amp; <span class="hljs-tag">&lt;<span class="hljs-name">Myhead</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Myhead</span>&gt;</span>&#125;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">Suspense</span>&gt;</span></span><br><span class="language-xml">      hello app</span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><p>效果：</p><p>点击之前，不会加载Head组件</p><p><img src="image-20230926163055842.png" alt="image-20230926163055842"></p><p>点击显示之后，再加载Head组件，而且加载的过程中会有设置的loading效果。</p><p><img src="image-20230926162723424.png" alt="image-20230926162723424"></p><p>注：关于lazy api详解以及返回的promise请查看以下链接： <a href="https://zh-hans.react.dev/reference/react/lazy">https://zh-hans.react.dev/reference/react/lazy</a></p>]]></content>
    
    
    <categories>
      
      <category>react</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>react使用error-boundary(错误边界)捕获渲染错误</title>
    <link href="/2023/09/26/react%E4%BD%BF%E7%94%A8error-boundary-%E9%94%99%E8%AF%AF%E8%BE%B9%E7%95%8C-%E6%8D%95%E8%8E%B7%E6%B8%B2%E6%9F%93%E9%94%99%E8%AF%AF/"/>
    <url>/2023/09/26/react%E4%BD%BF%E7%94%A8error-boundary-%E9%94%99%E8%AF%AF%E8%BE%B9%E7%95%8C-%E6%8D%95%E8%8E%B7%E6%B8%B2%E6%9F%93%E9%94%99%E8%AF%AF/</url>
    
    <content type="html"><![CDATA[<h1 id="react使用error-boundary-错误边界-捕获渲染错误-（类似vue中的try-catch）"><a href="#react使用error-boundary-错误边界-捕获渲染错误-（类似vue中的try-catch）" class="headerlink" title="react使用error-boundary(错误边界)捕获渲染错误 （类似vue中的try catch）"></a>react使用error-boundary(错误边界)捕获渲染错误 （类似vue中的try catch）</h1><p><strong>问题背景： 默认情况下，如果在渲染期间出错，React将从屏幕上移除其UI。简而言之，当某个组件发生错误的时候，整个页面都会不显示。</strong></p><p><strong>解决方法：为了防止这种情况发生，可以将UI的一部分包含到错误边界中，当该部分发生问题的时候，只会显示该部分有问题，而不会影响其余组件的渲染。</strong></p><p><strong>第三方库：react-error-boundary</strong></p><p>示例如下：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> &#123; classNames &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;classnames&quot;</span>;<span class="hljs-comment">//错误引用</span><br><span class="hljs-comment">//import classNames from &quot;classnames&quot;;//正确引用</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Head</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-title function_">classNames</span>();<br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>hello head<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      hello app</span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Head</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Head</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br><span class="hljs-comment">//分析：此时Head组件引用错误，会导致该组件不能成功渲染，由于react的机制，整体App组件页面会报错。</span><br></code></pre></td></tr></table></figure><p><img src="image-20230926155412373.png" alt="image-20230926155412373"></p><hr><p>利用error boundary解决</p><p>1.安装该第三方方法： <code>npm install react-error-boundary --save</code></p><p>2.导入 <code>import &#123; ErrorBoundary &#125; from &quot;react-error-boundary&quot;</code></p><p>2.将组件用<code>&lt;ErrorBoundary fallback=&#123;&lt;div&gt;该组件出问题了！&lt;/div&gt;&#125;&gt; &lt;/ErrorBoundary&gt;</code>包起来</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> &#123; classNames &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;classnames&quot;</span>; <span class="hljs-comment">//错误引用</span><br><span class="hljs-comment">//import classNames from &quot;classnames&quot;; //正确引用</span><br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">ErrorBoundary</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react-error-boundary&quot;</span>;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Head</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-title function_">classNames</span>();<br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>hello head<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      hello app</span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">ErrorBoundary</span> <span class="hljs-attr">fallback</span>=<span class="hljs-string">&#123;</span>&lt;<span class="hljs-attr">div</span>&gt;</span>该组件出问题了！<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>&#125;&gt;</span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">Head</span> /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">ErrorBoundary</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br><span class="hljs-comment">//此时当某个组件出问题的时候，不会影响整个页面，只会显示出问题的组件有问题</span><br></code></pre></td></tr></table></figure><p><img src="image-20230926160326908.png" alt="image-20230926160326908"></p>]]></content>
    
    
    <categories>
      
      <category>react</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>react-dom之flushSync确保dom立即更新</title>
    <link href="/2023/09/26/react-dom%E4%B9%8BflushSync%E7%A1%AE%E4%BF%9Ddom%E7%AB%8B%E5%8D%B3%E6%9B%B4%E6%96%B0/"/>
    <url>/2023/09/26/react-dom%E4%B9%8BflushSync%E7%A1%AE%E4%BF%9Ddom%E7%AB%8B%E5%8D%B3%E6%9B%B4%E6%96%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="react-dom之flushSync确保dom立即更新（类似vue中的nextTick）"><a href="#react-dom之flushSync确保dom立即更新（类似vue中的nextTick）" class="headerlink" title="react-dom之flushSync确保dom立即更新（类似vue中的nextTick）"></a>react-dom之flushSync确保dom立即更新（类似vue中的nextTick）</h1><p>问题背景：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> &#123; useState, useRef &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [count, setCount] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">const</span> ref = <span class="hljs-title function_">useRef</span>(<span class="hljs-literal">null</span>);<br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleclick</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-title function_">setCount</span>(count + <span class="hljs-number">1</span>);    <span class="hljs-comment">//当我们更新状态的时候，只有在下一次作用域才会更新页面</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(ref.<span class="hljs-property">current</span>.<span class="hljs-property">innerHTML</span>); <span class="hljs-comment">//此时只会拿到dom更新前的内容，也就是页面显示N的时候，控制台打印出的还是N-1</span><br>    <span class="hljs-comment">//若我们需要在更新状态的时候，同步处理一些dom操作，则就需要确保dom立即更新。</span><br>  &#125;;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;handleclick&#125;</span>&gt;</span>click<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&#123;ref&#125;</span>&gt;</span>&#123;count&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="image-20230926153302060.png" alt="image-20230926153302060"></p><hr/><p>利用react-dom中的flushSync方法实现dom立即更新</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> &#123; useState, useRef &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br><span class="hljs-keyword">import</span> &#123; flushSync &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react-dom&quot;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [count, setCount] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">const</span> ref = <span class="hljs-title function_">useRef</span>(<span class="hljs-literal">null</span>);<br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleclick</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-title function_">flushSync</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-title function_">setCount</span>(count + <span class="hljs-number">1</span>);<br>    &#125;);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(ref.<span class="hljs-property">current</span>.<span class="hljs-property">innerHTML</span>); <span class="hljs-comment">//此时会拿到dom更新后的内容,在此便可以对dom做一些需要的处理</span><br>  &#125;;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;handleclick&#125;</span>&gt;</span>click<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&#123;ref&#125;</span>&gt;</span>&#123;count&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br><br></code></pre></td></tr></table></figure><p><img src="image-20230926153750048.png" alt="image-20230926153750048"></p>]]></content>
    
    
    <categories>
      
      <category>react</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>react-自定义hooks</title>
    <link href="/2023/09/24/react-%E8%87%AA%E5%AE%9A%E4%B9%89hooks/"/>
    <url>/2023/09/24/react-%E8%87%AA%E5%AE%9A%E4%B9%89hooks/</url>
    
    <content type="html"><![CDATA[<h1 id="react之自定义hooks"><a href="#react之自定义hooks" class="headerlink" title="react之自定义hooks"></a>react之自定义hooks</h1><h2 id="一-什么是自定义hooks"><a href="#一-什么是自定义hooks" class="headerlink" title="一 什么是自定义hooks"></a>一 什么是自定义hooks</h2><p>自定义hook是一个<strong>函数</strong>，函数内部可以调用其他hook函数，且以use开头命名。主要作用是对逻辑功能进行封装处理，达到一种复用能力。</p><hr><h2 id="二-案例-实现一个实时获取鼠标坐标的自定义hook"><a href="#二-案例-实现一个实时获取鼠标坐标的自定义hook" class="headerlink" title="二 案例 实现一个实时获取鼠标坐标的自定义hook"></a>二 案例 实现一个实时获取鼠标坐标的自定义hook</h2><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> &#123; useEffect, useState &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br><br><span class="hljs-comment">//自定义useMouse hook，获取鼠标焦点</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">useMouse</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [state, setState] = <span class="hljs-title function_">useState</span>(&#123;<br>    <span class="hljs-attr">pageX</span>: <span class="hljs-title class_">NaN</span>,<br>    <span class="hljs-attr">pageY</span>: <span class="hljs-title class_">NaN</span>,<br>  &#125;);<br>  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">move</span>(<span class="hljs-params">e</span>) &#123;<br>      <span class="hljs-title function_">setState</span>(&#123;<br>        <span class="hljs-attr">pageX</span>: e.<span class="hljs-property">pageX</span>,<br>        <span class="hljs-attr">pageY</span>: e.<span class="hljs-property">pageY</span>,<br>      &#125;);<br>    &#125;<br>    <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;mousemove&quot;</span>, move);<br>    <span class="hljs-comment">//组件销毁的时候清理工作</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">removeEventListener</span>(<span class="hljs-string">&quot;mousemove&quot;</span>, move);<br>    &#125;;<br>  &#125;);<br>  <span class="hljs-keyword">return</span> state;<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> mouse = <span class="hljs-title function_">useMouse</span>();  <span class="hljs-comment">//使用自定义的hook</span><br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      hello app,&#123;mouse.pageX&#125;,&#123;mouse.pageY&#125;</span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br><br></code></pre></td></tr></table></figure><p><img src="image-20230924165353806.png" alt="image-20230924165353806"></p>]]></content>
    
    
    <categories>
      
      <category>react</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>react利用状态提升解决共享问题</title>
    <link href="/2023/09/20/react%E5%88%A9%E7%94%A8%E7%8A%B6%E6%80%81%E6%8F%90%E5%8D%87%E8%A7%A3%E5%86%B3%E5%85%B1%E4%BA%AB%E9%97%AE%E9%A2%98/"/>
    <url>/2023/09/20/react%E5%88%A9%E7%94%A8%E7%8A%B6%E6%80%81%E6%8F%90%E5%8D%87%E8%A7%A3%E5%86%B3%E5%85%B1%E4%BA%AB%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="react状态提升解决共享问题"><a href="#react状态提升解决共享问题" class="headerlink" title="react状态提升解决共享问题"></a>react状态提升解决共享问题</h1><p>背景：</p><p>react组件中的state状态值是相互独立的，一个实例化的组件状态改变不会影响另一个组件的状态。案例如下</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> &#123; useState &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br><br><span class="hljs-comment">//子组件</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Newbutton</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [count, setCount] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleClick</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-title function_">setCount</span>(count + <span class="hljs-number">1</span>);<br>  &#125;;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      &#123;count&#125;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;handleClick&#125;</span>&gt;</span>click<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Newbutton</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Newbutton</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Newbutton</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Newbutton</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br><br><br><span class="hljs-comment">//分析  效果是实例化了两个Newbutton组件，都能单独点击使得count+1，两个互不影响，这也是大多数组件应该有得状态。</span><br></code></pre></td></tr></table></figure><p><img src="image-20230920194546572.png" alt="image-20230920194546572"></p><br><p>然而某些时候，多次实例化需要共享state状态，便可利用状态提升来解决。<font color='yellow'>具体方法就是在父组件定义状态值和方法，通过父子属性传值将状态传递给子组件，当父组件中的状态值发生变化的时候，相应的子组件都会重新渲染</font>。</p><p>案例如下：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Newbutton</span>(<span class="hljs-params">&#123; childrenCount, childClick &#125;</span>) &#123;<br>  <span class="hljs-comment">//利用结构拿取props中的值</span><br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      &#123;childrenCount&#125;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;childClick&#125;</span>&gt;</span>click<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [count, setCount] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>); <span class="hljs-comment">//父组件管理共享状态，通过父子属性传值将状态传递给子组件</span><br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleClick</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-title function_">setCount</span>(count + <span class="hljs-number">1</span>);<br>  &#125;;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Newbutton</span> <span class="hljs-attr">childrenCount</span>=<span class="hljs-string">&#123;count&#125;</span> <span class="hljs-attr">childClick</span>=<span class="hljs-string">&#123;handleClick&#125;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Newbutton</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Newbutton</span> <span class="hljs-attr">childrenCount</span>=<span class="hljs-string">&#123;count&#125;</span> <span class="hljs-attr">childClick</span>=<span class="hljs-string">&#123;handleClick&#125;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Newbutton</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="image-20230920194433247.png" alt="image-20230920194433247"></p>]]></content>
    
    
    <categories>
      
      <category>react</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>react-state状态</title>
    <link href="/2023/09/19/react-state%E7%8A%B6%E6%80%81/"/>
    <url>/2023/09/19/react-state%E7%8A%B6%E6%80%81/</url>
    
    <content type="html"><![CDATA[<h1 id="react之state知识点"><a href="#react之state知识点" class="headerlink" title="react之state知识点"></a>react之state知识点</h1><h2 id="1-state是干嘛的？"><a href="#1-state是干嘛的？" class="headerlink" title="1.state是干嘛的？"></a>1.state是干嘛的？</h2><p>state 指状态，而状态即是驱动页面进行渲染是数据，react机制是数据驱动视图，当state中的状态值发生变化，页面更新。</p><p><br></br></p><h2 id="2-state的定义以及使用方法"><a href="#2-state的定义以及使用方法" class="headerlink" title="2.state的定义以及使用方法"></a>2.state的定义以及使用方法</h2><p>类组件</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">class</span> <span class="hljs-title class_">View</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Component</span>&#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>)&#123;<br>      <span class="hljs-variable language_">super</span>();<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>=&#123; <span class="hljs-comment">//方法一：直接在构造函数中定义</span><br>        <span class="hljs-attr">num</span>:<span class="hljs-number">10</span><br>      &#125;<br>    &#125;<br>    <span class="hljs-comment">//方法二 </span><br>    state = &#123;<br>        <span class="hljs-attr">num</span>:<span class="hljs-number">0</span><br>    &#125;<br>    <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-keyword">return</span>(<br>            <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>&#123;this.state.num&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>            <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span> = <span class="hljs-string">&#123;()</span>=&gt;</span>&#123;</span><br><span class="language-xml">                    this.setState&#123;   //只能通过this.setstate更改值</span><br><span class="language-xml">                        num:1</span><br><span class="language-xml">                    &#125;&#125;</span><br><span class="language-xml">              &#125;&gt;更改num<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br>        )<br>    &#125;<br>  &#125; <br></code></pre></td></tr></table></figure><p>函数式组件</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> &#123; useState &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>; <span class="hljs-comment">//导入useState这个hooks</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [list, setList] = <span class="hljs-title function_">useState</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]);<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> &#123;   //只能通过定义的setList更改</span><br><span class="language-xml">          setList([4, 5, 6]);</span><br><span class="language-xml">        &#125;&#125;</span><br><span class="language-xml">      &gt;</span><br><span class="language-xml">        click</span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span></span><br><span class="language-xml">        &#123;list.map((item) =&gt; &#123;</span><br><span class="language-xml">          return <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>&#123;item&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>;</span><br><span class="language-xml">        &#125;)&#125;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">App</span>;<br></code></pre></td></tr></table></figure><p><br></br></p><h2 id="3-异步执行与自动批处理"><a href="#3-异步执行与自动批处理" class="headerlink" title="3.异步执行与自动批处理"></a>3.异步执行与自动批处理</h2><p><strong><code>setState</code>其实本身执行的过程和代码都是同步的</strong></p><p><strong>自动批处理</strong>：同一时机多次调用<code>setState()</code>方法的一种处理机制，有助于减少在状态更改时发生的重新渲染次数。</p><p><strong><code>setState</code>其实本身执行的过程和代码都是同步的</strong></p><p><strong>自动批处理</strong>：同一时机多次调用<code>setState()</code>方法的一种处理机制，有助于减少在状态更改时发生的重新渲染次数。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs jsx">handleClick = <span class="hljs-function">() =&gt;</span> &#123;  <br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123;<br>        <span class="hljs-attr">msg</span>: <span class="hljs-string">&#x27;hi&#x27;</span><br>    &#125;);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123;<br>        <span class="hljs-attr">count</span>: <span class="hljs-number">1</span><br>    &#125;);<br>&#125;<br> <br><span class="hljs-comment">//虽然调用了两次`setState()`方法，但是只会触发一次`render()`方法的重新执行。</span><br></code></pre></td></tr></table></figure><br><h2 id="4-setstate什么时候会让页面重新渲染"><a href="#4-setstate什么时候会让页面重新渲染" class="headerlink" title="4.setstate什么时候会让页面重新渲染"></a>4.setstate什么时候会让页面重新渲染</h2><p><font color='yellow'>当state中的状态值发生变化的时候才会重新渲染</font></p><p>案例1</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> &#123; useState &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>; <span class="hljs-comment">//导入useState这个hooks</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [count, setCount] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleClick</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-title function_">setCount</span>(<span class="hljs-number">0</span>);<br>  &#125;;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;1234&quot;</span>);<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;handleClick&#125;</span>&gt;</span>click<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">      &#123;count&#125;</span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">App</span>;<br><br><span class="hljs-comment">//分析 当此时点击按钮的时候，不会打印1234，也就是不会重新渲染页面。原因：count的值没有发生变化</span><br></code></pre></td></tr></table></figure><p>案例2</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> &#123; useState &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>; <span class="hljs-comment">//导入useState这个hooks</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [list, setList] = <span class="hljs-title function_">useState</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]);<br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleClick</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    list.<span class="hljs-title function_">push</span>(<span class="hljs-number">5</span>);    <span class="hljs-comment">//push方法更改原来数组</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(list);<br>    <span class="hljs-title function_">setList</span>(list);<br>  &#125;;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;1234&quot;</span>);<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;handleClick&#125;</span>&gt;</span>click<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">      &#123;list.map((item) =&gt; &#123;</span><br><span class="language-xml">        return <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>&#123;item&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>;</span><br><span class="language-xml">      &#125;)&#125;</span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">App</span>;<br><br><span class="hljs-comment">//分析 点击按钮的时候，页面也不会重新渲染</span><br><span class="hljs-comment">//原因 push方法会改变原来数组，所以执行完list.push(5)以后，list数组就已经变成[1,2,3,4,5],再setList(list)相当于setList([1，2，3，4，5])，list的值没有发生变化，所以页面不更新</span><br><span class="hljs-comment">//常见解决方法见下文</span><br></code></pre></td></tr></table></figure><br><h2 id="5-常见的数组和对象的解决方法"><a href="#5-常见的数组和对象的解决方法" class="headerlink" title="5.常见的数组和对象的解决方法"></a>5.常见的数组和对象的解决方法</h2><p>1.在利用setstate更新数组和对象的时候，应该避免使用一些会影响原数组的方法，而需要使用一些返回新数组的方法</p><p><img src="image-20230919212720315.png" alt="image-20230919212720315"></p><p>案例1 </p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> &#123; useState &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>; <span class="hljs-comment">//导入useState这个hooks</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [list, setList] = <span class="hljs-title function_">useState</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]);<br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleClick</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-title function_">setList</span>([...list, <span class="hljs-number">5</span>]);  <span class="hljs-comment">//利用展开运算符</span><br>  &#125;;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;1234&quot;</span>);<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;handleClick&#125;</span>&gt;</span>click<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">      &#123;list.map((item) =&gt; &#123;</span><br><span class="language-xml">        return <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>&#123;item&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>;</span><br><span class="language-xml">      &#125;)&#125;</span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">App</span>;<br></code></pre></td></tr></table></figure><p>注意：当对象层级比较少的情况下，可以使用…展开运算符，如果层级较多的情况下，推荐使用深拷贝复制一份，然后将克隆的修改之后传入setstate中，如下图所示。</p><p><img src="image-20230919213631332.png" alt="image-20230919213631332"></p><br><p>有关浅拷贝与深拷贝方法,详细请查看该链接 <a href="https://yang-fan01.gitee.io/2023/05/24/%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B-%E6%B5%85%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B7%B1%E6%8B%B7%E8%B4%9D/">https://yang-fan01.gitee.io/2023/05/24/%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B-%E6%B5%85%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B7%B1%E6%8B%B7%E8%B4%9D/</a></p><br><h2 id="6-状态重置问题"><a href="#6-状态重置问题" class="headerlink" title="6.状态重置问题"></a>6.状态重置问题</h2><p><img src="image-20230920195751904.png" alt="image-20230920195751904"></p><p>详解：</p><p>第一点：例如一个计数组件NumberCount，用isshow和&amp;&amp;来控制该组件的显示与隐藏<code>&#123;isshow &amp;&amp; &lt;NumberCount&gt;&#125;</code>，每次隐藏以后再显示count的值都是从默认值开始。原因就是因为当isshow位false的时候，组件被销毁，对应的状态被重置。</p><p>第二点：同样上面的技术组加NumberCount，用isstyle判断是否显示样式</p><p>1，<code>&#123;isstyle?&lt;NumberCount style = &#123;&#123;border: "1px solid red"&#125;&#125;:&lt;NumberCount&gt;&#125;</code>,此时组件位置没有发生改变，状态会保留。</p><p>2，<code>&#123;isstyle?&lt;NumberCount style = &#123;&#123;border: "1px solid red"&#125;&#125;:&lt;div&gt;&lt;NumberCount&gt;&lt;/div&gt;&#125;</code>，此时状态会被重置，因为处于不同的结构体中。</p><p>3，<code>&#123;isstyle?&lt;NumberCount key=‘key1’ style = &#123;&#123;border: "1px solid red"&#125;&#125;:&lt;div&gt;&lt;NumberCount key=‘key2’&gt;&lt;/div&gt;&#125;</code>，此时状态会被重置，因为key属性不同。</p>]]></content>
    
    
    <categories>
      
      <category>react</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>react-redux教程</title>
    <link href="/2023/06/23/react-redux%E6%95%99%E7%A8%8B/"/>
    <url>/2023/06/23/react-redux%E6%95%99%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="一、redux"><a href="#一、redux" class="headerlink" title="一、redux"></a>一、redux</h2><h2 id="二、react-redux"><a href="#二、react-redux" class="headerlink" title="二、react-redux"></a>二、react-redux</h2><p><strong>步骤：</strong></p><ol><li><p><strong>安装相关依赖</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">npm i redux<br>npm i react-redux<br></code></pre></td></tr></table></figure></li><li><p><strong>构建reducer和store</strong></p><p><strong>创建reducer文件，构建reducer来相应actions。</strong></p><p><strong>创建store文件，通过createStore方法。</strong></p><p><strong>在app.js中引入store，在react-redux方法中在此处引入一次store即可，不用像redux中需要用state的e地方都要引入store。</strong></p></li><li><p><strong>搭建页面结构</strong></p></li><li><p><strong>全局组件外部利用provider包裹，注意provider需要设置store属性为引入的store文件。</strong></p></li><li><p><strong>子组件利用react-redux提供的connect方法进行加强，实现发送dispatch或者拿取state状态值。</strong></p></li></ol><p><strong>语法：<code>connect(MapStateToProps,MapDispatchToProps)(组件名)</code>，第一个参数为获取state状态值函数，第二个为dispatch函数。</strong></p><br><p>案例：加减显示</p><ol><li><p>安装依赖：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">npm i redux<br>npm i react-redux<br></code></pre></td></tr></table></figure></li><li><p>创建reducer文件和store文件</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-comment">//reducer.js</span><br><span class="hljs-comment">//设置初始值</span><br><span class="hljs-keyword">const</span> initialstate = &#123;<br>  <span class="hljs-attr">count</span>: <span class="hljs-number">0</span>,<br>&#125;;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">reducer</span> = (<span class="hljs-params">prepstate = initialstate, action</span>) =&gt; &#123;<br>  <span class="hljs-keyword">switch</span> (action.<span class="hljs-property">type</span>) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;add_action&quot;</span>:<br>      <span class="hljs-keyword">return</span> &#123;<br>        <span class="hljs-attr">count</span>: prepstate.<span class="hljs-property">count</span> + <span class="hljs-number">1</span>,<br>      &#125;;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;reduce_action&quot;</span>:<br>      <span class="hljs-keyword">return</span> &#123;<br>        <span class="hljs-attr">count</span>: prepstate.<span class="hljs-property">count</span> - <span class="hljs-number">1</span>,<br>      &#125;;<br>    <span class="hljs-attr">default</span>:<br>      <span class="hljs-keyword">return</span> prepstate;<br>  &#125;<br>&#125;;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> reducer;<br></code></pre></td></tr></table></figure><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-comment">//store.js</span><br><span class="hljs-keyword">import</span> &#123; legacy_createStore <span class="hljs-keyword">as</span> createStore &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;redux&quot;</span>;<br><span class="hljs-keyword">import</span> reducer <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;../Reducer&quot;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">createStore</span>(reducer);<br></code></pre></td></tr></table></figure></li><li><p>搭建页面结构</p><p>页面就一个显示结果组件ShowAnswer.js，另外加减方法各一个组件</p></li><li><p>全局组件provider包裹</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-comment">//app.js</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;./App.css&quot;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-title class_">AddButton</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./Components/AddButton&quot;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-title class_">ReduButton</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./Components/ReduButton&quot;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-title class_">ShowAnswer</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./Components/ShowAnswer&quot;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-title class_">Store</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./Store&quot;</span>;<br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">Provider</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react-redux&quot;</span>;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Provider</span> <span class="hljs-attr">store</span>=<span class="hljs-string">&#123;Store&#125;</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">AddButton</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">AddButton</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">ReduButton</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">ReduButton</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">ShowAnswer</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">ShowAnswer</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">Provider</span>&gt;</span></span><br>  );<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">App</span>;<br></code></pre></td></tr></table></figure></li><li><p>子组件利用connect加强，本案例中ShowAnswer组件需要获取state中的值，另外加减组件需要通过dispatch修改state中的值。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-comment">//ShowAnswer.js</span><br><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; <span class="hljs-title class_">Component</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br><span class="hljs-keyword">import</span> &#123; connect &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react-redux&quot;</span>;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ShowAnswer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Component</span> &#123;<br>  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>&#123;this.props.count&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">MapStateToProps</span> = (<span class="hljs-params">state</span>) =&gt; &#123;<br>  <span class="hljs-keyword">return</span> state;<br>&#125;;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">connect</span>(<span class="hljs-title class_">MapStateToProps</span>)(<span class="hljs-title class_">ShowAnswer</span>);<br><span class="hljs-comment">//语法：connect(MapStateToProps,MapDispatchToProps)(组件名)</span><br></code></pre></td></tr></table></figure><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-comment">//AddButton.js</span><br><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; <span class="hljs-title class_">Component</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br><span class="hljs-keyword">import</span> &#123; connect &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react-redux&quot;</span>;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AddButton</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Component</span> &#123;<br>  handleclick = <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">props</span>.<span class="hljs-title function_">addfuntion</span>();<br>  &#125;;<br>  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> (<br>      <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;this.handleclick&#125;</span>&gt;</span>+<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>    );<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">//注意写法：</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">dispatchfuntion</span> = (<span class="hljs-params">dispatch</span>) =&gt; &#123;<br>  <span class="hljs-keyword">return</span> &#123;<br>    <span class="hljs-attr">addfuntion</span>: <span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-title function_">dispatch</span>(&#123;<br>        <span class="hljs-attr">type</span>: <span class="hljs-string">&quot;add_action&quot;</span>,<br>      &#125;);<br>    &#125;,<br>  &#125;;<br>&#125;;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">connect</span>(<span class="hljs-literal">null</span>, dispatchfuntion)(<span class="hljs-title class_">AddButton</span>);<br><br></code></pre></td></tr></table></figure><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-comment">//ReduceButton.js</span><br><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br><span class="hljs-keyword">import</span> &#123; connect &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react-redux&quot;</span>;<br><br><span class="hljs-comment">//函数式写法</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">ReduButton</span>(<span class="hljs-params">props</span>) &#123;<br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleclick3</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    props.<span class="hljs-title function_">reducefuntion</span>();<br>  &#125;;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;handleclick3&#125;</span>&gt;</span>-<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">reduDispatchFuntion</span> = (<span class="hljs-params">dispatch</span>) =&gt; &#123;<br>  <span class="hljs-keyword">return</span> &#123;<br>    <span class="hljs-attr">reducefuntion</span>: <span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-title function_">dispatch</span>(&#123;<br>        <span class="hljs-attr">type</span>: <span class="hljs-string">&quot;reduce_action&quot;</span>,<br>      &#125;);<br>    &#125;,<br>  &#125;;<br>&#125;;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">connect</span>(<span class="hljs-literal">null</span>, reduDispatchFuntion)(<span class="hljs-title class_">ReduButton</span>);<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <categories>
      
      <category>react</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>react-内置hooks详解</title>
    <link href="/2023/06/11/react-hooks%E8%AF%A6%E8%A7%A3/"/>
    <url>/2023/06/11/react-hooks%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h2 id="一、什么是React-hooks，为什么要有React-hooks？"><a href="#一、什么是React-hooks，为什么要有React-hooks？" class="headerlink" title="一、什么是React hooks，为什么要有React hooks？"></a>一、什么是React hooks，为什么要有React hooks？</h2><p><strong>React Hooks 是 <code>React 16.8</code> 新增的特性，丰富扩展了原有<code>函数组件</code>的功能，让<code>函数组件</code>也有了<code>类组件</code>的一些特性。</strong></p><p>函数组件和类组件的区别：<br>（1）函数组件没有状态（state），类组件有<br>（2）函数组件没有生命周期，类组件有（挂载、更新、销毁）<br>（3）函数组件没有this，类组件有<br>（4）函数组件更适合做UI展示，类组件更适合做复杂的业务逻辑组件</p><h2 id="二、Hooks的用法"><a href="#二、Hooks的用法" class="headerlink" title="二、Hooks的用法:"></a>二、Hooks的用法:</h2><p><strong>1.useState(): 状态钩子</strong></p><p><font color='skyblue'>在<code>类组件</code>中是通过 <code>this.setState </code>来修改类组件中的状态值的，<code>函数组件</code>中则通过 <code>useState</code> 来修改。</font></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">const</span> [state, setState] = <span class="hljs-title function_">useState</span>(initalState); <span class="hljs-comment">// 初始化，state可以任意命名</span><br><span class="hljs-comment">// ...</span><br><span class="hljs-title function_">setState</span>(newState); <span class="hljs-comment">// 修改state的值</span><br></code></pre></td></tr></table></figure><p>代码示例：使用Hooks重写计数器</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">const</span> <span class="hljs-title function_">Count</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-keyword">const</span> [count, setCount] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>); <span class="hljs-comment">// 将0设置为count的初始值</span><br>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">addCount</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>        <span class="hljs-keyword">let</span> newCount = count;<br>        <span class="hljs-title function_">setCount</span>(newCount += <span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> (<br>        <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>&#123;count&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;addCount&#125;</span>&gt;</span>加1<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>    )<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>注意</strong>：在类组件中<font color='yellow'> this.setState 是<code>异步</code>执行</font>的，同样<font color='yellow'> useState 修改状态也是<code>异步</code>的</font>。也就是每次修改状态<code>不是立马生效</code>的。那如何在每次修改状态后可以拿到最新的数据呢？就可以用我们下面讲的<code>useEffect</code>实现。</p><br><p><strong>2.useEffect():</strong></p><p><font color='skyblue'>在<code>类组件</code>中放在 componentDidMount，componentDidUpdate 等执行的请求获取数据的操作，在React Hooks中都可以用 <code>useEffect</code> 来处理。</font></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-comment">// first 此处编写 组件挂载之后和组件重新渲染之后执行的代码</span><br>  ...<br>  <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-comment">// 此处编写 组件即将被卸载前执行的代码  second 主要负责一些清理工作</span><br>    ...<br>  &#125;<br>&#125;, [dep1, dep2 ...]); <span class="hljs-comment">// 依赖数据</span><br><br>    <br><span class="hljs-comment">//注意：useEffect是一个基于依赖的钩子函数，而不要说是生命周期。</span><br><span class="hljs-comment">// 依赖数据不是必填</span><br><span class="hljs-comment">// 当没有依赖项的时候，first函数会在页面初次渲染的时候执行一遍（即没有依赖的东西，自然就不会再执行了），second函数会在组件初次渲染和销毁的时候共执行两次。</span><br><span class="hljs-comment">// 当有依赖项的时候，first函数会在页面初次渲染以及依赖值更新的时候都会执行，second函数会在每次更新以及最后组件销毁的时候都执行。</span><br>    <br></code></pre></td></tr></table></figure><p>useEffect案例：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br><span class="hljs-keyword">import</span> &#123; useState, useEffect &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [type, setType] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">1</span>);<br>  <span class="hljs-keyword">var</span> nowplayingfun = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title function_">setType</span>(<span class="hljs-number">1</span>);<br>  &#125;;<br>  <span class="hljs-keyword">var</span> prepareplaying = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title function_">setType</span>(<span class="hljs-number">2</span>);<br>  &#125;;<br><br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;nowplayingfun&#125;</span>&gt;</span>正在热映<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;prepareplaying&#125;</span>&gt;</span>即将上映<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Detail</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&#123;type&#125;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Detail</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Detail</span>(<span class="hljs-params">props</span>) &#123;<br>  <span class="hljs-keyword">const</span> [filmsinfo, setFilmsinfo] = <span class="hljs-title function_">useState</span>([]);<br> <span class="hljs-comment">//函数式组件请求数据放在useEffect中执行</span><br>  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (props.<span class="hljs-property">type</span> === <span class="hljs-number">1</span>) &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;请求正在热映的数据&quot;</span>);<br>      <span class="hljs-title function_">setFilmsinfo</span>([<span class="hljs-number">11</span>, <span class="hljs-number">22</span>, <span class="hljs-number">33</span>, <span class="hljs-number">44</span>]);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;请求即将上映的数据&quot;</span>);<br>      <span class="hljs-title function_">setFilmsinfo</span>([<span class="hljs-number">55</span>, <span class="hljs-number">66</span>, <span class="hljs-number">77</span>, <span class="hljs-number">88</span>]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-comment">//组件销毁清楚定时器等操作</span><br>    &#125;<br>  &#125;, [props.<span class="hljs-property">type</span>]);<br> <span class="hljs-comment">//当依赖的props.type发生改变的时候，该组件就会重新渲染一遍。</span><br><br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      detail--&#123;props.type&#125;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span></span><br><span class="language-xml">        &#123;filmsinfo.map((item) =&gt; (</span><br><span class="language-xml">          <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&#123;item&#125;</span>&gt;</span>&#123;item&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br><span class="language-xml">        ))&#125;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br><br></code></pre></td></tr></table></figure><br><p><strong>3.useLayoutEffect():</strong></p><p><font color = 'skyblue'>useLayoutEffect 使用方法、所传参数和 useEffect <code>完全相同</code>。大多数情况下将 useEffect 替换成 useLayoutEffect 完全看不出区别。简单来说就是调用时机不同， useLayoutEffect 和原来 componentDidMount &amp; componentDidUpdate 一致，在<br>react完成DOM更新后马上同步调用的代码，会阻塞页面渲染。而 useEffect 是会在整个页面渲染完才会调用的<br>代码。</font></p><br><p><strong>4.useCallback():记忆函数    用于<font color='yellow'>函数缓存</font></strong> </p><p><font color = 'skyblue'><code>useCallback()</code>为记忆函数，它可以防止因为组件重新渲染，导致方法被重新创建，起到缓存作用</font>。语法如下：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">const</span> memoizedCallback = <span class="hljs-title function_">useCallback</span>(<br>  <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-title function_">doSomething</span>(a, b);<br>  &#125;,<br>  [a, b]<br>);<br></code></pre></td></tr></table></figure><p><font color='yellow'><em><strong>useCallback使用场景：避免不必要的函数在页面渲染的时候重复创建，造成资源浪费。</strong></em></font></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><br><span class="hljs-comment">//当页面重新渲染的时候，handleclick1、handleclick2、handleclick3都会被重新创建。</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">const</span> handleclick1 = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-comment">//具体代码</span><br>    &#125;<br>    <span class="hljs-keyword">const</span> handleclick2 = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-comment">//具体代码</span><br>    &#125;<br>    <span class="hljs-keyword">const</span> handleclick3 = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-comment">//具体代码</span><br>    &#125;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>App<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  )<br>&#125;<br></code></pre></td></tr></table></figure><p>改进方法：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; useCallback &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> handleclick1 = <span class="hljs-title function_">useCallback</span>(<br>    <span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-comment">//具体执行代码1</span><br>    &#125;,<br>    [] <span class="hljs-comment">//依赖数据</span><br>  );<br>  <span class="hljs-keyword">const</span> handleclick2 = <span class="hljs-title function_">useCallback</span>(<br>    <span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-comment">//具体执行代码2</span><br>    &#125;,<br>    [] <span class="hljs-comment">//依赖数据</span><br>  );<br>  <span class="hljs-keyword">const</span> handleclick3 = <span class="hljs-title function_">useCallback</span>(<br>    <span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-comment">//具体执行代码3</span><br>    &#125;,<br>    [] <span class="hljs-comment">//依赖数据</span><br>  );<br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>App<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>以下案例只有当msg改变了的时候，才会重新渲染，注意比较useCallback和useMemo的区别</p><p><img src="image-20230923215133427.png" alt="image-20230923215133427"></p><br><p><strong>5.useMemo():记忆组件  <font color='yellow'>与useCallback作用相同，用于缓存，类似vue中的computed</font></strong></p><p><code>useCallback()</code>的功能可以由<code>useMemo()</code>所替代，<code>useMemo()</code>也可以返回一个记忆函数，语法如下：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">const</span> memoizedValue = <span class="hljs-title function_">useMemo</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-comment">// 计算逻辑</span><br>  ...<br>  <span class="hljs-comment">// return res;</span><br>&#125;, [a, b]);<br><br></code></pre></td></tr></table></figure><p><code>useCallback()</code>不会执行第一个参数函数，而是将其返回，<code>useMemo()</code>会执行第一个函数并且将函数执行结果返回给你,useMemo使用场景与vue中计算属性类似。<code>useCallback()</code>常用记忆时间按函数，生成记忆后的时间函数传递给子组件使用，<code>useMemo()</code>更适合经过函数计算得到一个确定的只，比如记忆组件。</p><p>案例：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-comment">// 代码示例</span><br><span class="hljs-keyword">import</span> &#123; useState, useMemo &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Demo</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">const</span> [num, setNum] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">addNum</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>        <span class="hljs-title function_">setNum</span>(num + <span class="hljs-number">100</span>);<br>    &#125;;<br>    <span class="hljs-keyword">const</span> total = <span class="hljs-title function_">useMemo</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;---求和---&#x27;</span>);<br>        <span class="hljs-comment">// 求和计算</span><br>        <span class="hljs-keyword">let</span> temp = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = num; i &gt; <span class="hljs-number">0</span>; i--) &#123;<br>            temp += i;<br>        &#125;<br>        <span class="hljs-keyword">return</span> temp;<br>    &#125;, [num]);<br><br>    <span class="hljs-keyword">return</span> (<br>        <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;addNum&#125;</span>&gt;</span>addNum<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>&#123;`num: $&#123;num&#125;`&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>&#123;`total: $&#123;total&#125;`&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>    )<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">Demo</span>;<br><br></code></pre></td></tr></table></figure><br><p><strong>6.useRef(): 保存引用值</strong></p><p>1.用useRef获取操作dom，<font color = "skyblue">useRef()<code>等价于类组件中的</code>React.createRef(),可以获取节点，通过.current.value可以获取当前节点的值</font></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; useRef &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">APP</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> myref = <span class="hljs-title function_">useRef</span>();<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&#123;myref&#125;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">input</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> &#123;</span><br><span class="language-xml">          console.log(myref, myref.current, myref.current.value);</span><br><span class="language-xml">        &#125;&#125;</span><br><span class="language-xml">      &gt;</span><br><span class="language-xml">        click</span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="image-20230611193843819.png" alt="image-20230611193843819"></p><p>2.useRef可以记忆之前的值，案例如下：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> &#123; useRef &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br><span class="hljs-keyword">import</span> &#123; useState &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [count, setCount] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleclick</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-title function_">setCount</span>(count + <span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">123</span>);<br>    &#125;, <span class="hljs-number">1000</span>);<br>  &#125;;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;handleclick&#125;</span>&gt;</span>click<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">      &#123;count&#125;</span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br><span class="hljs-comment">//分析：此时每次触发handleclick函数，都会生成一个定时器，点击多次的效果就是生成多个定时器，打印的越来越快</span><br></code></pre></td></tr></table></figure><p>普通函数中对于定时器的处理：每次函数执行的时候先清楚当前定时器，再生成新的定时器</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [count, setCount] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">let</span> timer = <span class="hljs-literal">null</span>;<br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleclick</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-comment">// setCount(count + 1);  这句代码执行了会重新渲染页面</span><br>    <span class="hljs-built_in">clearInterval</span>(timer);   <span class="hljs-comment">//清楚当前定时器</span><br>    timer = <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">123</span>);<br>    &#125;, <span class="hljs-number">1000</span>);<br>  &#125;;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;handleclick&#125;</span>&gt;</span>click<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">      &#123;count&#125;</span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br><span class="hljs-comment">//分析：普通函数利用上面的方法能够很好地解决生成多个定时器的问题，但是如果涉及到state状态的改变，会使下面的函数重新执行，新生成函数作用域中无法找到之前定义的timer，进而也就无法清除之前的定时器。</span><br></code></pre></td></tr></table></figure><p>解决办法：利用useRef保存timer    usememo原理与此类似</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [count, setCount] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">const</span> timer = <span class="hljs-title function_">useRef</span>(<span class="hljs-literal">null</span>);<br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleclick</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-title function_">setCount</span>(count + <span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">clearInterval</span>(timer.<span class="hljs-property">current</span>);<br>    timer.<span class="hljs-property">current</span> = <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">123</span>);<br>    &#125;, <span class="hljs-number">1000</span>);<br>  &#125;;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;handleclick&#125;</span>&gt;</span>click<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">      &#123;count&#125;</span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><p>3.useRef在组件上的使用，需要使用<strong>forwardRef</strong>进行转发</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> &#123; useRef, forwardRef &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">Myinput</span> = <span class="hljs-title function_">forwardRef</span>(<span class="hljs-keyword">function</span> <span class="hljs-title function_">Myinput</span>(<span class="hljs-params">props, myref</span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&#123;myref&#125;</span> /&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;);<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> myref = <span class="hljs-title function_">useRef</span>(<span class="hljs-literal">null</span>);<br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleclick</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(myref.<span class="hljs-property">current</span>);<br>    myref.<span class="hljs-property">current</span>.<span class="hljs-property">style</span>.<span class="hljs-property">backgroundColor</span> = <span class="hljs-string">&quot;red&quot;</span>;<br>  &#125;;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;handleclick&#125;</span>&gt;</span>click<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Myinput</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&#123;myref&#125;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Myinput</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><br><p><strong>7.useImperativeHandle 与useref配合使用：自定义子组件暴露的方法</strong></p><p><code>useImperativeHandle</code> 可以让你在使用 <code>ref</code> 时自定义暴露给父组件的实例值。在大多数情况下，应当避免使用 ref 这样的命令式代码。<code>useImperativeHandle</code> 应当与 <a href="https://react.zcopy.site/docs/react-api.html#reactforwardref"><code>forwardRef</code></a> 一起使用：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">FancyInput</span>(<span class="hljs-params">props, ref</span>) &#123;<br>  <span class="hljs-keyword">const</span> inputRef = <span class="hljs-title function_">useRef</span>();<br>  <span class="hljs-title function_">useImperativeHandle</span>(ref, <span class="hljs-function">() =&gt;</span> (&#123;<br>    <span class="hljs-attr">focus</span>: <span class="hljs-function">() =&gt;</span> &#123;<br>      inputRef.<span class="hljs-property">current</span>.<span class="hljs-title function_">focus</span>();<br>    &#125;<br>  &#125;));<br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&#123;inputRef&#125;</span> <span class="hljs-attr">...</span> /&gt;</span></span>;<br>&#125;<br><span class="hljs-title class_">FancyInput</span> = <span class="hljs-title function_">forwardRef</span>(<span class="hljs-title class_">FancyInput</span>);<br><br><span class="hljs-comment">//在本例中，渲染 &lt;FancyInput ref=&#123;inputRef&#125; /&gt; 的父组件可以调用 inputRef.current.focus()。</span><br></code></pre></td></tr></table></figure><br><p><strong>8.useContext()：<font color='yellow'>useContext用于多层级组件的数据传递</font>数据共享，用于减少组件层级，类比类组件中context模式(provider,consumer)</strong></p><p>关于react中组件间通信的方式详解请点击 <a href="https://yang-fan01.gitee.io/2023/06/09/react%E7%BB%84%E4%BB%B6%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F/">https://yang-fan01.gitee.io/2023/06/09/react%E7%BB%84%E4%BB%B6%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F/</a></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-comment">//案例  组件层级  &lt;APP&gt;&lt;Content&gt;&lt;Title&gt;&lt;/Title&gt;&lt;/Content&gt;&lt;/APP&gt; 需要再Title组件中获取App组件中的值</span><br><br><span class="hljs-keyword">import</span> &#123; createContext, useContext, useState &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">MyContext</span> = <span class="hljs-title function_">createContext</span>(<span class="hljs-number">0</span>);  <span class="hljs-comment">//创建全局的context对象</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [count, setCount] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      hello app</span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">MyContext.Provider</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;count&#125;</span>&gt;</span>   //找到需要通信的组件公共的父组件，该父组件担任provider，value传递数据，value中可以是一个值，也可以是对象和数组</span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">Content</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Content</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">MyContext.Provider</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Title</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> titlecount = <span class="hljs-title function_">useContext</span>(<span class="hljs-title class_">MyContext</span>);  <span class="hljs-comment">//子组件通过useContext获取值</span><br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>hello title &#123;titlecount&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Content</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      hello content</span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Title</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><br><p><strong>9.useReducer()：Action钩子</strong></p><p><a href="https://react.zcopy.site/docs/hooks-reference.html#usestate"><code>useState</code></a> 的替代方案。它接收一个形如 <code>(state, action) =&gt; newState</code> 的 reducer，并返回当前的 state 以及与其配套的 <code>dispatch</code> 方法</p><p><font color='yellow'>reducer可以整合组件的状态的更新逻辑</font></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-comment">//useState写法</span><br><span class="hljs-keyword">import</span> &#123; useState &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [count, setCount] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleAdd</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-title function_">setCount</span>(count + <span class="hljs-number">1</span>);<br>  &#125;;<br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleReduce</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-title function_">setCount</span>(count - <span class="hljs-number">1</span>);<br>  &#125;;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      &#123;count&#125;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;handleAdd&#125;</span>&gt;</span>+<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;handleReduce&#125;</span>&gt;</span>-<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-comment">//useReducer写法</span><br><span class="hljs-keyword">import</span> &#123; useReducer &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br><br><span class="hljs-keyword">const</span> initialstate = &#123; <span class="hljs-attr">count</span>: <span class="hljs-number">0</span> &#125;; <span class="hljs-comment">//定义初始值</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">myreducer</span>(<span class="hljs-params">state, action</span>) &#123;  <br>  <span class="hljs-keyword">switch</span> (action.<span class="hljs-property">type</span>) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;add&quot;</span>:<br>      <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">count</span>: state.<span class="hljs-property">count</span> + <span class="hljs-number">1</span> &#125;;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;reduce&quot;</span>:<br>      <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">count</span>: state.<span class="hljs-property">count</span> - <span class="hljs-number">1</span> &#125;;<br>    <span class="hljs-attr">default</span>:<br>      <span class="hljs-keyword">return</span>;<br>  &#125;<br>&#125;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [state, dispatch] = <span class="hljs-title function_">useReducer</span>(myreducer, initialstate);<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      &#123;state.count&#125;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> dispatch(&#123; type: &quot;add&quot; &#125;)&#125;&gt;+<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> dispatch(&#123; type: &quot;reduce&quot; &#125;)&#125;&gt;-<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br><br></code></pre></td></tr></table></figure><p>注：useReducer和useContext一起使用，可以实现兄弟组件间的共享状态。</p><p>方法：</p><p>1, 创建一个组件Provide包含这两个兄弟组件</p><p>2, 在创建的Provide组件中利用 createContext 创建共享平台,利用useReducer管理组件的状态和方法。</p><p>3, 子组件通过useContext获取Provide组件中的状态和方法。</p><br><p>其余hooks函数见react官网</p><p><a href="https://react.zcopy.site/docs/hooks-reference.html">https://react.zcopy.site/docs/hooks-reference.html</a></p><p><img src="image-20230923220739381.png" alt="image-20230923220739381"></p>]]></content>
    
    
    <categories>
      
      <category>react</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>react生命周期</title>
    <link href="/2023/06/10/react%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <url>/2023/06/10/react%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="react生命周期"><a href="#react生命周期" class="headerlink" title="react生命周期"></a>react生命周期</h1><h2 id="一、初始化阶段"><a href="#一、初始化阶段" class="headerlink" title="一、初始化阶段"></a>一、初始化阶段</h2><ul><li><strong>componentWillMount</strong></li><li><strong>render</strong></li><li><strong>componentDidMount</strong></li></ul><p><code>componentWillMount</code>:第一次上树前的最后一次修改状态的机会。 （不安全）</p><p>应用：初始化数据。</p><p><code>render</code>：渲染页面，dom树，<font color='yellow'>不允许render中改变state状态值</font>，会陷入死循环。</p><p><code>componentDidMount</code>：页面dom节点渲染完毕。</p><p>应用：1.数据请求 axios；</p><p>​2.订阅函数调用，订阅方法见“react组件通信方法”一文；</p><p>​3.定时器 setInterval；</p><p>​4.基础创建完的dom进行初始化，。。如BetterScroll。</p><h2 id="二、运行中阶段"><a href="#二、运行中阶段" class="headerlink" title="二、运行中阶段"></a>二、运行中阶段</h2><ul><li><strong>componentWillReceivePeops</strong> : 父组件修改属性触发，可以<font color='yellow'>最先获得父组件传来的属性</font>，可以利用属性进行ajax或者逻辑处理。</li><li><strong>shouldComponentUpdata(nextProps,nextState):</strong> 该函数里面this.state是旧的函数值，返回false会阻止更新；（***<font color="red">性能优化函数</font>***）</li><li><strong>componetWillUpdata：</strong>（不安全）只能拿到旧的状态值，<font color='yellow'>不能更新状态</font>，因为只要setstate，就又要执行componetWillUpdata &#x3D;&gt; render &#x3D;&gt; componentDidUpdata这个过程，又将陷入死循环。</li><li><strong>render</strong>： 只能访问this.props和this.state，<font color='yellow'>不允许修改状态和dom输出</font>,会死循环；</li><li>**componentDidUpdata(prevProps,prevState)**： 该函数里面this.state是新的状态值，可以修改dom，可以传参数获取旧状态值。</li></ul><p>应用：</p><p>1：componentDidUpdata会多次执行，为了避免多次执行，可以给该方法传递参数，通过判断参数中旧状态的值来决定是否执行某段代码。例如：</p><p><img src="image-20230610143325141.png" alt="image-20230610143325141"></p><p>2.shouldComponentUpdata(nextProps,nextState)用于判断是否更新，当状态值没变的时候控制不更新，可以优化速度。</p><p><img src="image-20230610144658423.png" alt="image-20230610144658423"></p><h2 id="三、销毁阶段"><a href="#三、销毁阶段" class="headerlink" title="三、销毁阶段"></a>三、销毁阶段</h2><ul><li><strong>componentWillUnmount</strong>: 在删除组件之前进行清理操作，如计时器和事件监听器。</li></ul><h2 id="四、新生命周期"><a href="#四、新生命周期" class="headerlink" title="四、新生命周期"></a>四、新生命周期</h2><p><strong>老生命周期的问题：</strong></p><p>(1) componentWillMount ,在ssr中 这个方法将会被多次调用， 所以会重复触发多遍，同时在这里如果绑定事件，将无法解绑，导致内存泄漏 ， 变得不够安全高效逐步废弃。</p><p>(2) componentWillReceiveProps 外部组件多次频繁更新传入多次不同的 props，会导致不必要的异步请求</p><p>(3) componetWillupdate, 更新前记录 DOM 状态, 可能会做一些处理，与componentDidUpdate相隔时间如果过长， 会导致状态不可信。</p><p><strong>新生命周期的替代</strong></p><p>（1）<strong>getDerivedStateFromProps（nextProps,nextState）</strong> <strong>第一次的初始化组件以及后续的更新过程中(包括自身状态更新以及父传子)都会触发</strong> ，返回一个对象作为新的state，返回null则说明不需要在这里更新state；</p><p>getDerivedStateFromProps可以代替componentWillMount 和componentWillReceiveProps 。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-comment">//老的生命周期的写法 </span><br><span class="hljs-title function_">componentDidMount</span>(<span class="hljs-params"></span>) &#123; <br>    <span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">props</span>.<span class="hljs-property">value</span>!==<span class="hljs-literal">undefined</span>)&#123; <br>        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123; <span class="hljs-attr">current</span>:<span class="hljs-variable language_">this</span>.<span class="hljs-property">props</span>.<span class="hljs-property">value</span> &#125;) <br>    &#125; <br>&#125;<br><span class="hljs-title function_">componentWillReceiveProps</span>(<span class="hljs-params">nextProps</span>)&#123; <br>    <span class="hljs-keyword">if</span>(nextProps.<span class="hljs-property">value</span> !==<span class="hljs-literal">undefined</span>)&#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123; <span class="hljs-attr">current</span>:nextProps.<span class="hljs-property">value</span> &#125;) <br>    &#125; <br>&#125;<br><span class="hljs-comment">// 新的生命周期写法 </span><br><span class="hljs-keyword">static</span> <span class="hljs-title function_">getDerivedStateFromProps</span>(<span class="hljs-params">nextProps</span>) &#123; <br>    <span class="hljs-keyword">if</span>(nextProps.<span class="hljs-property">value</span>!==<span class="hljs-literal">undefined</span>)&#123; <br>        <span class="hljs-keyword">return</span> &#123; <br>            <span class="hljs-attr">current</span>:nextProps.<span class="hljs-property">value</span> <br>        &#125; <br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span> <br>&#125;<br></code></pre></td></tr></table></figure><p> (2) <strong>getSnapshotBeforeUpdate</strong> 取代了 componetWillUpdate ,触发时间为update发生的时候，在<strong>render之后dom渲染之前</strong>返回一个值，该函数return返回的值作为componentDidUpdate的第三个参数。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-comment">//新的数据不断插入数据前面， 导致我正在看的数据向下走，如何保持可视区依旧是我之前看的数据呢？ </span><br><span class="hljs-title function_">getSnapshotBeforeUpdate</span>(<span class="hljs-params"></span>)&#123; <br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">refs</span>.<span class="hljs-property">wrapper</span>.<span class="hljs-property">scrollHeight</span> <br>&#125;<br><span class="hljs-title function_">componentDidUpdate</span>(<span class="hljs-params">prevProps, prevState,preHeight</span>) &#123;<br>    <span class="hljs-comment">//if(preHeight===200)return ; </span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">refs</span>.<span class="hljs-property">wrapper</span>.<span class="hljs-property">scrollTop</span> +=<span class="hljs-variable language_">this</span>.<span class="hljs-property">refs</span>.<span class="hljs-property">wrapper</span>.<span class="hljs-property">scrollHeight</span>-preHeight <br>&#125;<br>&lt;div style=&#123;&#123;<span class="hljs-attr">height</span>:<span class="hljs-string">&quot;200px&quot;</span>,<span class="hljs-attr">overflow</span>:<span class="hljs-string">&quot;auto&quot;</span>&#125;&#125;&#125; <br>    ref=<span class="hljs-string">&quot;wrapper&quot;</span>&gt; <br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span>......... <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span> <br>&lt;/div&gt;<br></code></pre></td></tr></table></figure><h3 id="附：性能优化函数案例shouldComponentUpdate"><a href="#附：性能优化函数案例shouldComponentUpdate" class="headerlink" title="附：性能优化函数案例shouldComponentUpdate"></a>附：性能优化函数案例shouldComponentUpdate</h3><p>效果：输入框输入值，对应下标值的框改变颜色</p><p><img src="image-20230610174632977.png" alt="image-20230610174632977"></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-comment">//父组件</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; <span class="hljs-title class_">Component</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-title class_">Box</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./Box&quot;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;./22.css&quot;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Component</span> &#123;<br>  state = &#123;<br>    <span class="hljs-attr">list</span>: [<span class="hljs-string">&quot;11&quot;</span>, <span class="hljs-string">&quot;22&quot;</span>, <span class="hljs-string">&quot;33&quot;</span>, <span class="hljs-string">&quot;44&quot;</span>, <span class="hljs-string">&quot;55&quot;</span>, <span class="hljs-string">&quot;66&quot;</span>, <span class="hljs-string">&quot;77&quot;</span>, <span class="hljs-string">&quot;88&quot;</span>, <span class="hljs-string">&quot;99&quot;</span>, <span class="hljs-string">&quot;00&quot;</span>],<br>    <span class="hljs-attr">current</span>: <span class="hljs-number">2</span>,<br>  &#125;;<br>  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> (<br>      <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">input</span></span></span><br><span class="hljs-tag"><span class="language-xml">          <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;number&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">          <span class="hljs-attr">style</span>=<span class="hljs-string">&#123;&#123;</span> <span class="hljs-attr">overflow:</span> &quot;<span class="hljs-attr">hidden</span>&quot; &#125;&#125;</span></span><br><span class="hljs-tag"><span class="language-xml">          <span class="hljs-attr">onChange</span>=<span class="hljs-string">&#123;(evt)</span> =&gt;</span> &#123;</span><br><span class="language-xml">            this.setState(&#123;</span><br><span class="language-xml">              current: Number(evt.target.value),</span><br><span class="language-xml">            &#125;);</span><br><span class="language-xml">          &#125;&#125;</span><br><span class="language-xml">        &gt;<span class="hljs-tag">&lt;/<span class="hljs-name">input</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">          &#123;this.state.list.map((item, index) =&gt; (</span><br><span class="language-xml">&#123;//通过判断当前下标与输入值是否相等决定是否添加样式&#125;</span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">Box</span> <span class="hljs-attr">index</span>=<span class="hljs-string">&#123;index&#125;</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&#123;item&#125;</span> <span class="hljs-attr">current</span>=<span class="hljs-string">&#123;this.state.current&#125;</span>&gt;</span></span><br><span class="language-xml">              &#123;item&#125;</span><br><span class="language-xml">            <span class="hljs-tag">&lt;/<span class="hljs-name">Box</span>&gt;</span></span><br><span class="language-xml">          ))&#125;</span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">        &#123;console.log(this.props)&#125;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>    );<br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-comment">//子组件</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; <span class="hljs-title class_">Component</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;./22.css&quot;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Box</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Component</span> &#123;<br>  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;render&quot;</span>);<br>    <span class="hljs-keyword">return</span> (<br>      <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;box&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">style</span>=<span class="hljs-string">&#123;&#123;</span></span></span><br><span class="hljs-tag"><span class="language-xml">          <span class="hljs-attr">border:</span></span></span><br><span class="hljs-tag"><span class="language-xml">            <span class="hljs-attr">this.props.current</span> === <span class="hljs-string">this.props.index</span></span></span><br><span class="hljs-tag"><span class="language-xml">              ? &quot;<span class="hljs-attr">1px</span> <span class="hljs-attr">solid</span> <span class="hljs-attr">red</span>&quot;</span></span><br><span class="hljs-tag"><span class="language-xml">              <span class="hljs-attr">:</span> &quot;<span class="hljs-attr">1px</span> <span class="hljs-attr">solid</span> <span class="hljs-attr">gray</span>&quot;,</span></span><br><span class="hljs-tag"><span class="language-xml">        &#125;&#125;</span></span><br><span class="hljs-tag"><span class="language-xml">      &gt;</span></span><br><span class="language-xml">        &#123;this.props.children&#125;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>    );<br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>注意：此时效果可以实现，但是每次更改输入框的值，十个框都会重新渲染一遍，浪费内存。如下图所示：</p><p><img src="image-20230610175410224.png" alt="image-20230610175410224"></p><p>期待效果：每次输入框的值改变以后，只移除原来那个框的红色样式和给新框添加上红色边框样式，而其余的不重新渲染。</p><p>实现方法：在子组件中通过<code>shouldComponentUpdate</code>控制当前组件是否渲染。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Box</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Component</span> &#123;<br>  <span class="hljs-title function_">shouldComponentUpdate</span>(<span class="hljs-params">nextProps</span>) &#123;<br>    <span class="hljs-keyword">if</span> (<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">props</span>.<span class="hljs-property">current</span> === <span class="hljs-variable language_">this</span>.<span class="hljs-property">props</span>.<span class="hljs-property">index</span> ||<br>      nextProps.<span class="hljs-property">index</span> === nextProps.<span class="hljs-property">current</span><br>    ) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  &#125;<br></code></pre></td></tr></table></figure><p>效果：只会在第一次渲染到页面的时候会执行十次render函数，后面更改输入框的值的时候，只会执行旧框和新选择框的render函数。</p><p><img src="image-20230610175541280.png" alt="image-20230610175541280"></p><h3 id="性能优化-方案二-PureComponent"><a href="#性能优化-方案二-PureComponent" class="headerlink" title="性能优化 方案二 PureComponent"></a>性能优化 方案二 PureComponent</h3><p>PureComponent是react官方提供的，会自动比较新旧props、state（值相等,或者对象含有相同的属性、且属性值相等 ），决定shouldcomponentUpdate 返回true 或者false， 从而决定要不要呼叫 render function。</p><p>使用方法：引用的时候<code>import React &#123;PureComponet&#125; from react</code>即可。</p><p>注意：如果你的 state 或 props 『永远都会变』，那 PureComponent 不适合，因为 shallowEqual 也需要花时间。</p>]]></content>
    
    
    <categories>
      
      <category>react</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>react组件间的通信方式</title>
    <link href="/2023/06/09/react%E7%BB%84%E4%BB%B6%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F/"/>
    <url>/2023/06/09/react%E7%BB%84%E4%BB%B6%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="一、父子组件之间通信"><a href="#一、父子组件之间通信" class="headerlink" title="一、父子组件之间通信"></a>一、父子组件之间通信</h2><p>父子之间通信都是通过props来实现</p><p>口诀：父传子，靠属性，子传父，靠回调函数。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-comment">//父传子案例</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; <span class="hljs-title class_">Component</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br><br><span class="hljs-comment">// 父组件</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Component</span> &#123;<br>  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> (<br>      <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">Navbar</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;detailinfo&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Navbar</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>    );<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">//子组件 用props接受传递的属性值</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Navbar</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Component</span> &#123;<br>  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>&#123;this.props.value&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>子传父 下面是一个子组件输入框提交到父组件的案例</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; <span class="hljs-title class_">Component</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br><br><span class="hljs-comment">// 父组件</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Component</span> &#123;<br>  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> (<br>      <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">Navbar</span></span></span><br><span class="hljs-tag"><span class="language-xml">          <span class="hljs-attr">evt</span>=<span class="hljs-string">&#123;(value)</span> =&gt;</span> &#123;</span><br><span class="language-xml">            console.log(&quot;父组件获取到子组件中的值&quot;, value);</span><br><span class="language-xml">          &#125;&#125;</span><br><span class="language-xml">        &gt;<span class="hljs-tag">&lt;/<span class="hljs-name">Navbar</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>    );<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">//子组件</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Navbar</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Component</span> &#123;<br>  state = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;zhangsan&quot;</span>,<br>  &#125;;<br>  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> (<br>      <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">input</span></span></span><br><span class="hljs-tag"><span class="language-xml">          <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;this.state.name&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">          <span class="hljs-attr">onChange</span>=<span class="hljs-string">&#123;(e)</span> =&gt;</span> &#123;</span><br><span class="language-xml">            this.setState(&#123;</span><br><span class="language-xml">              name: e.target.value,</span><br><span class="language-xml">            &#125;);</span><br><span class="language-xml">          &#125;&#125;</span><br><span class="language-xml">        &gt;<span class="hljs-tag">&lt;/<span class="hljs-name">input</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> this.props.evt(this.state.name)&#125;&gt;提交<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>  //执行父组件回调函数</span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="二、亲兄弟之间通信（中间人模式）"><a href="#二、亲兄弟之间通信（中间人模式）" class="headerlink" title="二、亲兄弟之间通信（中间人模式）"></a>二、亲兄弟之间通信（中间人模式）</h2><p>亲兄弟之间的通信方式：中间人模式，也叫状态提升，即通过父子之间的通信，让父组件作为中间人实现亲兄弟之间的通信。</p><p><img src="image-20230609164727800.png" alt="image-20230609164727800"></p><p>中间人模式案例：案例左侧为电影信息列表，当点击电影列表之后，右侧固定区域会显示详情信息。</p><p><img src="image-20230609182430119.png" alt="image-20230609182430119"></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-comment">//父组件</span><br><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; <span class="hljs-title class_">Component</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br><span class="hljs-keyword">import</span> axios <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;axios&quot;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-title class_">FIlms</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./FIlms&quot;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-title class_">Detail</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./Detail&quot;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;./css/1.css&quot;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Component</span> &#123;<br>  state = &#123;<br>    <span class="hljs-attr">filmslist</span>: [],<br>    <span class="hljs-attr">info</span>: <span class="hljs-string">&quot;&quot;</span>,<br>  &#125;;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">super</span>();<br><span class="hljs-comment">//第一步：父组件获取电影列表信息</span><br>    <span class="hljs-title function_">axios</span>(&#123;<br>      <span class="hljs-attr">url</span>: <span class="hljs-string">&quot;https://m.maizuo.com/gateway?cityId=110100&amp;pageNum=1&amp;pageSize=10&amp;type=1&amp;k=4586297&quot;</span>,<br>      <span class="hljs-attr">method</span>: <span class="hljs-string">&quot;get&quot;</span>,<br>      <span class="hljs-attr">headers</span>: &#123;<br>        <span class="hljs-string">&quot;X-Client-Info&quot;</span>:<br>          <span class="hljs-string">&#x27;&#123;&quot;a&quot;:&quot;3000&quot;,&quot;ch&quot;:&quot;1002&quot;,&quot;v&quot;:&quot;5.2.1&quot;,&quot;e&quot;:&quot;16861261876689420153454593&quot;&#125;&#x27;</span>,<br>        <span class="hljs-string">&quot;X-Host&quot;</span>: <span class="hljs-string">&quot;mall.film-ticket.film.list&quot;</span>,<br>      &#125;,<br>    &#125;)<br>      .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;<br>        <span class="hljs-comment">// console.log(res.data.data.films);</span><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123;<br>          <span class="hljs-attr">filmslist</span>: res.<span class="hljs-property">data</span>.<span class="hljs-property">data</span>.<span class="hljs-property">films</span>,<br>        &#125;);<br>      &#125;)<br>      .<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err);<br>      &#125;);<br>  &#125;<br>  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> (<br><span class="hljs-comment">//第二步：父组件将数据电影列表数据传递给电影列表组件。传递的属性过多的时候，可以直接采用...展开运算符传递整个对象。</span><br>      <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">        &#123;this.state.filmslist.map((item) =&gt; &#123;</span><br><span class="language-xml">          return (</span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">FIlms</span></span></span><br><span class="hljs-tag"><span class="language-xml">              <span class="hljs-attr">key</span>=<span class="hljs-string">&#123;item.filmId&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">              &#123;<span class="hljs-attr">...item</span>&#125;</span></span><br><span class="hljs-tag"><span class="language-xml">              &#123;//<span class="hljs-attr">第四步</span>：<span class="hljs-attr">自传父回调函数</span>&#125;</span></span><br><span class="hljs-tag"><span class="language-xml">              <span class="hljs-attr">myevt</span>=<span class="hljs-string">&#123;(value)</span> =&gt;</span> &#123;</span><br><span class="language-xml">                this.setState(&#123;</span><br><span class="language-xml">                  info: value,</span><br><span class="language-xml">                &#125;);</span><br><span class="language-xml">              &#125;&#125;</span><br><span class="language-xml">            &gt;</span><br><span class="language-xml">            <span class="hljs-tag">&lt;/<span class="hljs-name">FIlms</span>&gt;</span></span><br><span class="language-xml">          );</span><br><span class="language-xml">        &#125;)&#125;</span><br><span class="language-xml"> &#123;//第五步：父组件通过属性传值，将电影组件点击的时候传递过来的详情数据又传递给详情组件。&#125;</span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">Detail</span> <span class="hljs-attr">info</span>=<span class="hljs-string">&#123;this.state.info&#125;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Detail</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-comment">//电影列表组件</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; <span class="hljs-title class_">Component</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FIlms</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Component</span> &#123;<br>  state = &#123;<br>    <span class="hljs-attr">info</span>: <span class="hljs-string">&quot;&quot;</span>,<br>  &#125;;<br>  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br><span class="hljs-comment">//第三步：接受父组件的传值</span><br>    <span class="hljs-keyword">let</span> &#123; poster, name, synopsis &#125; = <span class="hljs-variable language_">this</span>.<span class="hljs-property">props</span>;<br>    <span class="hljs-keyword">return</span> (<br><span class="hljs-comment">//第四步：点击单个电影列表的时候，通过回调函数将当前点击的电影详情传递给父组件。</span><br>      <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> &#123;</span><br><span class="language-xml">          this.props.myevt(synopsis);</span><br><span class="language-xml">        &#125;&#125;</span><br><span class="language-xml">      &gt;</span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&#123;poster&#125;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;name&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">img</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>&#123;name&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-comment">//详情组件</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; <span class="hljs-title class_">Component</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Detail</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Component</span> &#123;<br>  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;detail&quot;</span>&gt;</span>&#123;this.props.info&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="三、发布订阅者模式-subscribe-publish-（并非react独有的，而是原生js的）"><a href="#三、发布订阅者模式-subscribe-publish-（并非react独有的，而是原生js的）" class="headerlink" title="三、发布订阅者模式(subscribe  publish)（并非react独有的，而是原生js的）"></a>三、发布订阅者模式(subscribe  publish)（并非react独有的，而是原生js的）</h2><p>原理：通过设置一个公共平台，订阅者(subscribe)传回调函数到该平台，当发布者(publish)一执行的时候就执行订阅者的回调函数式,publish()函数调用的参数会传递到subscribe中。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; <span class="hljs-title class_">Component</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Component</span> &#123;<br>  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>main<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">//调度平台</span><br><span class="hljs-keyword">var</span> bus = &#123;<br>  <span class="hljs-attr">list</span>: [], <span class="hljs-comment">//用于保存订阅的回调函数</span><br>  <span class="hljs-comment">// 订阅者</span><br>  <span class="hljs-title function_">subsctibe</span>(<span class="hljs-params">callback</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">list</span>.<span class="hljs-title function_">push</span>(callback);<br>  &#125;,<br>  <span class="hljs-comment">//发布者   一发布的时候就执行订阅者的回调函数</span><br>  <span class="hljs-title function_">publish</span>(<span class="hljs-params">value</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">list</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">fun</span>) =&gt;</span> &#123;<br>      fun &amp;&amp; <span class="hljs-title function_">fun</span>(value);<br>    &#125;);<br>  &#125;,<br>&#125;;<br><br><span class="hljs-comment">//必须先订阅再发布</span><br>bus.<span class="hljs-title function_">subsctibe</span>(<span class="hljs-function">(<span class="hljs-params">val</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;订阅1111&quot;</span>, val);<br>&#125;);<br>bus.<span class="hljs-title function_">subsctibe</span>(<span class="hljs-function">(<span class="hljs-params">val</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;订阅222&quot;</span>, val);<br>&#125;);<br><br>bus.<span class="hljs-title function_">publish</span>(<span class="hljs-string">&quot;发布的参数值&quot;</span>);<br><br></code></pre></td></tr></table></figure><p>发布订阅者案例：同为上面电影列表详情，用发布订阅者方法实现：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; <span class="hljs-title class_">Component</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br><span class="hljs-keyword">import</span> axios <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;axios&quot;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;./css/1.css&quot;</span>;<br><br><span class="hljs-comment">//设置调度中心</span><br><span class="hljs-keyword">var</span> bus = &#123;<br>  <span class="hljs-attr">list</span>: [], <span class="hljs-comment">//用于保存订阅的回调函数</span><br>  <span class="hljs-comment">// 订阅者</span><br>  <span class="hljs-title function_">subsctibe</span>(<span class="hljs-params">callback</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">list</span>.<span class="hljs-title function_">push</span>(callback);<br>  &#125;,<br>  <span class="hljs-comment">//发布者   一发布的时候就执行订阅者的回调函数</span><br>  <span class="hljs-title function_">publish</span>(<span class="hljs-params">value</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">list</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">fun</span>) =&gt;</span> &#123;<br>      fun &amp;&amp; <span class="hljs-title function_">fun</span>(value);<br>    &#125;);<br>  &#125;,<br>&#125;;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Component</span> &#123;<br>  state = &#123;<br>    <span class="hljs-attr">filmslist</span>: [],<br>  &#125;;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">super</span>();<br>    <span class="hljs-title function_">axios</span>(&#123;<br>      <span class="hljs-attr">url</span>: <span class="hljs-string">&quot;https://m.maizuo.com/gateway?cityId=110100&amp;pageNum=1&amp;pageSize=10&amp;type=1&amp;k=4586297&quot;</span>,<br>      <span class="hljs-attr">method</span>: <span class="hljs-string">&quot;get&quot;</span>,<br>      <span class="hljs-attr">headers</span>: &#123;<br>        <span class="hljs-string">&quot;X-Client-Info&quot;</span>:<br>          <span class="hljs-string">&#x27;&#123;&quot;a&quot;:&quot;3000&quot;,&quot;ch&quot;:&quot;1002&quot;,&quot;v&quot;:&quot;5.2.1&quot;,&quot;e&quot;:&quot;16861261876689420153454593&quot;&#125;&#x27;</span>,<br>        <span class="hljs-string">&quot;X-Host&quot;</span>: <span class="hljs-string">&quot;mall.film-ticket.film.list&quot;</span>,<br>      &#125;,<br>    &#125;)<br>      .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;<br>        <span class="hljs-comment">// console.log(res.data.data.films);</span><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123;<br>          <span class="hljs-attr">filmslist</span>: res.<span class="hljs-property">data</span>.<span class="hljs-property">data</span>.<span class="hljs-property">films</span>,<br>        &#125;);<br>      &#125;)<br>      .<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err);<br>      &#125;);<br>  &#125;<br>  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> (<br>      <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">        &#123;this.state.filmslist.map((item) =&gt; &#123;</span><br><span class="language-xml">          return (</span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">FIlms</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&#123;item.filmId&#125;</span> &#123;<span class="hljs-attr">...item</span>&#125;&gt;</span></span><br><span class="language-xml">              films</span><br><span class="language-xml">            <span class="hljs-tag">&lt;/<span class="hljs-name">FIlms</span>&gt;</span></span><br><span class="language-xml">          );</span><br><span class="language-xml">        &#125;)&#125;</span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">Detail</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Detail</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>    );<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">//订阅者</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Detail</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Component</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">super</span>();<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = &#123;<br>      <span class="hljs-attr">info1</span>: <span class="hljs-string">&quot;&quot;</span>,<br>    &#125;;<br> <span class="hljs-comment">//设置订阅回调函数</span><br>    bus.<span class="hljs-title function_">subsctibe</span>(<span class="hljs-function">(<span class="hljs-params">info</span>) =&gt;</span> &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123;<br>        <span class="hljs-attr">info1</span>: info,<br>      &#125;);<br>    &#125;);<br>  &#125;<br>  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;detail&quot;</span>&gt;</span>&#123;this.state.info1&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">//发布者</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">FIlms</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Component</span> &#123;<br>  state = &#123;<br>    <span class="hljs-attr">info</span>: <span class="hljs-string">&quot;&quot;</span>,<br>  &#125;;<br>  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">let</span> &#123; poster, name, synopsis &#125; = <span class="hljs-variable language_">this</span>.<span class="hljs-property">props</span>;<br>    <span class="hljs-keyword">return</span> (<br>      <span class="hljs-comment">//发布成功以后立即执行订阅回调函数</span><br>      <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> &#123;</span><br><span class="language-xml">          bus.publish(synopsis);</span><br><span class="language-xml">        &#125;&#125;</span><br><span class="language-xml">      &gt;</span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&#123;poster&#125;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;name&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">img</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>&#123;name&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>    );<br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="四、多层级组件传值context方案（provider、consumer）"><a href="#四、多层级组件传值context方案（provider、consumer）" class="headerlink" title="四、多层级组件传值context方案（provider、consumer）"></a>四、多层级组件传值context方案（provider、consumer）</h2><p>类比现实：类似现实世界中的通信，比如电信运营商就是一个provider生产者，所有办了电信卡的就是consumer消费者，provider生产者提供有“打电话”、“发短信”等服务，consumer消费者便可使用这些服务，非consumer则不能使用这些服务。</p><p><img src="image-20230610123624732.png" alt="image-20230610123624732"></p><p>组件间的context方案：</p><p>1.利用react官方提供的方法先创建全局的context对象。<code>const MyGlobalContext = React.createContext()</code></p><p>2.找到需要通信的组件公共的父组件，该父组件担任provider。将该组件render部分html放在<code>&lt;MyGlobalContext.Provider value=&quot;服务&quot;&gt;&lt;/MyGlobalContext.Provider&gt;</code>里面。</p><p>3.将需要通信的组件render中html代码用<code>&lt;MyGlobalContext.consumer&gt;&lt;/MyGlobalContext.consumer&gt;</code>包裹，但是要<font color="yellow">注意要使用回调函数方法</font>，回调函数中value接受需要的服务。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; <span class="hljs-title class_">Component</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br><br><span class="hljs-comment">//第一步：创建全局的context对象</span><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">MyGlobalContext</span> = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">createContext</span>();<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">main</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Component</span> &#123;<br>  state = &#123;<br>    <span class="hljs-attr">info</span>: <span class="hljs-string">&quot;111&quot;</span>,<br>  &#125;;<br>  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br><span class="hljs-comment">//第二步：公共的父组件为provider，value属性传递服务。</span><br>    <span class="hljs-keyword">return</span> (<br>      <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">MyGlobalContext.Provider</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;&#123;</span></span></span><br><span class="hljs-tag"><span class="language-xml">          <span class="hljs-attr">info:</span> <span class="hljs-attr">this.state.info</span>,</span></span><br><span class="hljs-tag"><span class="language-xml">          <span class="hljs-attr">changeinfo:</span> () =&gt;</span> &#123;</span><br><span class="language-xml">            this.setState(&#123;</span><br><span class="language-xml">              info: &quot;2222&quot;,</span><br><span class="language-xml">            &#125;);</span><br><span class="language-xml">          &#125;,</span><br><span class="language-xml">        &#125;&#125;</span><br><span class="language-xml">      &gt;</span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">          父组件state的info值为--&#123;this.state.info&#125;</span><br><span class="language-xml">          <span class="hljs-tag">&lt;<span class="hljs-name">Child1</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Child1</span>&gt;</span></span><br><span class="language-xml">          <span class="hljs-tag">&lt;<span class="hljs-name">Child2</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Child2</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">MyGlobalContext.Provider</span>&gt;</span></span><br>    );<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Child1</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Component</span> &#123;<br>  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> (<br><span class="hljs-comment">//第三步：子组件成为consumer，注意用回调函数写法。回调函数拿取服务，服务可以是字符串、函数。。。</span><br>      <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">MyGlobalContext.Consumer</span>&gt;</span></span><br><span class="language-xml">        &#123;(value) =&gt; &#123;</span><br><span class="language-xml">          console.log(value);</span><br><span class="language-xml">          return (</span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">              <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;value.changeinfo&#125;</span>&gt;</span>点击改变父组件的值<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">          );</span><br><span class="language-xml">        &#125;&#125;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">MyGlobalContext.Consumer</span>&gt;</span></span><br>    );<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Child2</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Component</span> &#123;<br>  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> (<br>      <span class="hljs-comment">//子组件成为consumer，注意用回调函数写法。</span><br>      <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">MyGlobalContext.Consumer</span>&gt;</span></span><br><span class="language-xml">        &#123;(value) =&gt; &#123;</span><br><span class="language-xml">          return <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>展示父组件中info值&#123;value.info&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>;</span><br><span class="language-xml">        &#125;&#125;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">MyGlobalContext.Consumer</span>&gt;</span></span><br>    );<br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>react</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>react之受控组件与非受控组件</title>
    <link href="/2023/06/08/react%E4%B9%8B%E5%8F%97%E6%8E%A7%E7%BB%84%E4%BB%B6%E4%B8%8E%E9%9D%9E%E5%8F%97%E6%8E%A7%E7%BB%84%E4%BB%B6/"/>
    <url>/2023/06/08/react%E4%B9%8B%E5%8F%97%E6%8E%A7%E7%BB%84%E4%BB%B6%E4%B8%8E%E9%9D%9E%E5%8F%97%E6%8E%A7%E7%BB%84%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<p>React中的组件根据是否受React控制可分为受控的和非受控的</p><h2 id="一，受控组件（通过state中的状态值来控制显示）"><a href="#一，受控组件（通过state中的状态值来控制显示）" class="headerlink" title="一，受控组件（通过state中的状态值来控制显示）"></a>一，受控组件（通过state中的状态值来控制显示）</h2><ol><li>表单元素依赖于状态，表单元素需要默认值实时映射到状态的时候，就是受控组件，这个和双向绑定相似.</li><li>受控组件，表单元素的修改会实时映射到状态值上，此时就可以对输入的内容进行校验.</li><li>受控组件只有继承React.Component才会有状态.</li><li>受控组件必须要在表单上使用onChange事件来绑定对应的事件.</li></ol><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; <span class="hljs-title class_">Component</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Shoukong</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Component</span> &#123;<br>    <span class="hljs-comment">// 这样的写法也是声明在实例上的对象</span><br>    state = &#123;<br>        <span class="hljs-attr">username</span>: <span class="hljs-string">&quot;ff&quot;</span>,<br>       <span class="hljs-comment">// 给组件状态设置默认值，在实时修改时进行校验</span><br>    &#125;<br>    <span class="hljs-comment">// e为原生的事件绑定对象</span><br>    handleChange = <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> &#123;<br>        <span class="hljs-comment">// 获取原生对象上的属性</span><br>        <span class="hljs-keyword">let</span> name = e.<span class="hljs-property">target</span>.<span class="hljs-property">name</span>;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123;<br>            <span class="hljs-attr">username</span>: e.<span class="hljs-property">target</span>.<span class="hljs-property">value</span><br>        &#125;)<br>    &#125;<br> <br>    <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> (<br>            <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">                <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>&#123;this.state.username&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">                用户名：<span class="hljs-tag">&lt;<span class="hljs-name">input</span></span></span><br><span class="hljs-tag"><span class="language-xml">                    <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">                    <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;this.state.username&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">                    <span class="hljs-attr">onChange</span>=<span class="hljs-string">&#123;this.handleChange&#125;</span> /&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>        )<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>受控组件更新state的流程<br>1、 可以通过初始state中设置表单的默认值<br>2、每当表单的值发生变化时，调用onChange事件处理器<br>3、事件处理器通过事件对象event拿到改变后的状态，并更新组件的state<br>4、通过setState方法更新state，就会触发视图的重新渲染，即render里面就会重新执行，完成表单组件的更新</p><h2 id="二、非受控组件（通过ref直接获取值）"><a href="#二、非受控组件（通过ref直接获取值）" class="headerlink" title="二、非受控组件（通过ref直接获取值）"></a>二、非受控组件（通过ref直接获取值）</h2><p>在<a href="https://so.csdn.net/so/search?q=%E8%99%9A%E6%8B%9FDOM&spm=1001.2101.3001.7020">虚拟DOM</a>节点上声明一个ref属性，并且将创建好的引用赋值给这个ref属性</p><p>react会自动将输入框中输入的值放在实例的<strong>ref</strong>属性上</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; <span class="hljs-title class_">Component</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Feishou</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Component</span>&#123;<br><span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">super</span>();<br>    <span class="hljs-comment">// 在构造函数中创建一个引用</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">myref</span>=<span class="hljs-title class_">React</span>.<span class="hljs-title function_">createRef</span>();<br>&#125;<br>handleSubmit = <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> &#123;<br>    <span class="hljs-comment">// 阻止原生默认事件的触发(刷新)</span><br>    e.<span class="hljs-title function_">preventDefault</span>();<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">myref</span>.<span class="hljs-property">current</span>.<span class="hljs-property">value</span>);<br>&#125;<br><span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> (<br>        <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">onSubmit</span>=<span class="hljs-string">&#123;this.handleSubmit&#125;</span>&gt;</span></span><br><span class="language-xml">            &#123;/* 自动将输入框中输入的值放在实例的myref属性上 */&#125;</span><br><span class="language-xml">           <span class="hljs-tag">&lt;<span class="hljs-name">input</span></span></span><br><span class="hljs-tag"><span class="language-xml">                <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">                <span class="hljs-attr">ref</span>=<span class="hljs-string">&#123;this.myref&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">            /&gt;</span></span><br><span class="language-xml">             <span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>提交<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span> &#123;/* 手动提交 */&#125;</span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span></span><br>    )<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="三、对比受控组件与非受控组件的输入流程："><a href="#三、对比受控组件与非受控组件的输入流程：" class="headerlink" title="三、对比受控组件与非受控组件的输入流程："></a>三、对比受控组件与非受控组件的输入流程：</h2><ul><li><strong>非受控组件</strong>： 用户输入A &#x3D;&gt; input 中显示A</li><li><strong>受控组件</strong>： 用户输入A &#x3D;&gt; 触发onChange事件 &#x3D;&gt; handleChange 中设置 state.name &#x3D; “A” &#x3D;&gt; 渲染input使他的value变成A</li></ul><p>正式因为这样，使得 React 的 state 成为唯一数据源。<font color='yellow'>对于受控组件来说，输入的值始终由 React 的 state 驱动</font>。</p><p>所以官方强烈推荐使用受控组件，因为它能更好的控制组件的生命流程。</p><h2 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h2><p>受控组件的两个要点：</p><ul><li>组件的value属性与React中的状态绑定;</li><li>组件内声明了onChange事件处理value的变化;</li><li>非受控组件更像是传统的HTML表单元素，数据存储在DOM中，而不是组件内部，获取数据的方式是通过ref引用;</li><li>受控组件是将状态交由React处理，可以是任何元素，不局限于表单元素;</li><li>表单组件如果别的地方能用到，一定要用受控组件；</li><li>对于有大量表单元素的页面，使用受控组件会使程序变得繁琐难控，此时使用非受控组件更为明智;</li><li>在受控组件中，数据流是单向的(state是变化来源)，因此在改变state时都应该使用setState，而不要强制赋值;</li><li>Refs不能用于函数式组件，因为函数式组件没有实例,在函数式组件内部，是可以使用Refs的.</li><li><br></li></ul><p>————————————————<br>版权声明：本文为CSDN博主「阿昊在」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/m0_48982503/article/details/123423497">https://blog.csdn.net/m0_48982503/article/details/123423497</a></p>]]></content>
    
    
    <categories>
      
      <category>react</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>react事件绑定</title>
    <link href="/2023/06/07/react%E4%BA%8B%E4%BB%B6%E7%BB%91%E5%AE%9A/"/>
    <url>/2023/06/07/react%E4%BA%8B%E4%BB%B6%E7%BB%91%E5%AE%9A/</url>
    
    <content type="html"><![CDATA[<h2 id="react事件绑定的方法"><a href="#react事件绑定的方法" class="headerlink" title="react事件绑定的方法"></a>react事件绑定的方法</h2><p>react中绑定事件用关键字on+事件名来绑定，如绑定点击事件为onClick。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; <span class="hljs-title class_">Component</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Component</span> &#123;<br>  a = <span class="hljs-number">100</span><br>  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> (<br>      <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">        &#123;/* 方法一 */&#125;</span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;function()&#123;console.log(1111,this.a);&#125;&#125;</span>&gt;</span>111111<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>  </span><br><span class="language-xml"></span><br><span class="language-xml">        &#123;/* 方法二 箭头函数 */&#125;</span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span>=&gt;</span>&#123;console.log(222222,this.a)&#125;&#125;&gt;22222<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml">        &#123;/* 方法三、四 注意不要加（），vue是加不加都可以*/&#125;</span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;this.handleClick3&#125;</span>&gt;</span>333333<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;this.handleClick4&#125;</span>&gt;</span>444444<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml">        &#123;/* 方法五，结合方法二三  推荐这种写法，既不会有this指向问题，也方便传参*/&#125;</span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span>=&gt;</span>this.handleClick5()&#125;&gt;555555<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span> </span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span>=&gt;</span>&#123;</span><br><span class="language-xml">            this.handleClick5()</span><br><span class="language-xml">        &#125;&#125;&gt;555555普通函数<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>    )<br>  &#125;<br><span class="hljs-comment">// 方法三 </span><br>  <span class="hljs-title function_">handleClick3</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">33333</span>,<span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span>);<br>  &#125;<br><span class="hljs-comment">// 方法四 箭头函数</span><br>  handleClick4 = <span class="hljs-function">()=&gt;</span>&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">4444444</span>,<span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span>);<br>  &#125;<br>  <span class="hljs-comment">//方法五</span><br>  handleClick5 = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">555555</span>,<span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span>);<br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="this指向问题："><a href="#this指向问题：" class="headerlink" title="this指向问题："></a>this指向问题：</h3><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jsx">&lt;button onClick=&#123;<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">1111</span>,<span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span>);&#125;&#125;&gt;<span class="hljs-number">111111</span>&lt;/button&gt; <br></code></pre></td></tr></table></figure><p>方法一： 此时访问不到a，函数只有加（）调用时，才遵循谁调用this指向谁。此时函数体中的this并不指向button，更不指向App这个实例化对象，而是react会对其进行处理响应，所以自然访问不到a。</p><p>解决办法：利用bind改变其this指向App实例。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jsx">&lt;button onClick=&#123;<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">1111</span>,<span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span>);&#125;.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>)&#125;&gt;<span class="hljs-number">111111</span>改进&lt;/button&gt;  <br></code></pre></td></tr></table></figure><br><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jsx">&lt;button onClick=&#123;<span class="hljs-function">()=&gt;</span>&#123;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">222222</span>,<span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span>)&#125;&#125;&gt;<span class="hljs-number">22222</span>&lt;/button&gt;<br></code></pre></td></tr></table></figure><p>方法二：此时能正常访问到a的值，因为这是箭头函数，箭头函数中的this与其外部this一致。</p><br><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs jsx"> &lt;button onClick=&#123;<span class="hljs-variable language_">this</span>.<span class="hljs-property">handleClick3</span>&#125;&gt;<span class="hljs-number">333333</span>&lt;/button&gt;<br> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;this.handleClick4&#125;</span>&gt;</span>444444<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="hljs-comment">// 方法三 </span><br>  <span class="hljs-title function_">handleClick3</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">33333</span>,<span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span>);<br>  &#125;<br><span class="hljs-comment">// 方法四 箭头函数</span><br>  handleClick4 = <span class="hljs-function">()=&gt;</span>&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">4444444</span>,<span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span>);<br>  &#125;<br></code></pre></td></tr></table></figure><p>方法三四：同一二，方法三this指向不是实例化对象，所以访问不到a，方法四因为是箭头函数所以指向没有问题。方法三解决办法同方法一。</p><br><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs jsx">&lt;button onClick=&#123;<span class="hljs-function">()=&gt;</span><span class="hljs-variable language_">this</span>.<span class="hljs-title function_">handleClick5</span>()&#125;&gt;<span class="hljs-number">555555</span>&lt;<span class="hljs-regexp">/button&gt; &#123;/</span>* 推荐这种写法，传参 */&#125;<br>handleClick5 = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">555555</span>,<span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span>);<br>  &#125;<br>或<br>handleClick5 = <span class="hljs-function">()=&gt;</span>&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">555555</span>,<span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>方法五：能正常访问到a的值，因为onclick中是箭头函数，而不是因为handclick5函数为箭头函数。</p><p>推荐使用<font color = 'yellow'><code>onClick=&#123;()=&gt;this.handleClick5()&#125;</code></font>这种方法，既不会有this指向问题，this指向实例化对象App，也方便传参数。</p>]]></content>
    
    
    <categories>
      
      <category>react</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>var-let-const</title>
    <link href="/2023/05/26/var-let-const/"/>
    <url>/2023/05/26/var-let-const/</url>
    
    <content type="html"><![CDATA[<h3 id="1-var、let、const-的联系与区别"><a href="#1-var、let、const-的联系与区别" class="headerlink" title="1 var、let、const 的联系与区别"></a>1 var、let、const 的联系与区别</h3><p>三者均用于JavaScript中申明变量，其中let和const是ES6中才提出来的。</p><p>区别：</p><p><img src="image-20230526122315418.png" alt="image-20230526122315418"></p>]]></content>
    
    
    <categories>
      
      <category>javascript</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>基本类型与引用类型&amp;浅拷贝与深拷贝</title>
    <link href="/2023/05/24/%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B-%E6%B5%85%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B7%B1%E6%8B%B7%E8%B4%9D/"/>
    <url>/2023/05/24/%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B-%E6%B5%85%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B7%B1%E6%8B%B7%E8%B4%9D/</url>
    
    <content type="html"><![CDATA[<h3 id="1-基本类型与引用类型的区别"><a href="#1-基本类型与引用类型的区别" class="headerlink" title="1.基本类型与引用类型的区别"></a>1.基本类型与引用类型的区别</h3><h4 id="1-了解内存"><a href="#1-了解内存" class="headerlink" title="1.了解内存"></a>1.了解内存</h4><p>内存：内存是存储数据的，不同类型的数据要存储在不同的区域，即分类存放，不同的区域作用和功能也不一样。</p><p>以下为内存的分区图。内存分为四个区域：栈区（堆栈），堆区，全局静态区，只读区（常量区和代码区）。</p><p><img src="image-20230524202431206.png" alt="image-20230524202431206"></p><h4 id="2-基本类型与引用类型"><a href="#2-基本类型与引用类型" class="headerlink" title="2.基本类型与引用类型"></a>2.基本类型与引用类型</h4><p><strong>①基本数据类型与引用数据类型分别是什么？</strong></p><p>基本类型：就是值类型，即在变量所对应的内存区域存储的是值，如age&#x3D;18，age就是一个基本类型。</p><p>引用类型：就是地址类型。通过关键字new生成的即为引用类型，如数组，对象。例如var arr &#x3D; [12,23,34],实际应该是 var arr &#x3D; new Array() ,arr &#x3D; [12,23,34]。</p><p><strong>②基本数据类型与引用数据类型在内存存储上的区别。</strong></p><p>基本类型：定义变量age，在内存栈区申请内存空间，起名为age，由于250是<font color = 'yellow'>基本数据类型</font>，则给age直接赋值250，<font color = 'yellow'>值直接存储在栈中</font>。</p><p>引用类型：定义变量arr，在内存栈中申请内存空间，起名为arr，由于给arr赋的值为Array数组类型，不是基本类型，而是<font color = 'yellow'>引用类型，则在堆区中申请空间存放数据12、23、34，然后将该堆的地址赋值给栈区arr</font>。</p><p>存储结构如下图所示：</p><p><img src="image-20230524204112735.png" alt="image-20230524204112735"></p><p><strong>③基本数据类型和引用数据类型赋值的区别：</strong></p><p>基本类型：基本数据类型赋值会直接覆盖栈区中之前的数值。如</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = <span class="hljs-number">100</span><br><span class="hljs-keyword">var</span> b = <span class="hljs-number">200</span><br>a = b<br></code></pre></td></tr></table></figure><p><img src="image-20230524204705840.png" alt="image-20230524204705840"></p><p>引用类型：引用类型赋值而是将对应的地址赋值给被赋值对象，而堆区中的数据并没有发生变化。所以<em><strong>会导致更改其中一个对象中的引用类型值，另外一个对象的对应值也会发生改变。</strong></em></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> arr1 = &#123;<span class="hljs-attr">name</span>:<span class="hljs-string">&quot;zhangsan&quot;</span>,<span class="hljs-attr">age</span>:<span class="hljs-number">18</span>&#125;<br><span class="hljs-keyword">var</span> arr2 = &#123;&#125;  <span class="hljs-comment">//图一</span><br>arr2 = arr1    <span class="hljs-comment">//图二</span><br>arr2.<span class="hljs-property">age</span> = <span class="hljs-number">20</span>   <span class="hljs-comment">//图三</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr2.<span class="hljs-property">age</span>) <span class="hljs-comment">//20</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr1.<span class="hljs-property">age</span>) <span class="hljs-comment">//20</span><br></code></pre></td></tr></table></figure><p><img src="image-20230524205602197.png" alt="image-20230524205602197" style="zoom: 80%;" /><img src="image-20230524205648681.png" alt="image-20230524205648681" style="zoom:80%;" /><img src="image-20230524205815963.png" alt="image-20230524205815963" style="zoom:80%;" /></p><p><strong>④嵌套引用类型的存储方式：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123;<br>    <span class="hljs-attr">id</span>: <span class="hljs-number">1</span>,<br>    <span class="hljs-attr">goodname</span>:<span class="hljs-string">&quot;洗衣机&quot;</span>，<br>    <span class="hljs-attr">goods</span>:&#123;<br>    <span class="hljs-attr">ids</span>:<span class="hljs-number">11</span>,<br>    <span class="hljs-attr">name</span>:<span class="hljs-string">&quot;全自动&quot;</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="image-20230524210547685.png" alt="image-20230524210547685"></p><h3 id="2-赋值、浅拷贝与深拷贝的区别"><a href="#2-赋值、浅拷贝与深拷贝的区别" class="headerlink" title="2.赋值、浅拷贝与深拷贝的区别"></a>2.赋值、浅拷贝与深拷贝的区别</h3><table><thead><tr><th>类型</th><th>备注（基本类型哪种都不会影响原数据，下面区别均指的是引用类型数据）</th></tr></thead><tbody><tr><td>赋值</td><td>将原数据的地址赋值给新对象，<strong>没有创建新对象</strong>，更改任何数据都会影响原对象数据</td></tr><tr><td>浅拷贝</td><td>会<strong>创建新对象</strong>，但<strong>只有最外层对象被复制</strong>，内部的嵌套对象只是引用，更改最外层数据不会影响原对象数据，更改内层引用对象会影响原对象数据</td></tr><tr><td>深拷贝</td><td>会<strong>创建新对象</strong>，利用<strong>递归</strong>的方法，当前是基本类型则直接复制，是引用类型，则继续递归至为基本类型再复制。深拷贝对象<strong>不会影响原对象数据</strong></td></tr></tbody></table><p><strong>①赋值</strong>：</p><p>赋值是<strong>将原对象的引用传递给变量</strong>, 并不会产生一个独立的对象单独存在, 它只是将原有的数据贴上一个新标签, 所以<strong>原数据改变时, 赋值的变量也随之改变</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><span class="hljs-keyword">var</span> b = a;<br>b[<span class="hljs-number">0</span>] = <span class="hljs-number">5</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;a&quot;</span>, a);   <span class="hljs-comment">//a [5,2,3]</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;b&quot;</span>, b);   <span class="hljs-comment">//b [5,2,3]</span><br></code></pre></td></tr></table></figure><p><strong>②浅拷贝</strong>：浅拷贝是指创建一个新对象，然后将原始对象的内容逐个复制到<strong>新对象</strong>中。在浅拷贝中，只有<strong>最外层对象被复制</strong>，而内部的嵌套对象只是引用而已</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>], [<span class="hljs-number">6</span>, <span class="hljs-number">7</span>]];<br><span class="hljs-keyword">var</span> b = [];<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; a.<span class="hljs-property">length</span>; i++) &#123;<br>    b.<span class="hljs-title function_">push</span>(a[i]);<br>&#125;<br>b[<span class="hljs-number">0</span>] = <span class="hljs-number">5</span>;             <span class="hljs-comment">//最外层对象被复制，修改最外层不会影响原数据</span><br>b[<span class="hljs-number">3</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">6</span>;  <span class="hljs-comment">//修改内部的引用类型，原数据也会被更改</span><br>b[<span class="hljs-number">4</span>] = [<span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>];  <span class="hljs-comment">//替换引用类型，原数据不会被更改，相当于对最外层对象进行操作</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;a&quot;</span>, a);  <span class="hljs-comment">//[1,2,3,[6,5],[6,7]]</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;b&quot;</span>, b);  <span class="hljs-comment">//[5,2,3,[6,5],[8,9,10]]</span><br></code></pre></td></tr></table></figure><p><strong>②深拷贝</strong>：基本数据类型赋值，引用类型开辟新的堆空间，并把新的堆地址赋值给变量。一般用<font color = ' yellow'>递归函数</font>实现深拷贝。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">deepCopy</span>(<span class="hljs-params">newobj,oldobj</span>)&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> k <span class="hljs-keyword">in</span> oldobj)&#123;   <span class="hljs-comment">//for in 遍历对象，获取到的是key值</span><br>        <span class="hljs-comment">//1.获取属性值：</span><br>        <span class="hljs-keyword">var</span> item = oldobj[k]<br>        <span class="hljs-comment">//判断我们的属性值属于哪种数据类型</span><br>        <span class="hljs-comment">//2.判断是否为数组， 不能先判断是否为对象，因为数组也属于对象。</span><br>        <span class="hljs-keyword">if</span>(item <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Array</span>)&#123;<br>            newobj[k]=[] <span class="hljs-comment">//开辟一个新的堆存储空间,或者newobj[k] = new Array()</span><br>            <span class="hljs-title function_">deepCopy</span>(newobj[k],item)<br>        &#125;<br>        <span class="hljs-comment">//3.判断是否为对象</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (item <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Object</span>)&#123;<br>            newobj[k] = &#123;&#125; <span class="hljs-comment">//开辟一个新的堆存储空间，或者newobj[k] = new Object()</span><br>            <span class="hljs-title function_">deepcopy</span>(newobj[k],item)<br>        &#125;<br>        <span class="hljs-comment">//4.都不是则为基本数据类型</span><br>        <span class="hljs-keyword">else</span> &#123;<br>            newobj[k] = item<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> newobj   <span class="hljs-comment">//递归函数返回值千万别忘了</span><br>&#125;<br></code></pre></td></tr></table></figure><p><img src="image-20230524211927732.png" alt="image-20230524211927732"></p><br><p><font color="red">引用类型常见的复制方法：</font></p><ol><li><p>利用es6 …展开运算符，利用concat()、splice()来实现。</p><p>优点：简单方便</p><p>缺点：只能复制一层的数据，多层的不能复制。</p></li><li><p>利用 newobj &#x3D; JSON.parse(JSON.stringfy(oldobj))</p><p>优点：能够复制多层的数据。</p><p>缺点：若有undefined，会出现不可预期的问题。</p></li><li><p>递归复制</p><p>优点：可以准确复制</p><p>缺点：占用内存，效率低</p></li><li><p>react中 immutable库</p><p>immutable实现的原理式persistent Data Structure（持久化数据结构），也就是使用旧数据创建新数据时，要保证旧数据同时可用且不变，同时为了避免deepcopy把所有节点都复制一遍带来的性能损耗，immutable使用了Structural Sharing（结构共享），即如果对象树中一个节点发生变化，只修改这个节点和受他影响的父节点，其他节点则进行共享。</p><p>优点：既不会影响原数据，也能高效的复制。</p></li><li><p>利用第三方库封装的深拷贝方法(原理就是封装的递归)</p></li></ol><p>​<code>npm install lodash</code>这个库中提供了很多功能</p><p>​<code>import &#123;cloneDeep&#125; from lodash</code></p><p>​<code>const cloneList = cloneDeep(oldlist)</code></p>]]></content>
    
    
    <categories>
      
      <category>javascript</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>闭包及其案例</title>
    <link href="/2023/05/24/%E9%97%AD%E5%8C%85%E5%8F%8A%E5%85%B6%E6%A1%88%E4%BE%8B/"/>
    <url>/2023/05/24/%E9%97%AD%E5%8C%85%E5%8F%8A%E5%85%B6%E6%A1%88%E4%BE%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="1-什么是闭包"><a href="#1-什么是闭包" class="headerlink" title="1 什么是闭包"></a>1 什么是闭包</h2><p>MDN:<code>闭包（closure）是一个函数以及其捆绑的周边环境状态的引用的组合。换而言之，闭包让开发者可以从内部函数访问外部函数的作用域。在 JavaScript 中，闭包会随着函数的创建而被同时创建。</code></p><p>换言之：<font color = 'yellow'> 闭包就是一个函数，这个函数能够访问其他函数的作用域中的变量。</font></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">outer</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">var</span> inner = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a)<br>    &#125;<br>    <span class="hljs-keyword">return</span> inner <span class="hljs-comment">//inner就是一个闭包，因为能够访问outer函数作用域中的变量</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-闭包的特性"><a href="#2-闭包的特性" class="headerlink" title="2 闭包的特性"></a>2 闭包的特性</h2><p>相较于全局变量和局部变量，闭包有以下两个特性：</p><ul><li>函数嵌套函数；</li><li>内部函数可以访问外部函数的变量；</li><li>持久性：被访问的参数和变量不会被JavaScript垃圾回收机制回收（不会被销毁）。一般的函数，调用完毕之后，系统自动注销函数，而对于闭包来说，在外部函数被调用之后，闭包结构依然保存在系统中，闭包中的数据依然存在，从而实现对数据的持久使用。闭包拥有全局变量的不被释放的特点。</li></ul><h2 id="3-闭包的优缺点"><a href="#3-闭包的优缺点" class="headerlink" title="3 闭包的优缺点"></a>3 闭包的优缺点</h2><p><strong>优点：</strong></p><ul><li>可以让一个变量长期在内存中不被释放（用的太多就变成了缺点，占内存）。</li><li>避免全局变量的污染，和全局变量不同，闭包中的变量无法被外部使用。</li><li>保护函数内的变量安全；加强<strong>封装性</strong>，可以达到对变量的保护作用，如果在闭包内声明变量，外界是无法访问的，除非闭包主动向外界提供访问接口</li></ul><p>缺点：</p><ul><li>常驻内存，会增大内存使用量，使用不当很容易造成内存泄露。</li><li>内存浪费问题，这个内存浪费不仅仅因为它常驻内存，更重要的是，对闭包的使用不当会造成无效内存的产生。</li></ul><h2 id="4-闭包的作用"><a href="#4-闭包的作用" class="headerlink" title="4 闭包的作用"></a>4 闭包的作用</h2><p>闭包主要在三个方面应用：防抖、节流、函数柯里化</p><p><strong>1.防抖：</strong></p><p>原理：利用闭包的特性（用到的变量不会被js垃圾回收机制回收）来保存接收定时器的变量</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//防抖 避免函数的重复调用 只会调用一次</span><br>        <span class="hljs-keyword">function</span> <span class="hljs-title function_">Antishake</span>(<span class="hljs-params">fn,wait</span>)&#123; <span class="hljs-comment">//第一个参数是函数 第二个参数是毫秒值</span><br>            <span class="hljs-keyword">let</span> timer = <span class="hljs-literal">null</span> <span class="hljs-comment">//声明一个变量来接收延时器 初始值为null</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>                <span class="hljs-built_in">clearTimeout</span>(timer)<br>                timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>                    <span class="hljs-title function_">fn</span>() <span class="hljs-comment">//调用这函数</span><br>                &#125;, wait);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">let</span> an = <span class="hljs-title class_">Antishake</span>(<br>            <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123; <span class="hljs-comment">//用一个变量接收</span><br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;555&#x27;</span>);<br>        &#125;,<span class="hljs-number">2000</span>)<br>        <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&quot;button&quot;</span>).<span class="hljs-property">onclick</span> = <span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-title function_">an</span>(); <br>      &#125;; <span class="hljs-comment">//连续多次点击，也只会最后一次点击结束后过三秒打印555.</span><br></code></pre></td></tr></table></figure><p><strong>2.节流：</strong></p><p>原理：利用闭包的特性（用到的变量不会被js垃圾回收机制回收）来保存时间</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">throttle</span>(<span class="hljs-params">fn,wait</span>)&#123;<br>            <span class="hljs-keyword">let</span> timer = <span class="hljs-literal">null</span> <span class="hljs-comment">//节点闸</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>                <span class="hljs-keyword">if</span>(timer) <span class="hljs-keyword">return</span> <span class="hljs-comment">//null false 不是null结果减少true 如果上传没有我就直接跳过 没有人我就上去</span><br>                timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123; <span class="hljs-comment">//上车了</span><br>                    <span class="hljs-title function_">fn</span>()<br>                    timer = <span class="hljs-literal">null</span> <span class="hljs-comment">//做完之后重新关闭节点闸</span><br>                &#125;, wait);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">let</span> throttle1 = <span class="hljs-title function_">throttle</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;我上车了&#x27;</span>);<br>        &#125;,<span class="hljs-number">2000</span>)<br>        <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;div&#x27;</span>).<span class="hljs-property">onclick</span> = <span class="hljs-function">()=&gt;</span>&#123;<br>            <span class="hljs-title function_">throttle1</span>()<br>        &#125;<br></code></pre></td></tr></table></figure><p>防抖避免重复执行 只执行一次</p><p>节流 减少执行次数 执行多次</p><p>案例：窗口大小改变执行操作：</p><p><img src="image-20240307201556967.png" alt="image-20240307201556967"></p><p><strong>3.函数柯里化：</strong></p><p>1. </p><p>后续补充。。。</p><h2 id="5-闭包的经典案例"><a href="#5-闭包的经典案例" class="headerlink" title="5 闭包的经典案例"></a>5 闭包的经典案例</h2><p>1.点击标签，打印出索引值，用闭包模仿块级作用域</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>11111<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>11111<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>11111<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//大多数人以为是：</span><br><span class="hljs-keyword">var</span> lis = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelectorAll</span>(<span class="hljs-string">&quot;li&quot;</span>)<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>;i &lt; lis.<span class="hljs-property">length</span>;i++)&#123;<br>    lis[i].<span class="hljs-property">onclick</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i)<br>    &#125;<br>&#125;<br><span class="hljs-comment">//实际结果不管点击哪个都是打印 3</span><br><span class="hljs-comment">//原因：事件的执行函数是异步的，它只会在浏览器有空闲的时候执行。点击的时候，for循环已经遍历完了。</span><br><span class="hljs-comment">//Q1：为什么for循环遍历完了打印的是3，而不是2？</span><br><span class="hljs-comment">//answer：当循环事件完成的时候，i已经自增到3了，i为2的时候还在循环。</span><br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//利用闭包实现正确的方法：</span><br><span class="hljs-keyword">var</span> lis = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelectorAll</span>(<span class="hljs-string">&quot;li&quot;</span>)<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>;i &lt; lis.<span class="hljs-property">length</span>;i++)&#123;<br>    <span class="hljs-comment">//利用for循环创建4个立即执行函数</span><br>    (<span class="hljs-keyword">function</span> (<span class="hljs-params">a</span>)&#123;<br>lis[a].<span class="hljs-property">onclick</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a)<br>        &#125;        <br>    &#125;)(i)<br>&#125;<br></code></pre></td></tr></table></figure><p>注：ES6中用let定义i同样能实现该效果。</p><p>2.用闭包解决递归调用问题：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span>  <span class="hljs-title function_">factorial</span>(<span class="hljs-params">num</span>) &#123;<br>   <span class="hljs-keyword">if</span>(num&lt;= <span class="hljs-number">1</span>) &#123;<br>       <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>   &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">return</span> num * <span class="hljs-title function_">factorial</span>(num-<span class="hljs-number">1</span>)<br>   &#125;<br>&#125;<br><span class="hljs-keyword">var</span> anotherFactorial = factorial<br>factorial = <span class="hljs-literal">null</span><br><span class="hljs-title function_">anotherFactorial</span>(<span class="hljs-number">4</span>)   <span class="hljs-comment">// 报错 ，因为最好是return num* arguments.callee（num-1），arguments.callee指向当前执行函数，但是在严格模式下不能使用该属性也会报错，所以借助闭包来实现</span><br><br><br><span class="hljs-comment">// 使用闭包实现递归</span><br><span class="hljs-keyword">function</span> newFactorial = （<span class="hljs-keyword">function</span> <span class="hljs-title function_">f</span>(<span class="hljs-params">num</span>)&#123;<br>    <span class="hljs-keyword">if</span>(num&lt;<span class="hljs-number">1</span>) &#123;<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>&#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>       <span class="hljs-keyword">return</span> num* <span class="hljs-title function_">f</span>(num-<span class="hljs-number">1</span>)<br>    &#125;<br>&#125;） <span class="hljs-comment">//这样就没有问题了，实际上起作用的是闭包函数f，而不是外面的函数newFactorial</span><br></code></pre></td></tr></table></figure><h2 id="6-闭包中的坑"><a href="#6-闭包中的坑" class="headerlink" title="6 闭包中的坑"></a>6 闭包中的坑</h2><p>1.this指向问题</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> object = &#123;<br>     <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;&#x27;</span>object<span class="hljs-string">&quot;，</span><br><span class="hljs-string">     getName： function() &#123;</span><br><span class="hljs-string">        return function() &#123;</span><br><span class="hljs-string">             console.info(this.name)</span><br><span class="hljs-string">        &#125;</span><br><span class="hljs-string">    &#125;</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string">object.getName()()    // underfined</span><br><span class="hljs-string">// 因为里面的闭包函数是在window作用域下执行的，也就是说，this指向windows</span><br><span class="hljs-string">//实际等同于</span><br><span class="hljs-string">var fn = object.getName() //此时object调用getname方法，this指向object</span><br><span class="hljs-string">fn();  //此时window调用fn（）方法，所以this指向window</span><br></code></pre></td></tr></table></figure><p>2.内存泄漏问题：</p><p>​<strong>内存泄漏一般是指变量的内存没有及时的回收，导致内存资源浪费。</strong>一般有三种情况出现内存泄露比较多。（1）常见的声明了一个全局变量，但是又没有用上，那么就有点浪费内存了，（2）定时器没清除 （3）循环引用：A 对象里面有一个属性指向 B 对象，B 对象有一个属性指向 A 对象。互相引用<br>​解决内存泄露：我们编译器有一个自动的内存清理。常见的主要是引用记数 和 标记清除。 谷歌浏览器主要是用标记清除，大概流程是给每一个变量添加一个标记，通过内部算法计算引用情况，当不使用的时候就会自动清除。如果遇到定时器的话，我一般会在页面关闭的时候手动清除。如果遇到循环引用，我一般会手动把变量赋值为 null 来清除.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span>  <span class="hljs-title function_">showId</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">var</span> el = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;app&quot;</span>)<br>    el.<span class="hljs-property">onclick</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>      <span class="hljs-title function_">aler</span>(el.<span class="hljs-property">id</span>)   <span class="hljs-comment">// 这样会导致闭包引用外层的el，当执行完showId后，el无法释放</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 改成下面</span><br><span class="hljs-keyword">function</span>  <span class="hljs-title function_">showId</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">var</span> el = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;app&quot;</span>)<br>    <span class="hljs-keyword">var</span> id  = el.<span class="hljs-property">id</span><br>    el.<span class="hljs-property">onclick</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>      <span class="hljs-title function_">aler</span>(id)   <span class="hljs-comment">// 这样会导致闭包引用外层的el，当执行完showId后，el无法释放</span><br>    &#125;<br>    el = <span class="hljs-literal">null</span>    <span class="hljs-comment">// 主动释放el</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>javascript</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>javascript高阶函数</title>
    <link href="/2023/05/22/javascript%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0/"/>
    <url>/2023/05/22/javascript%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h3 id="1-什么是高阶函数"><a href="#1-什么是高阶函数" class="headerlink" title="1 什么是高阶函数"></a>1 什么是高阶函数</h3><p>函数满足以下任意任一条件就是高阶函数：</p><ul><li>接受函数作为参数</li><li>将函数作为返回值输出</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//情况1</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params">a,b,callback</span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a+b)<br>    callback &amp;&amp; <span class="hljs-title function_">callback</span>()<br>&#125;<br><span class="hljs-title function_">fn</span>(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;我是最后执行的&quot;</span>)&#125;)<br><br><span class="hljs-comment">//情况2</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;&#125;<br>&#125;<br><span class="hljs-title function_">fn</span>()<br></code></pre></td></tr></table></figure><h3 id="2-常见的高阶函数"><a href="#2-常见的高阶函数" class="headerlink" title="2.常见的高阶函数"></a>2.常见的高阶函数</h3><p>一般常见的回调函数为高阶函数，如：</p><ul><li>Array.prototype.map()</li><li>Array.prototype.reduce()</li><li>Array.prototype.every()</li><li>Array.prototype.some()</li><li>Array.prototype.filter()</li></ul>]]></content>
    
    
    <categories>
      
      <category>javascript</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript严格模式</title>
    <link href="/2023/05/22/JavaScript%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F/"/>
    <url>/2023/05/22/JavaScript%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="1-什么是严格模式"><a href="#1-什么是严格模式" class="headerlink" title="1 什么是严格模式"></a>1 什么是严格模式</h2><p>严格模式是在 ECMAScript5（ES5）中引入的，在严格模式下，JavaScript 对语法的要求会更加严格，一些在正常模式下能够运行的代码，在严格模式下将不能运行。</p><p>添加严格模式，主要有以下几个目的：</p><ul><li>消除 JavaScript 语法中一些不合理、不严谨的地方；</li><li>消除代码中一些不安全的地方，保证代码的安全运行；</li><li>提高 JavaScript 程序的运行效率；</li><li>为以后新版本的 JavaScript 做好铺垫。例如一些保留字：class,enum,export,extends,import,super,implements,interface,let,package,private,protected,public,static,yield…不能做变量名。</li></ul><p>目前，主流浏览器包括 IE10 及其之后的版本都已支持严格模式，JavaScript 正在向着更合理、更安全、更严谨的方向发展。</p><h2 id="2-开启严格模式的方法"><a href="#2-开启严格模式的方法" class="headerlink" title="2 开启严格模式的方法"></a>2 开启严格模式的方法</h2><p>方法1：直接在脚本开头加上”use strict”;</p><p>方法2：在自执行函数中添加严格模式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;script&gt;<br>        <span class="hljs-string">&#x27;use strict&#x27;</span><br>        <span class="hljs-comment">//此时该脚本都会执行严格模式</span><br><br>        (<span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params"></span>)&#123;<br>            <span class="hljs-string">&#x27;use strict&#x27;</span><br>        &#125;)()<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p>严格函数的作用域：</p><ul><li>在脚本开头位置添加则该脚本全部遵循严格模式；</li><li>在函数开头加，则仅该函数内遵循严格模式</li></ul><h3 id="3-严格模式中的变化"><a href="#3-严格模式中的变化" class="headerlink" title="3 严格模式中的变化"></a>3 严格模式中的变化</h3><p>1.变量规定</p><ul><li>变量必须先声明再赋值。</li><li>不允许删除变量或对象。</li><li>不允许变量重名:</li><li>不允许使用八进制:</li><li>不允许使用转义字符:</li><li>不允许对只读属性赋值:</li><li>不允许对一个使用getter方法读取的属性进行赋值</li><li>不允许删除一个不允许删除的属性：</li><li>由于一些安全原因，在作用域 eval() 创建的变量不能被调用：</li></ul><p>2.普通模式下全局作用域函数中的this指向window对象。但是<font color="yellow">严格模式下全局作用域函数中的this为undefind。</font></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;script&gt;<br>    <span class="hljs-string">&#x27;use strict&#x27;</span><br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>)<br>    &#125;<br>    <span class="hljs-title function_">fn</span>();   <span class="hljs-comment">//undefind</span><br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p>3.普通模式构造函数不加new也可以调用，此时this指向全局对象，但是严格模式下，如果构造函数不加new调用，this会报错。</p><p>未变的：</p><ul><li>严格模式下new实例化的构造函数仍指向对象实例，与普通模式一样。</li><li>定时器this还是指向window</li><li>事件、对象还是指向调用者</li></ul>]]></content>
    
    
    <categories>
      
      <category>javascript</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>函数及this指向问题</title>
    <link href="/2023/05/22/%E5%87%BD%E6%95%B0%E5%8F%8Athis%E6%8C%87%E5%90%91%E9%97%AE%E9%A2%98/"/>
    <url>/2023/05/22/%E5%87%BD%E6%95%B0%E5%8F%8Athis%E6%8C%87%E5%90%91%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="1-函数定义"><a href="#1-函数定义" class="headerlink" title="1 函数定义"></a>1 函数定义</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fun</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;函数声明方式function关键字，也叫命名函数&quot;</span>)<br>&#125;<br><br><span class="hljs-keyword">var</span> fun1 = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;函数表达式，匿名函数&quot;</span>)<br>&#125;<br><br><span class="hljs-comment">//利用new Function（&#x27;参数1&#x27;，&#x27;参数2&#x27;,&#x27;函数体&#x27;），不推荐这种写法，效率低</span><br><span class="hljs-keyword">var</span> fun2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Function</span>(<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-string">&#x27;console.log(&quot;利用new Function的形式&quot;)&#x27;</span>)<br></code></pre></td></tr></table></figure><ul><li><p>所有函数都是Function的实例对象</p><p><img src="image-20230522105305617.png" alt="image-20230522105305617"></p></li></ul><h2 id="2-函数调用"><a href="#2-函数调用" class="headerlink" title="2 函数调用"></a>2 函数调用</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//1.普通函数，this指向window</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">fun1</span>(<span class="hljs-params"></span>)&#123;&#125;<br><span class="hljs-title function_">fun1</span>()<br><br><span class="hljs-comment">//2.对象的方法，this指向该对象</span><br><span class="hljs-keyword">var</span> obj = &#123;<br>    <span class="hljs-attr">sayHi</span>:<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;hi&#x27;</span>)<br>    &#125;<br>&#125;<br>obj.<span class="hljs-title function_">sayHi</span>()<br><br><span class="hljs-comment">//3.构造函数,this指向实例ldh</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Star</span>(<span class="hljs-params">name,age</span>)&#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age<br>&#125;<br><span class="hljs-keyword">var</span> ldh = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Star</span>(<span class="hljs-string">&quot;刘德华&quot;</span>,<span class="hljs-number">18</span>)<br><br><span class="hljs-comment">//4.绑定事件函数，this指向执行该事件的元素</span><br>btn.<span class="hljs-property">onclick</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;this此时指向btn&quot;</span>)<br>&#125;<br><br><span class="hljs-comment">//5.定时器函数，this指向window</span><br><span class="hljs-built_in">setInterval</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>)&#123;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;111&quot;</span>)&#125;,<span class="hljs-number">1000</span>)<br><br><span class="hljs-comment">//6.立即执行函数，this指向window</span><br>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;立即执行&quot;</span>)<br>&#125;)()<br></code></pre></td></tr></table></figure><h3 id="3-改变this指向的方法"><a href="#3-改变this指向的方法" class="headerlink" title="3 改变this指向的方法"></a>3 改变this指向的方法</h3><p>JavaScript提供了一些函数方法来改变函数内部this指向，常见的有 bind(),call(),apply()</p><p><strong>1.call方法</strong></p><p>call（）方法调用一个对象。简单理解为<font color='yellow'>调用函数</font>的方式，改变this指向</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn1</span>(<span class="hljs-params"></span>)&#123;&#125;<br>fn1.<span class="hljs-title function_">call</span>() <span class="hljs-comment">//等同于fn1()</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Father</span>(<span class="hljs-params">name,age</span>)&#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Son</span>(<span class="hljs-params">name,age</span>)&#123;<br>    <span class="hljs-title class_">Father</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>,name,age) <span class="hljs-comment">//将Father中的this指向son</span><br>&#125;<br><span class="hljs-keyword">var</span> son = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Son</span>(<span class="hljs-string">&quot;张三&quot;</span>，<span class="hljs-number">18</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(son) <br></code></pre></td></tr></table></figure><p><strong>2.apply方法</strong></p><p>apply（）方法调用一个对象。简单理解为<font color='yellow'>调用函数</font>的方式，改变this指向,但是<font color='yellow'>apply传参数必须传（伪）数组</font>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Father</span>(<span class="hljs-params">name,age</span>)&#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Son</span>(<span class="hljs-params">name,age</span>)&#123;<br>    <span class="hljs-title class_">Father</span>.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>,[name,age]) <span class="hljs-comment">//将Father中的this指向son</span><br>&#125;<br><span class="hljs-keyword">var</span> son = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Son</span>(<span class="hljs-string">&quot;张三&quot;</span>，<span class="hljs-number">18</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(son)<br></code></pre></td></tr></table></figure><p>附：apply的应用：可以利用apply借助于数学对象求最大&#x2F;小值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">32</span>,<span class="hljs-number">4</span>,<span class="hljs-number">45</span>,<span class="hljs-number">66</span>]<br><span class="hljs-keyword">var</span> max = <span class="hljs-title class_">Math</span>.<span class="hljs-property">max</span>.<span class="hljs-title function_">apply</span>(<span class="hljs-title class_">Math</span>,arr)<br>cosole.<span class="hljs-title function_">log</span>(max)<br></code></pre></td></tr></table></figure><h3 id="3-bind方法"><a href="#3-bind方法" class="headerlink" title="3.bind方法"></a>3.bind方法</h3><p><font color='yellow'>bind()方法不会调用函数</font>，但是能够改变函数内部this指向</p><p><code>fun.bind(thisArg,arg1,arg2,...)</code></p><ul><li>thisArg: 在fun函数运行时指定this值</li><li>arg传递参数</li><li>返回由指定的this值和初始化参数改造的<font color='yellow'>原函数拷贝</font>,即返回的是原函数改变this之后产生的新函数</li></ul><p><font color='red'>bind应用：当函数不需要立即调用，又需要改变this指向的时候使用</font>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> o = &#123;<br>    <span class="hljs-attr">name</span>:<span class="hljs-string">&quot;zhangsan&quot;</span><br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>)<br>&#125;<br><span class="hljs-keyword">var</span> fn1 = fn.<span class="hljs-title function_">bind</span>(o)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">fn1</span>())<br></code></pre></td></tr></table></figure><p><img src="image-20230522124639682.png" alt="image-20230522124639682"></p><p> bind案例：当点击按钮以后就禁用按钮，3秒之后开启按钮。</p><p>错误写法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> btn = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&quot;button&quot;</span>);<br>      btn.<span class="hljs-property">onclick</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">disabled</span> = <span class="hljs-literal">true</span>;  <span class="hljs-comment">//此时this指向btn</span><br>        <span class="hljs-built_in">setInterval</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>          <span class="hljs-variable language_">this</span>.<span class="hljs-property">disabled</span> = <span class="hljs-literal">false</span>;  <span class="hljs-comment">//这种方法不会生效，因为setInterval函数为window调用，this执行window</span><br>        &#125;, <span class="hljs-number">1000</span>);<br>      &#125;;<br></code></pre></td></tr></table></figure><p>正确写法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> btn = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&quot;button&quot;</span>);<br>      btn.<span class="hljs-property">onclick</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">disabled</span> = <span class="hljs-literal">true</span>;<br>        <span class="hljs-built_in">setInterval</span>(<br>          <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>            <span class="hljs-variable language_">this</span>.<span class="hljs-property">disabled</span> = <span class="hljs-literal">false</span>;  <span class="hljs-comment">//this指向window，改变其指向btn</span><br>          &#125;.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>),  <span class="hljs-comment">//此行this指向btn</span><br>          <span class="hljs-number">1000</span><br>        );<br>      &#125;;<br></code></pre></td></tr></table></figure><p><img src="image-20230522131216773.png" alt="image-20230522131216773"></p>]]></content>
    
    
    <categories>
      
      <category>javascript</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>ES6之前利用构造函数和原型实现继承</title>
    <link href="/2023/05/16/ES6%E4%B9%8B%E5%89%8D%E5%88%A9%E7%94%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E5%8E%9F%E5%9E%8B%E5%AE%9E%E7%8E%B0%E7%BB%A7%E6%89%BF/"/>
    <url>/2023/05/16/ES6%E4%B9%8B%E5%89%8D%E5%88%A9%E7%94%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E5%8E%9F%E5%9E%8B%E5%AE%9E%E7%8E%B0%E7%BB%A7%E6%89%BF/</url>
    
    <content type="html"><![CDATA[<h2 id="ES6之前利用构造函数和原型实现继承"><a href="#ES6之前利用构造函数和原型实现继承" class="headerlink" title="ES6之前利用构造函数和原型实现继承"></a>ES6之前利用构造函数和原型实现继承</h2><h3 id="1-用构造函数继承属性"><a href="#1-用构造函数继承属性" class="headerlink" title="1.用构造函数继承属性"></a>1.用构造函数继承属性</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//利用构造函数继承属性</span><br><span class="hljs-comment">//1.父构造函数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Father</span>(<span class="hljs-params">uname, age</span>) &#123;<br>  <span class="hljs-comment">//this指向Father实例</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">uname</span> = uname;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age;<br>&#125;<br><span class="hljs-comment">//2.子构造函数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Son</span>(<span class="hljs-params">uname, age, score</span>) &#123;<br>  <span class="hljs-comment">//this指向Son的实例</span><br>  <span class="hljs-comment">//重点：子构造函数继承父构造函数属性，将父构造函数拿来用，一定要修改父构造函数中的this指向子构造函数的对象实例</span><br>  <span class="hljs-title class_">Father</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>, uname, age);<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">score</span> = score;<br>&#125;<br><span class="hljs-keyword">var</span> son = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Son</span>(<span class="hljs-string">&quot;zhangsan&quot;</span>, <span class="hljs-number">18</span>, <span class="hljs-number">100</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(son);<br><br></code></pre></td></tr></table></figure><p><img src="image-20230516153925949.png" alt="image-20230516153925949"></p><h3 id="2-用原型对象继承方法"><a href="#2-用原型对象继承方法" class="headerlink" title="2.用原型对象继承方法"></a>2.用原型对象继承方法</h3><p> 错误的继承方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//1.父构造函数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Father</span>(<span class="hljs-params">uname, age</span>) &#123;<br>  <span class="hljs-comment">//this指向Father实例</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">uname</span> = uname;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age;<br>&#125;<br><span class="hljs-comment">//父原型方法</span><br><span class="hljs-title class_">Father</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">money</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;挣钱&quot;</span>);<br>&#125;;<br><span class="hljs-comment">//2.子构造函数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Son</span>(<span class="hljs-params">uname, age, score</span>) &#123;<br>  <span class="hljs-comment">//this指向Son的实例</span><br>  <span class="hljs-title class_">Father</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>, uname, age);<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">score</span> = score;<br>&#125;<br><span class="hljs-comment">//错误的继承原型函数方法，两处错误：</span><br><span class="hljs-comment">//1.这种方法直接将子函数的原型方法指向父原型方法，所以原型中的constructor也指向了父元素。</span><br><span class="hljs-comment">//2.该方法仅仅只是将子元素的原型指向父元素原型，所以该方法改变子原型方法，父原型方法也会跟着改变。原理见下图</span><br><span class="hljs-title class_">Son</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-title class_">Father</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>;<br><span class="hljs-title class_">Son</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">exam</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;exam&quot;</span>);<br>&#125;;<br><span class="hljs-keyword">var</span> son = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Son</span>(<span class="hljs-string">&quot;zhangsan&quot;</span>, <span class="hljs-number">18</span>, <span class="hljs-number">100</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(son);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Father</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>);<br></code></pre></td></tr></table></figure><p><img src="image-20230516160005627.png" alt="image-20230516160005627"></p><img src="image-20230516160203939.png" alt="image-20230516160203939" style="zoom:50%;" /><p>正确的继承方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//2.子构造函数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Son</span>(<span class="hljs-params">uname, age, score</span>) &#123;<br>  <span class="hljs-comment">//this指向Son的实例</span><br>  <span class="hljs-title class_">Father</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>, uname, age);<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">score</span> = score;<br>&#125;<br><span class="hljs-comment">//正确方法：将子元素的原型指向一个父构造函数的实例对象，因为该实例对象可以通过__proto__获取到Father.prototype上的原型方法，所以子元素的原型也可以间接获得父原型上的方法。因为子原型对象没有直接指向父原型对象，所以修改子原型对象不会影响父原型对象，图解如下：</span><br><span class="hljs-comment">//如果利用对象的形式修改了原型对象，别忘了利用constructor指回原来的原型对象。所以下面一行代码同样会将son的constructor指向Father</span><br><span class="hljs-title class_">Son</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Father</span>();<br><span class="hljs-comment">//手动指回</span><br><span class="hljs-title class_">Son</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constructor</span> = <span class="hljs-title class_">Son</span>;<br><span class="hljs-title class_">Son</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">exam</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;exam&quot;</span>);<br>&#125;;<br><span class="hljs-keyword">var</span> son = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Son</span>(<span class="hljs-string">&quot;zhangsan&quot;</span>, <span class="hljs-number">18</span>, <span class="hljs-number">100</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(son);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Father</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>);<br></code></pre></td></tr></table></figure><p><img src="image-20230516161440097.png" alt="image-20230516161440097"></p><img src="image-20230516160808723.png" alt="image-20230516160808723" style="zoom:80%;" />]]></content>
    
    
    <categories>
      
      <category>javascript</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>ES6class类-继承-this指向</title>
    <link href="/2023/05/16/ES6-class%E7%B1%BB-%E7%BB%A7%E6%89%BF-this%E6%8C%87%E5%90%91/"/>
    <url>/2023/05/16/ES6-class%E7%B1%BB-%E7%BB%A7%E6%89%BF-this%E6%8C%87%E5%90%91/</url>
    
    <content type="html"><![CDATA[<h2>1、面向对象与面向过程</h2><h3>1.1 面向过程编辑POP(Process-oriented programming)</h3><p>面向过程就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候再一个一个的依次调用就可以了。面向过程，就是按照我们分析好的步骤，按照步骤解决问题。</p><h3 id="1-2-面向对象编程OOP-Object-Oriented-Programming"><a href="#1-2-面向对象编程OOP-Object-Oriented-Programming" class="headerlink" title="1.2 面向对象编程OOP(Object Oriented Programming)"></a><strong>1.2 面向对象编程OOP(Object Oriented Programming)</strong></h3><p>面向对象是把事务分解成一个个对象，然后由对象之间分工与合作。是以对象功能来划分问题，而不是步骤。</p><p>面向对象编辑具有灵活、代码可复用、容易维护和开发的优点。</p><p>面向对象的三大特征：封装性、继承性、多态性。</p><p>优点：易维护、易复用，易扩展，可以设计 出低耦合的系统，使系统更灵活、更加易于维护。</p><p>缺点：性能比面向过程低。</p><h2>2.类和对象</h2><h3 id="2-1-对象"><a href="#2-1-对象" class="headerlink" title="2.1 对象"></a>2.1 对象</h3><p>万物皆对象，对象是一个具体的事物，看得见摸得着的实物。例如：一本书、一个人可以是对象，一个数据库、一个远程服务器的连接也可以是对象。</p><p>在JavaScript中，对象是一组无序的相关属性和方法的集合，所有的事物都是对象，使用数据、数组、函数等。</p><p>对象是由属性和方法组件的：</p><p>属性：事物的特征，在对象中用属性来表示(常用名词)<br>方法：事物的行为，在对象中用方法来表示(常用动词)</p><h3 id="2-2-类-class"><a href="#2-2-类-class" class="headerlink" title="2.2 类 class"></a>2.2 类 class</h3><p>在ES6中增加了类的概念，可以使用class关键字声明一个类，之后以这个类来实例化对象。</p><p>类抽象了对的公共部分，它泛指某一大类(class)</p><p>对象特指某一个，通过类实例化一个具体的对象</p><h3 id="2-3-创建类"><a href="#2-3-创建类" class="headerlink" title="2.3 创建类"></a>2.3 创建类</h3><p>创建实例：类必须使用new 实例化对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> obj=<span class="hljs-keyword">new</span> <span class="hljs-title function_">name</span>()<br></code></pre></td></tr></table></figure><p><strong>new在执行时会做四件事性</strong>：</p><ol><li>在内存中创建一个新的空对象</li><li>让this指向这个新的对象</li><li>执行构造函数里的代码，给这个新对象添加属性和方法</li><li>返回这个新对象(所以构造函数里面不需要return)</li></ol><h3 id="2-4-构造函数-constructor"><a href="#2-4-构造函数-constructor" class="headerlink" title="2.4 构造函数 constructor"></a>2.4 构造函数 constructor</h3><p>constructor()方法是类的构造函数(默认方法)，用于传递参数，返回实例对象，通过new命令生成对象实例时，自动调用该方法。如果没有显示定义，类内部会自动给我们创建一个constructor().</p><p>1 通过class关键字创建类，首字母大写</p><p>2 constructor函数，可以接受传递过来的参数，同时返回实例对象</p><p>3 constructor只要new 生成实例时，就会自动调用这个函数，如果不写，类也会自动生成这个函数</p><p>4 生成实例,new 不能省略</p><p>5 创建类，类名后不加小括号，生成实例 类名后面要加小括号，构建函数不需要function</p><h2 id="3、类的继承"><a href="#3、类的继承" class="headerlink" title="3、类的继承"></a>3、类的继承</h2><h3 id="3-1-extends类的继承"><a href="#3-1-extends类的继承" class="headerlink" title="3.1 extends类的继承"></a>3.1 extends类的继承</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-comment">// 构造函数，</span><br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name, age</span>) &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age;<br>    &#125;<br>    <span class="hljs-title function_">sing</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;我会唱歌&quot;</span>)<br>    &#125;<br>  &#125;<br><span class="hljs-comment">//son继承的person</span><br>  <span class="hljs-keyword">class</span> <span class="hljs-title class_">Son</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Person</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>)&#123;&#125;<br>  &#125;<br>  <span class="hljs-keyword">var</span> son = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Son</span>();<br>  son.<span class="hljs-title function_">sing</span>();<br></code></pre></td></tr></table></figure><p>son通过extends继承person，son本身没有sing（）方法，但是由于继承了person，person中具有sing方法，于是可以执行son.sing()</p><h3 id="3-2-super关键字"><a href="#3-2-super关键字" class="headerlink" title="3.2 super关键字"></a>3.2 super关键字</h3><p>super 用于访问和 调用对象父类上的函数。可以调用父类的构造函数，也可以调用父类的普通函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-comment">// 构造函数，</span><br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name, age</span>) &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age;<br>    &#125;<br>    <span class="hljs-comment">// 普通函数</span><br>    <span class="hljs-title function_">funStr</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`姓名：<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.name&#125;</span>,年龄：<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.age&#125;</span>`</span>);<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">class</span> <span class="hljs-title class_">Son</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Person</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name, age</span>) &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age<br>      <span class="hljs-variable language_">super</span>(name, age);<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">var</span> son = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Son</span>(<span class="hljs-string">&#x27;bom&#x27;</span>, <span class="hljs-number">22</span>);<br>  son.<span class="hljs-title function_">funStr</span>();<br></code></pre></td></tr></table></figure><p>详细过程如下图：</p><p><img src="8fd75ea0c2c6ad0cf84a928e5feac5a6.png" alt="img"></p><h3 id="3-3-ES6中的类和对象"><a href="#3-3-ES6中的类和对象" class="headerlink" title="3.3 ES6中的类和对象"></a>3.3 ES6中的类和对象</h3><p><font color = 'yellow'>注意：</font></p><p>1.在ES6中类没有变量提升，所以必须先定义类，才能通过类实例化对象</p><p>2.类里面的共有属性和方法一定要加this使用</p><p>3.类里面的this指向问题</p><p>4.consturctor里面的this指向实例对象，方法里的this指向这个方法的调用者</p><h2 id="4-类中this指向问题"><a href="#4-类中this指向问题" class="headerlink" title="4.类中this指向问题"></a>4.类中this指向问题</h2><p>1.constructor中的this指向这个实例化对象</p><p>2.函数中的this，谁调用该函数指向谁。例如若是constructor中调用了该函数，则this指向该实例对象；若某个按钮点击触发该函数，则this指向该button；</p><p>案例：选项卡</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;container&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">nav</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;topnav&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;navul&quot;</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;navitem navactive&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>选择一<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;deletebtn&quot;</span>&gt;</span>x<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>          <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;navitem&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>选择二<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;deletebtn&quot;</span>&gt;</span>x<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>          <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;navitem&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>选择三<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;deletebtn&quot;</span>&gt;</span>x<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>          <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;addbtn&quot;</span>&gt;</span>+<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">nav</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;detail&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;item itemactive&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>内容一<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;item&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>内容二<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;item&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>内容三<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> that;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Tab</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>    that = <span class="hljs-variable language_">this</span>;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">doms</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getdoms</span>();<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">init</span>();<br>  &#125;<br>    <br>  <span class="hljs-comment">//获取dom元素</span><br>  <span class="hljs-title function_">getdoms</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">var</span> doms = &#123;<br>      <span class="hljs-attr">navul</span>: <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&quot;.navul&quot;</span>),<br>      <span class="hljs-attr">lis</span>: <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelectorAll</span>(<span class="hljs-string">&quot;.navitem&quot;</span>),<br>      <span class="hljs-attr">detail</span>: <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&quot;.detail&quot;</span>),<br>      <span class="hljs-attr">items</span>: <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelectorAll</span>(<span class="hljs-string">&quot;.item&quot;</span>),<br>      <span class="hljs-attr">addbtn</span>: <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&quot;.addbtn&quot;</span>),<br>      <span class="hljs-attr">deletebtn</span>: <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelectorAll</span>(<span class="hljs-string">&quot;.deletebtn&quot;</span>),<br>      <span class="hljs-attr">nav</span>: <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelectorAll</span>(<span class="hljs-string">&quot;.navul .navitem span:first-child&quot;</span>),<br>      <span class="hljs-attr">itemdetail</span>: <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelectorAll</span>(<span class="hljs-string">&quot;.detail .item span:first-child&quot;</span>),<br>      <span class="hljs-comment">//   itemdetail: document.querySelectorAll(&quot;.item&quot;).firstChild,</span><br>    &#125;;<br>    <span class="hljs-keyword">return</span> doms;<br>  &#125;<br>    <br>  <span class="hljs-comment">//增加、删除以后及时更新</span><br>  <span class="hljs-title function_">updatadoms</span>(<span class="hljs-params"></span>) &#123;<br>    that.<span class="hljs-property">doms</span>.<span class="hljs-property">lis</span> = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelectorAll</span>(<span class="hljs-string">&quot;.navitem&quot;</span>);<br>    that.<span class="hljs-property">doms</span>.<span class="hljs-property">items</span> = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelectorAll</span>(<span class="hljs-string">&quot;.item&quot;</span>);<br>    that.<span class="hljs-property">doms</span>.<span class="hljs-property">deletebtn</span> = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelectorAll</span>(<span class="hljs-string">&quot;.deletebtn&quot;</span>);<br>    (that.<span class="hljs-property">doms</span>.<span class="hljs-property">nav</span> = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelectorAll</span>(<br>      <span class="hljs-string">&quot;.navul .navitem span:first-child&quot;</span><br>    )),<br>      (that.<span class="hljs-property">doms</span>.<span class="hljs-property">itemdetail</span> = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelectorAll</span>(<br>        <span class="hljs-string">&quot;.detail .item span:first-child&quot;</span><br>      ));<br>  &#125;<br>    <br>  <span class="hljs-comment">//页面初始化，绑定点击事件</span><br>  <span class="hljs-comment">//init为constructor中调用，所以this指向这个实例化对象</span><br>  <span class="hljs-title function_">init</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">doms</span>.<span class="hljs-property">lis</span>.<span class="hljs-property">length</span>; i++) &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">doms</span>.<span class="hljs-property">lis</span>[i].<span class="hljs-property">index</span> = i;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">doms</span>.<span class="hljs-property">lis</span>[i].<span class="hljs-property">onclick</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">toggleTab</span>; <span class="hljs-comment">//绑定点击事件</span><br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">doms</span>.<span class="hljs-property">deletebtn</span>[i].<span class="hljs-property">onclick</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">decrease</span>;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">doms</span>.<span class="hljs-property">nav</span>[i].<span class="hljs-property">ondblclick</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">change</span>;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">doms</span>.<span class="hljs-property">itemdetail</span>[i].<span class="hljs-property">ondblclick</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">change</span>;<br>    &#125;<br>    that.<span class="hljs-property">doms</span>.<span class="hljs-property">addbtn</span>.<span class="hljs-property">onclick</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">increase</span>;<br>  &#125;<br>    <br>  <span class="hljs-comment">//排他思想 清除所有的样式</span><br>  <span class="hljs-title function_">clearAllActive</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; that.<span class="hljs-property">doms</span>.<span class="hljs-property">lis</span>.<span class="hljs-property">length</span>; i++) &#123;<br>      that.<span class="hljs-property">doms</span>.<span class="hljs-property">lis</span>[i].<span class="hljs-property">classList</span>.<span class="hljs-title function_">remove</span>(<span class="hljs-string">&quot;navactive&quot;</span>);<br>      that.<span class="hljs-property">doms</span>.<span class="hljs-property">items</span>[i].<span class="hljs-property">classList</span>.<span class="hljs-title function_">remove</span>(<span class="hljs-string">&quot;itemactive&quot;</span>);<br>    &#125;<br>  &#125;<br>    <br>  <span class="hljs-comment">//点击切换</span><br>  <span class="hljs-title function_">toggleTab</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">//this谁调用就指向谁，这里是li点击事件调用，所以指向li </span><br>    <span class="hljs-comment">//排他思想，先删除所有的</span><br>    that.<span class="hljs-title function_">clearAllActive</span>();<br>    that.<span class="hljs-property">doms</span>.<span class="hljs-property">lis</span>[<span class="hljs-variable language_">this</span>.<span class="hljs-property">index</span>].<span class="hljs-property">classList</span>.<span class="hljs-title function_">add</span>(<span class="hljs-string">&quot;navactive&quot;</span>);<br>    that.<span class="hljs-property">doms</span>.<span class="hljs-property">items</span>[<span class="hljs-variable language_">this</span>.<span class="hljs-property">index</span>].<span class="hljs-property">classList</span>.<span class="hljs-title function_">add</span>(<span class="hljs-string">&quot;itemactive&quot;</span>);<br>  &#125;<br>    <br>  <span class="hljs-comment">//增</span><br>  <span class="hljs-title function_">increase</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">//点击+按钮调用此函数，所以此时this指向btn</span><br>    that.<span class="hljs-title function_">clearAllActive</span>();<br>    <span class="hljs-keyword">var</span> li = <span class="hljs-string">`&lt;li class=&quot;navitem navactive&quot;&gt;&lt;span&gt;新选项卡&lt;/span&gt;</span><br><span class="hljs-string">    &lt;button class=&quot;deletebtn&quot;&gt;x&lt;/button&gt;</span><br><span class="hljs-string">    &lt;/li&gt;`</span>;<br>    <span class="hljs-keyword">var</span> div = <span class="hljs-string">`&lt;div class=&quot;item itemactive&quot;&gt;&lt;span&gt;新内容<span class="hljs-subst">$&#123;<span class="hljs-built_in">Math</span>.random(</span></span><br><span class="hljs-subst"><span class="hljs-string">      <span class="hljs-number">0</span>,</span></span><br><span class="hljs-subst"><span class="hljs-string">      <span class="hljs-number">1</span></span></span><br><span class="hljs-subst"><span class="hljs-string">    )&#125;</span>&lt;/span&gt;&lt;/div&gt;`</span>;<br>    that.<span class="hljs-property">doms</span>.<span class="hljs-property">navul</span>.<span class="hljs-title function_">insertAdjacentHTML</span>(<span class="hljs-string">&quot;beforeend&quot;</span>, li);<br>    that.<span class="hljs-property">doms</span>.<span class="hljs-property">detail</span>.<span class="hljs-title function_">insertAdjacentHTML</span>(<span class="hljs-string">&quot;beforeend&quot;</span>, div);<br>    that.<span class="hljs-title function_">updatadoms</span>();<br>    that.<span class="hljs-title function_">init</span>(); <span class="hljs-comment">//增加以后要重新为所有的绑定点击事件</span><br>  &#125;<br>    <br>  <span class="hljs-comment">//删</span><br>  <span class="hljs-title function_">decrease</span>(<span class="hljs-params">e</span>) &#123;<br>    <span class="hljs-comment">//this指向deletebtn</span><br>    e.<span class="hljs-title function_">stopPropagation</span>();<br>    <span class="hljs-keyword">var</span> index = <span class="hljs-variable language_">this</span>.<span class="hljs-property">parentNode</span>.<span class="hljs-property">index</span>; <span class="hljs-comment">//通过父元素找到index</span><br>    that.<span class="hljs-property">doms</span>.<span class="hljs-property">lis</span>[index].<span class="hljs-title function_">remove</span>();<br>    that.<span class="hljs-property">doms</span>.<span class="hljs-property">items</span>[index].<span class="hljs-title function_">remove</span>();<br>    that.<span class="hljs-title function_">updatadoms</span>();<br>    <span class="hljs-comment">//当删除的不是选中状态的时候，直接删除</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&quot;.navactive&quot;</span>)) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-comment">//当删除了选中状态的li的时候，让他的前一个处于选定状态</span><br>    <span class="hljs-keyword">if</span> (index &gt; <span class="hljs-number">0</span>) &#123;<br>      that.<span class="hljs-property">doms</span>.<span class="hljs-property">lis</span>[--index].<span class="hljs-title function_">click</span>();<br>    &#125;<br>  &#125;<br>    <br>  <span class="hljs-comment">//改</span><br>  <span class="hljs-title function_">change</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">//禁止双击选定文字</span><br>    <span class="hljs-variable language_">window</span>.<span class="hljs-property">getSelection</span><br>      ? <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">getSelection</span>().<span class="hljs-title function_">removeAllRanges</span>()<br>      : <span class="hljs-variable language_">document</span>.<span class="hljs-property">getSelection</span>.<span class="hljs-title function_">empty</span>();<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>);<br>    <span class="hljs-comment">//this指向当前点击span</span><br>    <span class="hljs-keyword">var</span> originvalue = <span class="hljs-variable language_">this</span>.<span class="hljs-property">innerHTML</span>;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">innerHTML</span> = <span class="hljs-string">`&lt;input type= &#x27;text&#x27; style = &#x27;max-width:60px&#x27;&gt;`</span>;<br>    <span class="hljs-keyword">var</span> input = <span class="hljs-variable language_">this</span>.<span class="hljs-property">children</span>[<span class="hljs-number">0</span>];<br>    input.<span class="hljs-property">value</span> = originvalue;<br>    input.<span class="hljs-title function_">select</span>(); <span class="hljs-comment">//文本框文字处于选定状态</span><br>    input.<span class="hljs-property">onblur</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-comment">//由于这是文本框失去焦点才调用该函数，所以此时this指向文本框</span><br>      <span class="hljs-comment">//此时 this.parentNode = span标签</span><br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>);<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">parentNode</span>.<span class="hljs-property">innerHTML</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>;<br>    &#125;;<br>    input.<span class="hljs-property">onkeyup</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) &#123;<br>      <span class="hljs-keyword">if</span> (e.<span class="hljs-property">keyCode</span> == <span class="hljs-number">13</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">blur</span>(); <span class="hljs-comment">//注意这种方法，几个函数执行相同的操作时，可以直接执行已经定义好的函数。</span><br>      &#125;<br>    &#125;;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">var</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Tab</span>();<br></code></pre></td></tr></table></figure><img src="image-20230516123819006.png" alt="image-20230516123819006" style="zoom:50%;" />]]></content>
    
    
    <categories>
      
      <category>javascript</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>属性描述符_Object.defineProperty</title>
    <link href="/2023/05/15/%E5%B1%9E%E6%80%A7%E6%8F%8F%E8%BF%B0%E7%AC%A6-Object-defineProperty/"/>
    <url>/2023/05/15/%E5%B1%9E%E6%80%A7%E6%8F%8F%E8%BF%B0%E7%AC%A6-Object-defineProperty/</url>
    
    <content type="html"><![CDATA[<h1>属性描述符</h1><p>从ES5开始，所有属性具有属性描述符。属性方法为 Object.getOwnPropertyDescriptor()</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> object = &#123;<br>    <span class="hljs-attr">a</span>: <span class="hljs-number">2</span><br>&#125;<br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getOwnPropertyDescriptor</span>(object,<span class="hljs-string">&quot;a&quot;</span>);<br><span class="hljs-comment">//返回 &#123;value: 2, writable: true, enumerable: true, configurable: true&#125;</span><br></code></pre></td></tr></table></figure><p>MDN参考文档：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty</a></p><h2>1.什么是属性描述符</h2><p><strong>(1)数据属性描述符</strong></p><ul><li><code>configurable</code>：可配置性，控制着其描述的属性的修改，表示能否修改属性的特性，能否把属性修改为访问器属性，或者能否通过<code>delete</code>删除属性从而重新定义属性。默认值为<code>true</code>。</li><li><code>enumerable</code>：可枚举性，表示能否通过<code>for-in</code>遍历得到属性。默认值为<code>true</code>。</li><li><code>writable</code>：可写性，表示能否修改属性的值。默认值为<code>true</code>。</li><li><code>value</code>：<code>数据属性</code>，表示属性的值。默认值为<code>undefined</code>。</li></ul><p><strong>（2）存取属性描述符</strong></p><ul><li><code>get</code>：在读取属性时调用的函数。只指定<code>get</code>则表示属性为只读属性。默认值为<code>undefined</code>。</li><li><code>set</code>：在写入属性时调用的函数。只指定<code>set</code>则表示属性为只写属性。默认值为<code>undefined</code>。</li></ul><p><font color='yellow'>存取描述符的使用场景：</font></p><p><font color='yellow'>1.隐藏一个私有属性。如下例子中隐藏属性add。</font></p><p><font color='yellow'>2.截获某一个属性的访问和设置值的过程，即在某个属性获取或设置的过程中需要进行某些操作时</font></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;kobe&quot;</span>,<br>  <span class="hljs-attr">age</span>: <span class="hljs-number">40</span>,<br>&#125;;<br><br><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(obj, <span class="hljs-string">&quot;_address&quot;</span>, &#123;<br>  <span class="hljs-attr">value</span>: <span class="hljs-string">&quot;北京&quot;</span>,   <span class="hljs-comment">//数据属性描述符</span><br>  <span class="hljs-attr">configurable</span>: <span class="hljs-literal">true</span>,<br>  <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">false</span>,<br>  <span class="hljs-attr">writable</span>: <span class="hljs-literal">true</span>,<br>&#125;)<br><br><br><span class="hljs-comment">//存取属性描述符的用法一：隐藏一个私有属性，不希望被外界直接使用和赋值</span><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(obj, <span class="hljs-string">&quot;add&quot;</span>, &#123;<br>  <span class="hljs-attr">configurable</span>: <span class="hljs-literal">true</span>,<br>  <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">true</span>,<br>  <span class="hljs-attr">get</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">_address</span><br>  &#125;,<br>  <span class="hljs-attr">set</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">val</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">_address</span> = val<br>  &#125;<br>&#125;)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj) <span class="hljs-comment">//&#123; name: &#x27;kobe&#x27;, age: 40, address: [Getter/Setter] &#125;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-property">add</span>) <span class="hljs-comment">//北京</span><br>obj.<span class="hljs-property">address</span> = <span class="hljs-string">&quot;上海&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-property">add</span>) <span class="hljs-comment">//上海</span><br><br><span class="hljs-comment">//存取属性描述符的用法二：截获某一个属性的访问和设置值的过程，</span><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(obj, <span class="hljs-string">&quot;address&quot;</span>, &#123;<br>  <span class="hljs-attr">configurable</span>: <span class="hljs-literal">true</span>,<br>  <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">true</span>,<br>  <span class="hljs-attr">get</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;获取了address的值&quot;</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">_address</span><br>  &#125;,<br>  <span class="hljs-attr">set</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">val</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;设置了address的值&quot;</span>)<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">_address</span> = val<br>  &#125;<br>&#125;)<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-property">address</span>)<br>obj.<span class="hljs-property">address</span> = <span class="hljs-number">50</span><br></code></pre></td></tr></table></figure><h2>2.属性描述符的应用</h2><p><strong>1.利用存取器属性来限制取值的范围</strong></p><p>例如，需要一个用户对象，保存姓名和年龄，对于年龄范围为0~150</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//构造函数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">User</span>(<span class="hljs-params">name,age</span>)&#123;<br>    <span class="hljs-comment">// 假设年龄范围为 0 ~ 150</span><br>    <span class="hljs-keyword">if</span> (age &gt; <span class="hljs-number">150</span>) &#123;<br>        age = <span class="hljs-number">150</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(age &lt; <span class="hljs-number">0</span>) &#123;<br>        age = <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age;<br>&#125;<br><span class="hljs-keyword">var</span> user = <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&quot;name&quot;</span>,<span class="hljs-number">18</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(user);   <span class="hljs-comment">// 输出User &#123;name: &#x27;name&#x27;, age: 18&#125;</span><br></code></pre></td></tr></table></figure><p><font color='red'>问题：</font>这样看起来没啥毛病，但会有个隐患，对于构造的user这个对象是可更改的，如果你哪天将年龄重新修改了，但忘了年龄范围，这时就会出现下面的情况</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">User</span>(<span class="hljs-params">name,age</span>)&#123;<br>    <span class="hljs-keyword">if</span> (age &gt; <span class="hljs-number">150</span>) &#123;<br>        age = <span class="hljs-number">150</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(age &lt; <span class="hljs-number">0</span>) &#123;<br>        age = <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age;<br>&#125;<br> <br><span class="hljs-keyword">var</span> user = <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&quot;name&quot;</span>,<span class="hljs-number">18</span>);<br>user.<span class="hljs-property">age</span> = <span class="hljs-number">1000</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(user);  <span class="hljs-comment">// 输出User &#123;name: &#x27;name&#x27;, age: 1000&#125;</span><br></code></pre></td></tr></table></figure><p><font color='red'>解决方案：</font>利用存取属性运算符来控制年龄范围</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">User</span>(<span class="hljs-params">name, age</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>    <span class="hljs-keyword">var</span> _age<br>    <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(<span class="hljs-variable language_">this</span>, <span class="hljs-string">&quot;age&quot;</span>, &#123;<br>        <span class="hljs-title function_">get</span>(<span class="hljs-params"></span>) &#123;<br>            <span class="hljs-keyword">return</span> _age<br>        &#125;,<br>        <span class="hljs-title function_">set</span>(<span class="hljs-params">value</span>) &#123;<br>            <span class="hljs-keyword">if</span> (value &lt; <span class="hljs-number">0</span>) &#123;<br>                value = <span class="hljs-number">0</span>;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (value &gt; <span class="hljs-number">150</span>) &#123;<br>                value = <span class="hljs-number">150</span>;<br>            &#125;<br>            _age = value;<br>        &#125;<br>    &#125;)<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = _age;<br>&#125;<br> <br><span class="hljs-keyword">var</span> user = <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-number">18</span>);<br>user.<span class="hljs-property">age</span> = <span class="hljs-number">1000</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(user); <br></code></pre></td></tr></table></figure><p><img src="image-20230515143820404.png" alt="image-20230515143820404"></p>]]></content>
    
    
    <categories>
      
      <category>javascript</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>工厂模式&amp;构造函数&amp;原型模式&amp;组合模式</title>
    <link href="/2023/05/14/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F-%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/"/>
    <url>/2023/05/14/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F-%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h2>1.js面向对象程序</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> o1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>    o1.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;张三&quot;</span>;<br>    o1.<span class="hljs-property">sex</span> = <span class="hljs-string">&quot;男&quot;</span>;<br>    o1.<span class="hljs-property">age</span> = <span class="hljs-string">&quot;27&quot;</span>;<br>o1.<span class="hljs-property">msg</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;姓名：&quot;</span>+<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>+<span class="hljs-string">&quot;  性别：&quot;</span>+<span class="hljs-variable language_">this</span>.<span class="hljs-property">sex</span>+<span class="hljs-string">&quot;  年龄：&quot;</span>+<span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span>);<br>&#125;<br> <br><span class="hljs-keyword">var</span> o2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>    o2.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;李四&quot;</span>;<br>    o2.<span class="hljs-property">sex</span> = <span class="hljs-string">&quot;女&quot;</span>;<br>    o2.<span class="hljs-property">age</span> = <span class="hljs-string">&quot;20&quot;</span>;<br>o2.<span class="hljs-property">msg</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;姓名：&quot;</span>+<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>+<span class="hljs-string">&quot;  性别：&quot;</span>+<span class="hljs-variable language_">this</span>.<span class="hljs-property">sex</span>+<span class="hljs-string">&quot;  年龄：&quot;</span>+<span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span>);<br>&#125;<br><span class="hljs-comment">//调用对象下面方法</span><br>o1.<span class="hljs-title function_">msg</span>();<br>o2.<span class="hljs-title function_">msg</span>();<br></code></pre></td></tr></table></figure><p>Q1： 如何让代码复用？</p><p>answer：为了解决这个，产生了JavaScript设计模式。</p><br><h2>2.工厂模式</h2><p>Q1: 什么是工厂模式？</p><p>answer：工厂模式是一种众所周知的设计模式，广泛应用于软件工程领域，用于抽象创建特定对象的过程。工厂模式是一种创建型模式，简单来说，工厂模式就是创建对象的一种方式。</p><p>Q2: 工厂模式有什么用？</p><p>answer： 作用：创建对象；降低代码冗余度。</p><p>应用场景：当你想要批量生产同种类的对象的时候；比如，你想生成一个班级的40个学生，每个学生都有姓名、年龄等特征。这时候你创建一个“工厂”，把信息丢到工厂里，工厂就给你造一个人出来，非常方便。</p><p>使用工厂模式的方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//将创建对象的代码封装在一个函数中</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">createPerson</span>(<span class="hljs-params">name, age, gender</span>) &#123;<br>  <span class="hljs-keyword">var</span> person = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>  person.<span class="hljs-property">name</span> = name;<br>  person.<span class="hljs-property">age</span> = age;<br>  person.<span class="hljs-property">gender</span> = gender;<br>  person.<span class="hljs-property">sayName</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);<br>  &#125;<br>  <span class="hljs-keyword">return</span> person;<br>&#125;<br><span class="hljs-comment">//利用工厂函数来创建对象</span><br><span class="hljs-keyword">var</span> person1 = <span class="hljs-title function_">createPerson</span>(<span class="hljs-string">&quot;张三&quot;</span>, <span class="hljs-number">17</span>, <span class="hljs-string">&#x27;male&#x27;</span>);<br><span class="hljs-keyword">var</span> person2 = <span class="hljs-title function_">createPerson</span>(<span class="hljs-string">&quot;李四&quot;</span>, <span class="hljs-number">20</span>, <span class="hljs-string">&#x27;female&#x27;</span>);<br></code></pre></td></tr></table></figure><p><font color = 'yellow'>优点：</font>只要我们往工厂函数里面塞参数，工厂函数就会像生产产品一样造个人出来，并且可以比较方便的一次创建多个具有相同属性的对象。</p><p><font color = 'yellow'>缺点：</font>这种方式本质上是将创建对象的过程进行了封装，本质并没有改变，我们创建一个student时无法知道其具体的数据类型，只知道这是一个对象，无法知道我们创建的对象和系统对象有什么区别，但是往往实际开发中我们需要确定这个对象到底是个Person的实例还是Dog的实例。</p><p><strong>为了解决这个：我们需要在外面new一个函数就可以了，这就引出了js另一种设计模式：构造函数模式</strong></p><h2>3.构造函数</h2><p>构造函数的特点：</p><ul><li>构造函数有原型对象prototype</li><li>构造函数原型对象prototype里面有constructor指向构造函数本身</li><li>构造函数可以通过原型对象添加方法</li><li>构造函数创建的实例对象有_proto_原型指向构造函数的原型对象。即<code>new Father().__proto__ === Father.prototype</code></li></ul><p>构造函数的使用方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 自定义构造函数  规定：构造函数首字母大写</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name, age, gender</span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">gender</span> = gender;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">sayName</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);<br>  &#125;<br>&#125;<br><span class="hljs-comment">//要创建 Person 的实例，应使用 new 操作符。</span><br><span class="hljs-keyword">var</span> person1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&#x27;张三&#x27;</span>, <span class="hljs-number">17</span>, <span class="hljs-string">&#x27;male&#x27;</span>); <span class="hljs-comment">//调用构造函数以后会执行以下四步：</span><br><span class="hljs-keyword">var</span> person2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&#x27;李四&#x27;</span>, <span class="hljs-number">19</span>, <span class="hljs-string">&#x27;female&#x27;</span>);<br><br>person1.<span class="hljs-title function_">sayName</span>(); <span class="hljs-comment">// 张三</span><br>person2.<span class="hljs-title function_">sayName</span>(); <span class="hljs-comment">// 李四</span><br><br><span class="hljs-comment">//instanceof运算符用于检测构造函数的 prototype` 属性是否出现在某个实例对象的原型链上。或者说判断一个对象是某个对象的实例。</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person1 <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Object</span>); <span class="hljs-comment">// true  person1是 Object 的实例，同时也是 Person 的实例</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person1 <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Person</span>); <span class="hljs-comment">// true </span><br></code></pre></td></tr></table></figure><p>(1) 在内存中创建一个新对象。</p><p>(2) 这个新对象内部的[[Prototype]] 特性被赋值为构造函数的 prototype 属性。</p><p>(3) 构造函数内部的 this 被赋值为这个新对象（即 this 指向新对象）。</p><p>(4) 执行构造函数内部的代码（给新对象添加属性）。</p><p>(5) 如果构造函数返回非空对象，则返回该对象；否则，返回刚创建的新对象。</p><br><p><font color='yellow'>构造函数的主要问题</font>在于，其定义的方法会在每个实例上都创建一遍。因此对前面的案例而言，person1 和 person2 都有名为 sayName()的方法，但这两个方法不是同一个 Function 实例,<font color='red'>存在浪费内存的问题</font>我们知道，ECMAScript 中的函数是对象，因此每次定义函数时，都会初始化一个对象。逻辑上讲，这个构造函数实际上是这样的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name, age, gender</span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">gender</span> = gender;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">sayName</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Function</span>(<span class="hljs-string">&quot;console.log(this.name)&quot;</span>); <span class="hljs-comment">// 逻辑等价</span><br>&#125;<br></code></pre></td></tr></table></figure><p>Q3: 如何在提供性能？？也就是让公用的属性和方法在内存中只存在一份？？</p><p><strong>answer: 这里用到js设计模式中另外一种模式：原型模式。就是将公用的属性和方法加载在原型上（prototype</strong>）</p><h2>4.原型模式</h2><p>1.原型是什么？</p><p>原型是一个对象，我们也称prototype为原型对象。</p><p>2.原型的作用是什么？</p><p>答：共享方法。</p><p>原型模式的使用方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params"></span>)&#123;&#125;<br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;张三&quot;</span>;<br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">sex</span> = <span class="hljs-string">&quot;男&quot;</span>;<br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">age</span> = <span class="hljs-string">&quot;10&quot;</span>;<br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">msg</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;姓名：&quot;</span>+<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>+<span class="hljs-string">&quot;  性别：&quot;</span>+<span class="hljs-variable language_">this</span>.<span class="hljs-property">sex</span>+<span class="hljs-string">&quot;  年龄：&quot;</span>+<span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span>);<br>&#125;<br><span class="hljs-keyword">var</span> person1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person1) <span class="hljs-comment">//对象身上系统添加一个 _proto_ 指向我们构造函数的原型对象 prototype</span><br>person1.<span class="hljs-title function_">msg</span>();<br><span class="hljs-keyword">var</span> person2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br>person2.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;李四&quot;</span>;<br>person2.<span class="hljs-title function_">msg</span>();<br></code></pre></td></tr></table></figure><p>原型模式导致的问题：</p><p>（1）它弱化了向构造函数传递初始化参数的能力，会导致所有实例默认都取得相同的属性值。</p><p>（2）原型上的所有属性是在实例间共享的（这对于一些相同的函数是优点，但是对于属性值就是缺点了，但一般来说，不同的实例应该有属于自己的属性副本。例子如下）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params"></span>) &#123; &#125;  <span class="hljs-comment">//构造函数</span><br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = &#123;<br>  <span class="hljs-attr">constructor</span>: <span class="hljs-title class_">Person</span>,  <span class="hljs-comment">//如果我们修改了原来的原型对象，即按此方法将原型赋值一个对象，则必须手动利用constructor指回原来的构造函数。</span><br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;zhangsan&quot;</span>,<br>  <span class="hljs-attr">friends</span>: [<span class="hljs-string">&quot;lisi&quot;</span>, <span class="hljs-string">&quot;wangwu&quot;</span>],<br>  <span class="hljs-title function_">sayName</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);<br>  &#125;<br>&#125;;<br><span class="hljs-keyword">var</span> person1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br><span class="hljs-keyword">var</span> person2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();  <span class="hljs-comment">//缺点一：person1和person2初始化的参数都相同。</span><br>person1.<span class="hljs-property">friends</span>.<span class="hljs-title function_">push</span>(<span class="hljs-string">&quot;zhaoliu&quot;</span>); <span class="hljs-comment">//缺点二：由于原型上的friends也是共享的，所以更改person1的friends也会导致person2的friends改变。</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person1.<span class="hljs-property">friends</span>); <span class="hljs-comment">// [ &#x27;lisi&#x27;, &#x27;wangwu&#x27;, &#x27;zhaoliu&#x27; ]</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person2.<span class="hljs-property">friends</span>); <span class="hljs-comment">// [ &#x27;lisi&#x27;, &#x27;wangwu&#x27;, &#x27;zhaoliu&#x27; ]</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person1.<span class="hljs-property">friends</span> === person2.<span class="hljs-property">friends</span>); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>为了既要高度复用方法函数，又要保证实例化对象都有各自的属性副本，<strong>所以产生了组合模式：（构造函数+原型模式）构造函数用于定义实例属性，原型模式用于定义方法和共享属性。</strong></p><h2>5.混合模式</h2><p>混合模式使用方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name, age, gender</span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;   <span class="hljs-comment">//构造函数中this指向对象实例</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">gender</span> = gender;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">firends</span> = [<span class="hljs-string">&#x27;zhangsan&#x27;</span>, <span class="hljs-string">&#x27;lisi&#x27;</span>];<br>&#125;<br>person.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">sayName</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>) <span class="hljs-comment">//原型对象函数里面的this指向对象实例</span><br>&#125;<br><br><span class="hljs-comment">// Person.prototype = &#123;    //原型模式用于定义方法和共享属性</span><br><span class="hljs-comment">//  constructor: Person,   ////如果我们修改了原来的原型对象，即按此方法将原型赋值一个对象，则必须手动利用constructor指回原来的构造函数。</span><br><span class="hljs-comment">//  sayName: function () &#123;</span><br><span class="hljs-comment">//    console.log(this.name);</span><br><span class="hljs-comment">//  &#125;</span><br><span class="hljs-comment">//&#125;;</span><br><span class="hljs-keyword">var</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&#x27;larry&#x27;</span>, <span class="hljs-number">44</span>, <span class="hljs-string">&#x27;male&#x27;</span>); <span class="hljs-comment">//构造函数用于定义实例属性</span><br><span class="hljs-keyword">var</span> p2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&#x27;terry&#x27;</span>, <span class="hljs-number">39</span>, <span class="hljs-string">&#x27;male&#x27;</span>);<br><br>p1.<span class="hljs-property">firends</span>.<span class="hljs-title function_">push</span>(<span class="hljs-string">&#x27;robin&#x27;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p1.<span class="hljs-property">firends</span>); <span class="hljs-comment">// [ &#x27;zhangsan&#x27;, &#x27;lisi&#x27;, &#x27;robin&#x27; ]</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p2.<span class="hljs-property">firends</span>); <span class="hljs-comment">// [ &#x27;zhangsan&#x27;, &#x27;lisi&#x27; ]</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p1.<span class="hljs-property">firends</span> === p2.<span class="hljs-property">firends</span>); <span class="hljs-comment">// false</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p1.<span class="hljs-property">sayName</span> === p2.<span class="hljs-property">sayName</span>); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>JavaScript在es6才出现class类的写法，类的本质也就是构造函数，上述功能代码在es6中可以这样写：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-comment">//构造函数用于定义实例属性</span><br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name, age, gender</span>)&#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">gender</span> = gender;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">firends</span> = [<span class="hljs-string">&#x27;zhangsan&#x27;</span>, <span class="hljs-string">&#x27;lisi&#x27;</span>];<br>    &#125;<br>    <span class="hljs-comment">//共有方法</span><br>    <span class="hljs-title function_">sayName</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>构造函数、实例、原型对象三者之间的关系</p><p><img src="image-20230516145743440.png" alt="image-20230516145743440"></p><h2 id="附：原型链"><a href="#附：原型链" class="headerlink" title="附：原型链"></a>附：原型链</h2><p><img src="image-20230516150251094.png" alt="image-20230516150251094"></p><p><img src="image-20230516150721747.png" alt="image-20230516150721747"></p><p>原型的作用：</p><p>扩展内置对象方法：</p><p>例如：Array数组原型本身没有求和方法，但是可以通过自定义添加扩展该方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr.<span class="hljs-title function_">sum</span>())  <span class="hljs-comment">//error 没有sum方法</span><br><br><span class="hljs-keyword">var</span> sum = <span class="hljs-number">0</span>;<br><span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">sum</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span> ;i&lt;<span class="hljs-variable language_">this</span>.<span class="hljs-property">length</span>;i++) &#123;<br>        sum += <span class="hljs-variable language_">this</span>[i];<br>    &#125;<br>    <span class="hljs-keyword">return</span> sum;<br>&#125;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr.<span class="hljs-title function_">sum</span>())  <span class="hljs-comment">//6</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>javascript</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>浏览器是如何渲染页面的</title>
    <link href="/2023/05/10/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%98%AF%E5%A6%82%E4%BD%95%E6%B8%B2%E6%9F%93%E9%A1%B5%E9%9D%A2%E7%9A%84/"/>
    <url>/2023/05/10/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%98%AF%E5%A6%82%E4%BD%95%E6%B8%B2%E6%9F%93%E9%A1%B5%E9%9D%A2%E7%9A%84/</url>
    
    <content type="html"><![CDATA[<h2 id="浏览器是如何渲染页面的？"><a href="#浏览器是如何渲染页面的？" class="headerlink" title="浏览器是如何渲染页面的？"></a>浏览器是如何渲染页面的？</h2><p><img src="image-20230510185204042.png" alt="image-20230510185204042"></p><p><strong>当浏览器的网络线程收到 HTML 文档后，会产生一个渲染任务，并将其传递给渲染主线程的消息队列。</strong></p><p><strong>在事件循环机制的作用下，渲染主线程取出消息队列中的渲染任务，开启渲染流程。</strong></p><hr><p><img src="image-20230510185123102.png" alt="image-20230510185123102"></p><p><strong>整个渲染流程分为多个阶段，分别是： HTML 解析、样式计算、布局、分层、绘制、分块、光栅化、画</strong></p><p>每个阶段都有明确的输入输出，上一个阶段的输出会成为下一个阶段的输入。</p><p>这样，整个渲染流程就形成了一套组织严密的生产流水线。</p><hr><img src="image-20230510190804294.png" alt="image-20230510190804294" style="zoom:50%;" /><p>渲染的第一步是<strong>解析 HTML</strong>。</p><p>解析过程中<strong>遇到 CSS 解析 CSS，遇到 JS 执行 JS</strong>。为了提高解析效率，浏览器在开始解析前，会启动一个<strong>预解析</strong>的线程，率先下载 HTML 中的外部 CSS 文件和 外部的 JS 文件。</p><p>如果主线程解析到<code>link</code>位置，此时外部的 CSS 文件还没有下载解析好，主线程<strong>不会等待</strong>，继续解析后续的 HTML。这是因为下载和解析 CSS 的工作是在预解析线程中进行的。这就是<font color = 'yellow'><u> <em><strong>CSS 不会阻塞 HTML 解析的根本原因</strong></em></u></font>。</p><p>如果主线程解析到<code>script</code>位置，会停止解析 HTML，转而等待 JS 文件下载好，并将全局代码解析执行完成后，才能继续解析 HTML。这是因为 JS 代码的执行过程可能会修改当前的 DOM 树，所以 DOM 树的生成必须暂停。这就是 <font color = 'yellow'><u><em><strong>JS 会阻塞 HTML 解析的根本原因</strong></em></u></font>。</p><p>第一步完成后，会得到 DOM 树和 CSSOM 树，浏览器的默认样式、内部样式、外部样式、行内样式均会包含在 CSSOM 树中。</p><hr><img src="image-20230510190854155.png" alt="image-20230510190854155" style="zoom:50%;" /><p>渲染的下一步是<strong>样式计算</strong>。</p><p>主线程会遍历得到的 DOM 树，依次为树中的每个节点计算出它最终的样式，称之为 Computed Style。</p><p>在这一过程中，很多预设值会变成绝对值，比如<code>red</code>会变成<code>rgb(255,0,0)</code>；相对单位会变成绝对单位，比如<code>em</code>会变成<code>px</code></p><p>这一步完成后，会得到一棵带有样式的 DOM 树。</p><hr><img src="image-20230510190928454.png" alt="image-20230510190928454" style="zoom:50%;" /><p>接下来是<strong>布局</strong>，布局完成后会得到布局树。</p><p>布局阶段会依次遍历 DOM 树的每一个节点，计算每个节点的几何信息。例如节点的宽高、相对包含块的位置。</p><img src="image-20230510191019415.png" alt="image-20230510191019415" style="zoom:50%;" /><p>大部分时候，DOM 树和布局树并非一一对应。</p><p>比如<code>display:none</code>的节点没有几何信息，因此不会生成到布局树；又比如使用了伪元素选择器，虽然 DOM 树中不存在这些伪元素节点，但它们拥有几何信息，所以会生成到布局树中。还有匿名行盒、匿名块盒等等都会导致 DOM 树和布局树无法一一对应。</p><hr><img src="image-20230510191104801.png" alt="image-20230510191104801" style="zoom:50%;" /><p>下一步是<strong>分层</strong></p><p>主线程会使用一套复杂的策略对整个布局树中进行分层。</p><p>分层的好处在于，将来某一个层改变后，仅会对该层进行后续处理，从而提升效率。</p><p>滚动条、堆叠上下文、transform、opacity 等样式都会或多或少的影响分层结果，也可以通过<code>will-change</code>属性更大程度的影响分层结果。</p><hr><p>再下一步是<strong>绘制</strong></p><img src="image-20230510191244535.png" alt="image-20230510191244535" style="zoom:50%;" /><p><font color = 'skyblue'><em><strong>渲染主线程的工作到此结束，剩余步骤由其他线程完成。</strong></em></font></p><p>主线程会为每个层单独产生绘制指令集，用于描述这一层的内容该如何画出来。</p><hr><img src="image-20230510191359252.png" alt="image-20230510191359252" style="zoom:50%;" /><img src="image-20230510191636181.png" alt="image-20230510191636181" style="zoom:50%;" /><p>完成绘制后，主线程将每个图层的绘制信息提交给合成线程，剩余工作将由合成线程完成。</p><p>合成线程首先对每个图层进行分块，将其划分为更多的小区域。</p><p>它会从线程池中拿取多个线程来完成分块工作。</p><hr><img src="image-20230510191715718.png" alt="image-20230510191715718" style="zoom:50%;" /><p>分块完成后，进入<strong>光栅化</strong>阶段。</p><p>合成线程会将块信息交给 GPU 进程，以极高的速度完成光栅化。</p><p>GPU 进程会开启多个线程来完成光栅化，并且优先处理靠近视口区域的块。</p><p>光栅化的结果，就是一块一块的位图</p><hr><img src="image-20230510191749513.png" alt="image-20230510191749513" style="zoom:50%;" /><p>最后一个阶段就是<strong>画</strong>了</p><p>合成线程拿到每个层、每个块的位图后，生成一个个「指引（quad）」信息。</p><p>指引会标识出每个位图应该画到屏幕的哪个位置，以及会考虑到旋转、缩放等变形。</p><p><font color = 'yellow'><em><strong>变形发生在合成线程，与渲染主线程无关，这就是<code>transform</code>效率高的本质原因。</strong></em></font></p><p>合成线程会把 quad 提交给 GPU 进程，由 GPU 进程产生系统调用，提交给 GPU 硬件，完成最终的屏幕成像。</p><h2 id="什么是-reflow？"><a href="#什么是-reflow？" class="headerlink" title="什么是 reflow？"></a>什么是 reflow？</h2><p>reflow 的本质就是重新计算 layout 树。</p><p>当进行了会影响布局树的操作后，需要重新计算布局树，会引发 layout。</p><p>为了避免连续的多次操作导致布局树反复计算，浏览器会合并这些操作，当 JS 代码全部完成后再进行统一计算。所以，改动属性造成的 reflow 是异步完成的。</p><p>也同样因为如此，当 JS 获取布局属性时，就可能造成无法获取到最新的布局信息。</p><p>浏览器在反复权衡下，最终决定获取属性立即 reflow。</p><h2 id="什么是-repaint？"><a href="#什么是-repaint？" class="headerlink" title="什么是 repaint？"></a>什么是 repaint？</h2><p>repaint 的本质就是重新根据分层信息计算了绘制指令。</p><p>当改动了可见样式后，就需要重新计算，会引发 repaint。</p><p>由于元素的布局信息也属于可见样式，所以 reflow 一定会引起 repaint。</p><h2 id="为什么-transform-的效率高？"><a href="#为什么-transform-的效率高？" class="headerlink" title="为什么 transform 的效率高？"></a>为什么 transform 的效率高？</h2><p>因为 transform 既不会影响布局也不会影响绘制指令，它影响的只是渲染流程的最后一个「draw」阶段</p><p>由于 draw 阶段在合成线程中，所以 transform 的变化几乎不会影响渲染主线程。反之，渲染主线程无论如何忙碌，也不会影响 transform 的变化。</p>]]></content>
    
    
    <categories>
      
      <category>常见问题</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>position定位</title>
    <link href="/2023/05/10/position%E5%AE%9A%E4%BD%8D/"/>
    <url>/2023/05/10/position%E5%AE%9A%E4%BD%8D/</url>
    
    <content type="html"><![CDATA[<h1>position定位属性值</h1><h2>1.position属性值</h2><p>① <code>relative</code>:相对定位：相对于自己在文档流中的<font color='yellow'>初始位置</font>偏移定位。<br>② <code>fixed</code>：固定定位：相对于<font color='yellow'>浏览器窗口</font>定位。<br>③ <code>absolute</code>：绝对定位：是相对于<font color='yellow'>父级非 position:static </font>定位。<br>如果没有任何一个父级元素是非 position:static属性，则会相对于文档定位。<br>这里它的父级元素是包含爷爷级元素、祖爷爷级元素、祖宗十八代级元素的。任意一级都可以。<br>如果它的父级元素和爷爷级元素都是非 position:static 属性，则，它会选择距离最近的父元素。</p><p>④ <code>static</code>:该关键字指定元素使用正常的布局行为，即元素在文档常规流中当前的布局位置。此时 top、right、bottom、left 属性无效。static是position的默认值 。</p><p>⑤ <code>sticky</code>:盒位置根据正常流计算(这称为正常流动中的位置)，然后相对于该元素在流中的 flow root（BFC）和 containing block（最近的块级祖先元素）定位。在所有情况下（即便被定位元素为 table时），该元素定位均不对后续元素造成影响。当元素 B 被粘性定位时，后续元素的位置仍按照 B 未定位时的位置来确定。position: sticky对 table元素的效果与 position: relative 相同。</p><h2>2.是否脱离文档流</h2><p>① position: relative;不会脱离文档流，</p><p>② position: fixed，position: absolute会脱离文档流</p><h2 id="3-开发中遇到的问题"><a href="#3-开发中遇到的问题" class="headerlink" title="3.开发中遇到的问题"></a>3.开发中遇到的问题</h2><p>position: relative;不会脱离文档流，但是在这个代码中，我设置了box1 position：relative以后，box1会有一种类似提升到最上层的效果，即box1会将box2盖住，但是box2由于“浮动的导致box1中的普通标准流填补box2浮动空下的位置”的效果还在，只是不显示了。如下图：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">      * &#123;</span><br><span class="language-css">        <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span>;</span><br><span class="language-css">        <span class="hljs-attribute">padding</span>: <span class="hljs-number">0</span>;</span><br><span class="language-css">      &#125;</span><br><span class="language-css">      <span class="hljs-selector-class">.box1</span> &#123;</span><br><span class="language-css">        <span class="hljs-attribute">background-color</span>: aqua;</span><br><span class="language-css">        <span class="hljs-attribute">width</span>: <span class="hljs-number">500px</span>;</span><br><span class="language-css">        <span class="hljs-attribute">height</span>: <span class="hljs-number">300px</span>;</span><br><span class="language-css">        <span class="hljs-attribute">position</span>: relative;</span><br><span class="language-css">      &#125;</span><br><span class="language-css">      <span class="hljs-selector-class">.box2</span> &#123;</span><br><span class="language-css">        <span class="hljs-attribute">background-color</span>: red;</span><br><span class="language-css">        <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;</span><br><span class="language-css">        <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;</span><br><span class="language-css">        <span class="hljs-attribute">float</span>: left;</span><br><span class="language-css">      &#125;</span><br><span class="language-css">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;box2&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;box1&quot;</span>&gt;</span><br>      dfjadshfkjaskldfjk<br>      asdfhjkahsdfjkasdfadsfjlasdhfjkjaskldfjkladsfjklasdjfkljdskflj<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p><img src="image-20240307193322474.png" alt="image-20240307193322474"></p><p>解决办法：通过给box1设置z-index为负值，让box2置于其上面。<br>注：只有position定位的元素可以设置z-index，浮动等不能设置z-index。</p><p><img src="image-20240307193435225.png" alt="image-20240307193435225"></p>]]></content>
    
    
    <categories>
      
      <category>css</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>clearfix(清除浮动)</title>
    <link href="/2023/05/10/clearfix-%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A8/"/>
    <url>/2023/05/10/clearfix-%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A8/</url>
    
    <content type="html"><![CDATA[<h1>clearfix-清除浮动</h1><h2 id="一、浮动的概念"><a href="#一、浮动的概念" class="headerlink" title="一、浮动的概念"></a>一、浮动的概念</h2><hr><p>浮动的框可以向左或向右移动，直到它的外边缘碰到包含框或另一个浮动框的边框为止。<br>由于浮动框不在文档的普通流中，所以文档的普通流中的块框表现得就像浮动框不存在一样。</p><h2 id="二、浮动的影响"><a href="#二、浮动的影响" class="headerlink" title="二、浮动的影响"></a>二、浮动的影响</h2><h3 id="1-浮动会导致父元素高度坍塌"><a href="#1-浮动会导致父元素高度坍塌" class="headerlink" title="1. 浮动会导致父元素高度坍塌"></a>1. 浮动会导致父元素高度坍塌</h3><p><img src="70.png" alt="img"></p><p>父元素中有子元素，并且父元素没有设置高度，子元素在父元素中浮动，结果必然是父元素的高度为0，这也就导致了父元素高度塌陷问题。</p><p>浮动脱离文档流，这个问题会对整个页面布局带来很大影响，如何解决高度坍塌问题，我们需要<a href="https://so.csdn.net/so/search?q=%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A8&spm=1001.2101.3001.7020">清除浮动</a>。</p><h2 id="三、浮动的清除"><a href="#三、浮动的清除" class="headerlink" title="三、浮动的清除"></a>三、浮动的清除</h2><h3 id="1-clear属性的空标签"><a href="#1-clear属性的空标签" class="headerlink" title="1. clear属性的空标签"></a>1. clear属性的空标签</h3><p>在浮动元素后添加一个空标签</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;container&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;item1&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;item2&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;clear&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.item1</span>,<span class="hljs-selector-class">.item2</span>&#123;<span class="hljs-attribute">float</span><span class="hljs-selector-pseudo">:left</span>&#125;<br><span class="hljs-selector-class">.clear</span>&#123;<span class="hljs-attribute">clear</span>:both;&#125;<br></code></pre></td></tr></table></figure><p><img src="image-20230510151049979.png" alt="image-20230510151049979"></p><ul><li>原理：添加一个空标签，利用CSS提高的clear:both清除浮动，让父元素可以自动获取到高度</li><li>优点：简单，代码少，兼容所有浏览器</li><li>缺点：增加页面的标签，造成结构的混乱</li><li>建议：不推荐使用，此方法已经过时</li></ul><h3 id="2-after伪元素"><a href="#2-after伪元素" class="headerlink" title="2. :after伪元素"></a>2. :after伪元素</h3><p>给浮动元素的容器添加一个<font color='yellow'>clearfix</font><code>的class，然后给这个class添加一个</code>:after&#96;伪元素实现元素之后添加一个看不见的块元素（Block element）清理浮动。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;container&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;item1&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;item2&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;item3&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs css">&lt;style&gt;<br>      <span class="hljs-selector-class">.container</span> &#123;<br>        <span class="hljs-attribute">background-color</span>: black;<br>      &#125;<br>      <span class="hljs-selector-class">.item1</span> &#123;<br>        <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br>        <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>        <span class="hljs-attribute">background-color</span>: skyblue;<br>        <span class="hljs-attribute">margin-bottom</span>: <span class="hljs-number">10px</span>;<br>        <span class="hljs-attribute">float</span>: left;<br>      &#125;<br>      <span class="hljs-selector-class">.item2</span> &#123;<br>        <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br>        <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>        <span class="hljs-attribute">background-color</span>: blue;<br>        <span class="hljs-attribute">float</span>: left;<br>      &#125;<br>      <span class="hljs-selector-class">.item3</span> &#123;<br>        <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br>        <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>        <span class="hljs-attribute">background-color</span>: beige;<br>        <span class="hljs-attribute">margin</span>: <span class="hljs-number">20px</span> <span class="hljs-number">0</span> <span class="hljs-number">20px</span> <span class="hljs-number">300px</span>;<br>      &#125;<br>    &lt;/style&gt;<br></code></pre></td></tr></table></figure><p>期待效果：</p><p><img src="image-20230510153921958.png" alt="image-20230510153921958"></p><p>实际效果</p><p><img src="image-20230510153941334.png" alt="image-20230510153941334"></p><p>clearfix方法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.clearfix</span><span class="hljs-selector-pseudo">:before</span>,<br><span class="hljs-selector-class">.clearfix</span><span class="hljs-selector-pseudo">:after</span> &#123;<br>    <span class="hljs-attribute">content</span>: <span class="hljs-string">&quot;&quot;</span>;<br>    <span class="hljs-attribute">display</span>: table;<br>&#125;<br><span class="hljs-selector-class">.clearfix</span><span class="hljs-selector-pseudo">:after</span> &#123;<br>    <span class="hljs-attribute">clear</span>: both;<br>&#125;<br><span class="hljs-selector-class">.clearfix</span>&#123;zoom:<span class="hljs-number">1</span>;&#125;  //兼容ie6和ie7<br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;container clearfix&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;item1&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;item2&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;item3&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>原理：通过CSS伪元素在容器的内部元素之后添加一个看不见的空格“&#x2F;20”或点“.” ，并且设置clear属性清除浮动。</li><li>优点：浏览器支持较好</li><li>缺点：clearfix这个class需要添加zoom: 1（触发haslayout），才能支持IE6和IE7浏览器</li><li>建议：推荐使用，设置公共类，减少CSS代码</li></ul><br><p>clearfix：根本原因是为了解决clearfix内部<font color='yellow'>非浮动元素</font>margin塌陷问题</p><p><code>针对浮动块级元素的相邻非浮动的元素如若其添加了上下的margin，因为浮动元素脱离了文档流，其实际与其父元素产生了margin重叠，导致margin塌陷，并且设置的margin效果作用与父元素。</code></p><p><code>使用before伪类就是在中间插入BFC，间隔上下文，以解决margin重叠现象。</code></p><p><font color='yellow'><code>针对非浮动元素时，display属性必须为table，若都是浮动元素，则display为block同样可以清楚浮动</code></font>。</p><p><font color='yellow'>display:table 是为了解决clearfix内部非浮动元素高度塌陷问题</font></p>]]></content>
    
    
    <categories>
      
      <category>css</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>子元素margin-top导致父元素移动的问题</title>
    <link href="/2023/05/10/%E5%AD%90%E5%85%83%E7%B4%A0margin-top%E5%AF%BC%E8%87%B4%E7%88%B6%E5%85%83%E7%B4%A0%E7%A7%BB%E5%8A%A8%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <url>/2023/05/10/%E5%AD%90%E5%85%83%E7%B4%A0margin-top%E5%AF%BC%E8%87%B4%E7%88%B6%E5%85%83%E7%B4%A0%E7%A7%BB%E5%8A%A8%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1>子元素margin-top导致父元素移动的问题</h1><h3>问题描述</h3><p>今天在修改页面样式的时候，遇到子元素设置<code>margin-top</code> 但是并没有使得子元素与父元素之间产生间隔，而是作用在了其父元素上，导致父元素产生了一个<code>margin-top</code> 的效果。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;container&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;item&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs css"> <span class="hljs-selector-class">.container</span> &#123;<br>        <span class="hljs-attribute">width</span>: <span class="hljs-number">500px</span>;<br>        <span class="hljs-attribute">height</span>: <span class="hljs-number">300px</span>;<br>        <span class="hljs-attribute">background-color</span>: skyblue;<br>        <span class="hljs-attribute">position</span>: relative;<br> &#125;<br><span class="hljs-selector-class">.item</span> &#123;<br>    <span class="hljs-attribute">background-color</span>: blue;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">300px</span>;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">150px</span>;<br>    <span class="hljs-attribute">margin-left</span>: <span class="hljs-number">100px</span>;<br>    <span class="hljs-attribute">margin-top</span>: <span class="hljs-number">50px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="image-20230510094052443.png" alt="image-20230510094052443" style="zoom:80%;" /><img src="image-20230510094142027.png" alt="image-20230510094142027" style="zoom:67%;" /></p><h3>问题分析</h3><p>MDN上面是这样说的：</p><p>块的上外边距(<code>margin-top</code>)和下外边距(<code>margin-bottom</code>)有时合并(折叠)为单个边距，其大小为单个边距的<font color = 'red'><strong>最大值</strong></font>，这种行为称为<code>边距折叠</code>。</p><p>注意：<font color = 'yellow'><strong>只有上下边距会产生折叠，左右边距不会产生折叠</strong></font></p><br><h4>上下边距会产生折叠的三种情况</h4><p><font color = 'skyblue'>1.同一层相邻元素之间</font></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;A&quot;</span>&gt;</span>元素A<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;B&quot;</span>&gt;</span>元素B<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css"><span class="hljs-selector-class">.A</span>,</span><br><span class="language-css"><span class="hljs-selector-class">.B</span> &#123;</span><br><span class="language-css">  <span class="hljs-attribute">width</span>: <span class="hljs-number">50px</span>;</span><br><span class="language-css">  <span class="hljs-attribute">height</span>: <span class="hljs-number">50px</span>;</span><br><span class="language-css">&#125;</span><br><span class="language-css"><span class="hljs-selector-class">.A</span> &#123;</span><br><span class="language-css">  <span class="hljs-attribute">background</span>: yellow;</span><br><span class="language-css">  <span class="hljs-attribute">margin-bottom</span>: <span class="hljs-number">10px</span>;</span><br><span class="language-css">&#125;</span><br><span class="language-css"><span class="hljs-selector-class">.B</span> &#123;</span><br><span class="language-css">  <span class="hljs-attribute">background</span>: pink;</span><br><span class="language-css">  <span class="hljs-attribute">margin-top</span>: <span class="hljs-number">20px</span>;</span><br><span class="language-css">&#125;</span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure><p><font color = 'yellow'><strong>· 当margin-bottom和margin-top都为正数时，间距取两者中较大值</strong></font></p><p><font color = 'yellow'><strong>· 当都为负数时候，两元素重叠，重叠高度为margin-top和margin-bottom中绝对值较大值</strong></font></p><p><font color = 'yellow'><strong>· 当一正一负时，间距为两者之和</strong></font></p><p>解决办法：A B上各自裹上一个BFC。</p><br><p><font color = 'skyblue'>2.当父子元素之间没有内容</font></p><p>案例见文章开头问题描述。</p><p><font color = 'yellow'><strong>解决办法：</strong></font></p><p>1.父元素创建块级格式上下文（<font color = 'yellow'><code>overflow:hidden</code></font>）</p><p>2.父元素设置上下border（<font color = 'yellow'><code>border: 1px solid transparent</code></font>）</p><p>3.父元素设置上下padding（<font color = 'yellow'><code>padding: 1px 0</code></font>）</p><p>4.子元素采用浮动<font color = 'red'><code>float</code></font>或者绝对定位<font color = 'yellow'><code>position：absolute</code></font> 的方式排列,即为子元素开启BFC。</p><br><p><font color = 'skyblue'>3.空的块级元素</font></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;top&quot;</span>&gt;</span>top<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;middle clearfix&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>   <span class="hljs-comment">&lt;!-- 空的块级元素 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;bottom&quot;</span>&gt;</span>bottom<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs css">&lt;style&gt;<br>    <span class="hljs-selector-class">.top</span>,<br>    <span class="hljs-selector-class">.bottom</span> &#123;<br>        <span class="hljs-attribute">width</span>: <span class="hljs-number">50px</span>;<br>        <span class="hljs-attribute">height</span>: <span class="hljs-number">50px</span>;<br>        <span class="hljs-attribute">background</span>: pink;<br>    &#125;<br>    <span class="hljs-selector-class">.middle</span> &#123;<br>        <span class="hljs-attribute">margin-top</span>: <span class="hljs-number">10px</span>;<br>        <span class="hljs-attribute">margin-bottom</span>: <span class="hljs-number">20px</span>;<br>    &#125;<br>&lt;/style&gt;<br></code></pre></td></tr></table></figure><p>结果：<img src="image-20230510115000974.png" alt="image-20230510115000974" style="zoom:50%;" />期望值：<img src="image-20230510115051397.png" alt="image-20230510115051397" style="zoom:50%;" /></p><p><font color = 'yellow'><strong>解决办法：</strong></font></p><p>1.middle元素： <font color = 'yellow'><strong><code>clearfix</code></strong> </font> ，原理：在父元素的最前边增加一个空白元素，然后将元素作为块元素来显示。clearfix使用方法详情见<a href="https://yang-fan01.gitee.io/2023/05/10/clearfix-%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A8/">https://yang-fan01.gitee.io/2023/05/10/clearfix-%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A8/</a></p><p>2.middle元素创建块级格式上下文（BFC）：<font color = 'yellow'><strong><code>overflow：hidden</code></strong></font></p><p>3.middle元素设置为行内块元素：<font color = 'yellow'><strong><code>display: inline-block</code></strong></font></p><p>4.middle元素设置高度：<font color = 'yellow'> <strong><code>height: 1px</code></strong></font></p><p>5.middle元素设置最小高度：<font color = 'yellow'><strong><code>min-height: 1px</code></strong></font></p><p>6.middle元素设置border：<font color = 'yellow'><strong><code>border-top: 1px solid transparent</code></strong></font></p><p>7.middle元素设置padding：<font color = 'yellow'><strong><code>padding-top: 1px</code></strong></font></p><br><h3>BFC</h3><h4>什么是BFC</h4><p>MDN: <strong>块格式化上下文</strong>（Block Formatting Context，BFC）是 Web 页面的可视 CSS 渲染的一部分，是块级盒子的布局过程发生的区域，也是浮动元素与其他元素交互的区域。</p><br><p>下列方式会创建块格式化上下文：</p><ul><li>根元素（<code>&lt;html&gt;</code>）</li><li>浮动元素（<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/float"><code>float</code></a> 值不为 <code>none</code>）</li><li>绝对定位元素（<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/position"><code>position</code></a> 值为 <code>absolute</code> 或 <code>fixed</code>）</li><li>行内块元素（<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/display"><code>display</code></a> 值为 <code>inline-block</code>）</li><li>表格单元格（<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/display"><code>display</code></a> 值为 <code>table-cell</code>，HTML 表格单元格默认值）</li><li>表格标题（<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/display"><code>display</code></a> 值为 <code>table-caption</code>，HTML 表格标题默认值）</li><li>匿名表格单元格元素（<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/display"><code>display</code></a> 值为 <code>table</code>、<code>table-row</code>、 <code>table-row-group</code>、<code>table-header-group</code>、<code>table-footer-group</code>（分别是 HTML table、tr、tbody、thead、tfoot 的默认值）或 <code>inline-table</code>）</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/overflow"><code>overflow</code></a> 值不为 <code>visible</code>、<code>clip</code> 的块元素</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/display"><code>display</code></a> 值为 <code>flow-root</code> 的元素</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/contain"><code>contain</code></a> 值为 <code>layout</code>、<code>content</code> 或 <code>paint</code> 的元素</li><li>弹性元素（<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/display"><code>display</code></a> 值为 <code>flex</code> 或 <code>inline-flex</code> 元素的直接子元素），如果它们本身既不是 <a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Flex_Container">flex</a>、<a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Grid_Container">grid</a> 也不是 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Table">table</a> 容器</li><li>网格元素（<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/display"><code>display</code></a> 值为 <code>grid</code> 或 <code>inline-grid</code> 元素的直接子元素），如果它们本身既不是 <a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Flex_Container">flex</a>、<a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Grid_Container">grid</a> 也不是 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Table">table</a> 容器</li><li>多列容器（<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/column-count"><code>column-count</code></a> 或 <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/column-width"><code>column-width</code> (en-US)</a> 值不为 <code>auto</code>，包括<code>column-count</code> 为 <code>1</code>）</li><li><code>column-span</code> 值为 <code>all</code> 的元素始终会创建一个新的 BFC，即使该元素没有包裹在一个多列容器中 (<a href="https://github.com/w3c/csswg-drafts/commit/a8634b96900279916bd6c505fda88dda71d8ec51">规范变更</a>, <a href="https://bugs.chromium.org/p/chromium/issues/detail?id=709362">Chrome bug</a>)</li></ul><h4>BFC的特性</h4><p><strong>特性1：上下外边距重叠：（同一个 BFC 下的两个相邻块级元素，会发生上下方向的 margin 重叠</strong>）。</p><p><strong>特性2：浮动元素也会参与计算高度</strong></p><p>例子：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">  <span class="hljs-selector-class">.container</span> &#123;</span><br><span class="language-css">    <span class="hljs-comment">/* overflow: hidden; */</span></span><br><span class="language-css">    <span class="hljs-attribute">padding</span>: <span class="hljs-number">5px</span>;</span><br><span class="language-css">    <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid <span class="hljs-number">#000</span>;</span><br><span class="language-css">  &#125;</span><br><span class="language-css">  <span class="hljs-selector-class">.box</span> &#123;</span><br><span class="language-css">    <span class="hljs-attribute">float</span>: left;</span><br><span class="language-css">    <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;</span><br><span class="language-css">    <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;</span><br><span class="language-css">    <span class="hljs-attribute">background-color</span>: cornflowerblue;</span><br><span class="language-css">  &#125;</span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;container&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;box&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p><img src="image-20230510144833970.png" alt="image-20230510144833970"></p>]]></content>
    
    
    <categories>
      
      <category>css</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>css属性及样式优先级</title>
    <link href="/2023/05/09/css%E6%A0%B7%E5%BC%8F%E4%BC%98%E5%85%88%E7%BA%A7/"/>
    <url>/2023/05/09/css%E6%A0%B7%E5%BC%8F%E4%BC%98%E5%85%88%E7%BA%A7/</url>
    
    <content type="html"><![CDATA[<p>Q1：一个元素的属性值是只有我们在css文件中写的那些属性吗？</p><p>answer：不是，答案是<strong>该元素上面会有 CSS 所有的属性。</strong>打开浏览器的开发者面板，选择【元素】，切换到【计算样式】，之后勾选【全部显示】，此时你就能看到在此 h1 上面所有 CSS 属性对应的值。换句话说，<strong>我们所书写的任何一个 HTML 元素，实际上都有完整的一整套 CSS 样式</strong>。只不过你没有书写的样式，<font color = 'yellow'>大概率可能</font>会使用其默认值。</p><p>Q2:为什么有的元素没有编写样式，但是也不使用默认值？</p><p>answer：详情见下面css属性值的计算过程。</p><h2>css属性值的计算过程</h2><p><strong>依次包含以下四个步骤：</strong></p><p><strong>1.确定的声明值（页面作者样式 &gt; 用户样式 &gt; 用户代理样式）</strong></p><p><strong>2.层叠冲突</strong></p><p><strong>3.使用继承</strong></p><p><strong>4.使用默认值</strong></p><br><h3>1.确定的声明值</h3><p>作者样式表，用户代理样式表 都属于确定的声明值</p><h3>2.层叠冲突</h3><p>在确定声明值时，可能出现一种情况，那就是声明的样式规则发生了冲突。</p><p>此时会进入解决层叠冲突的流程。而这一步又可以细分为下面这三个步骤：</p><ul><li>比较源的重要性</li><li>比较优先级</li><li>比较次序</li></ul><h4>比较源的重要性</h4><p>整体来讲有三种来源：</p><ul><li>网页的作者可以定义文档的样式，这是最常见的样式表，称之为<strong>页面作者样式</strong>。</li><li>浏览器的用户，可以使用自定义样式表定制使用体验，称之为<strong>用户样式</strong>。</li><li>浏览器会有一个基本的样式表来给任何网页设置默认样式。这些样式统称<strong>用户代理样式</strong>。</li></ul><p>来源优先级：<font color = 'yellow'> 页面作者样式 &gt; 用户样式 &gt; 用户代理样式</font></p><p>案例：</p><p>例如现在有<strong>页面作者样式表</strong>和<strong>用户代理样式表</strong>中存在属性的冲突，那么会以作者样式表优先。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">p</span>&#123;<br>  <span class="hljs-attribute">color</span> : red;<br>  <span class="hljs-attribute">display</span>: inline-block;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="2022-08-13-064222.png" alt="image-20220813144222152"></p><p>可以明显的看到，作者样式表和用户代理样式表中同时存在的 display 属性的设置，最终作者样式表干掉了用户代理样式表中冲突的属性。这就是第一步，根据不同源的重要性来决定应用哪一个源的样式。</p><h4>比较优先级</h4><p>案例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;test&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.test</span> <span class="hljs-selector-tag">h1</span>&#123;<br>  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">50px</span>;<br>&#125;<br><br><span class="hljs-selector-tag">h1</span> &#123;<br>  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">20px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>结果：<img src="image-20230509170307869.png" alt="image-20230509170307869"></p><p>我们可以看到应用的是font-size：50px，因为上面的选择器的权重要大于下面的选择器，因此最终标题呈现为 <em>50px</em></p><p>选择器优先级：<font color ='yellow'>id 选择器 &gt; 类选择器 &gt; 类型选择器</font></p><h4>比较次序</h4><p>经过前两个比较步骤，剩下的那就是样式声明既是同源，权重也相同。</p><p>此时就会进入第三个步骤，比较样式声明的次序。</p><p>例子：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs html">h1 &#123;<br>  font-size: 50px;<br>&#125;<br><br>h1 &#123;<br>  font-size: 20px;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="image-20230509170724194.png" alt="image-20230509170724194"></p><p>同源同优先级样式：<font color ='yellow'>后面的样式覆盖前面的样式</font></p><h3>3.使用继承</h3><p>案例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html]">&lt;div class=&quot;test&quot;&gt;<br>  &lt;div&gt;<br>    &lt;p&gt;Lorem ipsum dolor sit amet.&lt;/p&gt;<br>  &lt;/div&gt;<br>&lt;/div&gt;<br></code></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span> &#123;<br>  <span class="hljs-attribute">color</span>: red;<br>&#125;<br><span class="hljs-selector-class">.test</span>&#123;<br>  <span class="hljs-attribute">color</span>: blue;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="image-20230509171206173.png" alt="image-20230509171206173"></p><p><font color = 'yellow'>继承的样式采取 “就近原则”</font></p><p>(1)可继承样式：（<strong>一般</strong>关于文字的可继承）可在MDN查询属性是否可继承<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/">https://developer.mozilla.org/zh-CN/docs/Web/CSS/</a></p><p>所有元素可继承：<code>visibility和cursor</code></p><p>内联元素可继承：<code>letter-spacing、word-spacing、white-space、line-height、color、font、 font-family、font-size、font-style、font-variant、font-weight、text- decoration、text-transform、direction</code></p><p>块状元素可继承：<code>text-indent和text-align</code></p><p>列表元素可继承：<code>list-style、list-style-type、list-style-position、list-style-image</code></p><p>表格元素可继承：<code>border-collapse</code></p><p>（2）不可继承的：<code>display、margin、border、padding、background、height、min-height、max- height、width、min-width、max-width、overflow、position、left、right、top、 bottom、z-index、float、clear、table-layout、vertical-align、page-break-after、 page-bread-before和unicode-bidi</code></p><h3>4.使用默认值</h3><p>如果确定的声明值、继承的属性都没有，属性值还不能确定下来，那么就只能是使用默认值了。</p><p><img src="image-20230509182037263.png" alt="image-20230509182037263"></p><br><p>案例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span> &#123;<br>  <span class="hljs-attribute">color</span>: red;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="image-20230509182446345.png" alt="image-20230509182446345"></p><p>结果：a标签中的test为蓝色 ，p标签中的test为红色</p><p>原因：css中只对div设置了color属性值，a标签和p标签为直接针对其设置属性值。根据属性值的计算过程【1.确定的声明值（页面作者样式 &gt; 用户样式 &gt; 用户代理样式）2.层叠冲突  3.使用继承  4.使用默认值】，页面作者样式和用户样式均未设置相关属性，用户代理样式中设置有a链接的color样式为蓝色，所以a链接中的test显示蓝色，而p标签在前两步均不能获取到属性值，只能在第三步继承div的color属性值red。</p><br><h3 id="整体流程图"><a href="#整体流程图" class="headerlink" title="整体流程图"></a>整体流程图</h3><p><img src="image-20230911173113119.png" alt="image-20230911173113119"></p>]]></content>
    
    
    <categories>
      
      <category>css</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>margin重叠与BFC</title>
    <link href="/2023/05/08/margin%E9%87%8D%E5%8F%A0%E4%B8%8EBFC/"/>
    <url>/2023/05/08/margin%E9%87%8D%E5%8F%A0%E4%B8%8EBFC/</url>
    
    <content type="html"><![CDATA[<h1>子元素margin-top导致父元素移动的问题</h1><h3>问题描述</h3><p>今天在修改页面样式的时候，遇到子元素设置<code>margin-top</code> 但是并没有使得子元素与父元素之间产生间隔，而是作用在了其父元素上，导致父元素产生了一个<code>margin-top</code> 的效果。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;container&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;item&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs css"> <span class="hljs-selector-class">.container</span> &#123;<br>        <span class="hljs-attribute">width</span>: <span class="hljs-number">500px</span>;<br>        <span class="hljs-attribute">height</span>: <span class="hljs-number">300px</span>;<br>        <span class="hljs-attribute">background-color</span>: skyblue;<br>        <span class="hljs-attribute">position</span>: relative;<br> &#125;<br><span class="hljs-selector-class">.item</span> &#123;<br>    <span class="hljs-attribute">background-color</span>: blue;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">300px</span>;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">150px</span>;<br>    <span class="hljs-attribute">margin-left</span>: <span class="hljs-number">100px</span>;<br>    <span class="hljs-attribute">margin-top</span>: <span class="hljs-number">50px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="image-20230510094052443.png" alt="image-20230510094052443" style="zoom:80%;" /><img src="image-20230510094142027.png" alt="image-20230510094142027" style="zoom:67%;" /></p><h3>问题分析</h3><p>MDN上面是这样说的：</p><p>块的上外边距(<code>margin-top</code>)和下外边距(<code>margin-bottom</code>)有时合并(折叠)为单个边距，其大小为单个边距的<font color = 'red'><strong>最大值</strong></font>，这种行为称为<code>边距折叠</code>。</p><p>注意：<font color = 'yellow'><strong>只有上下边距会产生折叠，左右边距不会产生折叠</strong></font></p><br><h4>上下边距会产生折叠的三种情况</h4><p><font color = 'skyblue'>1.同一层相邻元素之间</font></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;A&quot;</span>&gt;</span>元素A<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;B&quot;</span>&gt;</span>元素B<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css"><span class="hljs-selector-class">.A</span>,</span><br><span class="language-css"><span class="hljs-selector-class">.B</span> &#123;</span><br><span class="language-css">  <span class="hljs-attribute">width</span>: <span class="hljs-number">50px</span>;</span><br><span class="language-css">  <span class="hljs-attribute">height</span>: <span class="hljs-number">50px</span>;</span><br><span class="language-css">&#125;</span><br><span class="language-css"><span class="hljs-selector-class">.A</span> &#123;</span><br><span class="language-css">  <span class="hljs-attribute">background</span>: yellow;</span><br><span class="language-css">  <span class="hljs-attribute">margin-bottom</span>: <span class="hljs-number">10px</span>;</span><br><span class="language-css">&#125;</span><br><span class="language-css"><span class="hljs-selector-class">.B</span> &#123;</span><br><span class="language-css">  <span class="hljs-attribute">background</span>: pink;</span><br><span class="language-css">  <span class="hljs-attribute">margin-top</span>: <span class="hljs-number">20px</span>;</span><br><span class="language-css">&#125;</span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure><p><font color = 'yellow'><strong>· 当margin-bottom和margin-top都为正数时，间距取两者中较大值</strong></font></p><p><font color = 'yellow'><strong>· 当都为负数时候，两元素重叠，重叠高度为margin-top和margin-bottom中绝对值较大值</strong></font></p><p><font color = 'yellow'><strong>· 当一正一负时，间距为两者之和</strong></font></p><p>解决办法：A B上各自裹上一个BFC。</p><br><p><font color = 'skyblue'>2.当父子元素之间没有内容</font></p><p>案例见文章开头问题描述。</p><p><font color = 'yellow'><strong>解决办法：</strong></font></p><p>1.父元素创建块级格式上下文（<font color = 'yellow'><code>overflow:hidden</code></font>）</p><p>2.父元素设置上下border（<font color = 'yellow'><code>border: 1px solid transparent</code></font>）</p><p>3.父元素设置上下padding（<font color = 'yellow'><code>padding: 1px 0</code></font>）</p><p>4.子元素采用浮动<font color = 'red'><code>float</code></font>或者绝对定位<font color = 'yellow'><code>position：absolute</code></font> 的方式排列,即为子元素开启BFC。</p><br><p><font color = 'skyblue'>3.空的块级元素</font></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;top&quot;</span>&gt;</span>top<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;middle clearfix&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>   <span class="hljs-comment">&lt;!-- 空的块级元素 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;bottom&quot;</span>&gt;</span>bottom<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs css">&lt;style&gt;<br>    <span class="hljs-selector-class">.top</span>,<br>    <span class="hljs-selector-class">.bottom</span> &#123;<br>        <span class="hljs-attribute">width</span>: <span class="hljs-number">50px</span>;<br>        <span class="hljs-attribute">height</span>: <span class="hljs-number">50px</span>;<br>        <span class="hljs-attribute">background</span>: pink;<br>    &#125;<br>    <span class="hljs-selector-class">.middle</span> &#123;<br>        <span class="hljs-attribute">margin-top</span>: <span class="hljs-number">10px</span>;<br>        <span class="hljs-attribute">margin-bottom</span>: <span class="hljs-number">20px</span>;<br>    &#125;<br>&lt;/style&gt;<br></code></pre></td></tr></table></figure><p>结果：<img src="image-20230510115000974.png" alt="image-20230510115000974" style="zoom:50%;" />期望值：<img src="image-20230510115051397.png" alt="image-20230510115051397" style="zoom:50%;" /></p><p><font color = 'yellow'><strong>解决办法：</strong></font></p><p>1.middle元素： <font color = 'yellow'><strong><code>clearfix</code></strong> </font> ，原理：在父元素的最前边增加一个空白元素，然后将元素作为块元素来显示。clearfix使用方法详情见<a href="https://yang-fan01.gitee.io/2023/05/10/clearfix-%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A8/">https://yang-fan01.gitee.io/2023/05/10/clearfix-%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A8/</a></p><p>2.middle元素创建块级格式上下文（BFC）：<font color = 'yellow'><strong><code>overflow：hidden</code></strong></font></p><p>3.middle元素设置为行内块元素：<font color = 'yellow'><strong><code>display: inline-block</code></strong></font></p><p>4.middle元素设置高度：<font color = 'yellow'> <strong><code>height: 1px</code></strong></font></p><p>5.middle元素设置最小高度：<font color = 'yellow'><strong><code>min-height: 1px</code></strong></font></p><p>6.middle元素设置border：<font color = 'yellow'><strong><code>border-top: 1px solid transparent</code></strong></font></p><p>7.middle元素设置padding：<font color = 'yellow'><strong><code>padding-top: 1px</code></strong></font></p><br><h3>BFC</h3><h4>什么是BFC?</h4><p>MDN: <strong>块格式化上下文</strong>（Block Formatting Context，BFC）是 Web 页面的可视 CSS 渲染的一部分，是块级盒子的布局过程发生的区域，也是浮动元素与其他元素交互的区域。</p><br><h4>如何创建BFC?</h4><p>下列方式会创建块格式化上下文：</p><ul><li>根元素（<code>&lt;html&gt;</code>）</li><li><strong><code>overflow</code> 属性</strong>：将元素的 <code>overflow</code> 属性设置为 <code>auto</code>、<code>hidden</code> 或 <code>scroll</code>，可以创建一个BFC;</li><li><strong><code>float</code> 属性</strong>：设置元素的 <code>float</code> 属性为 <code>left</code> 或 <code>right</code>;</li><li><strong><code>position</code> 属性</strong>：将元素的 <code>position</code> 属性设置为 <code>absolute</code> 或 <code>fixed</code>;</li><li><strong><code>display</code> 属性</strong>：将元素的 <code>display</code> 属性设置为 <code>inline-block</code>、<code>table-cell</code>、<code>table-caption</code> 或 <code>flex</code>。</li></ul><br><h4>BFC的特性</h4><p><strong>特性1：上下外边距重叠：（同一个 BFC 下的两个相邻块级元素，会发生上下方向的 margin 重叠</strong>）。</p><p><strong>特性2：浮动元素也会参与计算高度</strong></p><p><strong>特性3：BFC就是页面上的一个隔离的独立容器，容器里面的子标签不会影响到外面标签（可以把 BFC 理解为一个封闭的大箱子，箱子内部的元素无论如何翻江倒海，都不会影响到外部）</strong></p><p>例子：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">  <span class="hljs-selector-class">.container</span> &#123;</span><br><span class="language-css">    <span class="hljs-comment">/* overflow: hidden; */</span></span><br><span class="language-css">    <span class="hljs-attribute">padding</span>: <span class="hljs-number">5px</span>;</span><br><span class="language-css">    <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid <span class="hljs-number">#000</span>;</span><br><span class="language-css">  &#125;</span><br><span class="language-css">  <span class="hljs-selector-class">.box</span> &#123;</span><br><span class="language-css">    <span class="hljs-attribute">float</span>: left;</span><br><span class="language-css">    <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;</span><br><span class="language-css">    <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;</span><br><span class="language-css">    <span class="hljs-attribute">background-color</span>: cornflowerblue;</span><br><span class="language-css">  &#125;</span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;container&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;box&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p><img src="image-20230510144833970.png" alt="image-20230510144833970"></p><br><h4 id="BFC的作用"><a href="#BFC的作用" class="headerlink" title="BFC的作用"></a>BFC的作用</h4><p><strong>1.解决高度塌陷问题：当父元素没有高度时，浮动子元素会导致父级元素高度塌陷</strong></p><p>​解决办法：父元素创建BFC</p><p><strong>2.解决兄弟元素上下margin重叠问题：</strong></p><p>​解决办法：每个元素外层包裹一个BFC</p><p><strong>3.解决子元素上下边距影响父元素问题（如文章最顶部问题）：</strong></p><p>​解决办法：父元素创建BFC</p>]]></content>
    
    
    <categories>
      
      <category>css</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>事件循环2-异步</title>
    <link href="/2023/04/24/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF2-%E5%BC%82%E6%AD%A5/"/>
    <url>/2023/04/24/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF2-%E5%BC%82%E6%AD%A5/</url>
    
    <content type="html"><![CDATA[<h2>何为异步？</h2><p>代码在执⾏过程中，会遇到⼀些⽆法⽴即处理的任务，⽐如：</p><p>计时完成后需要执⾏的任务 —— <strong>setTimeout</strong> 、 <strong>setInterval</strong></p><p>⽹络通信完成后需要执⾏的任务 – <strong>XHR</strong> 、 <strong>Fetch</strong></p><p>⽤户操作后需要执⾏的任务 – <strong>addEventListener</strong></p><p>如果让渲染主线程等待这些任务的时机达到，就会导致主线程⻓期处于「阻塞」的状态，从⽽导致浏览器「卡死」</p><p><img src="image-20230424123207127.png" alt="image-20230424123207127"></p><p><strong>渲染主线程承担着极其重要的⼯作，⽆论如何都不能阻塞！</strong></p><p>因此，浏览器选择<strong>异步</strong>来解决这个问题</p><p><img src="%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF2-%E5%BC%82%E6%AD%A5/image-20230424123301209.png" alt="image-20230424123301209"></p><p>使⽤异步的⽅式，<strong>渲染主线程永不阻塞</strong></p><br><p>问：<font color= "red">如何理解 JS 的异步？</font></p><p>答：</p><ol><li><p>JS是⼀⻔单线程的语⾔，这是因为它运⾏在浏览器的渲染主线程中，⽽渲染主线程只有⼀个。⽽渲染主线程承担着诸多的⼯作，渲染⻚⾯、执⾏ JS 都在其中运⾏。</p></li><li><p>如果使⽤同步的⽅式，就<font color= "yellow">极有可能</font>导致主线程产⽣阻塞，从⽽导致消息队列中的很多其他任务⽆法得到执⾏。这样⼀来，⼀⽅⾯会导致繁忙的主线程⽩⽩的消耗时间，另⼀⽅⾯导致⻚⾯⽆法及时更新，给⽤户造成卡死现象。</p></li><li><p>所以浏览器采⽤异步的⽅式来避免。<font color= "yellow">具体做法是当某些任务发⽣时，⽐如计时器、⽹络、事件监听，主线程将任务交给其他线程去处理，⾃身⽴即结束任务的执⾏，转⽽执⾏后续代码。当其他线程完成时，将事先传递的回调函数包装成任务，加⼊到消息队列的末尾排队，等待主线程调度执⾏</font>。在这种异步模式下，浏览器永不阻塞，从⽽最⼤限度的保证了单线程的流畅运⾏。</p></li></ol><p><strong>案例：</strong></p><img src="image-20230424124008365.png" alt="image-20230424124008365" style="zoom:67%;" /><p>运行结果： 5 4 3 1 2</p><p>解析：</p><p>1.主线程全局执行：</p><p>​<img src="image-20230424124836713.png" alt="image-20230424124836713" style="zoom:80%;" /></p><ol start="2"><li><p>执行 fn（5）&#x3D;》 微队列 fn（4）&#x3D;》 延时队列fn（3 a）执行如下</p><img src="image-20230424125616689.png" alt="image-20230424125616689" style="zoom:80%;" /></li><li><p>主线程执行微队列中的 fn（a）任务</p><img src="image-20230424130040086.png" alt="image-20230424130040086" style="zoom:80%;" /></li><li><p>主线程执行上一步微队列中增加的 fn（2）任务  ，输出2，则最终输出为 5 4 3 1 2</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>javascript</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>事件循环1-进程与线程</title>
    <link href="/2023/04/24/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF1-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/"/>
    <url>/2023/04/24/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF1-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1>浏览器的进程模型</h1><h3>何为进程？</h3><p>程序运⾏需要有它⾃⼰专属的内存空间，可以把这块内存空间简单的理解为进程</p><p><img src="%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF1-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/image-20230424115531870.png" alt="image-20230424115531870"></p><p>每个应⽤⾄少有⼀个进程，进程之间相互独⽴，即使要通信，也需要双⽅同意。</p><h3>何为线程？</h3><p>有了进程后，就可以运⾏程序的代码了。</p><p>运⾏代码的「⼈」称之为「线程」。<font color = "red">⼀个进程⾄少有⼀个线程，所以在进程开启后会⾃动创建⼀个线程来运⾏代码，该线程称之为主线程。</font></p><p>如果程序需要同时执⾏多块代码，主线程就会启动更多的线程来执⾏代码，所以<font color = "red">⼀个进程中可以包含多个线程</font>。</p><p><img src="%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF1-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/image-20230424115624954.png" alt="image-20230424115624954"></p><h3>浏览器有哪些进程和线程？</h3><p><strong>浏览器是⼀个多进程多线程的应⽤程序</strong></p><p>浏览器内部⼯作极其复杂。</p><p><img src="image-20230424115930935.png" alt="image-20230424115930935"></p><p><img src="%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF1-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/image-20230424115930935.png" alt="image-20230424115930935"></p><p>为了避免相互影响，为了减少连环崩溃的⼏率，当启动浏览器后，它会⾃动启动多个进程。可以在浏览器的任务管理器中查看当前的所有进程,其中，最主要的进程有：</p><ol><li>浏览器进程</li></ol><p>主要负责界⾯显示、⽤户交互、⼦进程管理等。浏览器进程内部会启动多个</p><p>线程处理不同的任务。</p><ol start="2"><li>⽹络进程</li></ol><p>负责加载⽹络资源。⽹络进程内部会启动多个线程来处理不同的⽹络任务。</p><ol start="3"><li><strong>渲染进程</strong>（前端重点）</li></ol><p>渲染进程启动后，会开启⼀个<font color = "red"><strong>渲染主线程</strong></font>，主线程负责执⾏ HTML、CSS、JS 代码。</p><p>默认情况下，浏览器会为每个标签⻚开启⼀个新的渲染进程，以保证不同的标签⻚之间不相互影响。</p><h3>渲染主线程是如何⼯作的？</h3><p><strong>渲染主线程是浏览器中最繁忙的线程，需要它处理的任务包括但不限于</strong>：</p><p>解析 HTML</p><p>解析 CSS</p><p>计算样式</p><p>布局</p><p>处理图层</p><p>每秒把⻚⾯画 60 次</p><p>执⾏全局 JS 代码</p><p>执⾏事件处理函数</p><p>执⾏计时器的回调函数</p><p>……</p><h3><font color= "red">浏览器渲染进程的工作方式！</font></h3><p><strong>1.渲染主线程依次执行消息队列中的任务：</strong></p><p><img src="%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF1-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/image-20230424121419038.png" alt="image-20230424121419038"></p><ol><li><p>在最开始的时候，渲染主线程会进⼊⼀个⽆限循环</p></li><li><p>每⼀次循环会检查消息队列中是否有任务存在。如果有，就取出第⼀个任务执⾏，执⾏完⼀个后进⼊下⼀次循环；如果没有，则进⼊休眠状态。</p></li><li><p>其他所有线程（包括其他进程的线程）可以随时向消息队列添加任务。新任务会加到消息队列的末尾。在添加新任务时，如果主线程是休眠状态，则会将其唤醒以继续循环拿取任务</p></li></ol><p>这样⼀来，就可以让每个任务有条不紊的、持续的进⾏下去了。</p><p><strong>整个过程，被称之为<font color = "red">事件循环（消息循环）</font>&gt;</strong></p><p><strong>2.任务有优先级吗？</strong></p><p>答：<font color = "red">任务没有优先级，在消息队列中先进先出。但是消息队列有优先级</font></p><p>根据 W3C 的最新解释:</p><p>①.<font color = "red">每个任务都有⼀个任务类型，同⼀个类型的任务必须在⼀个队列，不同类型的任务可以分属于不同的队列。</font></p><p>②.在⼀次事件循环中，浏览器可以根据实际情况从不同的队列中取出任务执⾏。</p><p>③.浏览器必须准备好⼀个微队列，微队列中的任务优先所有其他任务执⾏。</p><p><img src="image-20230424122159388.png" alt="image-20230424122159388"></p><p>在⽬前 chrome 的实现中，⾄少包含了下⾯的队列：</p><p>① 微队列：⽤户存放需要最快执⾏的任务，优先级「最⾼」</p><p>② 交互队列：⽤于存放⽤户操作后产⽣的事件处理任务，优先级「⾼」</p><p>③ 延时队列：⽤于存放计时器到达后的回调任务，优先级「中」</p><p><img src="image-20230424122331258.png" alt="image-20230424122331258"></p><p><img src="%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF1-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/image-20230424122331258.png" alt="img"></p><br><p>问：阐述⼀下 JS 的事件循环</p><p>答：（事件循环的概念+消息队列的优先级）</p><p>① 事件循环⼜叫做消息循环，是<font color = "yellow">浏览器渲染主线程的⼯作⽅式</font>。</p><p>② 在 Chrome 的源码中，它<font color = "yellow">开启⼀个不会结束的 for 循环，每次循环从消息队列中取出第⼀个任务执⾏，⽽其他线程只需要在合适的时候将任务加⼊到队列末尾即可</font>。</p><p>③ 过去把消息队列简单分为宏队列和微队列，这种说法⽬前已⽆法满⾜复杂的浏览器环境，取⽽代之的是⼀种更加灵活多变的处理⽅式。</p><p>④ <font color = "yellow">根据 W3C 官⽅的解释，每个任务有不同的类型，同类型的任务必须在同⼀个队列，不同的任务可以属于不同的队列。不同任务队列有不同的优先级，在⼀次事件循环中，由浏览器⾃⾏决定取哪⼀个队列的任务。但浏览器必须有⼀个微队列，微队列的任务⼀定具有最⾼的优先级，必须优先调度执⾏</font>。</p><br><p>问：JS 中的计时器能做到精确计时吗？为什么？</p><p>答: 不能，原因有：<br>① 受事件循环的影响，计时器的回调函数只能在主线程空闲时运⾏，因此带来了偏差。</p><p>② 计算机硬件没有原⼦钟，⽆法做到精确计时，而是利用操作系统进行计时，操作系统的计时函数本身就有少量偏差，由于 JS 的计时器最终调⽤的是操作系统的函数，也就携带了这些偏差。</p><p>③ 按照 W3C 的标准，浏览器实现计时器时，如果嵌套层级超过 5 层，则会带有 4 毫秒的最少时间，这样在计时时间少于 4 毫秒时⼜带来了偏差。</p>]]></content>
    
    
    <categories>
      
      <category>javascript</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>vue函数是否加（）</title>
    <link href="/2023/04/21/vue%E5%87%BD%E6%95%B0%E6%98%AF%E5%90%A6%E5%8A%A0%EF%BC%88%EF%BC%89/"/>
    <url>/2023/04/21/vue%E5%87%BD%E6%95%B0%E6%98%AF%E5%90%A6%E5%8A%A0%EF%BC%88%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<img src="image-20230421105230000.png" alt="image-20230421105230000" style="zoom:150%;" />]]></content>
    
    
    <categories>
      
      <category>vue</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>vue底层原理</title>
    <link href="/2023/04/21/vue%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"/>
    <url>/2023/04/21/vue%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p><img src="wps1.jpg" alt="img"></p><p>1.vue 作为一种MVVM模式的框架， 其数据绑定的底层原理为：<strong>数据劫持 + 发布订阅者模式</strong>。</p><p>其中主要有这么<strong>四种“角色”</strong>：</p><p>· Observer </p><p>· Dep数据收集</p><p>· Watcer订阅者</p><p>· Compiler 模板编译器。</p><p><strong>Observer</strong> 主要负责 数据劫持， 核心是通过Obeject.defineProperty()来监听数据的变动，这个函数内部可以定义setter和getter。每当数据发生变化，就会触发setter()。这时候 Observer 就要通知给Dep 说有数据发生了变化。</p><p>发布订阅模式主要是通过 Dep 和 Watcher 来完成。</p><p><strong>Dep</strong> 中存放着 Watcher 实例化时存放的所有依赖，是个数据集，当 Dep 收到来自 Observer 的数据变化通知时，会调用 notice() 方法把发生变化的依赖告诉 Watcher。</p><p><strong>Watcher</strong> 是订阅者，是连接 Observer 和 Compile 之间通信的桥梁，当它收到来自 Dep 的数据变化通知后，会调用自身的 update() 方法，并触发Compile中绑定的回调。</p><p><strong>Compile</strong> 主要做的事情是解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦接收到数据有变动，收到通知，更新视图。</p><p>2.<img src="wps2.jpg" alt="img"> </p><p>先通过Obeject.defineProperty()来拦截，每次修改，就会触发setter()，拦截到了，通知watcher，watcher收录着当前状态在页面中所有用到的地方，将所有用到的相关组件代码进行更新，而在更新过程中，会先创建一份虚拟dom，然后新旧虚拟dom对比，在对比的过程中通过key值以最小的代价找出不同的更新到真是的dom中</p><p><img src="wps3.jpg" alt="img"> </p><p>面试的时候  vdom  vnode  virtual dom  virtual node  都是指的这个虚拟的dom节点  </p>]]></content>
    
    
    <categories>
      
      <category>vue</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>template为什么不能用v-show渲染</title>
    <link href="/2023/04/21/template%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BD%E7%94%A8v-show%E6%B8%B2%E6%9F%93/"/>
    <url>/2023/04/21/template%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BD%E7%94%A8v-show%E6%B8%B2%E6%9F%93/</url>
    
    <content type="html"><![CDATA[<h2>vue中template只能用v-if渲染，不能用v-show渲染</h2><p>1.template的作用</p><p>template 可以无形之中添加一个包装，将某些整体处理，html文档中不会发生变化。</p><p>template的效果相当于在需要整体处理的外面加了一个div包着，但是不会影响内外层之间的父子关系</p><br><p>2.<font color = "red">template 只能用v-if渲染，不能用v-show渲染，因为v-show是通过操作display来控制标签进行渲染的，但是template标签在vue解析后是不会显示在页面上的，是一个虚拟的dom，所以不可以，v-if是条件渲染。</font></p><br><h3 id="3-v-show-与-v-if-的共同点"><a href="#3-v-show-与-v-if-的共同点" class="headerlink" title="3.v-show 与 v-if 的共同点"></a><strong>3.v-show 与 v-if 的共同点</strong></h3><p> 在 vue 中 v-show 与 v-if 的作用效果是相同的(不含v-else)，都能控制元素在页面是否显示 。</p><ul><li>当表达式都为 false 时，都不会占据页面位置</li><li>当表达式结果为 true 时，都会占据页面的位置</li></ul><br><h3 id="4-v-show-与-v-if-的区别"><a href="#4-v-show-与-v-if-的区别" class="headerlink" title="4.v-show 与 v-if 的区别"></a><strong>4.v-show 与 v-if 的区别</strong></h3><p><strong>控制手段不同</strong>：v-show是通过设置该元素css–display:block\none来控制该元素的显示\隐藏，dom元素在页面渲染之初就会生成，一直都在。</p><p>​v-if是根据绑定表达式的返回值，当返回值为真时，页面渲染dom节点，当返回值非False时，删除dom节点，来达到dom元素显示与隐藏的效果。<br><strong>编译过程不同</strong>：v-if切换有一个局部编译&#x2F;卸载的过程，切换过程中合适地销毁和重建内部的事件监听和子组件；v-show只是简单的基于css切换。<br><strong>编译条件不同</strong>：v-if是真正的条件渲染，它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。只有渲染条件为假时，并不做操作，直到为真才渲染。</p><p><strong>生命周期</strong>：v-show 由false变为true的时候不会触发组件的生命周期。v-if由false变为true的时候，触发组件的beforeCreate、create、beforeMount、mounted钩子，由true变为false的时候触发组件的beforeDestory、destoryed方法。</p><p><strong>性能消耗</strong>：<font color= "red">v-if有更高的切换消耗；v-show有更高的初始渲染消耗</font>；</p><br><h3 id="5-v-show-与-v-if-使用场景"><a href="#5-v-show-与-v-if-使用场景" class="headerlink" title="5.v-show 与 v-if 使用场景"></a><strong>5.v-show 与 v-if 使用场景</strong></h3><p>v-if 与 v-show 都能控制dom元素在页面的显示</p><p>v-if 相比 v-show 开销更大的（直接操作dom节点增加与删除）</p><p>如果需要非常频繁地切换，则使用 v-show 较好</p><p>如果在运行时条件很少改变，则使用 v-if 较好</p>]]></content>
    
    
    <categories>
      
      <category>vue</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>BGW-代码输出</title>
    <link href="/2023/04/18/BGW-%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA/"/>
    <url>/2023/04/18/BGW-%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA/</url>
    
    <content type="html"><![CDATA[<p>代码输出</p><h3 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h3><p><strong>代码输出结果</strong>是面试中常考的题目，一段代码中可能涉及到很多的知识点，这就考察到了应聘者的基础能力。在前端面试中，常考的代码输出问题主要涉及到以下知识点：<strong>异步编程、事件循环、this指向、作用域、变量提升、闭包、原型、继承</strong>等，这些知识点往往不是单独出现的，而是在同一段代码中包含多个知识点。所以，笔者将这些问题大致分为四类进行讨论。这里不会系统的阐述基础知识，而是通过面试例题的形式，来讲述每个题目的知识点以及代码的执行过程。如果会了这些例题，在前端面试中多数代码输出问题就可以轻而易举的解决了。</p><h2 id="一、异步-amp-事件循环"><a href="#一、异步-amp-事件循环" class="headerlink" title="一、异步&amp;事件循环"></a>一、异步&amp;事件循环</h2><h3 id="1-代码输出结果"><a href="#1-代码输出结果" class="headerlink" title="1. 代码输出结果"></a>1. 代码输出结果</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">1</span>);<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">2</span>);<br>&#125;);<br>promise.<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">3</span>);<br>&#125;);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">4</span>);<br></code></pre></td></tr></table></figure><p>输出结果如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-number">1</span> <br><span class="hljs-number">2</span> <br><span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p>promise.then 是微任务，它会在所有的宏任务执行完之后才会执行，同时需要promise内部的状态发生变化，因为这里内部没有发生变化，一直处于pending状态，所以不输出3。</p><h3 id="2-代码输出结果"><a href="#2-代码输出结果" class="headerlink" title="2. 代码输出结果"></a>2. 代码输出结果</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> promise1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;promise1&#x27;</span>)<br>  <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;resolve1&#x27;</span>)<br>&#125;)<br><span class="hljs-keyword">const</span> promise2 = promise1.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res)<br>&#125;)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;1&#x27;</span>, promise1);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;2&#x27;</span>, promise2);<br></code></pre></td></tr></table></figure><p>输出结果如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript">promise1<br><span class="hljs-number">1</span> <span class="hljs-title class_">Promise</span>&#123;&lt;resolved&gt;: resolve1&#125;<br><span class="hljs-number">2</span> <span class="hljs-title class_">Promise</span>&#123;&lt;pending&gt;&#125;<br>resolve1<br></code></pre></td></tr></table></figure><p>需要注意的是，直接打印promise1，会打印出它的状态值和参数。</p><p>代码执行过程如下：</p><ol><li>script是一个宏任务，按照顺序执行这些代码；</li><li>首先进入Promise，执行该构造函数中的代码，打印<code>promise1</code>；</li><li>碰到<code>resolve</code>函数, 将<code>promise1</code>的状态改变为<code>resolved</code>, 并将结果保存下来；</li><li>碰到<code>promise1.then</code>这个微任务，将它放入微任务队列；</li><li><code>promise2</code>是一个新的状态为<code>pending</code>的<code>Promise</code>；</li><li>执行同步代码1， 同时打印出<code>promise1</code>的状态是<code>resolved</code>；</li><li>执行同步代码2，同时打印出<code>promise2</code>的状态是<code>pending</code>；</li><li>宏任务执行完毕，查找微任务队列，发现<code>promise1.then</code>这个微任务且状态为<code>resolved</code>，执行它。</li></ol><h3 id="3-代码输出结果"><a href="#3-代码输出结果" class="headerlink" title="3. 代码输出结果"></a>3. 代码输出结果</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">1</span>);<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;timerStart&quot;</span>);<br>    <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&quot;success&quot;</span>);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;timerEnd&quot;</span>);<br>  &#125;, <span class="hljs-number">0</span>);<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">2</span>);<br>&#125;);<br>promise.<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res);<br>&#125;);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">4</span>);<br></code></pre></td></tr></table></figure><p>输出结果如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-number">1</span><br><span class="hljs-number">2</span><br><span class="hljs-number">4</span><br>timerStart<br>timerEnd<br>success<br></code></pre></td></tr></table></figure><p>代码执行过程如下：</p><ul><li>首先遇到Promise构造函数，会先执行里面的内容，打印<code>1</code>；</li><li>遇到定时器<code>steTimeout</code>，它是一个宏任务，放入宏任务队列；</li><li>继续向下执行，打印出2；</li><li>由于<code>Promise</code>的状态此时还是<code>pending</code>，所以<code>promise.then</code>先不执行；</li><li>继续执行下面的同步任务，打印出4；</li><li>此时微任务队列没有任务，继续执行下一轮宏任务，执行<code>steTimeout</code>；</li><li>首先执行<code>timerStart</code>，然后遇到了<code>resolve</code>，将<code>promise</code>的状态改为<code>resolved</code>且保存结果并将之前的<code>promise.then</code>推入微任务队列，再执行<code>timerEnd</code>；</li><li>执行完这个宏任务，就去执行微任务<code>promise.then</code>，打印出<code>resolve</code>的结果。</li></ul><h3 id="4-代码输出结果"><a href="#4-代码输出结果" class="headerlink" title="4. 代码输出结果"></a>4. 代码输出结果</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;promise1&#x27;</span>);<br>  <span class="hljs-keyword">const</span> timer2 = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;timer2&#x27;</span>)<br>  &#125;, <span class="hljs-number">0</span>)<br>&#125;);<br><span class="hljs-keyword">const</span> timer1 = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;timer1&#x27;</span>)<br>  <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;promise2&#x27;</span>)<br>  &#125;)<br>&#125;, <span class="hljs-number">0</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;start&#x27;</span>);<br></code></pre></td></tr></table></figure><p>输出结果如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript">start<br>promise1<br>timer1<br>promise2<br>timer2<br></code></pre></td></tr></table></figure><p>代码执行过程如下：</p><ol><li>首先，<code>Promise.resolve().then</code>是一个微任务，加入微任务队列</li><li>执行timer1，它是一个宏任务，加入宏任务队列</li><li>继续执行下面的同步代码，打印出<code>start</code></li><li>这样第一轮宏任务就执行完了，开始执行微任务<code>Promise.resolve().then</code>，打印出<code>promise1</code></li><li>遇到<code>timer2</code>，它是一个宏任务，将其加入宏任务队列，此时宏任务队列有两个任务，分别是<code>timer1</code>、<code>timer2</code>；</li><li>这样第一轮微任务就执行完了，开始执行第二轮宏任务，首先执行定时器<code>timer1</code>，打印<code>timer1</code>；</li><li>遇到<code>Promise.resolve().then</code>，它是一个微任务，加入微任务队列</li><li>开始执行微任务队列中的任务，打印<code>promise2</code>；</li><li>最后执行宏任务<code>timer2</code>定时器，打印出<code>timer2</code>；</li></ol><h3 id="5-代码输出结果"><a href="#5-代码输出结果" class="headerlink" title="5. 代码输出结果"></a>5. 代码输出结果</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;success1&#x27;</span>);<br>    <span class="hljs-title function_">reject</span>(<span class="hljs-string">&#x27;error&#x27;</span>);<br>    <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;success2&#x27;</span>);<br>&#125;);<br>promise.<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;then:&#x27;</span>, res);<br>&#125;).<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;catch:&#x27;</span>, err);<br>&#125;)<br></code></pre></td></tr></table></figure><p>输出结果如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">then：success1<br></code></pre></td></tr></table></figure><p>这个题目考察的就是<strong>Promise的状态在发生变化之后，就不会再发生变化</strong>。开始状态由<code>pending</code>变为<code>resolve</code>，说明已经变为已完成状态，下面的两个状态的就不会再执行，同时下面的catch也不会捕获到错误。</p><h3 id="6-代码输出结果"><a href="#6-代码输出结果" class="headerlink" title="6. 代码输出结果"></a>6. 代码输出结果</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-number">1</span>)<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-number">2</span>)<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-number">3</span>))<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-variable language_">console</span>.<span class="hljs-property">log</span>)<br></code></pre></td></tr></table></figure><p>输出结果如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-number">1</span><br><span class="hljs-title class_">Promise</span> &#123;&lt;fulfilled&gt;: <span class="hljs-literal">undefined</span>&#125;<br></code></pre></td></tr></table></figure><p>Promise.resolve方法的参数如果是一个原始值，或者是一个不具有then方法的对象，则Promise.resolve方法返回一个新的Promise对象，状态为resolved，Promise.resolve方法的参数，会同时传给回调函数。</p><p>then方法接受的参数是函数，而如果传递的并非是一个函数，它实际上会将其解释为then(null)，这就会导致前一个Promise的结果会传递下面。</p><h3 id="7-代码输出结果"><a href="#7-代码输出结果" class="headerlink" title="7. 代码输出结果"></a>7. 代码输出结果</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> promise1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;success&#x27;</span>)<br>  &#125;, <span class="hljs-number">1000</span>)<br>&#125;)<br><span class="hljs-keyword">const</span> promise2 = promise1.<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;error!!!&#x27;</span>)<br>&#125;)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;promise1&#x27;</span>, promise1)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;promise2&#x27;</span>, promise2)<br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;promise1&#x27;</span>, promise1)<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;promise2&#x27;</span>, promise2)<br>&#125;, <span class="hljs-number">2000</span>)<br></code></pre></td></tr></table></figure><p>输出结果如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript">promise1 <span class="hljs-title class_">Promise</span> &#123;&lt;pending&gt;&#125;<br>promise2 <span class="hljs-title class_">Promise</span> &#123;&lt;pending&gt;&#125;<br><br><span class="hljs-title class_">Uncaught</span> (<span class="hljs-keyword">in</span> promise) <span class="hljs-title class_">Error</span>: error!!!<br>promise1 <span class="hljs-title class_">Promise</span> &#123;&lt;fulfilled&gt;: <span class="hljs-string">&quot;success&quot;</span>&#125;<br>promise2 <span class="hljs-title class_">Promise</span> &#123;&lt;rejected&gt;: <span class="hljs-title class_">Error</span>: error!!&#125;<br></code></pre></td></tr></table></figure><h3 id="8-代码输出结果"><a href="#8-代码输出结果" class="headerlink" title="8. 代码输出结果"></a>8. 代码输出结果</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-number">1</span>)<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>  &#125;)<br>  .<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;<br>  &#125;)<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res);<br>  &#125;);<br></code></pre></td></tr></table></figure><p>输出结果如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-number">1</span>   <br><span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>Promise是可以链式调用的，由于每次调用 <code>.then</code> 或者 <code>.catch</code> 都会返回一个新的 promise，从而实现了链式调用, 它并不像一般任务的链式调用一样return this。</p><p>上面的输出结果之所以依次打印出1和2，是因为<code>resolve(1)</code>之后走的是第一个then方法，并没有进catch里，所以第二个then中的res得到的实际上是第一个then的返回值。并且return 2会被包装成<code>resolve(2)</code>，被最后的then打印输出2。</p><h3 id="9-代码输出结果"><a href="#9-代码输出结果" class="headerlink" title="9. 代码输出结果"></a>9. 代码输出结果</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;error!!!&#x27;</span>)<br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;then: &quot;</span>, res)<br>&#125;).<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;catch: &quot;</span>, err)<br>&#125;)<br></code></pre></td></tr></table></figure><p>输出结果如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-string">&quot;then: &quot;</span> <span class="hljs-string">&quot;Error: error!!!&quot;</span><br></code></pre></td></tr></table></figure><p>返回任意一个非 promise 的值都会被包裹成 promise 对象，因此这里的<code>return new Error(&#39;error!!!&#39;)</code>也被包裹成了<code>return Promise.resolve(new Error(&#39;error!!!&#39;))</code>，因此它会被then捕获而不是catch。</p><h3 id="10-代码输出结果"><a href="#10-代码输出结果" class="headerlink" title="10. 代码输出结果"></a>10. 代码输出结果</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> promise = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-keyword">return</span> promise;<br>&#125;)<br>promise.<span class="hljs-title function_">catch</span>(<span class="hljs-variable language_">console</span>.<span class="hljs-property">err</span>)<br></code></pre></td></tr></table></figure><p>输出结果如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Uncaught</span> (<span class="hljs-keyword">in</span> promise) <span class="hljs-title class_">TypeError</span>: <span class="hljs-title class_">Chaining</span> cycle detected <span class="hljs-keyword">for</span> promise #&lt;<span class="hljs-title class_">Promise</span>&gt;<br></code></pre></td></tr></table></figure><p>这里其实是一个坑，<code>.then</code> 或 <code>.catch</code> 返回的值不能是 promise 本身，否则会造成死循环。</p><h3 id="11-代码输出结果"><a href="#11-代码输出结果" class="headerlink" title="11. 代码输出结果"></a>11. 代码输出结果</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-number">1</span>)<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-number">2</span>)<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-number">3</span>))<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-variable language_">console</span>.<span class="hljs-property">log</span>)<br></code></pre></td></tr></table></figure><p>输出结果如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>看到这个题目，好多的then，实际上只需要记住一个原则：<code>.then</code> 或<code>.catch</code> 的参数期望是函数，传入非函数则会发生<strong>值透传</strong>。</p><p>第一个then和第二个then中传入的都不是函数，一个是数字，一个是对象，因此发生了透传，将<code>resolve(1)</code> 的值直接传到最后一个then里，直接打印出1。</p><h3 id="12-代码输出结果"><a href="#12-代码输出结果" class="headerlink" title="12. 代码输出结果"></a>12. 代码输出结果</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(<span class="hljs-string">&#x27;err!!!&#x27;</span>)<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;success&#x27;</span>, res)<br>  &#125;, <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;error&#x27;</span>, err)<br>  &#125;).<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;catch&#x27;</span>, err)<br>  &#125;)<br></code></pre></td></tr></table></figure><p>输出结果如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">error err!!!<br></code></pre></td></tr></table></figure><p>我们知道，<code>.then</code>函数中的两个参数：</p><ul><li>第一个参数是用来处理Promise成功的函数</li><li>第二个则是处理失败的函数</li></ul><p>也就是说<code>Promise.resolve(&#39;1&#39;)</code>的值会进入成功的函数，<code>Promise.reject(&#39;2&#39;)</code>的值会进入失败的函数。</p><p>在这道题中，错误直接被<code>then</code>的第二个参数捕获了，所以就不会被<code>catch</code>捕获了，输出结果为：<code>error err!!!&#39;</code></p><p>但是，如果是像下面这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>()<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span> <span class="hljs-title function_">success</span> (res) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;error!!!&#x27;</span>)<br>  &#125;, <span class="hljs-keyword">function</span> <span class="hljs-title function_">fail1</span> (err) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;fail1&#x27;</span>, err)<br>  &#125;).<span class="hljs-title function_">catch</span>(<span class="hljs-keyword">function</span> <span class="hljs-title function_">fail2</span> (err) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;fail2&#x27;</span>, err)<br>  &#125;)<br></code></pre></td></tr></table></figure><p>在<code>then</code>的第一参数中抛出了错误，那么他就不会被第二个参数不活了，而是被后面的<code>catch</code>捕获到。</p><h3 id="13-代码输出结果"><a href="#13-代码输出结果" class="headerlink" title="13. 代码输出结果"></a>13. 代码输出结果</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;1&#x27;</span>)<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res)<br>  &#125;)<br>  .<span class="hljs-title function_">finally</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;finally&#x27;</span>)<br>  &#125;)<br><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;2&#x27;</span>)<br>  .<span class="hljs-title function_">finally</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;finally2&#x27;</span>)<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;我是finally2返回的值&#x27;</span><br>  &#125;)<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;finally2后面的then函数&#x27;</span>, res)<br>  &#125;)<br></code></pre></td></tr></table></figure><p>输出结果如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-number">1</span><br>finally2<br><span class="hljs-keyword">finally</span><br>finally2后面的then函数 <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p><code>.finally()</code>一般用的很少，只要记住以下几点就可以了：</p><ul><li><code>.finally()</code>方法不管Promise对象最后的状态如何都会执行</li><li><code>.finally()</code>方法的回调函数不接受任何的参数，也就是说你在<code>.finally()</code>函数中是无法知道Promise最终的状态是<code>resolved</code>还是<code>rejected</code>的</li><li>它最终返回的默认会是一个上一次的Promise对象值，不过如果抛出的是一个异常则返回异常的Promise对象。</li><li>finally本质上是then方法的特例</li></ul><p><code>.finally()</code>的错误捕获：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;1&#x27;</span>)<br>  .<span class="hljs-title function_">finally</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;finally1&#x27;</span>)<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;我是finally中抛出的异常&#x27;</span>)<br>  &#125;)<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;finally后面的then函数&#x27;</span>, res)<br>  &#125;)<br>  .<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;捕获错误&#x27;</span>, err)<br>  &#125;)<br></code></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;finally1&#x27;</span><br><span class="hljs-string">&#x27;捕获错误&#x27;</span> <span class="hljs-title class_">Error</span>: 我是<span class="hljs-keyword">finally</span>中抛出的异常<br></code></pre></td></tr></table></figure><h3 id="14-代码输出结果"><a href="#14-代码输出结果" class="headerlink" title="14. 代码输出结果"></a>14. 代码输出结果</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">runAsync</span> (x) &#123;<br>    <span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function"><span class="hljs-params">r</span> =&gt;</span> <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">r</span>(x, <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x)), <span class="hljs-number">1000</span>))<br>    <span class="hljs-keyword">return</span> p<br>&#125;<br><br><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>([<span class="hljs-title function_">runAsync</span>(<span class="hljs-number">1</span>), <span class="hljs-title function_">runAsync</span>(<span class="hljs-number">2</span>), <span class="hljs-title function_">runAsync</span>(<span class="hljs-number">3</span>)]).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res))<br></code></pre></td></tr></table></figure><p>输出结果如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-number">1</span><br><span class="hljs-number">2</span><br><span class="hljs-number">3</span><br>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br></code></pre></td></tr></table></figure><p>首先，定义了一个Promise，来异步执行函数runAsync，该函数传入一个值x，然后间隔一秒后打印出这个x。</p><p>之后再使用<code>Promise.all</code>来执行这个函数，执行的时候，看到一秒之后输出了1，2，3，同时输出了数组[1, 2, 3]，三个函数是同步执行的，并且在一个回调函数中返回了所有的结果。并且结果和函数的执行顺序是一致的。</p><h3 id="15-代码输出结果"><a href="#15-代码输出结果" class="headerlink" title="15. 代码输出结果"></a>15. 代码输出结果</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">runAsync</span> (x) &#123;<br>  <span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function"><span class="hljs-params">r</span> =&gt;</span> <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">r</span>(x, <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x)), <span class="hljs-number">1000</span>))<br>  <span class="hljs-keyword">return</span> p<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">runReject</span> (x) &#123;<br>  <span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">res, rej</span>) =&gt;</span> <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">rej</span>(<span class="hljs-string">`Error: <span class="hljs-subst">$&#123;x&#125;</span>`</span>, <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x)), <span class="hljs-number">1000</span> * x))<br>  <span class="hljs-keyword">return</span> p<br>&#125;<br><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>([<span class="hljs-title function_">runAsync</span>(<span class="hljs-number">1</span>), <span class="hljs-title function_">runReject</span>(<span class="hljs-number">4</span>), <span class="hljs-title function_">runAsync</span>(<span class="hljs-number">3</span>), <span class="hljs-title function_">runReject</span>(<span class="hljs-number">2</span>)])<br>       .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res))<br>       .<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err))<br></code></pre></td></tr></table></figure><p>输出结果如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 1s后输出</span><br><span class="hljs-number">1</span><br><span class="hljs-number">3</span><br><span class="hljs-comment">// 2s后输出</span><br><span class="hljs-number">2</span><br><span class="hljs-title class_">Error</span>: <span class="hljs-number">2</span><br><span class="hljs-comment">// 4s后输出</span><br><span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p>可以看到。catch捕获到了第一个错误，在这道题目中最先的错误就是<code>runReject(2)</code>的结果。如果一组异步操作中有一个异常都不会进入<code>.then()</code>的第一个回调函数参数中。会被<code>.then()</code>的第二个回调函数捕获。</p><h3 id="16-代码输出结果"><a href="#16-代码输出结果" class="headerlink" title="16. 代码输出结果"></a>16. 代码输出结果</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">runAsync</span> (x) &#123;<br>  <span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function"><span class="hljs-params">r</span> =&gt;</span> <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">r</span>(x, <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x)), <span class="hljs-number">1000</span>))<br>  <span class="hljs-keyword">return</span> p<br>&#125;<br><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">race</span>([<span class="hljs-title function_">runAsync</span>(<span class="hljs-number">1</span>), <span class="hljs-title function_">runAsync</span>(<span class="hljs-number">2</span>), <span class="hljs-title function_">runAsync</span>(<span class="hljs-number">3</span>)])<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;result: &#x27;</span>, res))<br>  .<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err))<br></code></pre></td></tr></table></figure><p>输出结果如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-number">1</span><br><span class="hljs-string">&#x27;result: &#x27;</span> <span class="hljs-number">1</span><br><span class="hljs-number">2</span><br><span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p>then只会捕获第一个成功的方法，其他的函数虽然还会继续执行，但是不是被then捕获了。</p><h3 id="17-代码输出结果"><a href="#17-代码输出结果" class="headerlink" title="17. 代码输出结果"></a>17. 代码输出结果</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">runAsync</span>(<span class="hljs-params">x</span>) &#123;<br>  <span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function"><span class="hljs-params">r</span> =&gt;</span><br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">r</span>(x, <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x)), <span class="hljs-number">1000</span>)<br>  );<br>  <span class="hljs-keyword">return</span> p;<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">runReject</span>(<span class="hljs-params">x</span>) &#123;<br>  <span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">res, rej</span>) =&gt;</span><br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">rej</span>(<span class="hljs-string">`Error: <span class="hljs-subst">$&#123;x&#125;</span>`</span>, <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x)), <span class="hljs-number">1000</span> * x)<br>  );<br>  <span class="hljs-keyword">return</span> p;<br>&#125;<br><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">race</span>([<span class="hljs-title function_">runReject</span>(<span class="hljs-number">0</span>), <span class="hljs-title function_">runAsync</span>(<span class="hljs-number">1</span>), <span class="hljs-title function_">runAsync</span>(<span class="hljs-number">2</span>), <span class="hljs-title function_">runAsync</span>(<span class="hljs-number">3</span>)])<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;result: &quot;</span>, res))<br>  .<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err));<br></code></pre></td></tr></table></figure><p>输出结果如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-number">0</span><br><span class="hljs-title class_">Error</span>: <span class="hljs-number">0</span><br><span class="hljs-number">1</span><br><span class="hljs-number">2</span><br><span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p>可以看到在catch捕获到第一个错误之后，后面的代码还不执行，不过不会再被捕获了。</p><p>注意：<code>all</code>和<code>race</code>传入的数组中如果有会抛出异常的异步任务，那么只有最先抛出的错误会被捕获，并且是被then的第二个参数或者后面的catch捕获；但并不会影响数组中其它的异步任务的执行。</p><h3 id="18-代码输出结果"><a href="#18-代码输出结果" class="headerlink" title="18. 代码输出结果"></a>18. 代码输出结果</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">async1</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;async1 start&quot;</span>);<br>  <span class="hljs-keyword">await</span> <span class="hljs-title function_">async2</span>();<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;async1 end&quot;</span>);<br>&#125;<br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">async2</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;async2&quot;</span>);<br>&#125;<br><span class="hljs-title function_">async1</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;start&#x27;</span>)<br></code></pre></td></tr></table></figure><p>输出结果如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript">async1 start<br>async2<br>start<br>async1 end<br></code></pre></td></tr></table></figure><p>代码的执行过程如下：</p><ol><li>首先执行函数中的同步代码<code>async1 start</code>，之后遇到了<code>await</code>，它会阻塞<code>async1</code>后面代码的执行，因此会先去执行<code>async2</code>中的同步代码<code>async2</code>，然后跳出<code>async1</code>；</li><li>跳出<code>async1</code>函数后，执行同步代码<code>start</code>；</li><li>在一轮宏任务全部执行完之后，再来执行<code>await</code>后面的内容<code>async1 end</code>。</li></ol><p>这里可以理解为await后面的语句相当于放到了new Promise中，下一行及之后的语句相当于放在Promise.then中。</p><h3 id="19-代码输出结果"><a href="#19-代码输出结果" class="headerlink" title="19. 代码输出结果"></a>19. 代码输出结果</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">async1</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;async1 start&quot;</span>);<br>  <span class="hljs-keyword">await</span> <span class="hljs-title function_">async2</span>();<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;async1 end&quot;</span>);<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;timer1&#x27;</span>)<br>  &#125;, <span class="hljs-number">0</span>)<br>&#125;<br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">async2</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;timer2&#x27;</span>)<br>  &#125;, <span class="hljs-number">0</span>)<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;async2&quot;</span>);<br>&#125;<br><span class="hljs-title function_">async1</span>();<br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;timer3&#x27;</span>)<br>&#125;, <span class="hljs-number">0</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;start&quot;</span>)<br></code></pre></td></tr></table></figure><p>输出结果如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript">async1 start<br>async2<br>start<br>async1 end<br>timer2<br>timer3<br>timer1<br></code></pre></td></tr></table></figure><p>代码的执行过程如下：</p><ol><li>首先进入<code>async1</code>，打印出<code>async1 start</code>；</li><li>之后遇到<code>async2</code>，进入<code>async2</code>，遇到定时器<code>timer2</code>，加入宏任务队列，之后打印<code>async2</code>；</li><li>由于<code>async2</code>阻塞了后面代码的执行，所以执行后面的定时器<code>timer3</code>，将其加入宏任务队列，之后打印<code>start</code>；</li><li>然后执行async2后面的代码，打印出<code>async1 end</code>，遇到定时器timer1，将其加入宏任务队列；</li><li>最后，宏任务队列有三个任务，先后顺序为<code>timer2</code>，<code>timer3</code>，<code>timer1</code>，没有微任务，所以直接所有的宏任务按照先进先出的原则执行。</li></ol><h3 id="20-代码输出结果"><a href="#20-代码输出结果" class="headerlink" title="20. 代码输出结果"></a>20. 代码输出结果</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">async1</span> () &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;async1 start&#x27;</span>);<br>  <span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;promise1&#x27;</span>)<br>  &#125;)<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;async1 success&#x27;</span>);<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;async1 end&#x27;</span><br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;srcipt start&#x27;</span>)<br><span class="hljs-title function_">async1</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res))<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;srcipt end&#x27;</span>)<br></code></pre></td></tr></table></figure><p>输出结果如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript">script start<br>async1 start<br>promise1<br>script end<br></code></pre></td></tr></table></figure><p>这里需要注意的是在<code>async1</code>中<code>await</code>后面的Promise是没有返回值的，也就是它的状态始终是<code>pending</code>状态，所以在<code>await</code>之后的内容是不会执行的，包括<code>async1</code>后面的 <code>.then</code>。</p><h3 id="21-代码输出结果"><a href="#21-代码输出结果" class="headerlink" title="21. 代码输出结果"></a>21. 代码输出结果</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">async1</span> () &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;async1 start&#x27;</span>);<br>  <span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;promise1&#x27;</span>)<br>    <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;promise1 resolve&#x27;</span>)<br>  &#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res))<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;async1 success&#x27;</span>);<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;async1 end&#x27;</span><br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;srcipt start&#x27;</span>)<br><span class="hljs-title function_">async1</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res))<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;srcipt end&#x27;</span>)<br></code></pre></td></tr></table></figure><p>这里是对上面一题进行了改造，加上了resolve。</p><p>输出结果如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript">script start<br>async1 start<br>promise1<br>script end<br>promise1 resolve<br>async1 success<br>async1 end<br></code></pre></td></tr></table></figure><h3 id="22-代码输出结果"><a href="#22-代码输出结果" class="headerlink" title="22. 代码输出结果"></a>22. 代码输出结果</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">async1</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;async1 start&quot;</span>);<br>  <span class="hljs-keyword">await</span> <span class="hljs-title function_">async2</span>();<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;async1 end&quot;</span>);<br>&#125;<br><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">async2</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;async2&quot;</span>);<br>&#125;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;script start&quot;</span>);<br><br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;setTimeout&quot;</span>);<br>&#125;, <span class="hljs-number">0</span>);<br><br><span class="hljs-title function_">async1</span>();<br><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;promise1&quot;</span>);<br>  <span class="hljs-title function_">resolve</span>();<br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;promise2&quot;</span>);<br>&#125;);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;script end&#x27;</span>)<br></code></pre></td></tr></table></figure><p>输出结果如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript">script start<br>async1 start<br>async2<br>promise1<br>script end<br>async1 end<br>promise2<br><span class="hljs-built_in">setTimeout</span><br></code></pre></td></tr></table></figure><p>代码执行过程如下： </p><ol><li>开头定义了async1和async2两个函数，但是并未执行，执行script中的代码，所以打印出script start；</li><li>遇到定时器Settimeout，它是一个宏任务，将其加入到宏任务队列；</li><li>之后执行函数async1，首先打印出async1 start；</li><li>遇到await，执行async2，打印出async2，并阻断后面代码的执行，将后面的代码加入到微任务队列；</li><li>然后跳出async1和async2，遇到Promise，打印出promise1；</li><li>遇到resolve，将其加入到微任务队列，然后执行后面的script代码，打印出script end；</li><li>之后就该执行微任务队列了，首先打印出async1 end，然后打印出promise2；</li><li>执行完微任务队列，就开始执行宏任务队列中的定时器，打印出setTimeout。</li></ol><h3 id="23-代码输出结果"><a href="#23-代码输出结果" class="headerlink" title="23. 代码输出结果"></a>23. 代码输出结果</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">async1</span> () &#123;<br>  <span class="hljs-keyword">await</span> <span class="hljs-title function_">async2</span>();<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;async1&#x27;</span>);<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;async1 success&#x27;</span><br>&#125;<br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">async2</span> () &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;async2&#x27;</span>)<br>    <span class="hljs-title function_">reject</span>(<span class="hljs-string">&#x27;error&#x27;</span>)<br>  &#125;)<br>&#125;<br><span class="hljs-title function_">async1</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res))<br></code></pre></td></tr></table></figure><p>输出结果如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">async2<br><span class="hljs-title class_">Uncaught</span> (<span class="hljs-keyword">in</span> promise) error<br></code></pre></td></tr></table></figure><p>可以看到，如果async函数中抛出了错误，就会终止错误结果，不会继续向下执行。</p><p>如果想要让错误不足之处后面的代码执行，可以使用catch来捕获：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">async1</span> () &#123;<br>  <span class="hljs-keyword">await</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(<span class="hljs-string">&#x27;error!!!&#x27;</span>).<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(e))<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;async1&#x27;</span>);<br>  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;async1 success&#x27;</span>)<br>&#125;<br><span class="hljs-title function_">async1</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res))<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;script start&#x27;</span>)<br></code></pre></td></tr></table></figure><p>这样的输出结果就是：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript">script start<br>error!!!<br>async1<br>async1 success<br></code></pre></td></tr></table></figure><h3 id="24-代码输出结果"><a href="#24-代码输出结果" class="headerlink" title="24. 代码输出结果"></a>24. 代码输出结果</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">first</span> = (<span class="hljs-params"></span>) =&gt; (<span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">3</span>);<br>    <span class="hljs-keyword">let</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">7</span>);<br>        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">5</span>);<br>            <span class="hljs-title function_">resolve</span>(<span class="hljs-number">6</span>);<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p)<br>        &#125;, <span class="hljs-number">0</span>)<br>        <span class="hljs-title function_">resolve</span>(<span class="hljs-number">1</span>);<br>    &#125;);<br>    <span class="hljs-title function_">resolve</span>(<span class="hljs-number">2</span>);<br>    p.<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">arg</span>) =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arg);<br>    &#125;);<br>&#125;));<br><span class="hljs-title function_">first</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">arg</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arg);<br>&#125;);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">4</span>);<br></code></pre></td></tr></table></figure><p>输出结果如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-number">3</span><br><span class="hljs-number">7</span><br><span class="hljs-number">4</span><br><span class="hljs-number">1</span><br><span class="hljs-number">2</span><br><span class="hljs-number">5</span><br><span class="hljs-title class_">Promise</span>&#123;&lt;resolved&gt;: <span class="hljs-number">1</span>&#125;<br></code></pre></td></tr></table></figure><p>代码的执行过程如下：</p><ol><li>首先会进入Promise，打印出3，之后进入下面的Promise，打印出7；</li><li>遇到了定时器，将其加入宏任务队列；</li><li>执行Promise  p中的resolve，状态变为resolved，返回值为1；</li><li>执行Promise first中的resolve，状态变为resolved，返回值为2；</li><li>遇到p.then，将其加入微任务队列，遇到first().then，将其加入任务队列；</li><li>执行外面的代码，打印出4；</li><li>这样第一轮宏任务就执行完了，开始执行微任务队列中的任务，先后打印出1和2；</li><li>这样微任务就执行完了，开始执行下一轮宏任务，宏任务队列中有一个定时器，执行它，打印出5，由于执行已经变为resolved状态，所以<code>resolve(6)</code>不会再执行；</li><li>最后<code>console.log(p)</code>打印出<code>Promise&#123;&lt;resolved&gt;: 1&#125;</code>；</li></ol><h3 id="25-代码输出结果"><a href="#25-代码输出结果" class="headerlink" title="25. 代码输出结果"></a>25. 代码输出结果</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">async1</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params"></span>) =&gt; &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;async1&#x27;</span>);<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;timer1&#x27;</span>)<br>  &#125;, <span class="hljs-number">2000</span>)<br>  <span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;promise1&#x27;</span>)<br>  &#125;)<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;async1 end&#x27;</span>)<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;async1 success&#x27;</span><br>&#125; <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;script start&#x27;</span>);<br><span class="hljs-title function_">async1</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res));<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;script end&#x27;</span>);<br><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-number">1</span>)<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-number">2</span>)<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-number">3</span>))<br>  .<span class="hljs-title function_">catch</span>(<span class="hljs-number">4</span>)<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res))<br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;timer2&#x27;</span>)<br>&#125;, <span class="hljs-number">1000</span>)<br></code></pre></td></tr></table></figure><p>输出结果如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript">script start<br>async1<br>promise1<br>script end<br><span class="hljs-number">1</span><br>timer2<br>timer1<br></code></pre></td></tr></table></figure><p>代码的执行过程如下：</p><ol><li>首先执行同步带吗，打印出script start；</li><li>遇到定时器timer1将其加入宏任务队列；</li><li>之后是执行Promise，打印出promise1，由于Promise没有返回值，所以后面的代码不会执行；</li><li>然后执行同步代码，打印出script end；</li><li>继续执行下面的Promise，.then和.catch期望参数是一个函数，这里传入的是一个数字，因此就会发生值渗透，将resolve(1)的值传到最后一个then，直接打印出1；</li><li>遇到第二个定时器，将其加入到微任务队列，执行微任务队列，按顺序依次执行两个定时器，但是由于定时器时间的原因，会在两秒后先打印出timer2，在四秒后打印出timer1。</li></ol><h3 id="26-代码输出结果"><a href="#26-代码输出结果" class="headerlink" title="26. 代码输出结果"></a>26. 代码输出结果</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> &#123;<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;resolve3&#x27;</span>);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;timer1&#x27;</span>)<br>  &#125;, <span class="hljs-number">0</span>)<br>  <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;resovle1&#x27;</span>);<br>  <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;resolve2&#x27;</span>);<br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res)  <span class="hljs-comment">// resolve1</span><br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p1)<br>  &#125;, <span class="hljs-number">1000</span>)<br>&#125;).<span class="hljs-title function_">finally</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;finally&#x27;</span>, res)<br>&#125;)<br></code></pre></td></tr></table></figure><p>执行结果为如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript">resolve1<br><span class="hljs-keyword">finally</span>  <span class="hljs-literal">undefined</span><br>timer1<br><span class="hljs-title class_">Promise</span>&#123;&lt;resolved&gt;: <span class="hljs-literal">undefined</span>&#125;<br></code></pre></td></tr></table></figure><p>需要注意的是最后一个定时器打印出的p1其实是<code>.finally</code>的返回值，我们知道<code>.finally</code>的返回值如果在没有抛出错误的情况下默认会是上一个Promise的返回值，而这道题中<code>.finally</code>上一个Promise是<code>.then()</code>，但是这个<code>.then()</code>并没有返回值，所以p1打印出来的Promise的值会是<code>undefined</code>，如果在定时器的下面加上一个<code>return 1</code>，则值就会变成1。</p><h3 id="27-代码输出结果"><a href="#27-代码输出结果" class="headerlink" title="27. 代码输出结果"></a>27. 代码输出结果</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;1&#x27;</span>);<br><br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;2&#x27;</span>);<br>    process.<span class="hljs-title function_">nextTick</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;3&#x27;</span>);<br>    &#125;)<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">resolve</span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;4&#x27;</span>);<br>        <span class="hljs-title function_">resolve</span>();<br>    &#125;).<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;5&#x27;</span>)<br>    &#125;)<br>&#125;)<br>process.<span class="hljs-title function_">nextTick</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;6&#x27;</span>);<br>&#125;)<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">resolve</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;7&#x27;</span>);<br>    <span class="hljs-title function_">resolve</span>();<br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;8&#x27;</span>)<br>&#125;)<br><br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;9&#x27;</span>);<br>    process.<span class="hljs-title function_">nextTick</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;10&#x27;</span>);<br>    &#125;)<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">resolve</span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;11&#x27;</span>);<br>        <span class="hljs-title function_">resolve</span>();<br>    &#125;).<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;12&#x27;</span>)<br>    &#125;)<br>&#125;)<br></code></pre></td></tr></table></figure><p>输出结果如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-number">1</span><br><span class="hljs-number">7</span><br><span class="hljs-number">6</span><br><span class="hljs-number">8</span><br><span class="hljs-number">2</span><br><span class="hljs-number">4</span><br><span class="hljs-number">3</span><br><span class="hljs-number">5</span><br><span class="hljs-number">9</span><br><span class="hljs-number">11</span><br><span class="hljs-number">10</span><br><span class="hljs-number">12</span><br></code></pre></td></tr></table></figure><p><strong>（1）第一轮事件循环流程分析如下：</strong></p><ul><li>整体script作为第一个宏任务进入主线程，遇到<code>console.log</code>，输出1。</li><li>遇到<code>setTimeout</code>，其回调函数被分发到宏任务Event Queue中。暂且记为<code>setTimeout1</code>。</li><li>遇到<code>process.nextTick()</code>，其回调函数被分发到微任务Event Queue中。记为<code>process1</code>。</li><li>遇到<code>Promise</code>，<code>new Promise</code>直接执行，输出7。<code>then</code>被分发到微任务Event Queue中。记为<code>then1</code>。</li><li>又遇到了<code>setTimeout</code>，其回调函数被分发到宏任务Event Queue中，记为<code>setTimeout2</code>。</li></ul><table><thead><tr><th>宏任务Event Queue</th><th>微任务Event Queue</th></tr></thead><tbody><tr><td>setTimeout1</td><td>process1</td></tr><tr><td>setTimeout2</td><td>then1</td></tr></tbody></table><p>上表是第一轮事件循环宏任务结束时各Event Queue的情况，此时已经输出了1和7。发现了<code>process1</code>和<code>then1</code>两个微任务：</p><ul><li>执行<code>process1</code>，输出6。</li><li>执行<code>then1</code>，输出8。</li></ul><p>第一轮事件循环正式结束，这一轮的结果是输出1，7，6，8。</p><p><strong>（2）第二轮时间循环从</strong><code>**setTimeout1**</code><strong>宏任务开始：</strong></p><ul><li>首先输出2。接下来遇到了<code>process.nextTick()</code>，同样将其分发到微任务Event Queue中，记为<code>process2</code>。</li><li><code>new Promise</code>立即执行输出4，<code>then</code>也分发到微任务Event Queue中，记为<code>then2</code>。</li></ul><table><thead><tr><th>宏任务Event Queue</th><th>微任务Event Queue</th></tr></thead><tbody><tr><td>setTimeout2</td><td>process2</td></tr><tr><td></td><td>then2</td></tr></tbody></table><p>第二轮事件循环宏任务结束，发现有<code>process2</code>和<code>then2</code>两个微任务可以执行：</p><ul><li>输出3。</li><li>输出5。</li></ul><p>第二轮事件循环结束，第二轮输出2，4，3，5。</p><p><strong>（3）第三轮事件循环开始，此时只剩setTimeout2了，执行。</strong></p><ul><li>直接输出9。</li><li>将<code>process.nextTick()</code>分发到微任务Event Queue中。记为<code>process3</code>。</li><li>直接执行<code>new Promise</code>，输出11。</li><li>将<code>then</code>分发到微任务Event Queue中，记为<code>then3</code>。</li></ul><table><thead><tr><th>宏任务Event Queue</th><th>微任务Event Queue</th></tr></thead><tbody><tr><td></td><td>process3</td></tr><tr><td></td><td>then3</td></tr></tbody></table><p>第三轮事件循环宏任务执行结束，执行两个微任务<code>process3</code>和<code>then3</code>：</p><ul><li>输出10。</li><li>输出12。</li></ul><p>第三轮事件循环结束，第三轮输出9，11，10，12。</p><p>整段代码，共进行了三次事件循环，完整的输出为1，7，6，8，2，4，3，5，9，11，10，12。</p><h3 id="28-代码输出结果"><a href="#28-代码输出结果" class="headerlink" title="28. 代码输出结果"></a>28. 代码输出结果</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">1</span>)<br><br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">2</span>)<br>&#125;)<br><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span>  &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">3</span>)<br>  <span class="hljs-title function_">resolve</span>(<span class="hljs-number">4</span>)<br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">d</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(d))<br><br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">5</span>)<br>  <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span>  &#123;<br>    <span class="hljs-title function_">resolve</span>(<span class="hljs-number">6</span>)<br>  &#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">d</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(d))<br>&#125;)<br><br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">7</span>)<br>&#125;)<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">8</span>)<br></code></pre></td></tr></table></figure><p>输出结果如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-number">1</span><br><span class="hljs-number">3</span><br><span class="hljs-number">8</span><br><span class="hljs-number">4</span><br><span class="hljs-number">2</span><br><span class="hljs-number">5</span><br><span class="hljs-number">6</span><br><span class="hljs-number">7</span><br></code></pre></td></tr></table></figure><p>代码执行过程如下：</p><ol><li>首先执行script代码，打印出1；</li><li>遇到第一个定时器，加入到宏任务队列；</li><li>遇到Promise，执行代码，打印出3，遇到resolve，将其加入到微任务队列；</li><li>遇到第二个定时器，加入到宏任务队列；</li><li>遇到第三个定时器，加入到宏任务队列；</li><li>继续执行script代码，打印出8，第一轮执行结束；</li><li>执行微任务队列，打印出第一个Promise的resolve结果：4；</li><li>开始执行宏任务队列，执行第一个定时器，打印出2；</li><li>此时没有微任务，继续执行宏任务中的第二个定时器，首先打印出5，遇到Promise，首选打印出6，遇到resolve，将其加入到微任务队列；</li><li>执行微任务队列，打印出6；</li><li>执行宏任务队列中的最后一个定时器，打印出7。</li></ol><h3 id="29-代码输出结果"><a href="#29-代码输出结果" class="headerlink" title="29. 代码输出结果"></a>29. 代码输出结果</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">1</span>);<br>    <br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">2</span>);<br>  <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">3</span>)<br>  &#125;);<br>&#125;);<br><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">4</span>)<br>  <span class="hljs-title function_">resolve</span>(<span class="hljs-number">5</span>)<br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data);<br>&#125;)<br><br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">6</span>);<br>&#125;)<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">7</span>);<br></code></pre></td></tr></table></figure><p>代码输出结果如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-number">1</span><br><span class="hljs-number">4</span><br><span class="hljs-number">7</span><br><span class="hljs-number">5</span><br><span class="hljs-number">2</span><br><span class="hljs-number">3</span><br><span class="hljs-number">6</span><br></code></pre></td></tr></table></figure><p>代码执行过程如下：</p><ol><li>首先执行scrip代码，打印出1；</li><li>遇到第一个定时器setTimeout，将其加入到宏任务队列；</li><li>遇到Promise，执行里面的同步代码，打印出4，遇到resolve，将其加入到微任务队列；</li><li>遇到第二个定时器setTimeout，将其加入到红任务队列；</li><li>执行script代码，打印出7，至此第一轮执行完成；</li><li>指定微任务队列中的代码，打印出resolve的结果：5；</li><li>执行宏任务中的第一个定时器setTimeout，首先打印出2，然后遇到 Promise.resolve().then()，将其加入到微任务队列；</li><li>执行完这个宏任务，就开始执行微任务队列，打印出3；</li><li>继续执行宏任务队列中的第二个定时器，打印出6。</li></ol><h3 id="30-代码输出结果"><a href="#30-代码输出结果" class="headerlink" title="30. 代码输出结果"></a>30. 代码输出结果</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;1&#x27;</span>);<br>    <span class="hljs-keyword">throw</span> <span class="hljs-string">&#x27;Error&#x27;</span>;<br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;2&#x27;</span>);<br>&#125;).<span class="hljs-title function_">catch</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;3&#x27;</span>);<br>    <span class="hljs-keyword">throw</span> <span class="hljs-string">&#x27;Error&#x27;</span>;<br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;4&#x27;</span>);<br>&#125;).<span class="hljs-title function_">catch</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;5&#x27;</span>);<br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;6&#x27;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><p>执行结果如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-number">1</span> <br><span class="hljs-number">3</span> <br><span class="hljs-number">5</span> <br><span class="hljs-number">6</span><br></code></pre></td></tr></table></figure><p>在这道题目中，我们需要知道，无论是thne还是catch中，只要throw 抛出了错误，就会被catch捕获，如果没有throw出错误，就被继续执行后面的then。</p><h3 id="31-代码输出结果"><a href="#31-代码输出结果" class="headerlink" title="31. 代码输出结果"></a>31. 代码输出结果</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">1</span>);<br>&#125;, <span class="hljs-number">100</span>);<br><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">resolve</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">2</span>);<br>  <span class="hljs-title function_">resolve</span>();<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">3</span>);<br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">4</span>);<br>  <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resove, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">5</span>);<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span>  &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">6</span>);<br>    &#125;, <span class="hljs-number">10</span>);<br>  &#125;)<br>&#125;);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">7</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">8</span>);<br></code></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-number">2</span><br><span class="hljs-number">3</span><br><span class="hljs-number">7</span><br><span class="hljs-number">8</span><br><span class="hljs-number">4</span><br><span class="hljs-number">5</span><br><span class="hljs-number">6</span><br><span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>代码执行过程如下：</p><ol><li>首先遇到定时器，将其加入到宏任务队列；</li><li>遇到Promise，首先执行里面的同步代码，打印出2，遇到resolve，将其加入到微任务队列，执行后面同步代码，打印出3；</li><li>继续执行script中的代码，打印出7和8，至此第一轮代码执行完成；</li><li>执行微任务队列中的代码，首先打印出4，如遇到Promise，执行其中的同步代码，打印出5，遇到定时器，将其加入到宏任务队列中，此时宏任务队列中有两个定时器；</li><li>执行宏任务队列中的代码，这里我们需要注意是的第一个定时器的时间为100ms，第二个定时器的时间为10ms，所以先执行第二个定时器，打印出6；</li><li>此时微任务队列为空，继续执行宏任务队列，打印出1。</li></ol><p>做完这道题目，我们就需要格外注意，每个定时器的时间，并不是所有定时器的时间都为0哦。</p><h2 id="二、this"><a href="#二、this" class="headerlink" title="二、this"></a>二、this</h2><h3 id="1-代码输出结果-1"><a href="#1-代码输出结果-1" class="headerlink" title="1. 代码输出结果"></a>1. 代码输出结果</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span> );<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">doFoo</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-title function_">foo</span>();<br>&#125;<br><br><span class="hljs-keyword">var</span> obj = &#123;<br>  <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>,<br>  <span class="hljs-attr">doFoo</span>: doFoo<br>&#125;;<br><br><span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span>; <br>obj.<span class="hljs-title function_">doFoo</span>()<br></code></pre></td></tr></table></figure><p>输出结果：2 </p><p>在Javascript中，this指向函数执行时的当前对象。在执行foo的时候，执行环境就是doFoo函数，执行环境为全局。所以，foo中的this是指向window的，所以会打印出2。</p><h3 id="2-代码输出结果-1"><a href="#2-代码输出结果-1" class="headerlink" title="2. 代码输出结果"></a>2. 代码输出结果</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = <span class="hljs-number">10</span><br><span class="hljs-keyword">var</span> obj = &#123;<br>  <span class="hljs-attr">a</span>: <span class="hljs-number">20</span>,<br>  <span class="hljs-attr">say</span>: <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span>)<br>  &#125;<br>&#125;<br>obj.<span class="hljs-title function_">say</span>() <br><br><span class="hljs-keyword">var</span> anotherObj = &#123; <span class="hljs-attr">a</span>: <span class="hljs-number">30</span> &#125; <br>obj.<span class="hljs-property">say</span>.<span class="hljs-title function_">apply</span>(anotherObj) <br></code></pre></td></tr></table></figure><p>输出结果：10  10</p><p>我么知道，箭头函数时不绑定this的，它的this来自原其父级所处的上下文，所以首先会打印全局中的 a 的值10。后面虽然让say方法指向了另外一个对象，但是仍不能改变箭头函数的特性，它的this仍然是指向全局的，所以依旧会输出10。</p><p>但是，如果是普通函数，那么就会有完全不一样的结果：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = <span class="hljs-number">10</span>  <br><span class="hljs-keyword">var</span> obj = &#123;  <br>  <span class="hljs-attr">a</span>: <span class="hljs-number">20</span>,  <br>  <span class="hljs-title function_">say</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span>)  <br>  &#125;  <br>&#125;  <br>obj.<span class="hljs-title function_">say</span>()   <br><span class="hljs-keyword">var</span> anotherObj=&#123;<span class="hljs-attr">a</span>:<span class="hljs-number">30</span>&#125;   <br>obj.<span class="hljs-property">say</span>.<span class="hljs-title function_">apply</span>(anotherObj)<br></code></pre></td></tr></table></figure><p>输出结果：20 30</p><p>这时，say方法中的this就会指向他所在的对象，输出其中的a的值。</p><h3 id="3-代码输出结果-1"><a href="#3-代码输出结果-1" class="headerlink" title="3. 代码输出结果"></a>3. 代码输出结果</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">a</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>);<br>&#125;<br>a.<span class="hljs-title function_">call</span>(<span class="hljs-literal">null</span>);<br></code></pre></td></tr></table></figure><p>打印结果：window对象</p><p>根据ECMAScript262规范规定：如果第一个参数传入的对象调用者是null或者undefined，call方法将把全局对象（浏览器上是window对象）作为this的值。所以，不管传入null 还是 undefined，其this都是全局对象window。所以，在浏览器上答案是输出 window 对象。</p><p>要注意的是，在严格模式中，null 就是 null，undefined 就是 undefined：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-meta">&#x27;use strict&#x27;</span>;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">a</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>);<br>&#125;<br>a.<span class="hljs-title function_">call</span>(<span class="hljs-literal">null</span>); <span class="hljs-comment">// null</span><br>a.<span class="hljs-title function_">call</span>(<span class="hljs-literal">undefined</span>); <span class="hljs-comment">// undefined</span><br></code></pre></td></tr></table></figure><h3 id="4-代码输出结果-1"><a href="#4-代码输出结果-1" class="headerlink" title="4. 代码输出结果"></a>4. 代码输出结果</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123; <br>  name : <span class="hljs-string">&#x27;cuggz&#x27;</span>, <br>  fun : <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123; <br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>); <br>  &#125; <br>&#125; <br>obj.<span class="hljs-title function_">fun</span>()     <span class="hljs-comment">// cuggz</span><br><span class="hljs-keyword">new</span> obj.<span class="hljs-title function_">fun</span>() <span class="hljs-comment">// undefined</span><br></code></pre></td></tr></table></figure><p>使用new构造函数时，其this指向的是全局环境window。</p><h3 id="6-代码输出结果-1"><a href="#6-代码输出结果-1" class="headerlink" title="6. 代码输出结果"></a>6. 代码输出结果</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123;<br>   <span class="hljs-attr">say</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>     <span class="hljs-keyword">var</span> <span class="hljs-title function_">f1</span> = (<span class="hljs-params"></span>) =&gt;  &#123;<br>       <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;1111&quot;</span>, <span class="hljs-variable language_">this</span>);<br>     &#125;<br>     <span class="hljs-title function_">f1</span>();<br>   &#125;,<br>   <span class="hljs-attr">pro</span>: &#123;<br>     <span class="hljs-attr">getPro</span>:<span class="hljs-function">() =&gt;</span>  &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>);<br>     &#125;<br>   &#125;<br>&#125;<br><span class="hljs-keyword">var</span> o = obj.<span class="hljs-property">say</span>;<br><span class="hljs-title function_">o</span>();<br>obj.<span class="hljs-title function_">say</span>();<br>obj.<span class="hljs-property">pro</span>.<span class="hljs-title function_">getPro</span>();<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-number">1111</span> <span class="hljs-variable language_">window</span>对象<br><span class="hljs-number">1111</span> obj对象<br><span class="hljs-variable language_">window</span>对象<br></code></pre></td></tr></table></figure><p><strong>解析：</strong></p><ol><li>o()，o是在全局执行的，而f1是箭头函数，它是没有绑定this的，它的this指向其父级的this，其父级say方法的this指向的是全局作用域，所以会打印出window；</li><li>obj.say()，谁调用say，say 的this就指向谁，所以此时this指向的是obj对象；</li><li>obj.pro.getPro()，我们知道，箭头函数时不绑定this的，getPro处于pro中，而对象不构成单独的作用域，所以箭头的函数的this就指向了全局作用域window。</li></ol><h3 id="7-代码输出结果-1"><a href="#7-代码输出结果-1" class="headerlink" title="7. 代码输出结果"></a>7. 代码输出结果</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> myObject = &#123;<br>    <span class="hljs-attr">foo</span>: <span class="hljs-string">&quot;bar&quot;</span>,<br>    <span class="hljs-attr">func</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">var</span> self = <span class="hljs-variable language_">this</span>;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">foo</span>);  <br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(self.<span class="hljs-property">foo</span>);  <br>        (<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">foo</span>);  <br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(self.<span class="hljs-property">foo</span>);  <br>        &#125;());<br>    &#125;<br>&#125;;<br>myObject.<span class="hljs-title function_">func</span>();<br></code></pre></td></tr></table></figure><p>输出结果：bar bar undefined bar</p><p><strong>解析：</strong></p><ol><li>首先func是由myObject调用的，this指向myObject。又因为var self &#x3D; this;所以self指向myObject。</li><li>这个立即执行匿名函数表达式是由window调用的，this指向window 。立即执行匿名函数的作用域处于myObject.func的作用域中，在这个作用域找不到self变量，沿着作用域链向上查找self变量，找到了指向 myObject对象的self。</li></ol><h3 id="8-代码输出问题"><a href="#8-代码输出问题" class="headerlink" title="8. 代码输出问题"></a>8. 代码输出问题</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">window</span>.<span class="hljs-property">number</span> = <span class="hljs-number">2</span>;<br><span class="hljs-keyword">var</span> obj = &#123;<br> <span class="hljs-attr">number</span>: <span class="hljs-number">3</span>,<br> <span class="hljs-attr">db1</span>: (<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>   <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>);<br>   <span class="hljs-variable language_">this</span>.<span class="hljs-property">number</span> *= <span class="hljs-number">4</span>;<br>   <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>     <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>);<br>     <span class="hljs-variable language_">this</span>.<span class="hljs-property">number</span> *= <span class="hljs-number">5</span>;<br>   &#125;<br> &#125;)()<br>&#125;<br><span class="hljs-keyword">var</span> db1 = obj.<span class="hljs-property">db1</span>;<br><span class="hljs-title function_">db1</span>();<br>obj.<span class="hljs-title function_">db1</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-property">number</span>);     <span class="hljs-comment">// 15</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">window</span>.<span class="hljs-property">number</span>);  <span class="hljs-comment">// 40</span><br></code></pre></td></tr></table></figure><p>这道题目看清起来有点乱，但是实际上是考察this指向的:</p><ol><li>执行db1()时，this指向全局作用域，所以window.number * 4 &#x3D; 8，然后执行匿名函数， 所以window.number * 5 &#x3D; 40；</li><li>执行obj.db1();时，this指向obj对象，执行匿名函数，所以obj.numer * 5 &#x3D; 15。</li></ol><h3 id="9-代码输出结果-1"><a href="#9-代码输出结果-1" class="headerlink" title="9. 代码输出结果"></a>9. 代码输出结果</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> length = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">length</span>);<br>&#125;<br> <br><span class="hljs-keyword">var</span> obj = &#123;<br>  <span class="hljs-attr">length</span>: <span class="hljs-number">5</span>,<br>  <span class="hljs-attr">method</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">fn</span>) &#123;<br>    <span class="hljs-title function_">fn</span>();<br>    <span class="hljs-variable language_">arguments</span>[<span class="hljs-number">0</span>]();<br>  &#125;<br>&#125;;<br> <br>obj.<span class="hljs-title function_">method</span>(fn, <span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><p>输出结果： 10 2 </p><p><strong>解析：</strong></p><ol><li>第一次执行fn()，this指向window对象，输出10。</li><li>第二次执行arguments<a href="">0</a>，相当于arguments调用方法，this指向arguments，而这里传了两个参数，故输出arguments长度为2。</li></ol><h3 id="10-代码输出结果-1"><a href="#10-代码输出结果-1" class="headerlink" title="10. 代码输出结果"></a>10. 代码输出结果</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">printA</span>(<span class="hljs-params"></span>)&#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span>);<br>&#125;<br><span class="hljs-keyword">var</span> obj=&#123;<br>  <span class="hljs-attr">a</span>:<span class="hljs-number">2</span>,<br>  <span class="hljs-attr">foo</span>:printA,<br>  <span class="hljs-attr">bar</span>:<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-title function_">printA</span>();<br>  &#125;<br>&#125;<br><br>obj.<span class="hljs-title function_">foo</span>(); <span class="hljs-comment">// 2</span><br>obj.<span class="hljs-title function_">bar</span>(); <span class="hljs-comment">// 1</span><br><span class="hljs-keyword">var</span> foo = obj.<span class="hljs-property">foo</span>;<br><span class="hljs-title function_">foo</span>(); <span class="hljs-comment">// 1</span><br></code></pre></td></tr></table></figure><p>输出结果： 2 1 1 </p><p><strong>解析：</strong></p><ol><li>obj.foo()，foo 的this指向obj对象，所以a会输出2；</li><li>obj.bar()，printA在bar方法中执行，所以此时printA的this指向的是window，所以会输出1；</li><li>foo()，foo是在全局对象中执行的，所以其this指向的是window，所以会输出1；</li></ol><h3 id="11-代码输出结果-1"><a href="#11-代码输出结果-1" class="headerlink" title="11. 代码输出结果"></a>11. 代码输出结果</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> x = <span class="hljs-number">3</span>;<br><span class="hljs-keyword">var</span> y = <span class="hljs-number">4</span>;<br><span class="hljs-keyword">var</span> obj = &#123;<br>    <span class="hljs-attr">x</span>: <span class="hljs-number">1</span>,<br>    <span class="hljs-attr">y</span>: <span class="hljs-number">6</span>,<br>    <span class="hljs-attr">getX</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">var</span> x = <span class="hljs-number">5</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">x</span>;<br>        &#125;();<br>    &#125;,<br>    <span class="hljs-attr">getY</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">var</span> y = <span class="hljs-number">7</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">y</span>;<br>    &#125;<br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-title function_">getX</span>()) <span class="hljs-comment">// 3</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-title function_">getY</span>()) <span class="hljs-comment">// 6</span><br></code></pre></td></tr></table></figure><p>输出结果：3  6</p><p><strong>解析：</strong></p><ol><li>我们知道，匿名函数的this是指向全局对象的，所以this指向window，会打印出3；</li><li>getY是由obj调用的，所以其this指向的是obj对象，会打印出6。</li></ol><h3 id="12-代码输出结果-1"><a href="#12-代码输出结果-1" class="headerlink" title="12. 代码输出结果"></a>12. 代码输出结果</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = <span class="hljs-number">10</span>; <br><span class="hljs-keyword">var</span> obt = &#123; <br>  <span class="hljs-attr">a</span>: <span class="hljs-number">20</span>, <br>  <span class="hljs-attr">fn</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123; <br>    <span class="hljs-keyword">var</span> a = <span class="hljs-number">30</span>; <br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span>)<br>  &#125; <br>&#125;<br>obt.<span class="hljs-title function_">fn</span>();  <span class="hljs-comment">// 20</span><br>obt.<span class="hljs-property">fn</span>.<span class="hljs-title function_">call</span>(); <span class="hljs-comment">// 10</span><br>(obt.<span class="hljs-property">fn</span>)(); <span class="hljs-comment">// 20</span><br></code></pre></td></tr></table></figure><p>输出结果： 20  10  20 </p><p><strong>解析：</strong></p><ol><li> obt.fn()，fn是由obt调用的，所以其this指向obt对象，会打印出20；</li><li> obt.fn.call()，这里call的参数啥都没写，就表示null，我们知道如果call的参数为undefined或null，那么this就会指向全局对象this，所以会打印出 10；</li><li> (obt.fn)()， 这里给表达式加了括号，而括号的作用是改变表达式的运算顺序，而在这里加与不加括号并无影响；相当于  obt.fn()，所以会打印出 20；</li></ol><h3 id="13-代码输出结果-1"><a href="#13-代码输出结果-1" class="headerlink" title="13. 代码输出结果"></a>13. 代码输出结果</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">a</span>(<span class="hljs-params">xx</span>)&#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">x</span> = xx;<br>  <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span><br>&#125;;<br><span class="hljs-keyword">var</span> x = <span class="hljs-title function_">a</span>(<span class="hljs-number">5</span>);<br><span class="hljs-keyword">var</span> y = <span class="hljs-title function_">a</span>(<span class="hljs-number">6</span>);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x.<span class="hljs-property">x</span>)  <span class="hljs-comment">// undefined</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(y.<span class="hljs-property">x</span>)  <span class="hljs-comment">// 6</span><br></code></pre></td></tr></table></figure><p>输出结果： undefined  6</p><p><strong>解析：</strong></p><ol><li>最关键的就是var x &#x3D; a(5)，函数a是在全局作用域调用，所以函数内部的this指向window对象。<strong>所以 this.x &#x3D; 5 就相当于：window.x &#x3D; 5。</strong>之后 return this，也就是说 var x &#x3D; a(5) 中的x变量的值是window，这里的x将函数内部的x的值覆盖了。然后执行console.log(x.x)， 也就是console.log(window.x)，而window对象中没有x属性，所以会输出undefined。</li><li>当指向y.x时，会给全局变量中的x赋值为6，所以会打印出6。</li></ol><h3 id="14-代码输出结果-1"><a href="#14-代码输出结果-1" class="headerlink" title="14. 代码输出结果"></a>14. 代码输出结果</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">something</span>)&#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span> = something<br>&#125;<br><br><span class="hljs-keyword">var</span> obj1 = &#123;<br>    <span class="hljs-attr">foo</span>: foo<br>&#125;<br><br><span class="hljs-keyword">var</span> obj2 = &#123;&#125;<br><br>obj1.<span class="hljs-title function_">foo</span>(<span class="hljs-number">2</span>); <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj1.<span class="hljs-property">a</span>); <span class="hljs-comment">// 2</span><br><br>obj1.<span class="hljs-property">foo</span>.<span class="hljs-title function_">call</span>(obj2, <span class="hljs-number">3</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj2.<span class="hljs-property">a</span>); <span class="hljs-comment">// 3</span><br><br><span class="hljs-keyword">var</span> bar = <span class="hljs-keyword">new</span> obj1.<span class="hljs-title function_">foo</span>(<span class="hljs-number">4</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj1.<span class="hljs-property">a</span>); <span class="hljs-comment">// 2</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(bar.<span class="hljs-property">a</span>); <span class="hljs-comment">// 4</span><br></code></pre></td></tr></table></figure><p>输出结果： 2  3  2  4</p><p><strong>解析：</strong></p><ol><li>首先执行obj1.foo(2); 会在obj中添加a属性，其值为2。之后执行obj1.a，a是右obj1调用的，所以this指向obj，打印出2；</li><li>执行 obj1.foo.call(obj2, 3) 时，会将foo的this指向obj2，后面就和上面一样了，所以会打印出3；</li><li>obj1.a会打印出2；</li><li>最后就是考察this绑定的优先级了，new 绑定是比隐式绑定优先级高，所以会输出4。</li></ol><h3 id="15-代码输出结果-1"><a href="#15-代码输出结果-1" class="headerlink" title="15. 代码输出结果"></a>15. 代码输出结果</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">something</span>)&#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span> = something<br>&#125;<br><br><span class="hljs-keyword">var</span> obj1 = &#123;&#125;<br><br><span class="hljs-keyword">var</span> bar = foo.<span class="hljs-title function_">bind</span>(obj1);<br><span class="hljs-title function_">bar</span>(<span class="hljs-number">2</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj1.<span class="hljs-property">a</span>); <span class="hljs-comment">// 2</span><br><br><span class="hljs-keyword">var</span> baz = <span class="hljs-keyword">new</span> <span class="hljs-title function_">bar</span>(<span class="hljs-number">3</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj1.<span class="hljs-property">a</span>); <span class="hljs-comment">// 2</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(baz.<span class="hljs-property">a</span>); <span class="hljs-comment">// 3</span><br></code></pre></td></tr></table></figure><p>输出结果： 2  2  3</p><p>这道题目和上面题目差不多，主要都是考察this绑定的优先级。记住以下结论即可：<strong>this绑定的优先级：new绑定 &gt; 显式绑定 &gt; 隐式绑定 &gt; 默认绑定。</strong></p><h2 id="三、作用域-amp-变量提升-amp-闭包"><a href="#三、作用域-amp-变量提升-amp-闭包" class="headerlink" title="三、作用域&amp;变量提升&amp;闭包"></a>三、作用域&amp;变量提升&amp;闭包</h2><h3 id="1-代码输出结果-2"><a href="#1-代码输出结果-2" class="headerlink" title="1. 代码输出结果"></a>1. 代码输出结果</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript">(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>   <span class="hljs-keyword">var</span> x = y = <span class="hljs-number">1</span>;<br>&#125;)();<br><span class="hljs-keyword">var</span> z;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(y); <span class="hljs-comment">// 1</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(z); <span class="hljs-comment">// undefined</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x); <span class="hljs-comment">// Uncaught ReferenceError: x is not defined</span><br></code></pre></td></tr></table></figure><p>这段代码的关键在于：var x &#x3D; y &#x3D; 1; 实际上这里是从右往左执行的，首先执行y &#x3D; 1, 因为y没有使用var声明，所以它是一个全局变量，然后第二步是将y赋值给x，讲一个全局变量赋值给了一个局部变量，最终，x是一个局部变量，y是一个全局变量，所以打印x是报错。</p><h3 id="2-代码输出结果-2"><a href="#2-代码输出结果-2" class="headerlink" title="2. 代码输出结果"></a>2. 代码输出结果</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a, b<br>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>   <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a);<br>   <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(b);<br>   <span class="hljs-keyword">var</span> a = (b = <span class="hljs-number">3</span>);<br>   <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a);<br>   <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(b);   <br>&#125;)()<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(b);<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-literal">undefined</span> <br><span class="hljs-literal">undefined</span> <br><span class="hljs-number">3</span> <br><span class="hljs-number">3</span> <br><span class="hljs-literal">undefined</span> <br><span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p>这个题目和上面题目考察的知识点类似，b赋值为3，b此时是一个全局变量，而将3赋值给a，a是一个局部变量，所以最后打印的时候，a仍旧是undefined。</p><h3 id="3-代码输出结果-2"><a href="#3-代码输出结果-2" class="headerlink" title="3. 代码输出结果"></a>3. 代码输出结果</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> friendName = <span class="hljs-string">&#x27;World&#x27;</span>;<br>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> friendName === <span class="hljs-string">&#x27;undefined&#x27;</span>) &#123;<br>    <span class="hljs-keyword">var</span> friendName = <span class="hljs-string">&#x27;Jack&#x27;</span>;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Goodbye &#x27;</span> + friendName);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Hello &#x27;</span> + friendName);<br>  &#125;<br>&#125;)();<br></code></pre></td></tr></table></figure><p>输出结果：Goodbye Jack</p><p>我们知道，在 JavaScript中， Function 和 var 都会被提升（变量提升），所以上面的代码就相当于：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> name = <span class="hljs-string">&#x27;World!&#x27;</span>;<br>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">var</span> name;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> name === <span class="hljs-string">&#x27;undefined&#x27;</span>) &#123;<br>        name = <span class="hljs-string">&#x27;Jack&#x27;</span>;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Goodbye &#x27;</span> + name);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Hello &#x27;</span> + name);<br>    &#125;<br>&#125;)();<br></code></pre></td></tr></table></figure><p>这样，答案就一目了然了。</p><h3 id="4-代码输出结果-2"><a href="#4-代码输出结果-2" class="headerlink" title="4. 代码输出结果"></a>4. 代码输出结果</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn1</span>(<span class="hljs-params"></span>)&#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;fn1&#x27;</span>)<br>&#125;<br><span class="hljs-keyword">var</span> fn2<br> <br><span class="hljs-title function_">fn1</span>()<br><span class="hljs-title function_">fn2</span>()<br> <br>fn2 = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;fn2&#x27;</span>)<br>&#125;<br> <br><span class="hljs-title function_">fn2</span>()<br></code></pre></td></tr></table></figure><p>输出结果： </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript">fn1<br><span class="hljs-title class_">Uncaught</span> <span class="hljs-title class_">TypeError</span>: fn2 is not a <span class="hljs-keyword">function</span><br>fn2<br></code></pre></td></tr></table></figure><p>这里也是在考察变量提升，关键在于第一个fn2()，这时fn2仍是一个undefined的变量，所以会报错fn2不是一个函数。</p><h3 id="5-代码输出结果-1"><a href="#5-代码输出结果-1" class="headerlink" title="5. 代码输出结果"></a>5. 代码输出结果</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">a</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">var</span> temp = <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">b</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(temp); <span class="hljs-comment">// 10</span><br>    &#125;<br>    <span class="hljs-title function_">b</span>();<br>&#125;<br><span class="hljs-title function_">a</span>();<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">a</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">var</span> temp = <span class="hljs-number">10</span>;<br>    <span class="hljs-title function_">b</span>();<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">b</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(temp); <span class="hljs-comment">// 报错 Uncaught ReferenceError: temp is not defined</span><br>&#125;<br><span class="hljs-title function_">a</span>();<br></code></pre></td></tr></table></figure><p>在上面的两段代码中，第一段是可以正常输出，这个应该没啥问题，关键在于第二段代码，它会报错Uncaught ReferenceError: temp is not defined。这时因为在b方法执行时，temp 的值为undefined。</p><h3 id="6-代码输出结果-2"><a href="#6-代码输出结果-2" class="headerlink" title="6. 代码输出结果"></a>6. 代码输出结果</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a=<span class="hljs-number">3</span>;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">c</span>(<span class="hljs-params"></span>)&#123;<br>   <span class="hljs-title function_">alert</span>(a);<br>&#125;<br>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br> <span class="hljs-keyword">var</span> a=<span class="hljs-number">4</span>;<br> <span class="hljs-title function_">c</span>();<br>&#125;)();<br></code></pre></td></tr></table></figure><p>js中变量的作用域链与定义时的环境有关，与执行时无关。执行环境只会改变this、传递的参数、全局变量等</p><h3 id="7-代码输出问题"><a href="#7-代码输出问题" class="headerlink" title="7.  代码输出问题"></a>7.  代码输出问题</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fun</span>(<span class="hljs-params">n, o</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(o)<br>  <span class="hljs-keyword">return</span> &#123;<br>    <span class="hljs-attr">fun</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">m</span>)&#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-title function_">fun</span>(m, n);<br>    &#125;<br>  &#125;;<br>&#125;<br><span class="hljs-keyword">var</span> a = <span class="hljs-title function_">fun</span>(<span class="hljs-number">0</span>);  a.<span class="hljs-title function_">fun</span>(<span class="hljs-number">1</span>);  a.<span class="hljs-title function_">fun</span>(<span class="hljs-number">2</span>);  a.<span class="hljs-title function_">fun</span>(<span class="hljs-number">3</span>);<br><span class="hljs-keyword">var</span> b = <span class="hljs-title function_">fun</span>(<span class="hljs-number">0</span>).<span class="hljs-title function_">fun</span>(<span class="hljs-number">1</span>).<span class="hljs-title function_">fun</span>(<span class="hljs-number">2</span>).<span class="hljs-title function_">fun</span>(<span class="hljs-number">3</span>);<br><span class="hljs-keyword">var</span> c = <span class="hljs-title function_">fun</span>(<span class="hljs-number">0</span>).<span class="hljs-title function_">fun</span>(<span class="hljs-number">1</span>);  c.<span class="hljs-title function_">fun</span>(<span class="hljs-number">2</span>);  c.<span class="hljs-title function_">fun</span>(<span class="hljs-number">3</span>);<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-literal">undefined</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span><br><span class="hljs-literal">undefined</span>  <span class="hljs-number">0</span>  <span class="hljs-number">1</span>  <span class="hljs-number">2</span><br><span class="hljs-literal">undefined</span>  <span class="hljs-number">0</span>  <span class="hljs-number">1</span>  <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>这是一道关于闭包的题目，对于fun方法，调用之后返回的是一个对象。我们知道，当调用函数的时候传入的实参比函数声明时指定的形参个数要少，剩下的形参都将设置为undefined值。所以 <code>console.log(o);</code> 会输出undefined。而a就是是fun(0)返回的那个对象。也就是说，函数fun中参数 n 的值是0，而返回的那个对象中，需要一个参数n，而这个对象的作用域中没有n，它就继续沿着作用域向上一级的作用域中寻找n，最后在函数fun中找到了n，n的值是0。了解了这一点，其他运算就很简单了，以此类推。</p><h3 id="8-代码输出结果-1"><a href="#8-代码输出结果-1" class="headerlink" title="8. 代码输出结果"></a>8. 代码输出结果</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript">f = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;;   <br>g = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;;   <br>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;   <br>   <span class="hljs-keyword">if</span> (<span class="hljs-title function_">g</span>() &amp;&amp; [] == ![]) &#123;   <br>      f = <span class="hljs-keyword">function</span> <span class="hljs-title function_">f</span>(<span class="hljs-params"></span>) &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;;   <br>      <span class="hljs-keyword">function</span> <span class="hljs-title function_">g</span>(<span class="hljs-params"></span>) &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;   <br>   &#125;   <br>&#125;)();   <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">f</span>());<br></code></pre></td></tr></table></figure><p>输出结果： false</p><p>这里首先定义了两个变量f和g，我们知道变量是可以重新赋值的。后面是一个匿名自执行函数，在 if 条件中调用了函数 g()，由于在匿名函数中，又重新定义了函数g，就覆盖了外部定义的变量g，所以，这里调用的是内部函数 g 方法，返回为 true。第一个条件通过，进入第二个条件。</p><p>第二个条件是[] &#x3D;&#x3D; ![]，先看 ![] ，在 JavaScript 中，当用于布尔运算时，比如在这里，对象的非空引用被视为 true，空引用 null 则被视为 false。由于这里不是一个 null, 而是一个没有元素的数组，所以 [] 被视为 true, 而 ![] 的结果就是 false 了。当一个布尔值参与到条件运算的时候，true 会被看作 1, 而 false 会被看作 0。现在条件变成了 [] &#x3D;&#x3D; 0 的问题了，当一个对象参与条件比较的时候，它会被求值，求值的结果是数组成为一个字符串，[] 的结果就是 ‘’ ，而 ‘’ 会被当作 0 ，所以，条件成立。</p><p>两个条件都成立，所以会执行条件中的代码， f 在定义是没有使用var，所以他是一个全局变量。因此，这里会通过闭包访问到外部的变量 f, 重新赋值，现在执行 f 函数返回值已经成为 false 了。而 g 则不会有这个问题，这里是一个函数内定义的 g，不会影响到外部的 g 函数。所以最后的结果就是 false。</p><h2 id="四、原型-amp-继承"><a href="#四、原型-amp-继承" class="headerlink" title="四、原型&amp;继承"></a>四、原型&amp;继承</h2><h3 id="1-代码输出结果-3"><a href="#1-代码输出结果-3" class="headerlink" title="1. 代码输出结果"></a>1. 代码输出结果</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name<br>&#125;<br><span class="hljs-keyword">var</span> p2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&#x27;king&#x27;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p2.<span class="hljs-property">__proto__</span>) <span class="hljs-comment">//Person.prototype</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p2.<span class="hljs-property">__proto__</span>.<span class="hljs-property">__proto__</span>) <span class="hljs-comment">//Object.prototype</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p2.<span class="hljs-property">__proto__</span>.<span class="hljs-property">__proto__</span>.<span class="hljs-property">__proto__</span>) <span class="hljs-comment">// null</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p2.<span class="hljs-property">__proto__</span>.<span class="hljs-property">__proto__</span>.<span class="hljs-property">__proto__</span>.<span class="hljs-property">__proto__</span>)<span class="hljs-comment">//null后面没有了，报错</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p2.<span class="hljs-property">__proto__</span>.<span class="hljs-property">__proto__</span>.<span class="hljs-property">__proto__</span>.<span class="hljs-property">__proto__</span>.<span class="hljs-property">__proto__</span>)<span class="hljs-comment">//null后面没有了，报错</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p2.<span class="hljs-property">constructor</span>)<span class="hljs-comment">//Person</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p2.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>)<span class="hljs-comment">//undefined p2是实例，没有prototype属性</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Person</span>.<span class="hljs-property">constructor</span>)<span class="hljs-comment">//Function 一个空函数</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>)<span class="hljs-comment">//打印出Person.prototype这个对象里所有的方法和属性</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constructor</span>)<span class="hljs-comment">//Person</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">__proto__</span>)<span class="hljs-comment">// Object.prototype</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Person</span>.<span class="hljs-property">__proto__</span>) <span class="hljs-comment">//Function.prototype</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">__proto__</span>)<span class="hljs-comment">//Object.prototype</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Function</span>.<span class="hljs-property">__proto__</span>)<span class="hljs-comment">//Function.prototype</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-property">__proto__</span>)<span class="hljs-comment">//Function.prototype</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">__proto__</span>)<span class="hljs-comment">//null</span><br></code></pre></td></tr></table></figure><p>这道义题目考察原型、原型链的基础，记住就可以了。</p><h3 id="2-代码输出结果-3"><a href="#2-代码输出结果-3" class="headerlink" title="2. 代码输出结果"></a>2. 代码输出结果</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// a</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Foo</span> () &#123;<br> getName = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>   <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">1</span>);<br> &#125;<br> <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>;<br>&#125;<br><span class="hljs-comment">// b</span><br><span class="hljs-title class_">Foo</span>.<span class="hljs-property">getName</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">2</span>);<br>&#125;<br><span class="hljs-comment">// c</span><br><span class="hljs-title class_">Foo</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">getName</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">3</span>);<br>&#125;<br><span class="hljs-comment">// d</span><br><span class="hljs-keyword">var</span> getName = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">4</span>);<br>&#125;<br><span class="hljs-comment">// e</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">getName</span> () &#123;<br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">5</span>);<br>&#125;<br><br><span class="hljs-title class_">Foo</span>.<span class="hljs-title function_">getName</span>();           <span class="hljs-comment">// 2</span><br><span class="hljs-title function_">getName</span>();               <span class="hljs-comment">// 4</span><br><span class="hljs-title class_">Foo</span>().<span class="hljs-title function_">getName</span>();         <span class="hljs-comment">// 1</span><br><span class="hljs-title function_">getName</span>();               <span class="hljs-comment">// 1 </span><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Foo</span>.<span class="hljs-title function_">getName</span>();       <span class="hljs-comment">// 2</span><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Foo</span>().<span class="hljs-title function_">getName</span>();     <span class="hljs-comment">// 3</span><br><span class="hljs-keyword">new</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Foo</span>().<span class="hljs-title function_">getName</span>(); <span class="hljs-comment">// 3</span><br></code></pre></td></tr></table></figure><p>输出结果：2  4  1  1  2  3  3</p><p><strong>解析：</strong></p><ol><li><strong>Foo.getName()，</strong> Foo为一个函数对象，对象都可以有属性，b 处定义Foo的getName属性为函数，输出2；</li><li><strong>getName()，</strong> 这里看d、e处，d为函数表达式，e为函数声明，两者区别在于变量提升，函数声明的 5 会被后边函数表达式的 4 覆盖；</li><li>** Foo().getName()，** 这里要看a处，在Foo内部将全局的getName重新赋值为 console.log(1) 的函数，执行Foo()返回 this，这个this指向window，Foo().getName() 即为window.getName()，输出 1；</li><li><strong>getName()，</strong> 上面3中，全局的getName已经被重新赋值，所以这里依然输出 1；</li><li><strong>new Foo.getName()，</strong> 这里等价于 new (Foo.getName())，先执行 Foo.getName()，输出 2，然后new一个实例；</li><li><strong>new Foo().getName()，</strong> 这 里等价于 (new Foo()).getName(), 先new一个Foo的实例，再执行这个实例的getName方法，但是这个实例本身没有这个方法，所以去原型链__protot__上边找，实例.<strong>protot</strong> &#x3D;&#x3D;&#x3D; Foo.prototype，所以输出 3；</li><li><strong>new new Foo().getName()，</strong> 这里等价于new (new Foo().getName())，如上述6，先输出 3，然后new 一个 new Foo().getName() 的实例。</li></ol><h3 id="3-代码输出结果-3"><a href="#3-代码输出结果-3" class="headerlink" title="3. 代码输出结果"></a>3. 代码输出结果</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> F = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;&#125;;<br><span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">a</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;a&#x27;</span>);<br>&#125;;<br><span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">b</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;b&#x27;</span>);<br>&#125;<br><span class="hljs-keyword">var</span> f = <span class="hljs-keyword">new</span> <span class="hljs-title function_">F</span>();<br>f.<span class="hljs-title function_">a</span>();<br>f.<span class="hljs-title function_">b</span>();<br>F.<span class="hljs-title function_">a</span>();<br>F.<span class="hljs-title function_">b</span>()<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript">a<br><span class="hljs-title class_">Uncaught</span> <span class="hljs-title class_">TypeError</span>: f.<span class="hljs-property">b</span> is not a <span class="hljs-keyword">function</span><br>a<br>b<br></code></pre></td></tr></table></figure><p><strong>解析：</strong></p><ol><li>f 并不是 Function 的实例，因为它本来就不是构造函数，调用的是 Function 原型链上的相关属性和方法，只能访问到 Object 原型链。所以 f.a() 输出 a  ，而 f.b() 就报错了。</li><li>F 是个构造函数，而 F 是构造函数 Function 的一个实例。因为 F instanceof  Object &#x3D;&#x3D;&#x3D; true，F instanceof Function &#x3D;&#x3D;&#x3D; true，由此可以得出结论：F 是 Object 和 Function 两个的实例，即 F 能访问到 a， 也能访问到 b。所以 F.a() 输出 a ，F.b() 输出 b。</li></ol><h3 id="4-代码输出结果-3"><a href="#4-代码输出结果-3" class="headerlink" title="4. 代码输出结果"></a>4. 代码输出结果</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Foo</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-title class_">Foo</span>.<span class="hljs-property">a</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">2</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-title class_">Foo</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">a</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">3</span>);<br>&#125;<br><br><span class="hljs-title class_">Foo</span>.<span class="hljs-property">a</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">4</span>);<br>&#125;<br><br><span class="hljs-title class_">Foo</span>.<span class="hljs-title function_">a</span>();<br><span class="hljs-keyword">let</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Foo</span>();<br>obj.<span class="hljs-title function_">a</span>();<br><span class="hljs-title class_">Foo</span>.<span class="hljs-title function_">a</span>();<br></code></pre></td></tr></table></figure><p>输出结果：4 2 1</p><p><strong>解析：</strong></p><ol><li>Foo.a() 这个是调用 Foo 函数的静态方法 a，虽然 Foo 中有优先级更高的属性方法 a，但 Foo 此时没有被调用，所以此时输出 Foo 的静态方法 a 的结果：4</li><li>let obj &#x3D; new Foo(); 使用了 new 方法调用了函数，返回了函数实例对象，此时 Foo 函数内部的属性方法初始化，原型链建立。</li><li>obj.a() ; 调用 obj 实例上的方法 a，该实例上目前有两个 a 方法：一个是内部属性方法，另一个是原型上的方法。当这两者都存在时，首先查找 ownProperty ，如果没有才去原型链上找，所以调用实例上的 a 输出：2</li><li>Foo.a() ; 根据第2步可知 Foo 函数内部的属性方法已初始化，覆盖了同名的静态方法，所以输出：1</li></ol><h3 id="5-代码输出结果-2"><a href="#5-代码输出结果-2" class="headerlink" title="5. 代码输出结果"></a>5. 代码输出结果</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Dog</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;puppy&#x27;</span><br>&#125;<br><span class="hljs-title class_">Dog</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">bark</span> = <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;woof!woof!&#x27;</span>)<br>&#125;<br><span class="hljs-keyword">const</span> dog = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>()<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Dog</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constructor</span> === <span class="hljs-title class_">Dog</span> &amp;&amp; dog.<span class="hljs-property">constructor</span> === <span class="hljs-title class_">Dog</span> &amp;&amp; dog <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Dog</span>)<br></code></pre></td></tr></table></figure><p>输出结果：true</p><p><strong>解析：</strong><br>因为constructor是prototype上的属性，所以dog.constructor实际上就是指向Dog.prototype.constructor；constructor属性指向构造函数。instanceof而实际检测的是类型是否在实例的原型链上。</p><p>constructor是prototype上的属性，这一点很容易被忽略掉。constructor和instanceof 的作用是不同的，感性地来说，constructor的限制比较严格，它只能严格对比对象的构造函数是不是指定的值；而instanceof比较松散，只要检测的类型在原型链上，就会返回true。</p><h3 id="6-代码输出结果-3"><a href="#6-代码输出结果-3" class="headerlink" title="6. 代码输出结果"></a>6. 代码输出结果</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> A = &#123;<span class="hljs-attr">n</span>: <span class="hljs-number">4399</span>&#125;;<br><span class="hljs-keyword">var</span> B =  <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<span class="hljs-variable language_">this</span>.<span class="hljs-property">n</span> = <span class="hljs-number">9999</span>&#125;;<br><span class="hljs-keyword">var</span> C =  <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<span class="hljs-keyword">var</span> n = <span class="hljs-number">8888</span>&#125;;<br>B.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = A;<br>C.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = A;<br><span class="hljs-keyword">var</span> b = <span class="hljs-keyword">new</span> <span class="hljs-title function_">B</span>();<br><span class="hljs-keyword">var</span> c = <span class="hljs-keyword">new</span> <span class="hljs-title function_">C</span>();<br>A.<span class="hljs-property">n</span>++<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(b.<span class="hljs-property">n</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(c.<span class="hljs-property">n</span>);<br></code></pre></td></tr></table></figure><p>输出结果：9999  4400</p><p><strong>解析：</strong></p><ol><li>console.log(b.n)，在查找b.n是首先查找 b 对象自身有没有 n 属性，如果没有会去原型（prototype）上查找，当执行var b &#x3D; new B()时，函数内部this.n&#x3D;9999(此时this指向 b) 返回b对象，b对象有自身的n属性，所以返回 9999。</li><li>console.log(c.n)，同理，当执行var c &#x3D; new C()时，c对象没有自身的n属性，向上查找，找到原型 （prototype）上的 n 属性，因为 A.n++(此时对象A中的n为4400)， 所以返回4400。</li></ol><h3 id="7-代码输出问题-1"><a href="#7-代码输出问题-1" class="headerlink" title="7. 代码输出问题"></a>7. 代码输出问题</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">A</span>(<span class="hljs-params"></span>)&#123;<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">B</span>(<span class="hljs-params">a</span>)&#123;<br>　　<span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span> = a;<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">C</span>(<span class="hljs-params">a</span>)&#123;<br>　　<span class="hljs-keyword">if</span>(a)&#123;<br><span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span> = a;<br>　　&#125;<br>&#125;<br>A.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">a</span> = <span class="hljs-number">1</span>;<br>B.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">a</span> = <span class="hljs-number">1</span>;<br>C.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">a</span> = <span class="hljs-number">1</span>;<br> <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">new</span> <span class="hljs-title function_">A</span>().<span class="hljs-property">a</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">new</span> <span class="hljs-title function_">B</span>().<span class="hljs-property">a</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">new</span> <span class="hljs-title function_">C</span>(<span class="hljs-number">2</span>).<span class="hljs-property">a</span>);<br></code></pre></td></tr></table></figure><p>输出结果：1  undefined  2</p><p><strong>解析：</strong></p><ol><li>console.log(new A().a)，new A()为构造函数创建的对象，本身没有a属性，所以向它的原型去找，发现原型的a属性的属性值为1，故该输出值为1；</li><li>console.log(new B().a)，ew B()为构造函数创建的对象，该构造函数有参数a，但该对象没有传参，故该输出值为undefined;</li><li>console.log(new C(2).a)，new C()为构造函数创建的对象，该构造函数有参数a，且传的实参为2，执行函数内部，发现if为真，执行this.a &#x3D; 2,故属性a的值为2。</li></ol><h3 id="8-代码输出问题-1"><a href="#8-代码输出问题-1" class="headerlink" title="8 代码输出问题"></a>8 代码输出问题</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Parent</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span> = <span class="hljs-number">1</span>;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">b</span> = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span>];<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">c</span> = &#123; <span class="hljs-attr">demo</span>: <span class="hljs-number">5</span> &#125;;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">show</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span> , <span class="hljs-variable language_">this</span>.<span class="hljs-property">b</span> , <span class="hljs-variable language_">this</span>.<span class="hljs-property">c</span>.<span class="hljs-property">demo</span> );<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Child</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span> = <span class="hljs-number">2</span>;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">change</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">b</span>.<span class="hljs-title function_">push</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span>);<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">b</span>.<span class="hljs-property">length</span>;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">c</span>.<span class="hljs-property">demo</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span>++;<br>    &#125;<br>&#125;<br><br><span class="hljs-title class_">Child</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Parent</span>();<br><span class="hljs-keyword">var</span> parent = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Parent</span>();<br><span class="hljs-keyword">var</span> child1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Child</span>();<br><span class="hljs-keyword">var</span> child2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Child</span>();<br>child1.<span class="hljs-property">a</span> = <span class="hljs-number">11</span>;<br>child2.<span class="hljs-property">a</span> = <span class="hljs-number">12</span>;<br>parent.<span class="hljs-title function_">show</span>();<br>child1.<span class="hljs-title function_">show</span>();<br>child2.<span class="hljs-title function_">show</span>();<br>child1.<span class="hljs-title function_">change</span>();<br>child2.<span class="hljs-title function_">change</span>();<br>parent.<span class="hljs-title function_">show</span>();<br>child1.<span class="hljs-title function_">show</span>();<br>child2.<span class="hljs-title function_">show</span>();<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript">parent.<span class="hljs-title function_">show</span>(); <span class="hljs-comment">// 1  [1,2,1] 5</span><br><br>child1.<span class="hljs-title function_">show</span>(); <span class="hljs-comment">// 11 [1,2,1] 5</span><br>child2.<span class="hljs-title function_">show</span>(); <span class="hljs-comment">// 12 [1,2,1] 5</span><br><br>parent.<span class="hljs-title function_">show</span>(); <span class="hljs-comment">// 1 [1,2,1] 5</span><br><br>child1.<span class="hljs-title function_">show</span>(); <span class="hljs-comment">// 5 [1,2,1,11,12] 5</span><br><br>child2.<span class="hljs-title function_">show</span>(); <span class="hljs-comment">// 6 [1,2,1,11,12] 5</span><br></code></pre></td></tr></table></figure><p>这道题目值得神帝，他涉及到的知识点很多，例如<strong>this的指向、原型、原型链、类的继承、数据类型</strong>等。</p><p><strong>解析：</strong></p><ol><li>parent.show()，可以直接获得所需的值，没啥好说的；</li><li>child1.show()，<code>Child</code>的构造函数原本是指向<code>Child</code>的，题目显式将<code>Child</code>类的原型对象指向了<code>Parent</code>类的一个实例，需要注意<code>Child.prototype</code>指向的是<code>Parent</code>的实例<code>parent</code>，而不是指向<code>Parent</code>这个类。</li><li>child2.show()，这个也没啥好说的；</li><li>parent.show()，<code>parent</code>是一个<code>Parent</code>类的实例，<code>Child.prorotype</code>指向的是<code>Parent</code>类的另一个实例，两者在堆内存中互不影响，所以上述操作不影响<code>parent</code>实例，所以输出结果不变；</li><li>child1.show()，<code>child1</code>执行了<code>change()</code>方法后，发生了怎样的变化呢?</li></ol><ul><li><strong>this.b.push(this.a)，</strong>由于this的动态指向特性，this.b会指向<code>Child.prototype</code>上的<strong>b</strong>数组,this.a会指向<code>child1</code>的<strong>a</strong>属性,所以<code>Child.prototype.b</code>变成了**[1,2,1,11]**;</li><li><strong>this.a &#x3D; this.b.length，</strong>这条语句中<code>this.a</code>和<code>this.b</code>的指向与上一句一致，故结果为<code>child1.a</code>变为<strong>4</strong>;</li><li><strong>this.c.demo &#x3D; this.a++，</strong>由于<code>child1</code>自身属性并没有<strong>c</strong>这个属性，所以此处的<code>this.c</code>会指向<code>Child.prototype.c</code>，<code>this.a</code>值为<strong>4</strong>，为原始类型，故赋值操作时会直接赋值，<code>Child.prototype.c.demo</code>的结果为<strong>4</strong>，而<code>this.a</code>随后自增为<strong>5(4 + 1 &#x3D; 5)。</strong></li></ul><ol start="6"><li><code>child2</code>执行了<code>change()</code>方法, 而<code>child2</code>和<code>child1</code>均是<code>Child</code>类的实例，所以他们的原型链指向同一个原型对象<code>Child.prototype</code>,也就是同一个<code>parent</code>实例，所以<code>child2.change()</code>中所有影响到原型对象的语句都会影响<code>child1</code>的最终输出结果。</li></ol><ul><li><strong>this.b.push(this.a)，</strong>由于this的动态指向特性，this.b会指向<code>Child.prototype</code>上的<strong>b</strong>数组,this.a会指向<code>child2</code>的<strong>a</strong>属性,所以<code>Child.prototype.b</code>变成了**[1,2,1,11,12]**;</li><li><strong>this.a &#x3D; this.b.length，</strong>这条语句中<code>this.a</code>和<code>this.b</code>的指向与上一句一致，故结果为<code>child2.a</code>变为<strong>5</strong>;</li><li><strong>this.c.demo &#x3D; this.a++，</strong>由于<code>child2</code>自身属性并没有<strong>c</strong>这个属性，所以此处的<code>this.c</code>会指向<code>Child.prototype.c</code>，故执行结果为<code>Child.prototype.c.demo</code>的值变为<code>child2.a</code>的值<strong>5</strong>，而<code>child2.a</code>最终自增为<strong>6(5 + 1 &#x3D; 6)。</strong></li></ul><h3 id="9-代码输出结果-2"><a href="#9-代码输出结果-2" class="headerlink" title="9. 代码输出结果"></a>9. 代码输出结果</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">SuperType</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">property</span> = <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-title class_">SuperType</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">getSuperValue</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">property</span>;<br>&#125;;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">SubType</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">subproperty</span> = <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-title class_">SubType</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SuperType</span>();<br><span class="hljs-title class_">SubType</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">getSubValue</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">subproperty</span>;<br>&#125;;<br><br><span class="hljs-keyword">var</span> instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SubType</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(instance.<span class="hljs-title function_">getSuperValue</span>());<br></code></pre></td></tr></table></figure><p>输出结果：true</p><p>实际上，这段代码就是在实现原型链继承，SubType继承了SuperType，本质是重写了SubType的原型对象，代之以一个新类型的实例。SubType的原型被重写了，所以instance.constructor指向的是SuperType。具体如下：<br><img src="1.png" alt="img"></p>]]></content>
    
    
    <categories>
      
      <category>BGW</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>BGW-手撕</title>
    <link href="/2023/04/18/BGW-%E6%89%8B%E6%92%95/"/>
    <url>/2023/04/18/BGW-%E6%89%8B%E6%92%95/</url>
    
    <content type="html"><![CDATA[<p>BGW-手撕</p><p> <img src="1.png" alt="img"></p><h2 id="一、JavaScript-基础"><a href="#一、JavaScript-基础" class="headerlink" title="一、JavaScript 基础"></a>一、JavaScript 基础</h2><h3 id="1-手写-Object-create"><a href="#1-手写-Object-create" class="headerlink" title="1. 手写 Object.create"></a>1. 手写 Object.create</h3><p>思路：将传入的对象作为原型</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">create</span>(<span class="hljs-params">obj</span>) &#123;<br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">F</span>(<span class="hljs-params"></span>) &#123;&#125;<br>  F.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = obj<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title function_">F</span>()<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-手写-instanceof-方法"><a href="#2-手写-instanceof-方法" class="headerlink" title="2. 手写 instanceof 方法"></a>2. 手写 instanceof 方法</h3><p>instanceof 运算符用于判断构造函数的 prototype 属性是否出现在对象的原型链中的任何位置。</p><p>实现步骤：</p><ol><li>首先获取类型的原型</li><li>然后获得对象的原型</li><li>然后一直循环判断对象的原型是否等于类型的原型，直到对象原型为 <code>null</code>，因为原型链最终为 <code>null</code></li></ol><p>具体实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">myInstanceof</span>(<span class="hljs-params">left, right</span>) &#123;<br>  <span class="hljs-keyword">let</span> proto = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getPrototypeOf</span>(left), <span class="hljs-comment">// 获取对象的原型</span><br>      prototype = right.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>; <span class="hljs-comment">// 获取构造函数的 prototype 对象</span><br><br>  <span class="hljs-comment">// 判断构造函数的 prototype 对象是否在对象的原型链上</span><br>  <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>    <span class="hljs-keyword">if</span> (!proto) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">if</span> (proto === prototype) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><br>    proto = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getPrototypeOf</span>(proto);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-手写-new-操作符"><a href="#3-手写-new-操作符" class="headerlink" title="3. 手写 new 操作符"></a>3. 手写 new 操作符</h3><p>在调用 <code>new</code> 的过程中会发生以上四件事情：</p><p>（1）首先创建了一个新的空对象</p><p>（2）设置原型，将对象的原型设置为函数的 prototype 对象。</p><p>（3）让函数的 this 指向这个对象，执行构造函数的代码（为这个新对象添加属性）</p><p>（4）判断函数的返回值类型，如果是值类型，返回创建的对象。如果是引用类型，就返回这个引用类型的对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">objectFactory</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">let</span> newObject = <span class="hljs-literal">null</span>;<br>  <span class="hljs-keyword">let</span> constructor = <span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">shift</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">arguments</span>);<br>  <span class="hljs-keyword">let</span> result = <span class="hljs-literal">null</span>;<br>  <span class="hljs-comment">// 判断参数是否是一个函数</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> constructor !== <span class="hljs-string">&quot;function&quot;</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&quot;type error&quot;</span>);<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>  <span class="hljs-comment">// 新建一个空对象，对象的原型为构造函数的 prototype 对象</span><br>  newObject = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(constructor.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>);<br>  <span class="hljs-comment">// 将 this 指向新建对象，并执行函数</span><br>  result = constructor.<span class="hljs-title function_">apply</span>(newObject, <span class="hljs-variable language_">arguments</span>);<br>  <span class="hljs-comment">// 判断返回对象</span><br>  <span class="hljs-keyword">let</span> flag = result &amp;&amp; (<span class="hljs-keyword">typeof</span> result === <span class="hljs-string">&quot;object&quot;</span> || <span class="hljs-keyword">typeof</span> result === <span class="hljs-string">&quot;function&quot;</span>);<br>  <span class="hljs-comment">// 判断返回结果</span><br>  <span class="hljs-keyword">return</span> flag ? result : newObject;<br>&#125;<br><span class="hljs-comment">// 使用方法</span><br><span class="hljs-title function_">objectFactory</span>(构造函数, 初始化参数);<br></code></pre></td></tr></table></figure><h3 id="4-手写-Promise"><a href="#4-手写-Promise" class="headerlink" title="4. 手写 Promise"></a>4. 手写 Promise</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">PENDING</span> = <span class="hljs-string">&quot;pending&quot;</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">RESOLVED</span> = <span class="hljs-string">&quot;resolved&quot;</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">REJECTED</span> = <span class="hljs-string">&quot;rejected&quot;</span>;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">MyPromise</span>(<span class="hljs-params">fn</span>) &#123;<br>  <span class="hljs-comment">// 保存初始化状态</span><br>  <span class="hljs-keyword">var</span> self = <span class="hljs-variable language_">this</span>;<br><br>  <span class="hljs-comment">// 初始化状态</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = <span class="hljs-variable constant_">PENDING</span>;<br><br>  <span class="hljs-comment">// 用于保存 resolve 或者 rejected 传入的值</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span> = <span class="hljs-literal">null</span>;<br><br>  <span class="hljs-comment">// 用于保存 resolve 的回调函数</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">resolvedCallbacks</span> = [];<br><br>  <span class="hljs-comment">// 用于保存 reject 的回调函数</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">rejectedCallbacks</span> = [];<br><br>  <span class="hljs-comment">// 状态转变为 resolved 方法</span><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">resolve</span>(<span class="hljs-params">value</span>) &#123;<br>    <span class="hljs-comment">// 判断传入元素是否为 Promise 值，如果是，则状态改变必须等待前一个状态改变后再进行改变</span><br>    <span class="hljs-keyword">if</span> (value <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">MyPromise</span>) &#123;<br>      <span class="hljs-keyword">return</span> value.<span class="hljs-title function_">then</span>(resolve, reject);<br>    &#125;<br><br>    <span class="hljs-comment">// 保证代码的执行顺序为本轮事件循环的末尾</span><br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-comment">// 只有状态为 pending 时才能转变，</span><br>      <span class="hljs-keyword">if</span> (self.<span class="hljs-property">state</span> === <span class="hljs-variable constant_">PENDING</span>) &#123;<br>        <span class="hljs-comment">// 修改状态</span><br>        self.<span class="hljs-property">state</span> = <span class="hljs-variable constant_">RESOLVED</span>;<br><br>        <span class="hljs-comment">// 设置传入的值</span><br>        self.<span class="hljs-property">value</span> = value;<br><br>        <span class="hljs-comment">// 执行回调函数</span><br>        self.<span class="hljs-property">resolvedCallbacks</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">callback</span> =&gt;</span> &#123;<br>          <span class="hljs-title function_">callback</span>(value);<br>        &#125;);<br>      &#125;<br>    &#125;, <span class="hljs-number">0</span>);<br>  &#125;<br><br>  <span class="hljs-comment">// 状态转变为 rejected 方法</span><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">reject</span>(<span class="hljs-params">value</span>) &#123;<br>    <span class="hljs-comment">// 保证代码的执行顺序为本轮事件循环的末尾</span><br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-comment">// 只有状态为 pending 时才能转变</span><br>      <span class="hljs-keyword">if</span> (self.<span class="hljs-property">state</span> === <span class="hljs-variable constant_">PENDING</span>) &#123;<br>        <span class="hljs-comment">// 修改状态</span><br>        self.<span class="hljs-property">state</span> = <span class="hljs-variable constant_">REJECTED</span>;<br><br>        <span class="hljs-comment">// 设置传入的值</span><br>        self.<span class="hljs-property">value</span> = value;<br><br>        <span class="hljs-comment">// 执行回调函数</span><br>        self.<span class="hljs-property">rejectedCallbacks</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">callback</span> =&gt;</span> &#123;<br>          <span class="hljs-title function_">callback</span>(value);<br>        &#125;);<br>      &#125;<br>    &#125;, <span class="hljs-number">0</span>);<br>  &#125;<br><br>  <span class="hljs-comment">// 将两个方法传入函数执行</span><br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-title function_">fn</span>(resolve, reject);<br>  &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>    <span class="hljs-comment">// 遇到错误时，捕获错误，执行 reject 函数</span><br>    <span class="hljs-title function_">reject</span>(e);<br>  &#125;<br>&#125;<br><br><span class="hljs-title class_">MyPromise</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">then</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">onResolved, onRejected</span>) &#123;<br>  <span class="hljs-comment">// 首先判断两个参数是否为函数类型，因为这两个参数是可选参数</span><br>  onResolved =<br>    <span class="hljs-keyword">typeof</span> onResolved === <span class="hljs-string">&quot;function&quot;</span><br>      ? onResolved<br>      : <span class="hljs-keyword">function</span>(<span class="hljs-params">value</span>) &#123;<br>          <span class="hljs-keyword">return</span> value;<br>        &#125;;<br><br>  onRejected =<br>    <span class="hljs-keyword">typeof</span> onRejected === <span class="hljs-string">&quot;function&quot;</span><br>      ? onRejected<br>      : <span class="hljs-keyword">function</span>(<span class="hljs-params">error</span>) &#123;<br>          <span class="hljs-keyword">throw</span> error;<br>        &#125;;<br><br>  <span class="hljs-comment">// 如果是等待状态，则将函数加入对应列表中</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> === <span class="hljs-variable constant_">PENDING</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">resolvedCallbacks</span>.<span class="hljs-title function_">push</span>(onResolved);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">rejectedCallbacks</span>.<span class="hljs-title function_">push</span>(onRejected);<br>  &#125;<br><br>  <span class="hljs-comment">// 如果状态已经凝固，则直接执行对应状态的函数</span><br><br>  <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> === <span class="hljs-variable constant_">RESOLVED</span>) &#123;<br>    <span class="hljs-title function_">onResolved</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>);<br>  &#125;<br><br>  <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> === <span class="hljs-variable constant_">REJECTED</span>) &#123;<br>    <span class="hljs-title function_">onRejected</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>);<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="5-手写-Promise-then"><a href="#5-手写-Promise-then" class="headerlink" title="5. 手写 Promise.then"></a>5. 手写 Promise.then</h3><p><code>then</code> 方法返回一个新的 <code>promise</code> 实例，为了在 <code>promise</code> 状态发生变化时（<code>resolve</code> &#x2F; <code>reject</code> 被调用时）再执行 <code>then</code> 里的函数，我们使用一个 <code>callbacks</code> 数组先把传给then的函数暂存起来，等状态改变时再调用。</p><p>**那么，怎么保证后一个 <strong><code>**then**</code></strong> 里的方法在前一个 **<code>**then**</code><strong>（可能是异步）结束之后再执行呢？</strong><br>我们可以将传给 <code>then</code> 的函数和新 <code>promise</code> 的 <code>resolve</code> 一起 <code>push</code> 到前一个 <code>promise</code> 的 <code>callbacks</code> 数组中，达到承前启后的效果：</p><ul><li>承前：当前一个 <code>promise</code> 完成后，调用其 <code>resolve</code> 变更状态，在这个 <code>resolve</code> 里会依次调用 <code>callbacks</code> 里的回调，这样就执行了 <code>then</code> 里的方法了</li><li>启后：上一步中，当 <code>then</code> 里的方法执行完成后，返回一个结果，如果这个结果是个简单的值，就直接调用新 <code>promise</code> 的 <code>resolve</code>，让其状态变更，这又会依次调用新 <code>promise</code> 的 <code>callbacks</code> 数组里的方法，循环往复。。如果返回的结果是个 <code>promise</code>，则需要等它完成之后再触发新 <code>promise</code> 的 <code>resolve</code>，所以可以在其结果的 <code>then</code> 里调用新 <code>promise</code> 的 <code>resolve</code></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">then</span>(<span class="hljs-params">onFulfilled, onReject</span>)&#123;<br>    <span class="hljs-comment">// 保存前一个promise的this</span><br>    <span class="hljs-keyword">const</span> self = <span class="hljs-variable language_">this</span>; <br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyPromise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>      <span class="hljs-comment">// 封装前一个promise成功时执行的函数</span><br>      <span class="hljs-keyword">let</span> <span class="hljs-title function_">fulfilled</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>        <span class="hljs-keyword">try</span>&#123;<br>          <span class="hljs-keyword">const</span> result = <span class="hljs-title function_">onFulfilled</span>(self.<span class="hljs-property">value</span>); <span class="hljs-comment">// 承前</span><br>          <span class="hljs-keyword">return</span> result <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">MyPromise</span>? result.<span class="hljs-title function_">then</span>(resolve, reject) : <span class="hljs-title function_">resolve</span>(result); <span class="hljs-comment">//启后</span><br>        &#125;<span class="hljs-keyword">catch</span>(err)&#123;<br>          <span class="hljs-title function_">reject</span>(err)<br>        &#125;<br>      &#125;<br>      <span class="hljs-comment">// 封装前一个promise失败时执行的函数</span><br>      <span class="hljs-keyword">let</span> <span class="hljs-title function_">rejected</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>        <span class="hljs-keyword">try</span>&#123;<br>          <span class="hljs-keyword">const</span> result = <span class="hljs-title function_">onReject</span>(self.<span class="hljs-property">reason</span>);<br>          <span class="hljs-keyword">return</span> result <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">MyPromise</span>? result.<span class="hljs-title function_">then</span>(resolve, reject) : <span class="hljs-title function_">reject</span>(result);<br>        &#125;<span class="hljs-keyword">catch</span>(err)&#123;<br>          <span class="hljs-title function_">reject</span>(err)<br>        &#125;<br>      &#125;<br>      <span class="hljs-keyword">switch</span>(self.<span class="hljs-property">status</span>)&#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-attr">PENDING</span>: <br>          self.<span class="hljs-property">onFulfilledCallbacks</span>.<span class="hljs-title function_">push</span>(fulfilled);<br>          self.<span class="hljs-property">onRejectedCallbacks</span>.<span class="hljs-title function_">push</span>(rejected);<br>          <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-attr">FULFILLED</span>:<br>          <span class="hljs-title function_">fulfilled</span>();<br>          <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-attr">REJECT</span>:<br>          <span class="hljs-title function_">rejected</span>();<br>          <span class="hljs-keyword">break</span>;<br>      &#125;<br>    &#125;)<br>   &#125;<br></code></pre></td></tr></table></figure><p><strong>注意：</strong></p><ul><li>连续多个 <code>then</code> 里的回调方法是同步注册的，但注册到了不同的 <code>callbacks</code> 数组中，因为每次 <code>then</code> 都返回新的 <code>promise</code> 实例（参考上面的例子和图）</li><li>注册完成后开始执行构造函数中的异步事件，异步完成之后依次调用 <code>callbacks</code> 数组中提前注册的回调</li></ul><h3 id="6-手写-Promise-all"><a href="#6-手写-Promise-all" class="headerlink" title="6. 手写 Promise.all"></a>6. 手写 Promise.all</h3><p><strong>1) 核心思路</strong></p><ol><li>接收一个 Promise 实例的数组或具有 Iterator 接口的对象作为参数</li><li>这个方法返回一个新的 promise 对象，</li><li>遍历传入的参数，用Promise.resolve()将参数”包一层”，使其变成一个promise对象</li><li>参数所有回调成功才是成功，返回值数组与参数顺序一致</li><li>参数数组其中一个失败，则触发失败状态，第一个触发失败的 Promise 错误信息作为 Promise.all 的错误信息。</li></ol><p><strong>2）实现代码</strong></p><p>一般来说，Promise.all 用来处理多个并发请求，也是为了页面数据构造的方便，将一个页面所用到的在不同接口的数据一起请求过来，不过，如果其中一个接口失败了，多个请求也就失败了，页面可能啥也出不来，这就看当前页面的耦合程度了</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">promiseAll</span>(<span class="hljs-params">promises</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">resolve, reject</span>) &#123;<br>    <span class="hljs-keyword">if</span>(!<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(promises))&#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeError</span>(<span class="hljs-string">`argument must be a array`</span>)<br>    &#125;<br>    <span class="hljs-keyword">var</span> resolvedCounter = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">var</span> promiseNum = promises.<span class="hljs-property">length</span>;<br>    <span class="hljs-keyword">var</span> resolvedResult = [];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; promiseNum; i++) &#123;<br>      <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(promises[i]).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">value</span>=&gt;</span>&#123;<br>        resolvedCounter++;<br>        resolvedResult[i] = value;<br>        <span class="hljs-keyword">if</span> (resolvedCounter == promiseNum) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-title function_">resolve</span>(resolvedResult)<br>          &#125;<br>      &#125;,<span class="hljs-function"><span class="hljs-params">error</span>=&gt;</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-title function_">reject</span>(error)<br>      &#125;)<br>    &#125;<br>  &#125;)<br>&#125;<br><span class="hljs-comment">// test</span><br><span class="hljs-keyword">let</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">resolve, reject</span>) &#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-title function_">resolve</span>(<span class="hljs-number">1</span>)<br>    &#125;, <span class="hljs-number">1000</span>)<br>&#125;)<br><span class="hljs-keyword">let</span> p2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">resolve, reject</span>) &#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-title function_">resolve</span>(<span class="hljs-number">2</span>)<br>    &#125;, <span class="hljs-number">2000</span>)<br>&#125;)<br><span class="hljs-keyword">let</span> p3 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">resolve, reject</span>) &#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-title function_">resolve</span>(<span class="hljs-number">3</span>)<br>    &#125;, <span class="hljs-number">3000</span>)<br>&#125;)<br><span class="hljs-title function_">promiseAll</span>([p3, p1, p2]).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res) <span class="hljs-comment">// [3, 1, 2]</span><br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="7-手写-Promise-race"><a href="#7-手写-Promise-race" class="headerlink" title="7. 手写 Promise.race"></a>7. 手写 Promise.race</h3><p>该方法的参数是 Promise 实例数组, 然后其 then 注册的回调方法是数组中的某一个 Promise 的状态变为 fulfilled 的时候就执行. 因为 Promise 的状态<strong>只能改变一次</strong>, 那么我们只需要把 Promise.race 中产生的 Promise 对象的 resolve 方法, 注入到数组中的每一个 Promise 实例中的回调函数中即可.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Promise</span>.<span class="hljs-property">race</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">args</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>, len = args.<span class="hljs-property">length</span>; i &lt; len; i++) &#123;<br>      args[i].<span class="hljs-title function_">then</span>(resolve, reject)<br>    &#125;<br>  &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="8-手写防抖函数"><a href="#8-手写防抖函数" class="headerlink" title="8. 手写防抖函数"></a>8. 手写防抖函数</h3><p>函数防抖是指在事件被触发 n 秒后再执行回调，如果在这 n 秒内事件又被触发，则重新计时。这可以使用在一些点击请求的事件上，避免因为用户的多次点击向后端发送多次请求。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 函数防抖的实现</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">debounce</span>(<span class="hljs-params">fn, wait</span>) &#123;<br>  <span class="hljs-keyword">let</span> timer = <span class="hljs-literal">null</span>;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">let</span> context = <span class="hljs-variable language_">this</span>,<br>        args = <span class="hljs-variable language_">arguments</span>;<br><br>    <span class="hljs-comment">// 如果此时存在定时器的话，则取消之前的定时器重新记时</span><br>    <span class="hljs-keyword">if</span> (timer) &#123;<br>      <span class="hljs-built_in">clearTimeout</span>(timer);<br>      timer = <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 设置定时器，使事件间隔指定事件后执行</span><br>    timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      fn.<span class="hljs-title function_">apply</span>(context, args);<br>    &#125;, wait);<br>  &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="9-手写节流函数"><a href="#9-手写节流函数" class="headerlink" title="9. 手写节流函数"></a>9. 手写节流函数</h3><p>函数节流是指规定一个单位时间，在这个单位时间内，只能有一次触发事件的回调函数执行，如果在同一个单位时间内某事件被触发多次，只有一次能生效。节流可以使用在 scroll 函数的事件监听上，通过事件节流来降低事件调用的频率。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 函数节流的实现;</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">throttle</span>(<span class="hljs-params">fn, delay</span>) &#123;<br>  <span class="hljs-keyword">let</span> curTime = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>();<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">let</span> context = <span class="hljs-variable language_">this</span>,<br>        args = <span class="hljs-variable language_">arguments</span>,<br>        nowTime = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>();<br><br>    <span class="hljs-comment">// 如果两次时间间隔超过了指定时间，则执行函数。</span><br>    <span class="hljs-keyword">if</span> (nowTime - curTime &gt;= delay) &#123;<br>      curTime = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>();<br>      <span class="hljs-keyword">return</span> fn.<span class="hljs-title function_">apply</span>(context, args);<br>    &#125;<br>  &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="10-手写类型判断函数"><a href="#10-手写类型判断函数" class="headerlink" title="10. 手写类型判断函数"></a>10. 手写类型判断函数</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">getType</span>(<span class="hljs-params">value</span>) &#123;<br>  <span class="hljs-comment">// 判断数据是 null 的情况</span><br>  <span class="hljs-keyword">if</span> (value === <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-keyword">return</span> value + <span class="hljs-string">&quot;&quot;</span>;<br>  &#125;<br>  <span class="hljs-comment">// 判断数据是引用类型的情况</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> value === <span class="hljs-string">&quot;object&quot;</span>) &#123;<br>    <span class="hljs-keyword">let</span> valueClass = <span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>(value),<br>      type = valueClass.<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot; &quot;</span>)[<span class="hljs-number">1</span>].<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot;&quot;</span>);<br>    type.<span class="hljs-title function_">pop</span>();<br>    <span class="hljs-keyword">return</span> type.<span class="hljs-title function_">join</span>(<span class="hljs-string">&quot;&quot;</span>).<span class="hljs-title function_">toLowerCase</span>();<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// 判断数据是基本数据类型的情况和函数的情况</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> value;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="11-手写-call-函数"><a href="#11-手写-call-函数" class="headerlink" title="11. 手写 call 函数"></a>11. 手写 call 函数</h3><p>call 函数的实现步骤：</p><ol><li>判断调用对象是否为函数，即使我们是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。</li><li>判断传入上下文对象是否存在，如果不存在，则设置为 window 。</li><li>处理传入的参数，截取第一个参数后的所有参数。</li><li>将函数作为上下文对象的一个属性。</li><li>使用上下文对象来调用这个方法，并保存返回结果。</li><li>删除刚才新增的属性。</li><li>返回结果。</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// call函数实现</span><br><span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">myCall</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">context</span>) &#123;<br>  <span class="hljs-comment">// 判断调用对象</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-variable language_">this</span> !== <span class="hljs-string">&quot;function&quot;</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&quot;type error&quot;</span>);<br>  &#125;<br>  <span class="hljs-comment">// 获取参数</span><br>  <span class="hljs-keyword">let</span> args = [...<span class="hljs-variable language_">arguments</span>].<span class="hljs-title function_">slice</span>(<span class="hljs-number">1</span>),<br>      result = <span class="hljs-literal">null</span>;<br>  <span class="hljs-comment">// 判断 context 是否传入，如果未传入则设置为 window</span><br>  context = context || <span class="hljs-variable language_">window</span>;<br>  <span class="hljs-comment">// 将调用函数设为对象的方法</span><br>  context.<span class="hljs-property">fn</span> = <span class="hljs-variable language_">this</span>;<br>  <span class="hljs-comment">// 调用函数</span><br>  result = context.<span class="hljs-title function_">fn</span>(...args);<br>  <span class="hljs-comment">// 将属性删除</span><br>  <span class="hljs-keyword">delete</span> context.<span class="hljs-property">fn</span>;<br>  <span class="hljs-keyword">return</span> result;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="12-手写-apply-函数"><a href="#12-手写-apply-函数" class="headerlink" title="12. 手写 apply 函数"></a>12. 手写 apply 函数</h3><p>apply 函数的实现步骤：</p><ol><li>判断调用对象是否为函数，即使我们是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。</li><li>判断传入上下文对象是否存在，如果不存在，则设置为 window 。</li><li>将函数作为上下文对象的一个属性。</li><li>判断参数值是否传入</li><li>使用上下文对象来调用这个方法，并保存返回结果。</li><li>删除刚才新增的属性</li><li>返回结果</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// apply 函数实现</span><br><span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">myApply</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">context</span>) &#123;<br>  <span class="hljs-comment">// 判断调用对象是否为函数</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-variable language_">this</span> !== <span class="hljs-string">&quot;function&quot;</span>) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeError</span>(<span class="hljs-string">&quot;Error&quot;</span>);<br>  &#125;<br>  <span class="hljs-keyword">let</span> result = <span class="hljs-literal">null</span>;<br>  <span class="hljs-comment">// 判断 context 是否存在，如果未传入则为 window</span><br>  context = context || <span class="hljs-variable language_">window</span>;<br>  <span class="hljs-comment">// 将函数设为对象的方法</span><br>  context.<span class="hljs-property">fn</span> = <span class="hljs-variable language_">this</span>;<br>  <span class="hljs-comment">// 调用方法</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">arguments</span>[<span class="hljs-number">1</span>]) &#123;<br>    result = context.<span class="hljs-title function_">fn</span>(...<span class="hljs-variable language_">arguments</span>[<span class="hljs-number">1</span>]);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    result = context.<span class="hljs-title function_">fn</span>();<br>  &#125;<br>  <span class="hljs-comment">// 将属性删除</span><br>  <span class="hljs-keyword">delete</span> context.<span class="hljs-property">fn</span>;<br>  <span class="hljs-keyword">return</span> result;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="13-手写-bind-函数"><a href="#13-手写-bind-函数" class="headerlink" title="13. 手写 bind 函数"></a>13. 手写 bind 函数</h3><p>bind 函数的实现步骤：</p><ol><li>判断调用对象是否为函数，即使我们是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。</li><li>保存当前函数的引用，获取其余传入参数值。</li><li>创建一个函数返回</li><li>函数内部使用 apply 来绑定函数调用，需要判断函数作为构造函数的情况，这个时候需要传入当前函数的 this 给 apply 调用，其余情况都传入指定的上下文对象。</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// bind 函数实现</span><br><span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">myBind</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">context</span>) &#123;<br>  <span class="hljs-comment">// 判断调用对象是否为函数</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-variable language_">this</span> !== <span class="hljs-string">&quot;function&quot;</span>) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeError</span>(<span class="hljs-string">&quot;Error&quot;</span>);<br>  &#125;<br>  <span class="hljs-comment">// 获取参数</span><br>  <span class="hljs-keyword">var</span> args = [...<span class="hljs-variable language_">arguments</span>].<span class="hljs-title function_">slice</span>(<span class="hljs-number">1</span>),<br>      fn = <span class="hljs-variable language_">this</span>;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Fn</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// 根据调用方式，传入不同绑定值</span><br>    <span class="hljs-keyword">return</span> fn.<span class="hljs-title function_">apply</span>(<br>      <span class="hljs-variable language_">this</span> <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Fn</span> ? <span class="hljs-variable language_">this</span> : context,<br>      args.<span class="hljs-title function_">concat</span>(...<span class="hljs-variable language_">arguments</span>)<br>    );<br>  &#125;;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="14-函数柯里化的实现"><a href="#14-函数柯里化的实现" class="headerlink" title="14. 函数柯里化的实现"></a>14. 函数柯里化的实现</h3><p> 函数柯里化指的是一种将使用多个参数的一个函数转换成一系列使用一个参数的函数的技术。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">curry</span>(<span class="hljs-params">fn, args</span>) &#123;<br>  <span class="hljs-comment">// 获取函数需要的参数长度</span><br>  <span class="hljs-keyword">let</span> length = fn.<span class="hljs-property">length</span>;<br><br>  args = args || [];<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">let</span> subArgs = args.<span class="hljs-title function_">slice</span>(<span class="hljs-number">0</span>);<br><br>    <span class="hljs-comment">// 拼接得到现有的所有参数</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-variable language_">arguments</span>.<span class="hljs-property">length</span>; i++) &#123;<br>      subArgs.<span class="hljs-title function_">push</span>(<span class="hljs-variable language_">arguments</span>[i]);<br>    &#125;<br><br>    <span class="hljs-comment">// 判断参数的长度是否已经满足函数所需参数的长度</span><br>    <span class="hljs-keyword">if</span> (subArgs.<span class="hljs-property">length</span> &gt;= length) &#123;<br>      <span class="hljs-comment">// 如果满足，执行函数</span><br>      <span class="hljs-keyword">return</span> fn.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, subArgs);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// 如果不满足，递归返回科里化的函数，等待参数的传入</span><br>      <span class="hljs-keyword">return</span> curry.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>, fn, subArgs);<br>    &#125;<br>  &#125;;<br>&#125;<br><br><span class="hljs-comment">// es6 实现</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">curry</span>(<span class="hljs-params">fn, ...args</span>) &#123;<br>  <span class="hljs-keyword">return</span> fn.<span class="hljs-property">length</span> &lt;= args.<span class="hljs-property">length</span> ? <span class="hljs-title function_">fn</span>(...args) : curry.<span class="hljs-title function_">bind</span>(<span class="hljs-literal">null</span>, fn, ...args);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="15-实现AJAX请求"><a href="#15-实现AJAX请求" class="headerlink" title="15. 实现AJAX请求"></a>15. 实现AJAX请求</h3><p>AJAX是 Asynchronous JavaScript and XML 的缩写，指的是通过 JavaScript 的 异步通信，从服务器获取 XML 文档从中提取数据，再更新当前网页的对应部分，而不用刷新整个网页。</p><p>创建AJAX请求的步骤：</p><ul><li><strong>创建一个 XMLHttpRequest 对象。</strong></li><li>在这个对象上<strong>使用 open 方法创建一个 HTTP 请求</strong>，open 方法所需要的参数是请求的方法、请求的地址、是否异步和用户的认证信息。</li><li>在发起请求前，可以为这个对象<strong>添加一些信息和监听函数</strong>。比如说可以通过 setRequestHeader 方法来为请求添加头信息。还可以为这个对象添加一个状态监听函数。一个 XMLHttpRequest 对象一共有 5 个状态，当它的状态变化时会触发onreadystatechange 事件，可以通过设置监听函数，来处理请求成功后的结果。当对象的 readyState 变为 4 的时候，代表服务器返回的数据接收完成，这个时候可以通过判断请求的状态，如果状态是 2xx 或者 304 的话则代表返回正常。这个时候就可以通过 response 中的数据来对页面进行更新了。</li><li>当对象的属性和监听函数设置完成后，最后调<strong>用 sent 方法来向服务器发起请求</strong>，可以传入参数作为发送的数据体。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">SERVER_URL</span> = <span class="hljs-string">&quot;/server&quot;</span>;<br><span class="hljs-keyword">let</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>();<br><span class="hljs-comment">// 创建 Http 请求</span><br>xhr.<span class="hljs-title function_">open</span>(<span class="hljs-string">&quot;GET&quot;</span>, <span class="hljs-variable constant_">SERVER_URL</span>, <span class="hljs-literal">true</span>);<br><span class="hljs-comment">// 设置状态监听函数</span><br>xhr.<span class="hljs-property">onreadystatechange</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">readyState</span> !== <span class="hljs-number">4</span>) <span class="hljs-keyword">return</span>;<br>  <span class="hljs-comment">// 当请求成功时</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> === <span class="hljs-number">200</span>) &#123;<br>    <span class="hljs-title function_">handle</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">response</span>);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">statusText</span>);<br>  &#125;<br>&#125;;<br><span class="hljs-comment">// 设置请求失败时的监听函数</span><br>xhr.<span class="hljs-property">onerror</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">statusText</span>);<br>&#125;;<br><span class="hljs-comment">// 设置请求头信息</span><br>xhr.<span class="hljs-property">responseType</span> = <span class="hljs-string">&quot;json&quot;</span>;<br>xhr.<span class="hljs-title function_">setRequestHeader</span>(<span class="hljs-string">&quot;Accept&quot;</span>, <span class="hljs-string">&quot;application/json&quot;</span>);<br><span class="hljs-comment">// 发送 Http 请求</span><br>xhr.<span class="hljs-title function_">send</span>(<span class="hljs-literal">null</span>);<br></code></pre></td></tr></table></figure><h3 id="16-使用Promise封装AJAX请求"><a href="#16-使用Promise封装AJAX请求" class="headerlink" title="16. 使用Promise封装AJAX请求"></a>16. 使用Promise封装AJAX请求</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// promise 封装实现：</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">getJSON</span>(<span class="hljs-params">url</span>) &#123;<br>  <span class="hljs-comment">// 创建一个 promise 对象</span><br>  <span class="hljs-keyword">let</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">resolve, reject</span>) &#123;<br>    <span class="hljs-keyword">let</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>();<br>    <span class="hljs-comment">// 新建一个 http 请求</span><br>    xhr.<span class="hljs-title function_">open</span>(<span class="hljs-string">&quot;GET&quot;</span>, url, <span class="hljs-literal">true</span>);<br>    <span class="hljs-comment">// 设置状态的监听函数</span><br>    xhr.<span class="hljs-property">onreadystatechange</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">readyState</span> !== <span class="hljs-number">4</span>) <span class="hljs-keyword">return</span>;<br>      <span class="hljs-comment">// 当请求成功或失败时，改变 promise 的状态</span><br>      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> === <span class="hljs-number">200</span>) &#123;<br>        <span class="hljs-title function_">resolve</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">response</span>);<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">statusText</span>));<br>      &#125;<br>    &#125;;<br>    <span class="hljs-comment">// 设置错误监听函数</span><br>    xhr.<span class="hljs-property">onerror</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">statusText</span>));<br>    &#125;;<br>    <span class="hljs-comment">// 设置响应的数据类型</span><br>    xhr.<span class="hljs-property">responseType</span> = <span class="hljs-string">&quot;json&quot;</span>;<br>    <span class="hljs-comment">// 设置请求头信息</span><br>    xhr.<span class="hljs-title function_">setRequestHeader</span>(<span class="hljs-string">&quot;Accept&quot;</span>, <span class="hljs-string">&quot;application/json&quot;</span>);<br>    <span class="hljs-comment">// 发送 http 请求</span><br>    xhr.<span class="hljs-title function_">send</span>(<span class="hljs-literal">null</span>);<br>  &#125;);<br>  <span class="hljs-keyword">return</span> promise;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="17-实现浅拷贝"><a href="#17-实现浅拷贝" class="headerlink" title="17. 实现浅拷贝"></a>17. 实现浅拷贝</h3><p>浅拷贝是指，一个新的对象对原始对象的属性值进行精确地拷贝，如果拷贝的是基本数据类型，拷贝的就是基本数据类型的值，如果是引用数据类型，拷贝的就是内存地址。如果其中一个对象的引用内存地址发生改变，另一个对象也会发生变化。</p><h4 id="（1）Object-assign"><a href="#（1）Object-assign" class="headerlink" title="（1）Object.assign()"></a>（1）Object.assign()</h4><p><code>Object.assign()</code>是ES6中对象的拷贝方法，接受的第一个参数是目标对象，其余参数是源对象，用法：<code>Object.assign(target, source_1, ···)</code>，该方法可以实现浅拷贝，也可以实现一维对象的深拷贝。</p><p><strong>注意：</strong></p><ul><li>如果目标对象和源对象有同名属性，或者多个源对象有同名属性，则后面的属性会覆盖前面的属性。</li><li>如果该函数只有一个参数，当参数为对象时，直接返回该对象；当参数不是对象时，会先将参数转为对象然后返回。</li><li>因为<code>null</code> 和 <code>undefined</code> 不能转化为对象，所以第一个参数不能为<code>null</code>或 <code>undefined</code>，会报错。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> target = &#123;<span class="hljs-attr">a</span>: <span class="hljs-number">1</span>&#125;;<br><span class="hljs-keyword">let</span> object2 = &#123;<span class="hljs-attr">b</span>: <span class="hljs-number">2</span>&#125;;<br><span class="hljs-keyword">let</span> object3 = &#123;<span class="hljs-attr">c</span>: <span class="hljs-number">3</span>&#125;;<br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(target,object2,object3);  <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(target);  <span class="hljs-comment">// &#123;a: 1, b: 2, c: 3&#125;</span><br></code></pre></td></tr></table></figure><h4 id="（2）扩展运算符"><a href="#（2）扩展运算符" class="headerlink" title="（2）扩展运算符"></a>（2）扩展运算符</h4><p>使用扩展运算符可以在构造字面量对象的时候，进行属性的拷贝。语法：<code>let cloneObj = &#123; ...obj &#125;;</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> obj1 = &#123;<span class="hljs-attr">a</span>:<span class="hljs-number">1</span>,<span class="hljs-attr">b</span>:&#123;<span class="hljs-attr">c</span>:<span class="hljs-number">1</span>&#125;&#125;<br><span class="hljs-keyword">let</span> obj2 = &#123;...obj1&#125;;<br>obj1.<span class="hljs-property">a</span> = <span class="hljs-number">2</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj1); <span class="hljs-comment">//&#123;a:2,b:&#123;c:1&#125;&#125;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj2); <span class="hljs-comment">//&#123;a:1,b:&#123;c:1&#125;&#125;</span><br>obj1.<span class="hljs-property">b</span>.<span class="hljs-property">c</span> = <span class="hljs-number">2</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj1); <span class="hljs-comment">//&#123;a:2,b:&#123;c:2&#125;&#125;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj2); <span class="hljs-comment">//&#123;a:1,b:&#123;c:2&#125;&#125;</span><br></code></pre></td></tr></table></figure><h4 id="（3）数组方法实现数组浅拷贝"><a href="#（3）数组方法实现数组浅拷贝" class="headerlink" title="（3）数组方法实现数组浅拷贝"></a>（3）数组方法实现数组浅拷贝</h4><h6 id="1）Array-prototype-slice"><a href="#1）Array-prototype-slice" class="headerlink" title="1）Array.prototype.slice"></a><strong>1）Array.prototype.slice</strong></h6><ul><li><code>slice()</code>方法是JavaScript数组的一个方法，这个方法可以从已有数组中返回选定的元素：用法：<code>array.slice(start, end)</code>，该方法不会改变原始数组。</li><li>该方法有两个参数，两个参数都可选，如果两个参数都不写，就可以实现一个数组的浅拷贝。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>];<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr.<span class="hljs-title function_">slice</span>()); <span class="hljs-comment">// [1,2,3,4]</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr.<span class="hljs-title function_">slice</span>() === arr); <span class="hljs-comment">//false</span><br></code></pre></td></tr></table></figure><h6 id="2）Array-prototype-concat"><a href="#2）Array-prototype-concat" class="headerlink" title="2）Array.prototype.concat"></a><strong>2）Array.prototype.concat</strong></h6><ul><li><code>concat()</code> 方法用于合并两个或多个数组。此方法不会更改现有数组，而是返回一个新数组。</li><li>该方法有两个参数，两个参数都可选，如果两个参数都不写，就可以实现一个数组的浅拷贝。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>];<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr.<span class="hljs-title function_">concat</span>()); <span class="hljs-comment">// [1,2,3,4]</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr.<span class="hljs-title function_">concat</span>() === arr); <span class="hljs-comment">//false</span><br></code></pre></td></tr></table></figure><h4 id="（4）手写实现浅拷贝"><a href="#（4）手写实现浅拷贝" class="headerlink" title="（4）手写实现浅拷贝"></a>（4）手写实现浅拷贝</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 浅拷贝的实现;</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">shallowCopy</span>(<span class="hljs-params">object</span>) &#123;<br>  <span class="hljs-comment">// 只拷贝对象</span><br>  <span class="hljs-keyword">if</span> (!object || <span class="hljs-keyword">typeof</span> object !== <span class="hljs-string">&quot;object&quot;</span>) <span class="hljs-keyword">return</span>;<br><br>  <span class="hljs-comment">// 根据 object 的类型判断是新建一个数组还是对象</span><br>  <span class="hljs-keyword">let</span> newObject = <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(object) ? [] : &#123;&#125;;<br><br>  <span class="hljs-comment">// 遍历 object，并且判断是 object 的属性才拷贝</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> object) &#123;<br>    <span class="hljs-keyword">if</span> (object.<span class="hljs-title function_">hasOwnProperty</span>(key)) &#123;<br>      newObject[key] = object[key];<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> newObject;<br>&#125;<span class="hljs-comment">// 浅拷贝的实现;</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">shallowCopy</span>(<span class="hljs-params">object</span>) &#123;<br>  <span class="hljs-comment">// 只拷贝对象</span><br>  <span class="hljs-keyword">if</span> (!object || <span class="hljs-keyword">typeof</span> object !== <span class="hljs-string">&quot;object&quot;</span>) <span class="hljs-keyword">return</span>;<br><br>  <span class="hljs-comment">// 根据 object 的类型判断是新建一个数组还是对象</span><br>  <span class="hljs-keyword">let</span> newObject = <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(object) ? [] : &#123;&#125;;<br><br>  <span class="hljs-comment">// 遍历 object，并且判断是 object 的属性才拷贝</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> object) &#123;<br>    <span class="hljs-keyword">if</span> (object.<span class="hljs-title function_">hasOwnProperty</span>(key)) &#123;<br>      newObject[key] = object[key];<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> newObject;<br>&#125;<span class="hljs-comment">// 浅拷贝的实现;</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">shallowCopy</span>(<span class="hljs-params">object</span>) &#123;<br>  <span class="hljs-comment">// 只拷贝对象</span><br>  <span class="hljs-keyword">if</span> (!object || <span class="hljs-keyword">typeof</span> object !== <span class="hljs-string">&quot;object&quot;</span>) <span class="hljs-keyword">return</span>;<br>  <span class="hljs-comment">// 根据 object 的类型判断是新建一个数组还是对象</span><br>  <span class="hljs-keyword">let</span> newObject = <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(object) ? [] : &#123;&#125;;<br>  <span class="hljs-comment">// 遍历 object，并且判断是 object 的属性才拷贝</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> object) &#123;<br>    <span class="hljs-keyword">if</span> (object.<span class="hljs-title function_">hasOwnProperty</span>(key)) &#123;<br>      newObject[key] = object[key];<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> newObject;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="18-实现深拷贝"><a href="#18-实现深拷贝" class="headerlink" title="18. 实现深拷贝"></a>18. 实现深拷贝</h3><ul><li><strong>浅拷贝：</strong> 浅拷贝指的是将一个对象的属性值复制到另一个对象，如果有的属性的值为引用类型的话，那么会将这个引用的地址复制给对象，因此两个对象会有同一个引用类型的引用。浅拷贝可以使用  Object.assign 和展开运算符来实现。</li><li><strong>深拷贝：</strong> 深拷贝相对浅拷贝而言，如果遇到属性值为引用类型的时候，它新建一个引用类型并将对应的值复制给它，因此对象获得的一个新的引用类型而不是一个原有类型的引用。深拷贝对于一些对象可以使用 JSON 的两个函数来实现，但是由于 JSON 的对象格式比 js 的对象格式更加严格，所以如果属性值里边出现函数或者 Symbol 类型的值时，会转换失败</li></ul><h4 id="（1）JSON-stringify"><a href="#（1）JSON-stringify" class="headerlink" title="（1）JSON.stringify()"></a>（1）JSON.stringify()</h4><ul><li><code>JSON.parse(JSON.stringify(obj))</code>是目前比较常用的深拷贝方法之一，它的原理就是利用<code>JSON.stringify</code> 将<code>js</code>对象序列化（JSON字符串），再使用<code>JSON.parse</code>来反序列化(还原)<code>js</code>对象。</li><li>这个方法可以简单粗暴的实现深拷贝，但是还存在问题，拷贝的对象中如果有函数，undefined，symbol，当使用过<code>JSON.stringify()</code>进行处理之后，都会消失。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> obj1 = &#123;  <span class="hljs-attr">a</span>: <span class="hljs-number">0</span>,<br>              <span class="hljs-attr">b</span>: &#123;<br>                 <span class="hljs-attr">c</span>: <span class="hljs-number">0</span><br>                 &#125;<br>            &#125;;<br><span class="hljs-keyword">let</span> obj2 = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(obj1));<br>obj1.<span class="hljs-property">a</span> = <span class="hljs-number">1</span>;<br>obj1.<span class="hljs-property">b</span>.<span class="hljs-property">c</span> = <span class="hljs-number">1</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj1); <span class="hljs-comment">// &#123;a: 1, b: &#123;c: 1&#125;&#125;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj2); <span class="hljs-comment">// &#123;a: 0, b: &#123;c: 0&#125;&#125;</span><br></code></pre></td></tr></table></figure><h4 id="（2）函数库lodash的-cloneDeep方法"><a href="#（2）函数库lodash的-cloneDeep方法" class="headerlink" title="（2）函数库lodash的_.cloneDeep方法"></a>（2）函数库lodash的_.cloneDeep方法</h4><p>该函数库也有提供_.cloneDeep用来做 Deep Copy</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> _ = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;lodash&#x27;</span>);<br><span class="hljs-keyword">var</span> obj1 = &#123;<br>    <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>,<br>    <span class="hljs-attr">b</span>: &#123; <span class="hljs-attr">f</span>: &#123; <span class="hljs-attr">g</span>: <span class="hljs-number">1</span> &#125; &#125;,<br>    <span class="hljs-attr">c</span>: [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br>&#125;;<br><span class="hljs-keyword">var</span> obj2 = _.<span class="hljs-title function_">cloneDeep</span>(obj1);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj1.<span class="hljs-property">b</span>.<span class="hljs-property">f</span> === obj2.<span class="hljs-property">b</span>.<span class="hljs-property">f</span>);<span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><h4 id="（3）手写实现深拷贝函数"><a href="#（3）手写实现深拷贝函数" class="headerlink" title="（3）手写实现深拷贝函数"></a>（3）手写实现深拷贝函数</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 深拷贝的实现</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">deepCopy</span>(<span class="hljs-params">object</span>) &#123;<br>  <span class="hljs-keyword">if</span> (!object || <span class="hljs-keyword">typeof</span> object !== <span class="hljs-string">&quot;object&quot;</span>) <span class="hljs-keyword">return</span>;<br><br>  <span class="hljs-keyword">let</span> newObject = <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(object) ? [] : &#123;&#125;;<br><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> object) &#123;<br>    <span class="hljs-keyword">if</span> (object.<span class="hljs-title function_">hasOwnProperty</span>(key)) &#123;<br>      newObject[key] =<br>        <span class="hljs-keyword">typeof</span> object[key] === <span class="hljs-string">&quot;object&quot;</span> ? <span class="hljs-title function_">deepCopy</span>(object[key]) : object[key];<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> newObject;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="二、数据处理"><a href="#二、数据处理" class="headerlink" title="二、数据处理"></a>二、数据处理</h2><h3 id="1-实现日期格式化函数"><a href="#1-实现日期格式化函数" class="headerlink" title="1. 实现日期格式化函数"></a>1. 实现日期格式化函数</h3><p>输入：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">dateFormat</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(<span class="hljs-string">&#x27;2020-12-01&#x27;</span>), <span class="hljs-string">&#x27;yyyy/MM/dd&#x27;</span>) <span class="hljs-comment">// 2020/12/01</span><br><span class="hljs-title function_">dateFormat</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(<span class="hljs-string">&#x27;2020-04-01&#x27;</span>), <span class="hljs-string">&#x27;yyyy/MM/dd&#x27;</span>) <span class="hljs-comment">// 2020/04/01</span><br><span class="hljs-title function_">dateFormat</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(<span class="hljs-string">&#x27;2020-04-01&#x27;</span>), <span class="hljs-string">&#x27;yyyy年MM月dd日&#x27;</span>) <span class="hljs-comment">// 2020年04月01日</span><br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">dateFormat</span> = (<span class="hljs-params">dateInput, format</span>)=&gt;&#123;<br>    <span class="hljs-keyword">var</span> day = dateInput.<span class="hljs-title function_">getDate</span>() <br>    <span class="hljs-keyword">var</span> month = dateInput.<span class="hljs-title function_">getMonth</span>() + <span class="hljs-number">1</span>  <br>    <span class="hljs-keyword">var</span> year = dateInput.<span class="hljs-title function_">getFullYear</span>()   <br>    format = format.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/yyyy/</span>, year)<br>    format = format.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/MM/</span>,month)<br>    format = format.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/dd/</span>,day)<br>    <span class="hljs-keyword">return</span> format<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-交换a-b的值，不能用临时变量"><a href="#2-交换a-b的值，不能用临时变量" class="headerlink" title="2. 交换a,b的值，不能用临时变量"></a>2. 交换a,b的值，不能用临时变量</h3><p>巧妙的利用两个数的和、差：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript">a = a + b<br>b = a - b<br>a = a - b<br></code></pre></td></tr></table></figure><h3 id="3-实现数组的乱序输出"><a href="#3-实现数组的乱序输出" class="headerlink" title="3. 实现数组的乱序输出"></a>3. 实现数组的乱序输出</h3><p>主要的实现思路就是：</p><ul><li>取出数组的第一个元素，随机产生一个索引值，将该第一个元素和这个索引对应的元素进行交换。</li><li>第二次取出数据数组第二个元素，随机产生一个除了索引为1的之外的索引值，并将第二个元素与该索引值对应的元素进行交换</li><li>按照上面的规律执行，直到遍历完成</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>];<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; arr.<span class="hljs-property">length</span>; i++) &#123;<br>  <span class="hljs-keyword">const</span> randomIndex = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">round</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() * (arr.<span class="hljs-property">length</span> - <span class="hljs-number">1</span> - i)) + i;<br>  [arr[i], arr[randomIndex]] = [arr[randomIndex], arr[i]];<br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr)<br></code></pre></td></tr></table></figure><p>还有一方法就是倒序遍历：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>];<br><span class="hljs-keyword">let</span> length = arr.<span class="hljs-property">length</span>,<br>    randomIndex,<br>    temp;<br>  <span class="hljs-keyword">while</span> (length) &#123;<br>    randomIndex = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() * length--);<br>    temp = arr[length];<br>    arr[length] = arr[randomIndex];<br>    arr[randomIndex] = temp;<br>  &#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr)<br></code></pre></td></tr></table></figure><h3 id="4-实现数组元素求和"><a href="#4-实现数组元素求和" class="headerlink" title="4. 实现数组元素求和"></a>4. 实现数组元素求和</h3><ul><li>arr&#x3D;[1,2,3,4,5,6,7,8,9,10]，求和</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>]<br><span class="hljs-keyword">let</span> sum = arr.<span class="hljs-title function_">reduce</span>( <span class="hljs-function">(<span class="hljs-params">total,i</span>) =&gt;</span> total += i,<span class="hljs-number">0</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(sum);<br></code></pre></td></tr></table></figure><ul><li>arr&#x3D;[1,2,3,[[4,5],6],7,8,9]，求和</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> = arr=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,[[<span class="hljs-number">4</span>,<span class="hljs-number">5</span>],<span class="hljs-number">6</span>],<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>]<br><span class="hljs-keyword">let</span> arr= arr.<span class="hljs-title function_">toString</span>().<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27;,&#x27;</span>).<span class="hljs-title function_">reduce</span>( <span class="hljs-function">(<span class="hljs-params">total,i</span>) =&gt;</span> total += <span class="hljs-title class_">Number</span>(i),<span class="hljs-number">0</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr);<br></code></pre></td></tr></table></figure><p>递归实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>] <br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">arr</span>) &#123;<br>    <span class="hljs-keyword">if</span> (arr.<span class="hljs-property">length</span> == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> arr[<span class="hljs-number">0</span>] <br>    <span class="hljs-keyword">return</span> arr[<span class="hljs-number">0</span>] + <span class="hljs-title function_">add</span>(arr.<span class="hljs-title function_">slice</span>(<span class="hljs-number">1</span>)) <br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">add</span>(arr)) <span class="hljs-comment">// 21</span><br></code></pre></td></tr></table></figure><h3 id="5-实现数组的扁平化"><a href="#5-实现数组的扁平化" class="headerlink" title="5. 实现数组的扁平化"></a>5. 实现数组的扁平化</h3><p><strong>（1）递归实现</strong></p><p>普通的递归思路很容易理解，就是通过循环递归的方式，一项一项地去遍历，如果每一项还是一个数组，那么就继续往下遍历，利用递归程序的方法，来实现数组的每一项的连接：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, [<span class="hljs-number">2</span>, [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]]];<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">flatten</span>(<span class="hljs-params">arr</span>) &#123;<br>  <span class="hljs-keyword">let</span> result = [];<br><br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; arr.<span class="hljs-property">length</span>; i++) &#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(arr[i])) &#123;<br>      result = result.<span class="hljs-title function_">concat</span>(<span class="hljs-title function_">flatten</span>(arr[i]));<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      result.<span class="hljs-title function_">push</span>(arr[i]);<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> result;<br>&#125;<br><span class="hljs-title function_">flatten</span>(arr);  <span class="hljs-comment">//  [1, 2, 3, 4，5]</span><br></code></pre></td></tr></table></figure><p><strong>（2）reduce 函数迭代</strong></p><p>从上面普通的递归函数中可以看出，其实就是对数组的每一项进行处理，那么其实也可以用reduce 来实现数组的拼接，从而简化第一种方法的代码，改造后的代码如下所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, [<span class="hljs-number">2</span>, [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>]]];<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">flatten</span>(<span class="hljs-params">arr</span>) &#123;<br>    <span class="hljs-keyword">return</span> arr.<span class="hljs-title function_">reduce</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">prev, next</span>)&#123;<br>        <span class="hljs-keyword">return</span> prev.<span class="hljs-title function_">concat</span>(<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(next) ? <span class="hljs-title function_">flatten</span>(next) : next)<br>    &#125;, [])<br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">flatten</span>(arr));<span class="hljs-comment">//  [1, 2, 3, 4，5]</span><br></code></pre></td></tr></table></figure><p><strong>（3）扩展运算符实现</strong></p><p>这个方法的实现，采用了扩展运算符和 some 的方法，两者共同使用，达到数组扁平化的目的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, [<span class="hljs-number">2</span>, [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>]]];<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">flatten</span>(<span class="hljs-params">arr</span>) &#123;<br>    <span class="hljs-keyword">while</span> (arr.<span class="hljs-title function_">some</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(item))) &#123;<br>        arr = [].<span class="hljs-title function_">concat</span>(...arr);<br>    &#125;<br>    <span class="hljs-keyword">return</span> arr;<br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">flatten</span>(arr)); <span class="hljs-comment">//  [1, 2, 3, 4，5]</span><br></code></pre></td></tr></table></figure><p><strong>（4）split 和 toString</strong></p><p>可以通过 split 和 toString 两个方法来共同实现数组扁平化，由于数组会默认带一个 toString 的方法，所以可以把数组直接转换成逗号分隔的字符串，然后再用 split 方法把字符串重新转换为数组，如下面的代码所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, [<span class="hljs-number">2</span>, [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>]]];<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">flatten</span>(<span class="hljs-params">arr</span>) &#123;<br>    <span class="hljs-keyword">return</span> arr.<span class="hljs-title function_">toString</span>().<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27;,&#x27;</span>);<br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">flatten</span>(arr)); <span class="hljs-comment">//  [1, 2, 3, 4，5]</span><br></code></pre></td></tr></table></figure><p>通过这两个方法可以将多维数组直接转换成逗号连接的字符串，然后再重新分隔成数组。</p><p><strong>（5）ES6 中的 flat</strong></p><p>我们还可以直接调用 ES6 中的 flat 方法来实现数组扁平化。flat 方法的语法：<code>arr.flat([depth])</code></p><p>其中 depth 是 flat 的参数，depth 是可以传递数组的展开深度（默认不填、数值是 1），即展开一层数组。如果层数不确定，参数可以传进 Infinity，代表不论多少层都要展开：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, [<span class="hljs-number">2</span>, [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>]]];<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">flatten</span>(<span class="hljs-params">arr</span>) &#123;<br>  <span class="hljs-keyword">return</span> arr.<span class="hljs-title function_">flat</span>(<span class="hljs-title class_">Infinity</span>);<br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">flatten</span>(arr)); <span class="hljs-comment">//  [1, 2, 3, 4，5]</span><br></code></pre></td></tr></table></figure><p>可以看出，一个嵌套了两层的数组，通过将 flat 方法的参数设置为 Infinity，达到了我们预期的效果。其实同样也可以设置成 2，也能实现这样的效果。在编程过程中，如果数组的嵌套层数不确定，最好直接使用 Infinity，可以达到扁平化。<br><strong>（6）正则和 JSON 方法</strong><br>在第4种方法中已经使用 toString 方法，其中仍然采用了将 JSON.stringify 的方法先转换为字符串，然后通过正则表达式过滤掉字符串中的数组的方括号，最后再利用 JSON.parse 把它转换成数组：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, [<span class="hljs-number">2</span>, [<span class="hljs-number">3</span>, [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>]]], <span class="hljs-number">6</span>];<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">flatten</span>(<span class="hljs-params">arr</span>) &#123;<br>  <span class="hljs-keyword">let</span> str = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(arr);<br>  str = str.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/(\[|\])/g</span>, <span class="hljs-string">&#x27;&#x27;</span>);<br>  str = <span class="hljs-string">&#x27;[&#x27;</span> + str + <span class="hljs-string">&#x27;]&#x27;</span>;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(str); <br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">flatten</span>(arr)); <span class="hljs-comment">//  [1, 2, 3, 4，5]</span><br></code></pre></td></tr></table></figure><h3 id="6-实现数组去重"><a href="#6-实现数组去重" class="headerlink" title="6. 实现数组去重"></a>6. 实现数组去重</h3><p>给定某无序数组，要求去除数组中的重复数字并且返回新的无重复数组。</p><p>ES6方法（使用数据结构集合）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> array = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">9</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">8</span>];<br><br><span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>(array)); <span class="hljs-comment">// [1, 2, 3, 5, 9, 8]</span><br></code></pre></td></tr></table></figure><p>ES5方法：使用map存储不重复的数字</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> array = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">9</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">8</span>];<br><br><span class="hljs-title function_">uniqueArray</span>(array); <span class="hljs-comment">// [1, 2, 3, 5, 9, 8]</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">uniqueArray</span>(<span class="hljs-params">array</span>) &#123;<br>  <span class="hljs-keyword">let</span> map = &#123;&#125;;<br>  <span class="hljs-keyword">let</span> res = [];<br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; array.<span class="hljs-property">length</span>; i++) &#123;<br>    <span class="hljs-keyword">if</span>(!map.<span class="hljs-title function_">hasOwnProperty</span>([array[i]])) &#123;<br>      map[array[i]] = <span class="hljs-number">1</span>;<br>      res.<span class="hljs-title function_">push</span>(array[i]);<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="7-实现数组的flat方法"><a href="#7-实现数组的flat方法" class="headerlink" title="7. 实现数组的flat方法"></a>7. 实现数组的flat方法</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">_flat</span>(<span class="hljs-params">arr, depth</span>) &#123;<br>  <span class="hljs-keyword">if</span>(!<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(arr) || depth &lt;= <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">return</span> arr;<br>  &#125;<br>  <span class="hljs-keyword">return</span> arr.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">prev, cur</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(cur)) &#123;<br>      <span class="hljs-keyword">return</span> prev.<span class="hljs-title function_">concat</span>(<span class="hljs-title function_">_flat</span>(cur, depth - <span class="hljs-number">1</span>))<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">return</span> prev.<span class="hljs-title function_">concat</span>(cur);<br>    &#125;<br>  &#125;, []);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="8-实现数组的push方法"><a href="#8-实现数组的push方法" class="headerlink" title="8. 实现数组的push方法"></a>8. 实现数组的push方法</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr = [];<br><span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">push</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br><span class="hljs-keyword">for</span>( <span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span> ; i &lt; <span class="hljs-variable language_">arguments</span>.<span class="hljs-property">length</span> ; i++)&#123;<br><span class="hljs-variable language_">this</span>[<span class="hljs-variable language_">this</span>.<span class="hljs-property">length</span>] = <span class="hljs-variable language_">arguments</span>[i] ;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">length</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="9-实现数组的filter方法"><a href="#9-实现数组的filter方法" class="headerlink" title="9. 实现数组的filter方法"></a>9. 实现数组的filter方法</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">_filter</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">fn</span>) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> fn !== <span class="hljs-string">&quot;function&quot;</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;参数必须是一个函数&#x27;</span>);<br>    &#125;<br>    <span class="hljs-keyword">const</span> res = [];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>, len = <span class="hljs-variable language_">this</span>.<span class="hljs-property">length</span>; i &lt; len; i++) &#123;<br>        <span class="hljs-title function_">fn</span>(<span class="hljs-variable language_">this</span>[i]) &amp;&amp; res.<span class="hljs-title function_">push</span>(<span class="hljs-variable language_">this</span>[i]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="10-实现数组的map方法"><a href="#10-实现数组的map方法" class="headerlink" title="10. 实现数组的map方法"></a>10. 实现数组的map方法</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">_map</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">fn</span>) &#123;<br>   <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> fn !== <span class="hljs-string">&quot;function&quot;</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;参数必须是一个函数&#x27;</span>);<br>    &#125;<br>    <span class="hljs-keyword">const</span> res = [];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>, len = <span class="hljs-variable language_">this</span>.<span class="hljs-property">length</span>; i &lt; len; i++) &#123;<br>        res.<span class="hljs-title function_">push</span>(<span class="hljs-title function_">fn</span>(<span class="hljs-variable language_">this</span>[i]));<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="11-实现字符串的repeat方法"><a href="#11-实现字符串的repeat方法" class="headerlink" title="11. 实现字符串的repeat方法"></a>11. 实现字符串的repeat方法</h3><p>输入字符串s，以及其重复的次数，输出重复的结果，例如输入abc，2，输出abcabc。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">repeat</span>(<span class="hljs-params">s, n</span>) &#123;<br>    <span class="hljs-keyword">return</span> (<span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(n + <span class="hljs-number">1</span>)).<span class="hljs-title function_">join</span>(s);<br>&#125;<br></code></pre></td></tr></table></figure><p>递归：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">repeat</span>(<span class="hljs-params">s, n</span>) &#123;<br>    <span class="hljs-keyword">return</span> (n &gt; <span class="hljs-number">0</span>) ? s.<span class="hljs-title function_">concat</span>(<span class="hljs-title function_">repeat</span>(s, --n)) : <span class="hljs-string">&quot;&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="12-实现字符串翻转"><a href="#12-实现字符串翻转" class="headerlink" title="12. 实现字符串翻转"></a>12. 实现字符串翻转</h3><p>在字符串的原型链上添加一个方法，实现字符串翻转：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">String</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">_reverse</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">a</span>)&#123;<br>    <span class="hljs-keyword">return</span> a.<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot;&quot;</span>).<span class="hljs-title function_">reverse</span>().<span class="hljs-title function_">join</span>(<span class="hljs-string">&quot;&quot;</span>);<br>&#125;<br><span class="hljs-keyword">var</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>();<br><span class="hljs-keyword">var</span> res = obj.<span class="hljs-property">_reverse</span> (<span class="hljs-string">&#x27;hello&#x27;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res);    <span class="hljs-comment">// olleh</span><br></code></pre></td></tr></table></figure><p>需要注意的是，必须通过实例化对象之后再去调用定义的方法，不然找不到该方法。</p><h3 id="13-将数字每千分位用逗号隔开"><a href="#13-将数字每千分位用逗号隔开" class="headerlink" title="13. 将数字每千分位用逗号隔开"></a>13. 将数字每千分位用逗号隔开</h3><p><strong>数字有小数版本：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> <span class="hljs-title function_">format</span> = n =&gt; &#123;<br>    <span class="hljs-keyword">let</span> num = n.<span class="hljs-title function_">toString</span>() <span class="hljs-comment">// 转成字符串</span><br>    <span class="hljs-keyword">let</span> decimals = <span class="hljs-string">&#x27;&#x27;</span><br>        <span class="hljs-comment">// 判断是否有小数</span><br>    num.<span class="hljs-title function_">indexOf</span>(<span class="hljs-string">&#x27;.&#x27;</span>) &gt; -<span class="hljs-number">1</span> ? decimals = num.<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27;.&#x27;</span>)[<span class="hljs-number">1</span>] : decimals<br>    <span class="hljs-keyword">let</span> len = num.<span class="hljs-property">length</span><br>    <span class="hljs-keyword">if</span> (len &lt;= <span class="hljs-number">3</span>) &#123;<br>        <span class="hljs-keyword">return</span> num<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">let</span> temp = <span class="hljs-string">&#x27;&#x27;</span><br>        <span class="hljs-keyword">let</span> remainder = len % <span class="hljs-number">3</span><br>        decimals ? temp = <span class="hljs-string">&#x27;.&#x27;</span> + decimals : temp<br>        <span class="hljs-keyword">if</span> (remainder &gt; <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 不是3的整数倍</span><br>            <span class="hljs-keyword">return</span> num.<span class="hljs-title function_">slice</span>(<span class="hljs-number">0</span>, remainder) + <span class="hljs-string">&#x27;,&#x27;</span> + num.<span class="hljs-title function_">slice</span>(remainder, len).<span class="hljs-title function_">match</span>(<span class="hljs-regexp">/\d&#123;3&#125;/g</span>).<span class="hljs-title function_">join</span>(<span class="hljs-string">&#x27;,&#x27;</span>) + temp<br>        &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 是3的整数倍</span><br>            <span class="hljs-keyword">return</span> num.<span class="hljs-title function_">slice</span>(<span class="hljs-number">0</span>, len).<span class="hljs-title function_">match</span>(<span class="hljs-regexp">/\d&#123;3&#125;/g</span>).<span class="hljs-title function_">join</span>(<span class="hljs-string">&#x27;,&#x27;</span>) + temp <br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-title function_">format</span>(<span class="hljs-number">12323.33</span>)  <span class="hljs-comment">// &#x27;12,323.33&#x27;</span><br></code></pre></td></tr></table></figure><p><strong>数字无小数版本：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> <span class="hljs-title function_">format</span> = n =&gt; &#123;<br>    <span class="hljs-keyword">let</span> num = n.<span class="hljs-title function_">toString</span>() <br>    <span class="hljs-keyword">let</span> len = num.<span class="hljs-property">length</span><br>    <span class="hljs-keyword">if</span> (len &lt;= <span class="hljs-number">3</span>) &#123;<br>        <span class="hljs-keyword">return</span> num<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">let</span> remainder = len % <span class="hljs-number">3</span><br>        <span class="hljs-keyword">if</span> (remainder &gt; <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 不是3的整数倍</span><br>            <span class="hljs-keyword">return</span> num.<span class="hljs-title function_">slice</span>(<span class="hljs-number">0</span>, remainder) + <span class="hljs-string">&#x27;,&#x27;</span> + num.<span class="hljs-title function_">slice</span>(remainder, len).<span class="hljs-title function_">match</span>(<span class="hljs-regexp">/\d&#123;3&#125;/g</span>).<span class="hljs-title function_">join</span>(<span class="hljs-string">&#x27;,&#x27;</span>) <br>        &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 是3的整数倍</span><br>            <span class="hljs-keyword">return</span> num.<span class="hljs-title function_">slice</span>(<span class="hljs-number">0</span>, len).<span class="hljs-title function_">match</span>(<span class="hljs-regexp">/\d&#123;3&#125;/g</span>).<span class="hljs-title function_">join</span>(<span class="hljs-string">&#x27;,&#x27;</span>) <br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-title function_">format</span>(<span class="hljs-number">1232323</span>)  <span class="hljs-comment">// &#x27;1,232,323&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="14-实现非负大整数相加"><a href="#14-实现非负大整数相加" class="headerlink" title="14. 实现非负大整数相加"></a>14. 实现非负大整数相加</h3><p>JavaScript对数值有范围的限制，限制如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Number</span>.<span class="hljs-property">MAX_VALUE</span> <span class="hljs-comment">// 1.7976931348623157e+308</span><br><span class="hljs-title class_">Number</span>.<span class="hljs-property">MAX_SAFE_INTEGER</span> <span class="hljs-comment">// 9007199254740991</span><br><span class="hljs-title class_">Number</span>.<span class="hljs-property">MIN_VALUE</span> <span class="hljs-comment">// 5e-324</span><br><span class="hljs-title class_">Number</span>.<span class="hljs-property">MIN_SAFE_INTEGER</span> <span class="hljs-comment">// -9007199254740991</span><br></code></pre></td></tr></table></figure><p>如果想要对一个超大的整数(<code>&gt; Number.MAX_SAFE_INTEGER</code>)进行加法运算，但是又想输出一般形式，那么使用 + 是无法达到的，一旦数字超过 <code>Number.MAX_SAFE_INTEGER</code> 数字会被立即转换为科学计数法，并且数字精度相比以前将会有误差。</p><p>实现一个算法进行大数的相加：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">sumBigNumber</span>(<span class="hljs-params">a, b</span>) &#123;<br>  <span class="hljs-keyword">let</span> res = <span class="hljs-string">&#x27;&#x27;</span>;<br>  <span class="hljs-keyword">let</span> temp = <span class="hljs-number">0</span>;<br>  <br>  a = a.<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27;&#x27;</span>);<br>  b = b.<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27;&#x27;</span>);<br>  <br>  <span class="hljs-keyword">while</span> (a.<span class="hljs-property">length</span> || b.<span class="hljs-property">length</span> || temp) &#123;<br>    temp += ~~a.<span class="hljs-title function_">pop</span>() + ~~b.<span class="hljs-title function_">pop</span>();<br>    res = (temp % <span class="hljs-number">10</span>) + res;<br>    temp  = temp &gt; <span class="hljs-number">9</span><br>  &#125;<br>  <span class="hljs-keyword">return</span> res.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/^0+/</span>, <span class="hljs-string">&#x27;&#x27;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>其主要的思路如下：</p><ul><li>首先用字符串的方式来保存大数，这样数字在数学表示上就不会发生变化</li><li>初始化res，temp来保存中间的计算结果，并将两个字符串转化为数组，以便进行每一位的加法运算</li><li>将两个数组的对应的位进行相加，两个数相加的结果可能大于10，所以可能要仅为，对10进行取余操作，将结果保存在当前位</li><li>判断当前位是否大于9，也就是是否会进位，若是则将temp赋值为true，因为在加法运算中，true会自动隐式转化为1，以便于下一次相加</li><li>重复上述操作，直至计算结束</li></ul><h3 id="13-实现-add-1-2-3"><a href="#13-实现-add-1-2-3" class="headerlink" title="13. 实现 add(1)(2)(3)"></a>13. 实现 add(1)(2)(3)</h3><p>函数柯里化概念： 柯里化（Currying）是把接受多个参数的函数转变为接受一个单一参数的函数，并且返回接受余下的参数且返回结果的新函数的技术。</p><p>1）粗暴版</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span> (a) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">b</span>) &#123;<br> <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">c</span>) &#123;<br>      <span class="hljs-keyword">return</span> a + b + c;<br> &#125;<br>&#125;<br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">add</span>(<span class="hljs-number">1</span>)(<span class="hljs-number">2</span>)(<span class="hljs-number">3</span>)); <span class="hljs-comment">// 6</span><br></code></pre></td></tr></table></figure><p>2）柯里化解决方案</p><ul><li>参数长度固定</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> add = <span class="hljs-keyword">function</span> (<span class="hljs-params">m</span>) &#123;<br>  <span class="hljs-keyword">var</span> temp = <span class="hljs-keyword">function</span> (<span class="hljs-params">n</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">add</span>(m + n);<br>  &#125;<br>  temp.<span class="hljs-property">toString</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> m;<br>  &#125;<br>  <span class="hljs-keyword">return</span> temp;<br>&#125;;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">add</span>(<span class="hljs-number">3</span>)(<span class="hljs-number">4</span>)(<span class="hljs-number">5</span>)); <span class="hljs-comment">// 12</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">add</span>(<span class="hljs-number">3</span>)(<span class="hljs-number">6</span>)(<span class="hljs-number">9</span>)(<span class="hljs-number">25</span>)); <span class="hljs-comment">// 43</span><br></code></pre></td></tr></table></figure><p>对于add(3)(4)(5)，其执行过程如下：</p><ol><li>先执行add(3)，此时m&#x3D;3，并且返回temp函数；</li><li>执行temp(4)，这个函数内执行add(m+n)，n是此次传进来的数值4，m值还是上一步中的3，所以add(m+n)&#x3D;add(3+4)&#x3D;add(7)，此时m&#x3D;7，并且返回temp函数</li><li>执行temp(5)，这个函数内执行add(m+n)，n是此次传进来的数值5，m值还是上一步中的7，所以add(m+n)&#x3D;add(7+5)&#x3D;add(12)，此时m&#x3D;12，并且返回temp函数</li><li>由于后面没有传入参数，等于返回的temp函数不被执行而是打印，了解JS的朋友都知道对象的toString是修改对象转换字符串的方法，因此代码中temp函数的toString函数return m值，而m值是最后一步执行函数时的值m&#x3D;12，所以返回值是12。</li></ol><ul><li>参数长度不固定</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span> (...args) &#123;<br>    <span class="hljs-comment">//求和</span><br>    <span class="hljs-keyword">return</span> args.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a + b)<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">currying</span> (fn) &#123;<br>    <span class="hljs-keyword">let</span> args = []<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">temp</span> (...newArgs) &#123;<br>        <span class="hljs-keyword">if</span> (newArgs.<span class="hljs-property">length</span>) &#123;<br>            args = [<br>                ...args,<br>                ...newArgs<br>            ]<br>            <span class="hljs-keyword">return</span> temp<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">let</span> val = fn.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, args)<br>            args = [] <span class="hljs-comment">//保证再次调用时清空</span><br>            <span class="hljs-keyword">return</span> val<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">let</span> addCurry = <span class="hljs-title function_">currying</span>(add)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">addCurry</span>(<span class="hljs-number">1</span>)(<span class="hljs-number">2</span>)(<span class="hljs-number">3</span>)(<span class="hljs-number">4</span>, <span class="hljs-number">5</span>)())  <span class="hljs-comment">//15</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">addCurry</span>(<span class="hljs-number">1</span>)(<span class="hljs-number">2</span>)(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>)())  <span class="hljs-comment">//15</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">addCurry</span>(<span class="hljs-number">1</span>)(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>)())  <span class="hljs-comment">//15</span><br></code></pre></td></tr></table></figure><h3 id="14-实现类数组转化为数组"><a href="#14-实现类数组转化为数组" class="headerlink" title="14. 实现类数组转化为数组"></a>14. 实现类数组转化为数组</h3><p>类数组转换为数组的方法有这样几种：</p><ul><li>通过 call 调用数组的 slice 方法来实现转换</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">slice</span>.<span class="hljs-title function_">call</span>(arrayLike);<br></code></pre></td></tr></table></figure><ul><li>通过 call 调用数组的 splice 方法来实现转换</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">splice</span>.<span class="hljs-title function_">call</span>(arrayLike, <span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><ul><li>通过 apply 调用数组的 concat 方法来实现转换</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">concat</span>.<span class="hljs-title function_">apply</span>([], arrayLike);<br></code></pre></td></tr></table></figure><ul><li>通过 Array.from 方法来实现转换</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(arrayLike);<br></code></pre></td></tr></table></figure><h3 id="15-使用-reduce-求和"><a href="#15-使用-reduce-求和" class="headerlink" title="15. 使用 reduce 求和"></a>15. 使用 reduce 求和</h3><p>arr &#x3D; [1,2,3,4,5,6,7,8,9,10]，求和</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>]<br>arr.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">prev, cur</span>) =&gt;</span> &#123; <span class="hljs-keyword">return</span> prev + cur &#125;, <span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><p>arr &#x3D; [1,2,3,[[4,5],6],7,8,9]，求和</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>]<br>arr.<span class="hljs-title function_">flat</span>(<span class="hljs-title class_">Infinity</span>).<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">prev, cur</span>) =&gt;</span> &#123; <span class="hljs-keyword">return</span> prev + cur &#125;, <span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><p>arr &#x3D; [{a:1, b:3}, {a:2, b:3, c:4}, {a:3}]，求和</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr = [&#123;<span class="hljs-attr">a</span>:<span class="hljs-number">9</span>, <span class="hljs-attr">b</span>:<span class="hljs-number">3</span>, <span class="hljs-attr">c</span>:<span class="hljs-number">4</span>&#125;, &#123;<span class="hljs-attr">a</span>:<span class="hljs-number">1</span>, <span class="hljs-attr">b</span>:<span class="hljs-number">3</span>&#125;, &#123;<span class="hljs-attr">a</span>:<span class="hljs-number">3</span>&#125;] <br><br>arr.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">prev, cur</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> prev + cur[<span class="hljs-string">&quot;a&quot;</span>];<br>&#125;, <span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><h3 id="16-将js对象转化为树形结构"><a href="#16-将js对象转化为树形结构" class="headerlink" title="16. 将js对象转化为树形结构"></a>16. 将js对象转化为树形结构</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 转换前：</span><br>source = [&#123;<br>            <span class="hljs-attr">id</span>: <span class="hljs-number">1</span>,<br>            <span class="hljs-attr">pid</span>: <span class="hljs-number">0</span>,<br>            <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;body&#x27;</span><br>          &#125;, &#123;<br>            <span class="hljs-attr">id</span>: <span class="hljs-number">2</span>,<br>            <span class="hljs-attr">pid</span>: <span class="hljs-number">1</span>,<br>            <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;title&#x27;</span><br>          &#125;, &#123;<br>            <span class="hljs-attr">id</span>: <span class="hljs-number">3</span>,<br>            <span class="hljs-attr">pid</span>: <span class="hljs-number">2</span>,<br>            <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;div&#x27;</span><br>          &#125;]<br><span class="hljs-comment">// 转换为: </span><br>tree = [&#123;<br>          <span class="hljs-attr">id</span>: <span class="hljs-number">1</span>,<br>          <span class="hljs-attr">pid</span>: <span class="hljs-number">0</span>,<br>          <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;body&#x27;</span>,<br>          <span class="hljs-attr">children</span>: [&#123;<br>            <span class="hljs-attr">id</span>: <span class="hljs-number">2</span>,<br>            <span class="hljs-attr">pid</span>: <span class="hljs-number">1</span>,<br>            <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;title&#x27;</span>,<br>            <span class="hljs-attr">children</span>: [&#123;<br>              <span class="hljs-attr">id</span>: <span class="hljs-number">3</span>,<br>              <span class="hljs-attr">pid</span>: <span class="hljs-number">1</span>,<br>              <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;div&#x27;</span><br>            &#125;]<br>          &#125;<br>        &#125;]<br></code></pre></td></tr></table></figure><p>代码实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">jsonToTree</span>(<span class="hljs-params">data</span>) &#123;<br>  <span class="hljs-comment">// 初始化结果数组，并判断输入数据的格式</span><br>  <span class="hljs-keyword">let</span> result = []<br>  <span class="hljs-keyword">if</span>(!<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(data)) &#123;<br>    <span class="hljs-keyword">return</span> result<br>  &#125;<br>  <span class="hljs-comment">// 使用map，将当前对象的id与当前对象对应存储起来</span><br>  <span class="hljs-keyword">let</span> map = &#123;&#125;;<br>  data.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> &#123;<br>    map[item.<span class="hljs-property">id</span>] = item;<br>  &#125;);<br>  <span class="hljs-comment">// </span><br>  data.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">let</span> parent = map[item.<span class="hljs-property">pid</span>];<br>    <span class="hljs-keyword">if</span>(parent) &#123;<br>      (parent.<span class="hljs-property">children</span> || (parent.<span class="hljs-property">children</span> = [])).<span class="hljs-title function_">push</span>(item);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      result.<span class="hljs-title function_">push</span>(item);<br>    &#125;<br>  &#125;);<br>  <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="17-使用ES5和ES6求函数参数的和"><a href="#17-使用ES5和ES6求函数参数的和" class="headerlink" title="17. 使用ES5和ES6求函数参数的和"></a>17. 使用ES5和ES6求函数参数的和</h3><p>ES5：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">sum</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">let</span> sum = <span class="hljs-number">0</span><br>    <span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">forEach</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">arguments</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">item</span>) &#123;<br>        sum += item * <span class="hljs-number">1</span><br>    &#125;)<br>    <span class="hljs-keyword">return</span> sum<br>&#125;<br></code></pre></td></tr></table></figure><p>ES6：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">sum</span>(<span class="hljs-params">...nums</span>) &#123;<br>    <span class="hljs-keyword">let</span> sum = <span class="hljs-number">0</span><br>    nums.<span class="hljs-title function_">forEach</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">item</span>) &#123;<br>        sum += item * <span class="hljs-number">1</span><br>    &#125;)<br>    <span class="hljs-keyword">return</span> sum<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="18-解析-URL-Params-为对象"><a href="#18-解析-URL-Params-为对象" class="headerlink" title="18. 解析 URL Params 为对象"></a>18. 解析 URL Params 为对象</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> url = <span class="hljs-string">&#x27;http://www.domain.com/?user=anonymous&amp;id=123&amp;id=456&amp;city=%E5%8C%97%E4%BA%AC&amp;enabled&#x27;</span>;<br><span class="hljs-title function_">parseParam</span>(url)<br><span class="hljs-comment">/* 结果</span><br><span class="hljs-comment">&#123; user: &#x27;anonymous&#x27;,</span><br><span class="hljs-comment">  id: [ 123, 456 ], // 重复出现的 key 要组装成数组，能被转成数字的就转成数字类型</span><br><span class="hljs-comment">  city: &#x27;北京&#x27;, // 中文需解码</span><br><span class="hljs-comment">  enabled: true, // 未指定值得 key 约定为 true</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">parseParam</span>(<span class="hljs-params">url</span>) &#123;<br>  <span class="hljs-keyword">const</span> paramsStr = <span class="hljs-regexp">/.+\?(.+)$/</span>.<span class="hljs-title function_">exec</span>(url)[<span class="hljs-number">1</span>]; <span class="hljs-comment">// 将 ? 后面的字符串取出来</span><br>  <span class="hljs-keyword">const</span> paramsArr = paramsStr.<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27;&amp;&#x27;</span>); <span class="hljs-comment">// 将字符串以 &amp; 分割后存到数组中</span><br>  <span class="hljs-keyword">let</span> paramsObj = &#123;&#125;;<br>  <span class="hljs-comment">// 将 params 存到对象中</span><br>  paramsArr.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">param</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-regexp">/=/</span>.<span class="hljs-title function_">test</span>(param)) &#123; <span class="hljs-comment">// 处理有 value 的参数</span><br>      <span class="hljs-keyword">let</span> [key, val] = param.<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27;=&#x27;</span>); <span class="hljs-comment">// 分割 key 和 value</span><br>      val = <span class="hljs-built_in">decodeURIComponent</span>(val); <span class="hljs-comment">// 解码</span><br>      val = <span class="hljs-regexp">/^\d+$/</span>.<span class="hljs-title function_">test</span>(val) ? <span class="hljs-built_in">parseFloat</span>(val) : val; <span class="hljs-comment">// 判断是否转为数字</span><br>      <span class="hljs-keyword">if</span> (paramsObj.<span class="hljs-title function_">hasOwnProperty</span>(key)) &#123; <span class="hljs-comment">// 如果对象有 key，则添加一个值</span><br>        paramsObj[key] = [].<span class="hljs-title function_">concat</span>(paramsObj[key], val);<br>      &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 如果对象没有这个 key，创建 key 并设置值</span><br>        paramsObj[key] = val;<br>      &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 处理没有 value 的参数</span><br>      paramsObj[param] = <span class="hljs-literal">true</span>;<br>    &#125;<br>  &#125;)<br>  <span class="hljs-keyword">return</span> paramsObj;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="三、场景应用"><a href="#三、场景应用" class="headerlink" title="三、场景应用"></a>三、场景应用</h2><h3 id="1-循环打印红黄绿"><a href="#1-循环打印红黄绿" class="headerlink" title="1. 循环打印红黄绿"></a>1. 循环打印红黄绿</h3><p>下面来看一道比较典型的问题，通过这个问题来对比几种异步编程方法：<strong>红灯 3s 亮一次，绿灯 1s 亮一次，黄灯 2s 亮一次；如何让三个灯不断交替重复亮灯？</strong></p><p>三个亮灯函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">red</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;red&#x27;</span>);<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">green</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;green&#x27;</span>);<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">yellow</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;yellow&#x27;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>这道题复杂的地方在于<strong>需要“交替重复”亮灯</strong>，而不是“亮完一次”就结束了。</p><h4 id="（1）用-callback-实现"><a href="#（1）用-callback-实现" class="headerlink" title="（1）用 callback 实现"></a>（1）用 callback 实现</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">task</span> = (<span class="hljs-params">timer, light, callback</span>) =&gt; &#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-keyword">if</span> (light === <span class="hljs-string">&#x27;red&#x27;</span>) &#123;<br>            <span class="hljs-title function_">red</span>()<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (light === <span class="hljs-string">&#x27;green&#x27;</span>) &#123;<br>            <span class="hljs-title function_">green</span>()<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (light === <span class="hljs-string">&#x27;yellow&#x27;</span>) &#123;<br>            <span class="hljs-title function_">yellow</span>()<br>        &#125;<br>        <span class="hljs-title function_">callback</span>()<br>    &#125;, timer)<br>&#125;<br><span class="hljs-title function_">task</span>(<span class="hljs-number">3000</span>, <span class="hljs-string">&#x27;red&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-title function_">task</span>(<span class="hljs-number">2000</span>, <span class="hljs-string">&#x27;green&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-title function_">task</span>(<span class="hljs-number">1000</span>, <span class="hljs-string">&#x27;yellow&#x27;</span>, <span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>)<br>    &#125;)<br>&#125;)<br></code></pre></td></tr></table></figure><p>这里存在一个 bug：代码只是完成了一次流程，执行后红黄绿灯分别只亮一次。该如何让它交替重复进行呢？</p><p>上面提到过递归，可以递归亮灯的一个周期：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">step</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-title function_">task</span>(<span class="hljs-number">3000</span>, <span class="hljs-string">&#x27;red&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-title function_">task</span>(<span class="hljs-number">2000</span>, <span class="hljs-string">&#x27;green&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>            <span class="hljs-title function_">task</span>(<span class="hljs-number">1000</span>, <span class="hljs-string">&#x27;yellow&#x27;</span>, step)<br>        &#125;)<br>    &#125;)<br>&#125;<br><span class="hljs-title function_">step</span>()<br></code></pre></td></tr></table></figure><p><strong>注意看黄灯亮的回调里又再次调用了 step 方法</strong> 以完成循环亮灯。</p><h4 id="（2）用-promise-实现"><a href="#（2）用-promise-实现" class="headerlink" title="（2）用 promise 实现"></a>（2）用 promise 实现</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">task</span> = (<span class="hljs-params">timer, light</span>) =&gt; <br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>            <span class="hljs-keyword">if</span> (light === <span class="hljs-string">&#x27;red&#x27;</span>) &#123;<br>                <span class="hljs-title function_">red</span>()<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (light === <span class="hljs-string">&#x27;green&#x27;</span>) &#123;<br>                <span class="hljs-title function_">green</span>()<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (light === <span class="hljs-string">&#x27;yellow&#x27;</span>) &#123;<br>                <span class="hljs-title function_">yellow</span>()<br>            &#125;<br>            <span class="hljs-title function_">resolve</span>()<br>        &#125;, timer)<br>    &#125;)<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">step</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-title function_">task</span>(<span class="hljs-number">3000</span>, <span class="hljs-string">&#x27;red&#x27;</span>)<br>        .<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">task</span>(<span class="hljs-number">2000</span>, <span class="hljs-string">&#x27;green&#x27;</span>))<br>        .<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">task</span>(<span class="hljs-number">2100</span>, <span class="hljs-string">&#x27;yellow&#x27;</span>))<br>        .<span class="hljs-title function_">then</span>(step)<br>&#125;<br><span class="hljs-title function_">step</span>()<br></code></pre></td></tr></table></figure><p>这里将回调移除，在一次亮灯结束后，resolve 当前 promise，并依然使用递归进行。</p><h4 id="（3）用-async-x2F-await-实现"><a href="#（3）用-async-x2F-await-实现" class="headerlink" title="（3）用 async&#x2F;await 实现"></a>（3）用 async&#x2F;await 实现</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">taskRunner</span> =  <span class="hljs-keyword">async</span> (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-keyword">await</span> <span class="hljs-title function_">task</span>(<span class="hljs-number">3000</span>, <span class="hljs-string">&#x27;red&#x27;</span>)<br>    <span class="hljs-keyword">await</span> <span class="hljs-title function_">task</span>(<span class="hljs-number">2000</span>, <span class="hljs-string">&#x27;green&#x27;</span>)<br>    <span class="hljs-keyword">await</span> <span class="hljs-title function_">task</span>(<span class="hljs-number">2100</span>, <span class="hljs-string">&#x27;yellow&#x27;</span>)<br>    <span class="hljs-title function_">taskRunner</span>()<br>&#125;<br><span class="hljs-title function_">taskRunner</span>()<br></code></pre></td></tr></table></figure><h3 id="2-实现每隔一秒打印-1-2-3-4"><a href="#2-实现每隔一秒打印-1-2-3-4" class="headerlink" title="2. 实现每隔一秒打印 1,2,3,4"></a>2. 实现每隔一秒打印 1,2,3,4</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 使用闭包实现</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>  (<span class="hljs-keyword">function</span>(<span class="hljs-params">i</span>) &#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i);<br>    &#125;, i * <span class="hljs-number">1000</span>);<br>  &#125;)(i);<br>&#125;<br><span class="hljs-comment">// 使用 let 块级作用域</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i);<br>  &#125;, i * <span class="hljs-number">1000</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-小孩报数问题"><a href="#3-小孩报数问题" class="headerlink" title="3. 小孩报数问题"></a>3. 小孩报数问题</h3><p>有30个小孩儿，编号从1-30，围成一圈依此报数，1、2、3 数到 3 的小孩儿退出这个圈， 然后下一个小孩 重新报数 1、2、3，问最后剩下的那个小孩儿的编号是多少?</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">childNum</span>(<span class="hljs-params">num, count</span>)&#123;<br>    <span class="hljs-keyword">let</span> allplayer = [];    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; num; i++)&#123;<br>        allplayer[i] = i + <span class="hljs-number">1</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">let</span> exitCount = <span class="hljs-number">0</span>;    <span class="hljs-comment">// 离开人数</span><br>    <span class="hljs-keyword">let</span> counter = <span class="hljs-number">0</span>;      <span class="hljs-comment">// 记录报数</span><br>    <span class="hljs-keyword">let</span> curIndex = <span class="hljs-number">0</span>;     <span class="hljs-comment">// 当前下标</span><br>    <br>    <span class="hljs-keyword">while</span>(exitCount &lt; num - <span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-keyword">if</span>(allplayer[curIndex] !== <span class="hljs-number">0</span>) counter++;    <br>        <br>        <span class="hljs-keyword">if</span>(counter == count)&#123;<br>            allplayer[curIndex] = <span class="hljs-number">0</span>;                 <br>            counter = <span class="hljs-number">0</span>;<br>            exitCount++;  <br>        &#125;<br>        curIndex++;<br>        <span class="hljs-keyword">if</span>(curIndex == num)&#123;<br>            curIndex = <span class="hljs-number">0</span>               <br>        &#125;;           <br>    &#125;    <br>    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; num; i++)&#123;<br>        <span class="hljs-keyword">if</span>(allplayer[i] !== <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> allplayer[i]<br>        &#125;      <br>    &#125;<br>&#125;<br><span class="hljs-title function_">childNum</span>(<span class="hljs-number">30</span>, <span class="hljs-number">3</span>)<br></code></pre></td></tr></table></figure><h3 id="4-用Promise实现图片的异步加载"><a href="#4-用Promise实现图片的异步加载" class="headerlink" title="4. 用Promise实现图片的异步加载"></a>4. 用Promise实现图片的异步加载</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> <span class="hljs-title function_">imageAsync</span>=(<span class="hljs-params">url</span>)=&gt;&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br>                <span class="hljs-keyword">let</span> img = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Image</span>();<br>                img.<span class="hljs-property">src</span> = url;<br>                img.οnlοad=<span class="hljs-function">()=&gt;</span>&#123;<br>                    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`图片请求成功，此处进行通用操作`</span>);<br>                    <span class="hljs-title function_">resolve</span>(image);<br>                &#125;<br>                img.οnerrοr=<span class="hljs-function">(<span class="hljs-params">err</span>)=&gt;</span>&#123;<br>                    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`失败，此处进行失败的通用操作`</span>);<br>                    <span class="hljs-title function_">reject</span>(err);<br>                &#125;<br>            &#125;)<br>        &#125;<br>        <br><span class="hljs-title function_">imageAsync</span>(<span class="hljs-string">&quot;url&quot;</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;加载成功&quot;</span>);<br>&#125;).<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">error</span>)=&gt;</span>&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;加载失败&quot;</span>);<br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="5-实现发布-订阅模式"><a href="#5-实现发布-订阅模式" class="headerlink" title="5. 实现发布-订阅模式"></a>5. 实现发布-订阅模式</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">EventCenter</span>&#123;<br>  <span class="hljs-comment">// 1. 定义事件容器，用来装事件数组</span><br><span class="hljs-keyword">let</span> handlers = &#123;&#125;<br><br>  <span class="hljs-comment">// 2. 添加事件方法，参数：事件名 事件方法</span><br>  <span class="hljs-title function_">addEventListener</span>(<span class="hljs-params">type, handler</span>) &#123;<br>    <span class="hljs-comment">// 创建新数组容器</span><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-property">handlers</span>[type]) &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">handlers</span>[type] = []<br>    &#125;<br>    <span class="hljs-comment">// 存入事件</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">handlers</span>[type].<span class="hljs-title function_">push</span>(handler)<br>  &#125;<br><br>  <span class="hljs-comment">// 3. 触发事件，参数：事件名 事件参数</span><br>  <span class="hljs-title function_">dispatchEvent</span>(<span class="hljs-params">type, params</span>) &#123;<br>    <span class="hljs-comment">// 若没有注册该事件则抛出错误</span><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-property">handlers</span>[type]) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;该事件未注册&#x27;</span>)<br>    &#125;<br>    <span class="hljs-comment">// 触发事件</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">handlers</span>[type].<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">handler</span> =&gt;</span> &#123;<br>      <span class="hljs-title function_">handler</span>(...params)<br>    &#125;)<br>  &#125;<br><br>  <span class="hljs-comment">// 4. 事件移除，参数：事件名 要删除事件，若无第二个参数则删除该事件的订阅和发布</span><br>  <span class="hljs-title function_">removeEventListener</span>(<span class="hljs-params">type, handler</span>) &#123;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-property">handlers</span>[type]) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;事件无效&#x27;</span>)<br>    &#125;<br>    <span class="hljs-keyword">if</span> (!handler) &#123;<br>      <span class="hljs-comment">// 移除事件</span><br>      <span class="hljs-keyword">delete</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">handlers</span>[type]<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">const</span> index = <span class="hljs-variable language_">this</span>.<span class="hljs-property">handlers</span>[type].<span class="hljs-title function_">findIndex</span>(<span class="hljs-function"><span class="hljs-params">el</span> =&gt;</span> el === handler)<br>      <span class="hljs-keyword">if</span> (index === -<span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;无该绑定事件&#x27;</span>)<br>      &#125;<br>      <span class="hljs-comment">// 移除事件</span><br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">handlers</span>[type].<span class="hljs-title function_">splice</span>(index, <span class="hljs-number">1</span>)<br>      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">handlers</span>[type].<span class="hljs-property">length</span> === <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">delete</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">handlers</span>[type]<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6-查找文章中出现频率最高的单词"><a href="#6-查找文章中出现频率最高的单词" class="headerlink" title="6. 查找文章中出现频率最高的单词"></a>6. 查找文章中出现频率最高的单词</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">findMostWord</span>(<span class="hljs-params">article</span>) &#123;<br>  <span class="hljs-comment">// 合法性判断</span><br>  <span class="hljs-keyword">if</span> (!article) <span class="hljs-keyword">return</span>;<br>  <span class="hljs-comment">// 参数处理</span><br>  article = article.<span class="hljs-title function_">trim</span>().<span class="hljs-title function_">toLowerCase</span>();<br>  <span class="hljs-keyword">let</span> wordList = article.<span class="hljs-title function_">match</span>(<span class="hljs-regexp">/[a-z]+/g</span>),<br>    visited = [],<br>    maxNum = <span class="hljs-number">0</span>,<br>    maxWord = <span class="hljs-string">&quot;&quot;</span>;<br>  article = <span class="hljs-string">&quot; &quot;</span> + wordList.<span class="hljs-title function_">join</span>(<span class="hljs-string">&quot;  &quot;</span>) + <span class="hljs-string">&quot; &quot;</span>;<br>  <span class="hljs-comment">// 遍历判断单词出现次数</span><br>  wordList.<span class="hljs-title function_">forEach</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">item</span>) &#123;<br>    <span class="hljs-keyword">if</span> (visited.<span class="hljs-title function_">indexOf</span>(item) &lt; <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-comment">// 加入 visited </span><br>      visited.<span class="hljs-title function_">push</span>(item);<br>      <span class="hljs-keyword">let</span> word = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RegExp</span>(<span class="hljs-string">&quot; &quot;</span> + item + <span class="hljs-string">&quot; &quot;</span>, <span class="hljs-string">&quot;g&quot;</span>),<br>        num = article.<span class="hljs-title function_">match</span>(word).<span class="hljs-property">length</span>;<br>      <span class="hljs-keyword">if</span> (num &gt; maxNum) &#123;<br>        maxNum = num;<br>        maxWord = item;<br>      &#125;<br>    &#125;<br>  &#125;);<br>  <span class="hljs-keyword">return</span> maxWord + <span class="hljs-string">&quot;  &quot;</span> + maxNum;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="7-封装异步的fetch，使用async-await方式来使用"><a href="#7-封装异步的fetch，使用async-await方式来使用" class="headerlink" title="7. 封装异步的fetch，使用async await方式来使用"></a>7. 封装异步的fetch，使用async await方式来使用</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs javascript">(<span class="hljs-keyword">async</span> () =&gt; &#123;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">HttpRequestUtil</span> &#123;<br>        <span class="hljs-keyword">async</span> <span class="hljs-title function_">get</span>(<span class="hljs-params">url</span>) &#123;<br>            <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(url);<br>            <span class="hljs-keyword">const</span> data = <span class="hljs-keyword">await</span> res.<span class="hljs-title function_">json</span>();<br>            <span class="hljs-keyword">return</span> data;<br>        &#125;<br>        <span class="hljs-keyword">async</span> <span class="hljs-title function_">post</span>(<span class="hljs-params">url, data</span>) &#123;<br>            <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(url, &#123;<br>                <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;POST&#x27;</span>,<br>                <span class="hljs-attr">headers</span>: &#123;<br>                    <span class="hljs-string">&#x27;Content-Type&#x27;</span>: <span class="hljs-string">&#x27;application/json&#x27;</span><br>                &#125;,<br>                <span class="hljs-attr">body</span>: <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(data)<br>            &#125;);<br>            <span class="hljs-keyword">const</span> result = <span class="hljs-keyword">await</span> res.<span class="hljs-title function_">json</span>();<br>            <span class="hljs-keyword">return</span> result;<br>        &#125;<br>        <span class="hljs-keyword">async</span> <span class="hljs-title function_">put</span>(<span class="hljs-params">url, data</span>) &#123;<br>            <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(url, &#123;<br>                <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;PUT&#x27;</span>,<br>                <span class="hljs-attr">headers</span>: &#123;<br>                    <span class="hljs-string">&#x27;Content-Type&#x27;</span>: <span class="hljs-string">&#x27;application/json&#x27;</span><br>                &#125;,<br>                <span class="hljs-attr">data</span>: <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(data)<br>            &#125;);<br>            <span class="hljs-keyword">const</span> result = <span class="hljs-keyword">await</span> res.<span class="hljs-title function_">json</span>();<br>            <span class="hljs-keyword">return</span> result;<br>        &#125;<br>        <span class="hljs-keyword">async</span> <span class="hljs-title function_">delete</span>(<span class="hljs-params">url, data</span>) &#123;<br>            <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(url, &#123;<br>                <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;DELETE&#x27;</span>,<br>                <span class="hljs-attr">headers</span>: &#123;<br>                    <span class="hljs-string">&#x27;Content-Type&#x27;</span>: <span class="hljs-string">&#x27;application/json&#x27;</span><br>                &#125;,<br>                <span class="hljs-attr">data</span>: <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(data)<br>            &#125;);<br>            <span class="hljs-keyword">const</span> result = <span class="hljs-keyword">await</span> res.<span class="hljs-title function_">json</span>();<br>            <span class="hljs-keyword">return</span> result;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">const</span> httpRequestUtil = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HttpRequestUtil</span>();<br>    <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> httpRequestUtil.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;http://golderbrother.cn/&#x27;</span>);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res);<br>&#125;)();<br></code></pre></td></tr></table></figure><h3 id="8-实现prototype继承"><a href="#8-实现prototype继承" class="headerlink" title="8. 实现prototype继承"></a>8. 实现prototype继承</h3><p>所谓的原型链继承就是让新实例的原型等于父类的实例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//父方法</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">SupperFunction</span>(<span class="hljs-params">flag1</span>)&#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">flag1</span> = flag1;<br>&#125;<br><br><span class="hljs-comment">//子方法</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">SubFunction</span>(<span class="hljs-params">flag2</span>)&#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">flag2</span> = flag2;<br>&#125;<br><br><span class="hljs-comment">//父实例</span><br><span class="hljs-keyword">var</span> superInstance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SupperFunction</span>(<span class="hljs-literal">true</span>);<br><br><span class="hljs-comment">//子继承父</span><br><span class="hljs-title class_">SubFunction</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = superInstance;<br><br><span class="hljs-comment">//子实例</span><br><span class="hljs-keyword">var</span> subInstance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SubFunction</span>(<span class="hljs-literal">false</span>);<br><span class="hljs-comment">//子调用自己和父的属性</span><br>subInstance.<span class="hljs-property">flag1</span>;   <span class="hljs-comment">// true</span><br>subInstance.<span class="hljs-property">flag2</span>;   <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><h3 id="9-实现双向数据绑定"><a href="#9-实现双向数据绑定" class="headerlink" title="9. 实现双向数据绑定"></a>9. 实现双向数据绑定</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> obj = &#123;&#125;<br><span class="hljs-keyword">let</span> input = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;input&#x27;</span>)<br><span class="hljs-keyword">let</span> span = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;span&#x27;</span>)<br><span class="hljs-comment">// 数据劫持</span><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(obj, <span class="hljs-string">&#x27;text&#x27;</span>, &#123;<br>  <span class="hljs-attr">configurable</span>: <span class="hljs-literal">true</span>,<br>  <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">true</span>,<br>  <span class="hljs-title function_">get</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;获取数据了&#x27;</span>)<br>  &#125;,<br>  <span class="hljs-title function_">set</span>(<span class="hljs-params">newVal</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;数据更新了&#x27;</span>)<br>    input.<span class="hljs-property">value</span> = newVal<br>    span.<span class="hljs-property">innerHTML</span> = newVal<br>  &#125;<br>&#125;)<br><span class="hljs-comment">// 输入监听</span><br>input.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;keyup&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) &#123;<br>  obj.<span class="hljs-property">text</span> = e.<span class="hljs-property">target</span>.<span class="hljs-property">value</span><br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="10-实现简单路由"><a href="#10-实现简单路由" class="headerlink" title="10. 实现简单路由"></a>10. 实现简单路由</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// hash路由</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Route</span>&#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-comment">// 路由存储对象</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">routes</span> = &#123;&#125;<br>    <span class="hljs-comment">// 当前hash</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">currentHash</span> = <span class="hljs-string">&#x27;&#x27;</span><br>    <span class="hljs-comment">// 绑定this，避免监听时this指向改变</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">freshRoute</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">freshRoute</span>.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>)<br>    <span class="hljs-comment">// 监听</span><br>    <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;load&#x27;</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">freshRoute</span>, <span class="hljs-literal">false</span>)<br>    <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;hashchange&#x27;</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">freshRoute</span>, <span class="hljs-literal">false</span>)<br>  &#125;<br>  <span class="hljs-comment">// 存储</span><br>  storeRoute (path, cb) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">routes</span>[path] = cb || <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;&#125;<br>  &#125;<br>  <span class="hljs-comment">// 更新</span><br>  freshRoute () &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">currentHash</span> = location.<span class="hljs-property">hash</span>.<span class="hljs-title function_">slice</span>(<span class="hljs-number">1</span>) || <span class="hljs-string">&#x27;/&#x27;</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">routes</span>[<span class="hljs-variable language_">this</span>.<span class="hljs-property">currentHash</span>]()<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="11-实现斐波那契数列"><a href="#11-实现斐波那契数列" class="headerlink" title="11. 实现斐波那契数列"></a>11. 实现斐波那契数列</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 递归</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span> (n)&#123;<br>    <span class="hljs-keyword">if</span>(n==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    <span class="hljs-keyword">if</span>(n==<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">fn</span>(n-<span class="hljs-number">2</span>)+<span class="hljs-title function_">fn</span>(n-<span class="hljs-number">1</span>)<br>&#125;<br><span class="hljs-comment">// 优化</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">fibonacci2</span>(<span class="hljs-params">n</span>) &#123;<br>    <span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>];<br>    <span class="hljs-keyword">const</span> arrLen = arr.<span class="hljs-property">length</span>;<br><br>    <span class="hljs-keyword">if</span> (n &lt;= arrLen) &#123;<br>        <span class="hljs-keyword">return</span> arr[n];<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = arrLen; i &lt; n; i++) &#123;<br>        arr.<span class="hljs-title function_">push</span>(arr[i - <span class="hljs-number">1</span>] + arr[ i - <span class="hljs-number">2</span>]);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> arr[arr.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>];<br>&#125;<br><span class="hljs-comment">// 非递归</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params">n</span>) &#123;<br>    <span class="hljs-keyword">let</span> pre1 = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">let</span> pre2 = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">let</span> current = <span class="hljs-number">2</span>;<br><br>    <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">2</span>) &#123;<br>        <span class="hljs-keyword">return</span> current;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">2</span>; i &lt; n; i++) &#123;<br>        pre1 = pre2;<br>        pre2 = current;<br>        current = pre1 + pre2;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> current;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="12-字符串出现的不重复最长长度"><a href="#12-字符串出现的不重复最长长度" class="headerlink" title="12. 字符串出现的不重复最长长度"></a>12. 字符串出现的不重复最长长度</h3><p>用一个滑动窗口装没有重复的字符，枚举字符记录最大值即可。用 map 维护字符的索引，遇到相同的字符，把左边界移动过去即可。挪动的过程中记录最大长度：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> lengthOfLongestSubstring = <span class="hljs-keyword">function</span> (<span class="hljs-params">s</span>) &#123;<br>    <span class="hljs-keyword">let</span> map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();<br>    <span class="hljs-keyword">let</span> i = -<span class="hljs-number">1</span><br>    <span class="hljs-keyword">let</span> res = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">let</span> n = s.<span class="hljs-property">length</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>        <span class="hljs-keyword">if</span> (map.<span class="hljs-title function_">has</span>(s[j])) &#123;<br>            i = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(i, map.<span class="hljs-title function_">get</span>(s[j]))<br>        &#125;<br>        res = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(res, j - i)<br>        map.<span class="hljs-title function_">set</span>(s[j], j)<br>    &#125;<br>    <span class="hljs-keyword">return</span> res<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="13-使用-setTimeout-实现-setInterval"><a href="#13-使用-setTimeout-实现-setInterval" class="headerlink" title="13. 使用 setTimeout 实现 setInterval"></a>13. 使用 setTimeout 实现 setInterval</h3><p>setInterval 的作用是每隔一段指定时间执行一个函数，但是这个执行不是真的到了时间立即执行，它真正的作用是每隔一段时间将事件加入事件队列中去，只有当当前的执行栈为空的时候，才能去从事件队列中取出事件执行。所以可能会出现这样的情况，就是当前执行栈执行的时间很长，导致事件队列里边积累多个定时器加入的事件，当执行栈结束的时候，这些事件会依次执行，因此就不能到间隔一段时间执行的效果。</p><p>针对 setInterval 的这个缺点，我们可以使用 setTimeout 递归调用来模拟 setInterval，这样我们就确保了只有一个事件结束了，我们才会触发下一个定时器事件，这样解决了 setInterval 的问题。</p><p>实现思路是使用递归函数，不断地去执行 setTimeout 从而达到 setInterval 的效果</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">mySetInterval</span>(<span class="hljs-params">fn, timeout</span>) &#123;<br>  <span class="hljs-comment">// 控制器，控制定时器是否继续执行</span><br>  <span class="hljs-keyword">var</span> timer = &#123;<br>    <span class="hljs-attr">flag</span>: <span class="hljs-literal">true</span><br>  &#125;;<br>  <span class="hljs-comment">// 设置递归函数，模拟定时器执行。</span><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">interval</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">if</span> (timer.<span class="hljs-property">flag</span>) &#123;<br>      <span class="hljs-title function_">fn</span>();<br>      <span class="hljs-built_in">setTimeout</span>(interval, timeout);<br>    &#125;<br>  &#125;<br>  <span class="hljs-comment">// 启动定时器</span><br>  <span class="hljs-built_in">setTimeout</span>(interval, timeout);<br>  <span class="hljs-comment">// 返回控制器</span><br>  <span class="hljs-keyword">return</span> timer;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="14-实现-jsonp"><a href="#14-实现-jsonp" class="headerlink" title="14. 实现 jsonp"></a>14. 实现 jsonp</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 动态的加载js文件</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">addScript</span>(<span class="hljs-params">src</span>) &#123;<br>  <span class="hljs-keyword">const</span> script = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;script&#x27;</span>);<br>  script.<span class="hljs-property">src</span> = src;<br>  script.<span class="hljs-property">type</span> = <span class="hljs-string">&quot;text/javascript&quot;</span>;<br>  <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">appendChild</span>(script);<br>&#125;<br><span class="hljs-title function_">addScript</span>(<span class="hljs-string">&quot;http://xxx.xxx.com/xxx.js?callback=handleRes&quot;</span>);<br><span class="hljs-comment">// 设置一个全局的callback函数来接收回调结果</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">handleRes</span>(<span class="hljs-params">res</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res);<br>&#125;<br><span class="hljs-comment">// 接口返回的数据格式</span><br><span class="hljs-title function_">handleRes</span>(&#123;<span class="hljs-attr">a</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">b</span>: <span class="hljs-number">2</span>&#125;);<br></code></pre></td></tr></table></figure><h3 id="15-判断对象是否存在循环引用"><a href="#15-判断对象是否存在循环引用" class="headerlink" title="15. 判断对象是否存在循环引用"></a>15. 判断对象是否存在循环引用</h3><p>循环引用对象本来没有什么问题，但是序列化的时候就会发生问题，比如调用<code>JSON.stringify()</code>对该类对象进行序列化，就会报错: <code>Converting circular structure to JSON.</code></p><p>下面方法可以用来判断一个对象中是否已存在循环引用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">isCycleObject</span> = (<span class="hljs-params">obj,parent</span>) =&gt; &#123;<br>    <span class="hljs-keyword">const</span> parentArr = parent || [obj];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i <span class="hljs-keyword">in</span> obj) &#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span> obj[i] === <span class="hljs-string">&#x27;object&#x27;</span>) &#123;<br>            <span class="hljs-keyword">let</span> flag = <span class="hljs-literal">false</span>;<br>            parentArr.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">pObj</span>) =&gt;</span> &#123;<br>                <span class="hljs-keyword">if</span>(pObj === obj[i])&#123;<br>                    flag = <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;)<br>            <span class="hljs-keyword">if</span>(flag) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            flag = <span class="hljs-title function_">isCycleObject</span>(obj[i],[...parentArr,obj[i]]);<br>            <span class="hljs-keyword">if</span>(flag) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><br><span class="hljs-keyword">const</span> a = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">const</span> b = &#123;a&#125;;<br><span class="hljs-keyword">const</span> c = &#123;b&#125;;<br><span class="hljs-keyword">const</span> o = &#123;<span class="hljs-attr">d</span>:&#123;<span class="hljs-attr">a</span>:<span class="hljs-number">3</span>&#125;,c&#125;<br>o.<span class="hljs-property">c</span>.<span class="hljs-property">b</span>.<span class="hljs-property">aa</span> = a;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">isCycleObject</span>(o)<br></code></pre></td></tr></table></figure><p>查找有序二维数组的目标值：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> findNumberIn2DArray = <span class="hljs-keyword">function</span>(<span class="hljs-params">matrix, target</span>) &#123;<br>    <span class="hljs-keyword">if</span> (matrix == <span class="hljs-literal">null</span> || matrix.<span class="hljs-property">length</span> == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">let</span> row = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">let</span> column = matrix[<span class="hljs-number">0</span>].<span class="hljs-property">length</span> - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (row &lt; matrix.<span class="hljs-property">length</span> &amp;&amp; column &gt;= <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">if</span> (matrix[row][column] == target) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (matrix[row][column] &gt; target) &#123;<br>            column--;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            row++;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;;<br><br></code></pre></td></tr></table></figure><p>二维数组斜向打印：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">printMatrix</span>(<span class="hljs-params">arr</span>)&#123;<br>  <span class="hljs-keyword">let</span> m = arr.<span class="hljs-property">length</span>, n = arr[<span class="hljs-number">0</span>].<span class="hljs-property">length</span><br><span class="hljs-keyword">let</span> res = []<br>  <br>  <span class="hljs-comment">// 左上角，从0 到 n - 1 列进行打印</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> k = <span class="hljs-number">0</span>; k &lt; n; k++) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>, j = k; i &lt; m &amp;&amp; j &gt;= <span class="hljs-number">0</span>; i++, j--) &#123;<br>      res.<span class="hljs-title function_">push</span>(arr[i][j]);<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">// 右下角，从1 到 n - 1 行进行打印</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> k = <span class="hljs-number">1</span>; k &lt; m; k++) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = k, j = n - <span class="hljs-number">1</span>; i &lt; m &amp;&amp; j &gt;= <span class="hljs-number">0</span>; i++, j--) &#123;<br>      res.<span class="hljs-title function_">push</span>(arr[i][j]);<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>BGW</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>BGW-前端优化</title>
    <link href="/2023/04/18/BGW-%E5%89%8D%E7%AB%AF%E4%BC%98%E5%8C%96/"/>
    <url>/2023/04/18/BGW-%E5%89%8D%E7%AB%AF%E4%BC%98%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<p>BGW-性能优化</p><p> <img src="1.png" alt="img"></p><h2 id="一、CDN"><a href="#一、CDN" class="headerlink" title="一、CDN"></a>一、CDN</h2><h3 id="1-CDN的概念"><a href="#1-CDN的概念" class="headerlink" title="1. CDN的概念"></a>1. CDN的概念</h3><p>CDN（Content Delivery Network，<strong>内容分发网络</strong>）是指一种通过互联网互相连接的电脑网络系统，利用最靠近每位用户的服务器，更快、更可靠地将音乐、图片、视频、应用程序及其他文件发送给用户，来提供高性能、可扩展性及低成本的网络内容传递给用户。</p><p>典型的CDN系统由下面三个部分组成：</p><ul><li><strong>分发服务系统：</strong> 最基本的工作单元就是Cache设备，cache（边缘cache）负责直接响应最终用户的访问请求，把缓存在本地的内容快速地提供给用户。同时cache还负责与源站点进行内容同步，把更新的内容以及本地没有的内容从源站点获取并保存在本地。Cache设备的数量、规模、总服务能力是衡量一个CDN系统服务能力的最基本的指标。</li><li><strong>负载均衡系统：</strong> 主要功能是负责对所有发起服务请求的用户进行访问调度，确定提供给用户的最终实际访问地址。两级调度体系分为全局负载均衡（GSLB）和本地负载均衡（SLB）。<strong>全局负载均衡</strong>主要根据用户就近性原则，通过对每个服务节点进行“最优”判断，确定向用户提供服务的cache的物理位置。<strong>本地负载均衡</strong>主要负责节点内部的设备负载均衡</li><li><strong>运营管理系统：</strong> 运营管理系统分为运营管理和网络管理子系统，负责处理业务层面的与外界系统交互所必须的收集、整理、交付工作，包含客户管理、产品管理、计费管理、统计分析等功能。</li></ul><h3 id="2-CDN的作用"><a href="#2-CDN的作用" class="headerlink" title="2. CDN的作用"></a>2. CDN的作用</h3><p>CDN一般会用来托管Web资源（包括文本、图片和脚本等），可供下载的资源（媒体文件、软件、文档等），应用程序（门户网站等）。使用CDN来加速这些资源的访问。</p><p>（1）在性能方面，引入CDN的作用在于：</p><ul><li>用户收到的内容来自最近的数据中心，延迟更低，内容加载更快</li><li>部分资源请求分配给了CDN，减少了服务器的负载</li></ul><p>（2）在安全方面，CDN有助于防御DDoS、MITM等网络攻击：</p><ul><li>针对DDoS：通过监控分析异常流量，限制其请求频率</li><li>针对MITM：从源服务器到 CDN 节点到 ISP（Internet Service Provider），全链路 HTTPS 通信</li></ul><p>除此之外，CDN作为一种基础的云服务，同样具有资源托管、按需扩展（能够应对流量高峰）等方面的优势。</p><h3 id="3-CDN的原理"><a href="#3-CDN的原理" class="headerlink" title="3. CDN的原理"></a>3. CDN的原理</h3><p>CDN和DNS有着密不可分的联系，先来看一下DNS的解析域名过程，在浏览器输入 <a href="http://www.test.com/">www.test.com</a> 的解析过程如下：<br>（1） 检查浏览器缓存<br>（2）检查操作系统缓存，常见的如hosts文件<br>（3）检查路由器缓存<br>（4）如果前几步都没没找到，会向ISP(网络服务提供商)的LDNS服务器查询<br>（5）如果LDNS服务器没找到，会向根域名服务器(Root Server)请求解析，分为以下几步：</p><ul><li>根服务器返回顶级域名(TLD)服务器如<code>.com</code>，<code>.cn</code>，<code>.org</code>等的地址，该例子中会返回<code>.com</code>的地址</li><li>接着向顶级域名服务器发送请求，然后会返回次级域名(SLD)服务器的地址，本例子会返回<code>.test</code>的地址</li><li>接着向次级域名服务器发送请求，然后会返回通过域名查询到的目标IP，本例子会返回<code>www.test.com</code>的地址</li><li>Local DNS Server会缓存结果，并返回给用户，缓存在系统中</li></ul><p><strong>CDN的工作原理：</strong><br>（1）用户未使用CDN缓存资源的过程：</p><ol><li>浏览器通过DNS对域名进行解析（就是上面的DNS解析过程），依次得到此域名对应的IP地址</li><li>浏览器根据得到的IP地址，向域名的服务主机发送数据请求</li><li>服务器向浏览器返回响应数据</li></ol><p>（2）用户使用CDN缓存资源的过程：</p><ol><li>对于点击的数据的URL，经过本地DNS系统的解析，发现该URL对应的是一个CDN专用的DNS服务器，DNS系统就会将域名解析权交给CNAME指向的CDN专用的DNS服务器。</li><li>CND专用DNS服务器将CND的全局负载均衡设备IP地址返回给用户</li><li>用户向CDN的全局负载均衡设备发起数据请求</li><li>CDN的全局负载均衡设备根据用户的IP地址，以及用户请求的内容URL，选择一台用户所属区域的区域负载均衡设备，告诉用户向这台设备发起请求</li><li>区域负载均衡设备选择一台合适的缓存服务器来提供服务，将该缓存服务器的IP地址返回给全局负载均衡设备</li><li>全局负载均衡设备把服务器的IP地址返回给用户</li><li>用户向该缓存服务器发起请求，缓存服务器响应用户的请求，将用户所需内容发送至用户终端。</li></ol><p>如果缓存服务器没有用户想要的内容，那么缓存服务器就会向它的上一级缓存服务器请求内容，以此类推，直到获取到需要的资源。最后如果还是没有，就会回到自己的服务器去获取资源。</p><p><img src="2.png" alt="img"><br>CNAME（意为：别名）：在域名解析中，实际上解析出来的指定域名对应的IP地址，或者该域名的一个CNAME，然后再根据这个CNAME来查找对应的IP地址。</p><h3 id="4-CDN的使用场景"><a href="#4-CDN的使用场景" class="headerlink" title="4. CDN的使用场景"></a>4. CDN的使用场景</h3><ul><li><strong>使用第三方的CDN服务：</strong>如果想要开源一些项目，可以使用第三方的CDN服务</li><li><strong>使用CDN进行静态资源的缓存：</strong>将自己网站的静态资源放在CDN上，比如js、css、图片等。可以将整个项目放在CDN上，完成一键部署。</li><li><strong>直播传送：</strong>直播本质上是使用流媒体进行传送，CDN也是支持流媒体传送的，所以直播完全可以使用CDN来提高访问速度。CDN在处理流媒体的时候与处理普通静态文件有所不同，普通文件如果在边缘节点没有找到的话，就会去上一层接着寻找，但是流媒体本身数据量就非常大，如果使用回源的方式，必然会带来性能问题，所以流媒体一般采用的都是主动推送的方式来进行。</li></ul><h2 id="二、懒加载"><a href="#二、懒加载" class="headerlink" title="二、懒加载"></a>二、懒加载</h2><h3 id="1-懒加载的概念"><a href="#1-懒加载的概念" class="headerlink" title="1. 懒加载的概念"></a>1. 懒加载的概念</h3><p>懒加载也叫做延迟加载、按需加载，指的是在长网页中延迟加载图片数据，是一种较好的网页性能优化的方式。在比较长的网页或应用中，如果图片很多，所有的图片都被加载出来，而用户只能看到可视窗口的那一部分图片数据，这样就浪费了性能。</p><p>如果使用图片的懒加载就可以解决以上问题。在滚动屏幕之前，可视化区域之外的图片不会进行加载，在滚动屏幕时才加载。这样使得网页的加载速度更快，减少了服务器的负载。懒加载适用于图片较多，页面列表较长（长列表）的场景中。</p><h3 id="2-懒加载的特点"><a href="#2-懒加载的特点" class="headerlink" title="2. 懒加载的特点"></a>2. 懒加载的特点</h3><ul><li><strong>减少无用资源的加载</strong>：使用懒加载明显减少了服务器的压力和流量，同时也减小了浏览器的负担。</li><li><strong>提升用户体验</strong>: 如果同时加载较多图片，可能需要等待的时间较长，这样影响了用户体验，而使用懒加载就能大大的提高用户体验。</li><li><strong>防止加载过多图片而影响其他资源文件的加载</strong> ：会影响网站应用的正常使用。</li></ul><h3 id="3-懒加载的实现原理"><a href="#3-懒加载的实现原理" class="headerlink" title="3. 懒加载的实现原理"></a>3. 懒加载的实现原理</h3><p>图片的加载是由<code>src</code>引起的，当对<code>src</code>赋值时，浏览器就会请求图片资源。根据这个原理，我们使用HTML5 的<code>data-xxx</code>属性来储存图片的路径，在需要加载图片的时候，将<code>data-xxx</code>中图片的路径赋值给<code>src</code>，这样就实现了图片的按需加载，即懒加载。</p><p>注意：<code>data-xxx</code> 中的<code>xxx</code>可以自定义，这里我们使用<code>data-src</code>来定义。</p><p>懒加载的实现重点在于确定用户需要加载哪张图片，在浏览器中，可视区域内的资源就是用户需要的资源。所以当图片出现在可视区域时，获取图片的真实地址并赋值给图片即可。</p><p>使用原生JavaScript实现懒加载：</p><p><strong>知识点：</strong></p><p>（1）<code>window.innerHeight</code> 是浏览器可视区的高度</p><p>（2）<code>document.body.scrollTop || document.documentElement.scrollTop</code> 是浏览器滚动的过的距离</p><p>（3）<code>imgs.offsetTop</code> 是元素顶部距离文档顶部的高度（包括滚动条的距离）</p><p>（4）图片加载条件：<code>img.offsetTop &lt; window.innerHeight + document.body.scrollTop;</code></p><p> <strong>图示：</strong><br><img src="3.png" alt="img"><br><strong>代码实现：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;div <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;container&quot;</span>&gt;<br>     &lt;img src=&quot;loading.gif&quot;  data-src=&quot;pic.png&quot;&gt;<br>     &lt;img src=&quot;loading.gif&quot;  data-src=&quot;pic.png&quot;&gt;<br>     &lt;img src=&quot;loading.gif&quot;  data-src=&quot;pic.png&quot;&gt;<br>     &lt;img src=&quot;loading.gif&quot;  data-src=&quot;pic.png&quot;&gt;<br>     &lt;img src=&quot;loading.gif&quot;  data-src=&quot;pic.png&quot;&gt;<br>     &lt;img src=&quot;loading.gif&quot;  data-src=&quot;pic.png&quot;&gt;<br>&lt;/div&gt;<br>&lt;script&gt;<br>var imgs = document.querySelectorAll(&#x27;img&#x27;);<br>function lozyLoad()&#123;<br>var scrollTop = document.body.scrollTop || document.documentElement.scrollTop;<br>var winHeight= window.innerHeight;<br>for(var i=0;i &lt; imgs.length;i++)&#123;<br>if(imgs[i].offsetTop &lt; scrollTop + winHeight )&#123;<br>imgs[i].src = imgs[i].getAttribute(&#x27;data-src&#x27;);<br>&#125;<br>&#125;<br>&#125;<br>  window.onscroll = lozyLoad();<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><h3 id="4-懒加载与预加载的区别"><a href="#4-懒加载与预加载的区别" class="headerlink" title="4. 懒加载与预加载的区别"></a>4. 懒加载与预加载的区别</h3><p>这两种方式都是提高网页性能的方式，两者主要区别是一个是提前加载，一个是迟缓甚至不加载。懒加载对服务器前端有一定的缓解压力作用，预加载则会增加服务器前端压力。</p><ul><li><strong>懒加载也叫延迟加载，指的是在长网页中延迟加载图片的时机，当用户需要访问时，再去加载</strong>，这样可以提高网站的首屏加载速度，提升用户的体验，并且可以减少服务器的压力。它适用于图片很多，页面很长的电商网站的场景。懒加载的实现原理是，将页面上的图片的 src 属性设置为空字符串，将图片的真实路径保存在一个自定义属性中，当页面滚动的时候，进行判断，如果图片进入页面可视区域内，则从自定义属性中取出真实路径赋值给图片的 src 属性，以此来实现图片的延迟加载。</li><li><strong>预加载指的是将所需的资源提前请求加载到本地，这样后面在需要用到时就直接从缓存取资源。</strong> 通过预加载能够减少用户的等待时间，提高用户的体验。我了解的预加载的最常用的方式是使用 js 中的 image 对象，通过为 image 对象来设置 scr 属性，来实现图片的预加载。</li></ul><h2 id="三、回流与重绘"><a href="#三、回流与重绘" class="headerlink" title="三、回流与重绘"></a>三、回流与重绘</h2><h3 id="1-回流与重绘的概念及触发条件"><a href="#1-回流与重绘的概念及触发条件" class="headerlink" title="1. 回流与重绘的概念及触发条件"></a>1. 回流与重绘的概念及触发条件</h3><h4 id="（1）回流"><a href="#（1）回流" class="headerlink" title="（1）回流"></a>（1）回流</h4><p>当渲染树中部分或者全部元素的尺寸、结构或者属性发生变化时，浏览器会重新渲染部分或者全部文档的过程就称为<strong>回流</strong>。</p><p>下面这些操作会导致回流：</p><ul><li>页面的首次渲染</li><li>浏览器的窗口大小发生变化</li><li>元素的内容发生变化</li><li>元素的尺寸或者位置发生变化</li><li>元素的字体大小发生变化</li><li>激活CSS伪类</li><li>查询某些属性或者调用某些方法</li><li>添加或者删除可见的DOM元素</li></ul><p>在触发回流（重排）的时候，由于浏览器渲染页面是基于流式布局的，所以当触发回流时，会导致周围的DOM元素重新排列，它的影响范围有两种：</p><ul><li>全局范围：从根节点开始，对整个渲染树进行重新布局</li><li>局部范围：对渲染树的某部分或者一个渲染对象进行重新布局</li></ul><h4 id="（2）重绘"><a href="#（2）重绘" class="headerlink" title="（2）重绘"></a>（2）重绘</h4><p>当页面中某些元素的样式发生变化，但是不会影响其在文档流中的位置时，浏览器就会对元素进行重新绘制，这个过程就是<strong>重绘</strong>。</p><p>下面这些操作会导致回流：</p><ul><li>color、background 相关属性：background-color、background-image 等</li><li>outline 相关属性：outline-color、outline-width 、text-decoration</li><li>border-radius、visibility、box-shadow</li></ul><p>注意： <strong>当触发回流时，一定会触发重绘，但是重绘不一定会引发回流。</strong></p><h3 id="2-如何避免回流与重绘？"><a href="#2-如何避免回流与重绘？" class="headerlink" title="2. 如何避免回流与重绘？"></a>2. 如何避免回流与重绘？</h3><p><strong>减少回流与重绘的措施：</strong></p><ul><li>操作DOM时，尽量在低层级的DOM节点进行操作</li><li>不要使用<code>table</code>布局， 一个小的改动可能会使整个<code>table</code>进行重新布局</li><li>使用CSS的表达式</li><li>不要频繁操作元素的样式，对于静态页面，可以修改类名，而不是样式。</li><li>使用absolute或者fixed，使元素脱离文档流，这样他们发生变化就不会影响其他元素</li><li>避免频繁操作DOM，可以创建一个文档片段<code>documentFragment</code>，在它上面应用所有DOM操作，最后再把它添加到文档中</li><li>将元素先设置<code>display: none</code>，操作结束后再把它显示出来。因为在display属性为none的元素上进行的DOM操作不会引发回流和重绘。</li><li>将DOM的多个读操作（或者写操作）放在一起，而不是读写操作穿插着写。这得益于<strong>浏览器的渲染队列机制</strong>。</li></ul><p>浏览器针对页面的回流与重绘，进行了自身的优化——<strong>渲染队列</strong></p><p><strong>浏览器会将所有的回流、重绘的操作放在一个队列中，当队列中的操作到了一定的数量或者到了一定的时间间隔，浏览器就会对队列进行批处理。这样就会让多次的回流、重绘变成一次回流重绘。</strong></p><p>上面，将多个读操作（或者写操作）放在一起，就会等所有的读操作进入队列之后执行，这样，原本应该是触发多次回流，变成了只触发一次回流。</p><h3 id="3-如何优化动画？"><a href="#3-如何优化动画？" class="headerlink" title="3. 如何优化动画？"></a>3. 如何优化动画？</h3><p>对于如何优化动画，我们知道，一般情况下，动画需要频繁的操作DOM，就就会导致页面的性能问题，我们可以将动画的<code>position</code>属性设置为<code>absolute</code>或者<code>fixed</code>，将动画脱离文档流，这样他的回流就不会影响到页面了。</p><h3 id="4-documentFragment-是什么？用它跟直接操作-DOM-的区别是什么？"><a href="#4-documentFragment-是什么？用它跟直接操作-DOM-的区别是什么？" class="headerlink" title="4. documentFragment 是什么？用它跟直接操作 DOM 的区别是什么？"></a>4. documentFragment 是什么？用它跟直接操作 DOM 的区别是什么？</h3><p>MDN中对<code>documentFragment</code>的解释：</p><blockquote><p>DocumentFragment，文档片段接口，一个没有父对象的最小文档对象。它被作为一个轻量版的 Document使用，就像标准的document一样，存储由节点（nodes）组成的文档结构。与document相比，最大的区别是DocumentFragment不是真实 DOM 树的一部分，它的变化不会触发 DOM 树的重新渲染，且不会导致性能等问题。</p></blockquote><p>当我们把一个 DocumentFragment 节点插入文档树时，插入的不是 DocumentFragment 自身，而是它的所有子孙节点。在频繁的DOM操作时，我们就可以将DOM元素插入DocumentFragment，之后一次性的将所有的子孙节点插入文档中。和直接操作DOM相比，将DocumentFragment 节点插入DOM树时，不会触发页面的重绘，这样就大大提高了页面的性能。</p><h2 id="四、节流与防抖"><a href="#四、节流与防抖" class="headerlink" title="四、节流与防抖"></a>四、节流与防抖</h2><h3 id="1-对节流与防抖的理解"><a href="#1-对节流与防抖的理解" class="headerlink" title="1. 对节流与防抖的理解"></a>1. 对节流与防抖的理解</h3><ul><li>函数防抖是指在事件被触发 n 秒后再执行回调，如果在这 n 秒内事件又被触发，则重新计时。这可以使用在一些点击请求的事件上，避免因为用户的多次点击向后端发送多次请求。</li><li>函数节流是指规定一个单位时间，在这个单位时间内，只能有一次触发事件的回调函数执行，如果在同一个单位时间内某事件被触发多次，只有一次能生效。节流可以使用在 scroll 函数的事件监听上，通过事件节流来降低事件调用的频率。</li></ul><p><strong>防抖函数的应用场景：</strong></p><ul><li>按钮提交场景：防⽌多次提交按钮，只执⾏最后提交的⼀次 </li><li>服务端验证场景：表单验证需要服务端配合，只执⾏⼀段连续的输⼊事件的最后⼀次，还有搜索联想词功能类似⽣存环境请⽤lodash.debounce</li></ul><p><strong>节流函数的适⽤场景：</strong></p><ul><li>拖拽场景：固定时间内只执⾏⼀次，防⽌超⾼频次触发位置变动 </li><li>缩放场景：监控浏览器resize </li><li>动画场景：避免短时间内多次触发动画引起性能问题</li></ul><h3 id="2-实现节流函数和防抖函数"><a href="#2-实现节流函数和防抖函数" class="headerlink" title="2. 实现节流函数和防抖函数"></a>2. 实现节流函数和防抖函数</h3><p><strong>函数防抖的实现：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">debounce</span>(<span class="hljs-params">fn, wait</span>) &#123;<br>  <span class="hljs-keyword">var</span> timer = <span class="hljs-literal">null</span>;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">var</span> context = <span class="hljs-variable language_">this</span>,<br>      args = [...<span class="hljs-variable language_">arguments</span>];<br><br>    <span class="hljs-comment">// 如果此时存在定时器的话，则取消之前的定时器重新记时</span><br>    <span class="hljs-keyword">if</span> (timer) &#123;<br>      <span class="hljs-built_in">clearTimeout</span>(timer);<br>      timer = <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 设置定时器，使事件间隔指定事件后执行</span><br>    timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      fn.<span class="hljs-title function_">apply</span>(context, args);<br>    &#125;, wait);<br>  &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>函数节流的实现：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 时间戳版</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">throttle</span>(<span class="hljs-params">fn, delay</span>) &#123;<br>  <span class="hljs-keyword">var</span> preTime = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>();<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">var</span> context = <span class="hljs-variable language_">this</span>,<br>      args = [...<span class="hljs-variable language_">arguments</span>],<br>      nowTime = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>();<br><br>    <span class="hljs-comment">// 如果两次时间间隔超过了指定时间，则执行函数。</span><br>    <span class="hljs-keyword">if</span> (nowTime - preTime &gt;= delay) &#123;<br>      preTime = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>();<br>      <span class="hljs-keyword">return</span> fn.<span class="hljs-title function_">apply</span>(context, args);<br>    &#125;<br>  &#125;;<br>&#125;<br><br><span class="hljs-comment">// 定时器版</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">throttle</span> (fun, wait)&#123;<br>  <span class="hljs-keyword">let</span> timeout = <span class="hljs-literal">null</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">let</span> context = <span class="hljs-variable language_">this</span><br>    <span class="hljs-keyword">let</span> args = [...<span class="hljs-variable language_">arguments</span>]<br>    <span class="hljs-keyword">if</span>(!timeout)&#123;<br>      timeout = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        fun.<span class="hljs-title function_">apply</span>(context, args)<br>        timeout = <span class="hljs-literal">null</span> <br>      &#125;, wait)<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="五、图片优化"><a href="#五、图片优化" class="headerlink" title="五、图片优化"></a>五、图片优化</h2><h3 id="1-如何对项目中的图片进行优化？"><a href="#1-如何对项目中的图片进行优化？" class="headerlink" title="1. 如何对项目中的图片进行优化？"></a>1. 如何对项目中的图片进行优化？</h3><ol><li>不用图片。很多时候会使用到很多修饰类图片，其实这类修饰图片完全可以用 CSS 去代替。</li><li>对于移动端来说，屏幕宽度就那么点，完全没有必要去加载原图浪费带宽。一般图片都用 CDN 加载，可以计算出适配屏幕的宽度，然后去请求相应裁剪好的图片。</li><li>小图使用 base64 格式</li><li>将多个图标文件整合到一张图片中（雪碧图）</li><li>选择正确的图片格式：<ul><li>对于能够显示 WebP 格式的浏览器尽量使用 WebP 格式。因为 WebP 格式具有更好的图像数据压缩算法，能带来更小的图片体积，而且拥有肉眼识别无差异的图像质量，缺点就是兼容性并不好</li><li>小图使用 PNG，其实对于大部分图标这类图片，完全可以使用 SVG 代替</li><li>照片使用 JPEG</li></ul></li></ol><h3 id="2-常见的图片格式及使用场景"><a href="#2-常见的图片格式及使用场景" class="headerlink" title="2. 常见的图片格式及使用场景"></a>2. 常见的图片格式及使用场景</h3><p>（1）<strong>BMP</strong>，是无损的、既支持索引色也支持直接色的点阵图。这种图片格式几乎没有对数据进行压缩，所以BMP格式的图片通常是较大的文件。</p><p>（2）<strong>GIF</strong>是无损的、采用索引色的点阵图。采用LZW压缩算法进行编码。文件小，是GIF格式的优点，同时，GIF格式还具有支持动画以及透明的优点。但是GIF格式仅支持8bit的索引色，所以GIF格式适用于对色彩要求不高同时需要文件体积较小的场景。</p><p>（3）<strong>JPEG</strong>是有损的、采用直接色的点阵图。JPEG的图片的优点是采用了直接色，得益于更丰富的色彩，JPEG非常适合用来存储照片，与GIF相比，JPEG不适合用来存储企业Logo、线框类的图。因为有损压缩会导致图片模糊，而直接色的选用，又会导致图片文件较GIF更大。</p><p>（4）<strong>PNG-8</strong>是无损的、使用索引色的点阵图。PNG是一种比较新的图片格式，PNG-8是非常好的GIF格式替代者，在可能的情况下，应该尽可能的使用PNG-8而不是GIF，因为在相同的图片效果下，PNG-8具有更小的文件体积。除此之外，PNG-8还支持透明度的调节，而GIF并不支持。除非需要动画的支持，否则没有理由使用GIF而不是PNG-8。</p><p>（5）<strong>PNG-24</strong>是无损的、使用直接色的点阵图。PNG-24的优点在于它压缩了图片的数据，使得同样效果的图片，PNG-24格式的文件大小要比BMP小得多。当然，PNG24的图片还是要比JPEG、GIF、PNG-8大得多。</p><p>（6）<strong>SVG</strong>是无损的矢量图。SVG是矢量图意味着SVG图片由直线和曲线以及绘制它们的方法组成。当放大SVG图片时，看到的还是线和曲线，而不会出现像素点。这意味着SVG图片在放大时，不会失真，所以它非常适合用来绘制Logo、Icon等。</p><p>（7）<strong>WebP</strong>是谷歌开发的一种新图片格式，WebP是同时支持有损和无损压缩的、使用直接色的点阵图。从名字就可以看出来它是为Web而生的，什么叫为Web而生呢？就是说相同质量的图片，WebP具有更小的文件体积。现在网站上充满了大量的图片，如果能够降低每一个图片的文件大小，那么将大大减少浏览器和服务器之间的数据传输量，进而降低访问延迟，提升访问体验。目前只有Chrome浏览器和Opera浏览器支持WebP格式，兼容性不太好。</p><ul><li>在无损压缩的情况下，相同质量的WebP图片，文件大小要比PNG小26%；</li><li>在有损压缩的情况下，具有相同图片精度的WebP图片，文件大小要比JPEG小25%~34%；</li><li>WebP图片格式支持图片透明度，一个无损压缩的WebP图片，如果要支持透明度只需要22%的格外文件大小。</li></ul><h2 id="六、Webpack优化"><a href="#六、Webpack优化" class="headerlink" title="六、Webpack优化"></a>六、Webpack优化</h2><h3 id="1-如何提⾼webpack的打包速度"><a href="#1-如何提⾼webpack的打包速度" class="headerlink" title="1. 如何提⾼webpack的打包速度?"></a>1. 如何提⾼<strong>webpack</strong>的打包速度?</h3><h4 id="（1）优化-Loader"><a href="#（1）优化-Loader" class="headerlink" title="（1）优化 Loader"></a>（1）优化 Loader</h4><p>对于 Loader 来说，影响打包效率首当其冲必属 Babel 了。因为 Babel 会将代码转为字符串生成 AST，然后对 AST 继续进行转变最后再生成新的代码，项目越大，<strong>转换代码越多，效率就越低</strong>。当然了，这是可以优化的。</p><p>首先我们<strong>优化 Loader 的文件搜索范围</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-attr">module</span>: &#123;<br>    <span class="hljs-attr">rules</span>: [<br>      &#123;<br>        <span class="hljs-comment">// js 文件才使用 babel</span><br>        <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.js$/</span>,<br>        <span class="hljs-attr">loader</span>: <span class="hljs-string">&#x27;babel-loader&#x27;</span>,<br>        <span class="hljs-comment">// 只在 src 文件夹下查找</span><br>        <span class="hljs-attr">include</span>: [<span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;src&#x27;</span>)],<br>        <span class="hljs-comment">// 不会去查找的路径</span><br>        <span class="hljs-attr">exclude</span>: <span class="hljs-regexp">/node_modules/</span><br>      &#125;<br>    ]<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>对于 Babel 来说，希望只作用在 JS 代码上的，然后 <code>node_modules</code> 中使用的代码都是编译过的，所以完全没有必要再去处理一遍。</p><p>当然这样做还不够，还可以将 Babel 编译过的文件<strong>缓存</strong>起来，下次只需要编译更改过的代码文件即可，这样可以大幅度加快打包时间</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-attr">loader</span>: <span class="hljs-string">&#x27;babel-loader?cacheDirectory=true&#x27;</span><br></code></pre></td></tr></table></figure><h4 id="（2）HappyPack"><a href="#（2）HappyPack" class="headerlink" title="（2）HappyPack"></a>（2）HappyPack</h4><p>受限于 Node 是单线程运行的，所以 Webpack 在打包的过程中也是单线程的，特别是在执行 Loader 的时候，长时间编译的任务很多，这样就会导致等待的情况。</p><p><strong>HappyPack 可以将 Loader 的同步执行转换为并行的</strong>，这样就能充分利用系统资源来加快打包效率了</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-attr">module</span>: &#123;<br>  <span class="hljs-attr">loaders</span>: [<br>    &#123;<br>      <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.js$/</span>,<br>      <span class="hljs-attr">include</span>: [<span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;src&#x27;</span>)],<br>      <span class="hljs-attr">exclude</span>: <span class="hljs-regexp">/node_modules/</span>,<br>      <span class="hljs-comment">// id 后面的内容对应下面</span><br>      <span class="hljs-attr">loader</span>: <span class="hljs-string">&#x27;happypack/loader?id=happybabel&#x27;</span><br>    &#125;<br>  ]<br>&#125;,<br><span class="hljs-attr">plugins</span>: [<br>  <span class="hljs-keyword">new</span> <span class="hljs-title class_">HappyPack</span>(&#123;<br>    <span class="hljs-attr">id</span>: <span class="hljs-string">&#x27;happybabel&#x27;</span>,<br>    <span class="hljs-attr">loaders</span>: [<span class="hljs-string">&#x27;babel-loader?cacheDirectory&#x27;</span>],<br>    <span class="hljs-comment">// 开启 4 个线程</span><br>    <span class="hljs-attr">threads</span>: <span class="hljs-number">4</span><br>  &#125;)<br>]<br></code></pre></td></tr></table></figure><h4 id="（3）DllPlugin"><a href="#（3）DllPlugin" class="headerlink" title="（3）DllPlugin"></a>（3）DllPlugin</h4><p><strong>DllPlugin 可以将特定的类库提前打包然后引入</strong>。这种方式可以极大的减少打包类库的次数，只有当类库更新版本才有需要重新打包，并且也实现了将公共代码抽离成单独文件的优化方案。DllPlugin的使用方法如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 单独配置在一个文件中</span><br><span class="hljs-comment">// webpack.dll.conf.js</span><br><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>)<br><span class="hljs-keyword">const</span> webpack = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;webpack&#x27;</span>)<br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-attr">entry</span>: &#123;<br>    <span class="hljs-comment">// 想统一打包的类库</span><br>    <span class="hljs-attr">vendor</span>: [<span class="hljs-string">&#x27;react&#x27;</span>]<br>  &#125;,<br>  <span class="hljs-attr">output</span>: &#123;<br>    <span class="hljs-attr">path</span>: path.<span class="hljs-title function_">join</span>(__dirname, <span class="hljs-string">&#x27;dist&#x27;</span>),<br>    <span class="hljs-attr">filename</span>: <span class="hljs-string">&#x27;[name].dll.js&#x27;</span>,<br>    <span class="hljs-attr">library</span>: <span class="hljs-string">&#x27;[name]-[hash]&#x27;</span><br>  &#125;,<br>  <span class="hljs-attr">plugins</span>: [<br>    <span class="hljs-keyword">new</span> webpack.<span class="hljs-title class_">DllPlugin</span>(&#123;<br>      <span class="hljs-comment">// name 必须和 output.library 一致</span><br>      <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;[name]-[hash]&#x27;</span>,<br>      <span class="hljs-comment">// 该属性需要与 DllReferencePlugin 中一致</span><br>      <span class="hljs-attr">context</span>: __dirname,<br>      <span class="hljs-attr">path</span>: path.<span class="hljs-title function_">join</span>(__dirname, <span class="hljs-string">&#x27;dist&#x27;</span>, <span class="hljs-string">&#x27;[name]-manifest.json&#x27;</span>)<br>    &#125;)<br>  ]<br>&#125;<br></code></pre></td></tr></table></figure><p>然后需要执行这个配置文件生成依赖文件，接下来需要使用 <code>DllReferencePlugin</code> 将依赖文件引入项目中</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// webpack.conf.js</span><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-comment">// ...省略其他配置</span><br>  <span class="hljs-attr">plugins</span>: [<br>    <span class="hljs-keyword">new</span> webpack.<span class="hljs-title class_">DllReferencePlugin</span>(&#123;<br>      <span class="hljs-attr">context</span>: __dirname,<br>      <span class="hljs-comment">// manifest 就是之前打包出来的 json 文件</span><br>      <span class="hljs-attr">manifest</span>: <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./dist/vendor-manifest.json&#x27;</span>),<br>    &#125;)<br>  ]<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="（4）代码压缩"><a href="#（4）代码压缩" class="headerlink" title="（4）代码压缩"></a>（4）代码压缩</h4><p>在 Webpack3 中，一般使用 <code>UglifyJS</code> 来压缩代码，但是这个是单线程运行的，为了加快效率，可以使用 <code>webpack-parallel-uglify-plugin</code> 来并行运行 <code>UglifyJS</code>，从而提高效率。</p><p>在 Webpack4 中，不需要以上这些操作了，只需要将 <code>mode</code> 设置为 <code>production</code> 就可以默认开启以上功能。代码压缩也是我们必做的性能优化方案，当然我们不止可以压缩 JS 代码，还可以压缩 HTML、CSS 代码，并且在压缩 JS 代码的过程中，我们还可以通过配置实现比如删除 <code>console.log</code> 这类代码的功能。</p><h4 id="（5）其他"><a href="#（5）其他" class="headerlink" title="（5）其他"></a>（5）其他</h4><p>可以通过一些小的优化点来加快打包速度</p><ul><li><code>resolve.extensions</code>：用来表明文件后缀列表，默认查找顺序是 <code>[&#39;.js&#39;, &#39;.json&#39;]</code>，如果你的导入文件没有添加后缀就会按照这个顺序查找文件。我们应该尽可能减少后缀列表长度，然后将出现频率高的后缀排在前面</li><li><code>resolve.alias</code>：可以通过别名的方式来映射一个路径，能让 Webpack 更快找到路径</li><li><code>module.noParse</code>：如果你确定一个文件下没有其他依赖，就可以使用该属性让 Webpack 不扫描该文件，这种方式对于大型的类库很有帮助</li></ul><h3 id="2-如何减少-Webpack-打包体积"><a href="#2-如何减少-Webpack-打包体积" class="headerlink" title="2. 如何减少 Webpack 打包体积"></a>2. 如何减少 Webpack 打包体积</h3><h4 id="（1）按需加载"><a href="#（1）按需加载" class="headerlink" title="（1）按需加载"></a>（1）按需加载</h4><p>在开发 SPA 项目的时候，项目中都会存在很多路由页面。如果将这些页面全部打包进一个 JS 文件的话，虽然将多个请求合并了，但是同样也加载了很多并不需要的代码，耗费了更长的时间。那么为了首页能更快地呈现给用户，希望首页能加载的文件体积越小越好，<strong>这时候就可以使用按需加载，将每个路由页面单独打包为一个文件</strong>。当然不仅仅路由可以按需加载，对于 <code>loadash</code> 这种大型类库同样可以使用这个功能。</p><p>按需加载的代码实现这里就不详细展开了，因为鉴于用的框架不同，实现起来都是不一样的。当然了，虽然他们的用法可能不同，但是底层的机制都是一样的。都是当使用的时候再去下载对应文件，返回一个 <code>Promise</code>，当 <code>Promise</code> 成功以后去执行回调。</p><h4 id="（2）Scope-Hoisting"><a href="#（2）Scope-Hoisting" class="headerlink" title="（2）Scope Hoisting"></a>（2）Scope Hoisting</h4><p><strong>Scope Hoisting 会分析出模块之间的依赖关系，尽可能的把打包出来的模块合并到一个函数中去。</strong></p><p>比如希望打包两个文件：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// test.js</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> a = <span class="hljs-number">1</span><br><span class="hljs-comment">// index.js</span><br><span class="hljs-keyword">import</span> &#123; a &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./test.js&#x27;</span><br></code></pre></td></tr></table></figure><p>对于这种情况，打包出来的代码会类似这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript">[<br>  <span class="hljs-comment">/* 0 */</span><br>  <span class="hljs-keyword">function</span> (<span class="hljs-params"><span class="hljs-variable language_">module</span>, <span class="hljs-built_in">exports</span>, <span class="hljs-built_in">require</span></span>) &#123;<br>    <span class="hljs-comment">//...</span><br>  &#125;,<br>  <span class="hljs-comment">/* 1 */</span><br>  <span class="hljs-keyword">function</span> (<span class="hljs-params"><span class="hljs-variable language_">module</span>, <span class="hljs-built_in">exports</span>, <span class="hljs-built_in">require</span></span>) &#123;<br>    <span class="hljs-comment">//...</span><br>  &#125;<br>]<br></code></pre></td></tr></table></figure><p>但是如果使用 Scope Hoisting ，代码就会尽可能的合并到一个函数中去，也就变成了这样的类似代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript">[<br>  <span class="hljs-comment">/* 0 */</span><br>  <span class="hljs-keyword">function</span> (<span class="hljs-params"><span class="hljs-variable language_">module</span>, <span class="hljs-built_in">exports</span>, <span class="hljs-built_in">require</span></span>) &#123;<br>    <span class="hljs-comment">//...</span><br>  &#125;<br>]<br></code></pre></td></tr></table></figure><p>这样的打包方式生成的代码明显比之前的少多了。如果在 Webpack4 中你希望开启这个功能，只需要启用 <code>optimization.concatenateModules</code> 就可以了：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-attr">optimization</span>: &#123;<br>    <span class="hljs-attr">concatenateModules</span>: <span class="hljs-literal">true</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="（3）Tree-Shaking"><a href="#（3）Tree-Shaking" class="headerlink" title="（3）Tree Shaking"></a>（3）Tree Shaking</h4><p><strong>Tree Shaking 可以实现删除项目中未被引用的代码</strong>，比如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// test.js</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> a = <span class="hljs-number">1</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> b = <span class="hljs-number">2</span><br><span class="hljs-comment">// index.js</span><br><span class="hljs-keyword">import</span> &#123; a &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./test.js&#x27;</span><br></code></pre></td></tr></table></figure><p>对于以上情况，<code>test</code> 文件中的变量 <code>b</code> 如果没有在项目中使用到的话，就不会被打包到文件中。</p><p>如果使用 Webpack 4 的话，开启生产环境就会自动启动这个优化功能。</p><h3 id="3-如何⽤webpack来优化前端性能？"><a href="#3-如何⽤webpack来优化前端性能？" class="headerlink" title="3. 如何⽤webpack来优化前端性能？"></a>3. 如何⽤<strong>webpack</strong>来优化前端性能？</h3><p>⽤webpack优化前端性能是指优化webpack的输出结果，让打包的最终结果在浏览器运⾏快速⾼效。 </p><ul><li><strong>压缩代码</strong>：删除多余的代码、注释、简化代码的写法等等⽅式。可以利⽤webpack的 UglifyJsPlugin 和 ParallelUglifyPlugin 来压缩JS⽂件， 利⽤ cssnano （css-loader?minimize）来压缩css </li><li><strong>利⽤CDN加速</strong>: 在构建过程中，将引⽤的静态资源路径修改为CDN上对应的路径。可以利⽤webpack对于 output 参数和各loader的 publicPath 参数来修改资源路径 </li><li><strong>Tree Shaking</strong>: 将代码中永远不会⾛到的⽚段删除掉。可以通过在启动webpack时追加参数 –optimize-minimize 来实现</li><li><strong>Code Splitting:</strong> 将代码按路由维度或者组件分块(chunk),这样做到按需加载,同时可以充分利⽤浏览器缓存 </li><li><strong>提取公共第三⽅库</strong>: SplitChunksPlugin插件来进⾏公共模块抽取,利⽤浏览器缓存可以⻓期缓存这些⽆需频繁变动的公共代码</li></ul><h3 id="4-如何提⾼webpack的构建速度？"><a href="#4-如何提⾼webpack的构建速度？" class="headerlink" title="4. 如何提⾼webpack的构建速度？"></a>4. 如何提⾼<strong>webpack</strong>的构建速度？</h3><ol><li>多⼊⼝情况下，使⽤ CommonsChunkPlugin 来提取公共代码 </li><li>通过 externals 配置来提取常⽤库 </li><li>利⽤ DllPlugin 和 DllReferencePlugin 预编译资源模块 通过 DllPlugin 来对那些我们引⽤但是绝对不会修改的npm包来进⾏预编译，再通过 DllReferencePlugin 将预编译的模块加载进来。 </li><li>使⽤ Happypack 实现多线程加速编译 </li><li>使⽤ webpack-uglify-parallel 来提升 uglifyPlugin 的压缩速度。 原理上 webpack-uglify-parallel 采⽤了多核并⾏压缩来提升压缩速度 </li><li>使⽤ Tree-shaking 和 Scope Hoisting 来剔除多余代码</li></ol>]]></content>
    
    
    <categories>
      
      <category>BGW</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>BGW-浏览器原理</title>
    <link href="/2023/04/18/BGW-%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8E%9F%E7%90%86/"/>
    <url>/2023/04/18/BGW-%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p>BGW-浏览器原理</p><p> <img src="1.png" alt="img"></p><h2 id="一、浏览器安全"><a href="#一、浏览器安全" class="headerlink" title="一、浏览器安全"></a>一、浏览器安全</h2><h3 id="1-什么是-XSS-攻击？"><a href="#1-什么是-XSS-攻击？" class="headerlink" title="1.  什么是 XSS 攻击？"></a>1.  什么是 XSS 攻击？</h3><h4 id="（1）概念"><a href="#（1）概念" class="headerlink" title="（1）概念"></a>（1）概念</h4><p>XSS 攻击指的是跨站脚本攻击，是一种代码注入攻击。攻击者通过在网站注入恶意脚本，使之在用户的浏览器上运行，从而盗取用户的信息如 cookie 等。</p><p>XSS 的本质是因为网站没有对恶意代码进行过滤，与正常的代码混合在一起了，浏览器没有办法分辨哪些脚本是可信的，从而导致了恶意代码的执行。</p><p>攻击者可以通过这种攻击方式可以进行以下操作：</p><ul><li>获取页面的数据，如DOM、cookie、localStorage；</li><li>DOS攻击，发送合理请求，占用服务器资源，从而使用户无法访问服务器；</li><li>破坏页面结构；</li><li>流量劫持（将链接指向某网站）；</li></ul><h4 id="（2）攻击类型"><a href="#（2）攻击类型" class="headerlink" title="（2）攻击类型"></a>（2）攻击类型</h4><p>XSS 可以分为存储型、反射型和 DOM 型：</p><ul><li>存储型指的是恶意脚本会存储在目标服务器上，当浏览器请求数据时，脚本从服务器传回并执行。</li><li>反射型指的是攻击者诱导用户访问一个带有恶意代码的 URL 后，服务器端接收数据后处理，然后把带有恶意代码的数据发送到浏览器端，浏览器端解析这段带有 XSS 代码的数据后当做脚本执行，最终完成 XSS 攻击。 </li><li>DOM 型指的通过修改页面的 DOM 节点形成的 XSS。</li></ul><p><strong>1）存储型 XSS 的攻击步骤：</strong></p><ol><li>攻击者将恶意代码提交到⽬标⽹站的数据库中。 </li><li>⽤户打开⽬标⽹站时，⽹站服务端将恶意代码从数据库取出，拼接在 HTML 中返回给浏览器。 </li><li>⽤户浏览器接收到响应后解析执⾏，混在其中的恶意代码也被执⾏。 </li><li>恶意代码窃取⽤户数据并发送到攻击者的⽹站，或者冒充⽤户的⾏为，调⽤⽬标⽹站接⼝执⾏攻击者指定的操作。</li></ol><p>这种攻击常⻅于带有⽤户保存数据的⽹站功能，如论坛发帖、商品评论、⽤户私信等。</p><p><strong>2）反射型 XSS 的攻击步骤：</strong></p><ol><li>攻击者构造出特殊的 URL，其中包含恶意代码。 </li><li>⽤户打开带有恶意代码的 URL 时，⽹站服务端将恶意代码从 URL 中取出，拼接在 HTML 中返回给浏览器。 </li><li>⽤户浏览器接收到响应后解析执⾏，混在其中的恶意代码也被执⾏。 </li><li>恶意代码窃取⽤户数据并发送到攻击者的⽹站，或者冒充⽤户的⾏为，调⽤⽬标⽹站接⼝执⾏攻击者指定的操作。</li></ol><p>反射型 XSS 跟存储型 XSS 的区别是：存储型 XSS 的恶意代码存在数据库⾥，反射型 XSS 的恶意代码存在 URL ⾥。 </p><p>反射型 XSS 漏洞常⻅于通过 URL 传递参数的功能，如⽹站搜索、跳转等。 由于需要⽤户主动打开恶意的 URL 才能⽣效，攻击者往往会结合多种⼿段诱导⽤户点击。  </p><p><strong>3）DOM 型 XSS 的攻击步骤：</strong> </p><ol><li>攻击者构造出特殊的 URL，其中包含恶意代码。 </li><li>⽤户打开带有恶意代码的 URL。 </li><li>⽤户浏览器接收到响应后解析执⾏，前端 JavaScript 取出 URL 中的恶意代码并执⾏。 </li><li>恶意代码窃取⽤户数据并发送到攻击者的⽹站，或者冒充⽤户的⾏为，调⽤⽬标⽹站接⼝执⾏攻击者指定的操作。</li></ol><p>DOM 型 XSS 跟前两种 XSS 的区别：DOM 型 XSS 攻击中，取出和执⾏恶意代码由浏览器端完成，属于前端JavaScript ⾃身的安全漏洞，⽽其他两种 XSS 都属于服务端的安全漏洞。 </p><h3 id="2-如何防御-XSS-攻击？"><a href="#2-如何防御-XSS-攻击？" class="headerlink" title="2. 如何防御 XSS 攻击？"></a>2. 如何防御 XSS 攻击？</h3><p>可以看到XSS危害如此之大， 那么在开发网站时就要做好防御措施，具体措施如下：</p><ul><li>可以从浏览器的执行来进行预防，一种是使用纯前端的方式，不用服务器端拼接后返回（不使用服务端渲染）。另一种是对需要插入到 HTML 中的代码做好充分的转义。对于 DOM 型的攻击，主要是前端脚本的不可靠而造成的，对于数据获取渲染和字符串拼接的时候应该对可能出现的恶意代码情况进行判断。</li><li>使用 CSP ，CSP 的本质是建立一个白名单，告诉浏览器哪些外部资源可以加载和执行，从而防止恶意代码的注入攻击。</li></ul><blockquote><ol><li>CSP 指的是内容安全策略，它的本质是建立一个白名单，告诉浏览器哪些外部资源可以加载和执行。我们只需要配置规则，如何拦截由浏览器自己来实现。</li><li>通常有两种方式来开启 CSP，一种是设置 HTTP 首部中的 Content-Security-Policy，一种是设置 meta 标签的方式 <meta http-equiv="Content-Security-Policy"></li></ol></blockquote><ul><li>对一些敏感信息进行保护，比如 cookie 使用 http-only，使得脚本无法获取。也可以使用验证码，避免脚本伪装成用户执行一些操作。</li></ul><h3 id="3-什么是-CSRF-攻击？"><a href="#3-什么是-CSRF-攻击？" class="headerlink" title="3. 什么是 CSRF 攻击？"></a>3. 什么是 CSRF 攻击？</h3><h4 id="（1）概念-1"><a href="#（1）概念-1" class="headerlink" title="（1）概念"></a>（1）概念</h4><p>CSRF 攻击指的是<strong>跨站请求伪造攻击</strong>，攻击者诱导用户进入一个第三方网站，然后该网站向被攻击网站发送跨站请求。如果用户在被攻击网站中保存了登录状态，那么攻击者就可以利用这个登录状态，绕过后台的用户验证，冒充用户向服务器执行一些操作。</p><p>CSRF 攻击的<strong>本质是利用 cookie 会在同源请求中携带发送给服务器的特点，以此来实现用户的冒充。</strong></p><h4 id="（2）攻击类型-1"><a href="#（2）攻击类型-1" class="headerlink" title="（2）攻击类型"></a>（2）攻击类型</h4><p>常见的 CSRF 攻击有三种：</p><ul><li>GET 类型的 CSRF 攻击，比如在网站中的一个 img 标签里构建一个请求，当用户打开这个网站的时候就会自动发起提交。</li><li>POST 类型的 CSRF 攻击，比如构建一个表单，然后隐藏它，当用户进入页面时，自动提交这个表单。</li><li>链接类型的 CSRF 攻击，比如在 a 标签的 href 属性里构建一个请求，然后诱导用户去点击。</li></ul><h3 id="4-如何防御-CSRF-攻击？"><a href="#4-如何防御-CSRF-攻击？" class="headerlink" title="4. 如何防御 CSRF 攻击？"></a>4. 如何防御 CSRF 攻击？</h3><p><strong>CSRF 攻击可以使用以下方法来防护：</strong></p><ul><li><strong>进行同源检测</strong>，服务器根据 http 请求头中 origin 或者 referer 信息来判断请求是否为允许访问的站点，从而对请求进行过滤。当 origin 或者 referer 信息都不存在的时候，直接阻止请求。这种方式的缺点是有些情况下 referer 可以被伪造，同时还会把搜索引擎的链接也给屏蔽了。所以一般网站会允许搜索引擎的页面请求，但是相应的页面请求这种请求方式也可能被攻击者给利用。（Referer 字段会告诉服务器该网页是从哪个页面链接过来的）</li><li><strong>使用 CSRF Token 进行验证</strong>，服务器向用户返回一个随机数 Token ，当网站再次发起请求时，在请求参数中加入服务器端返回的 token ，然后服务器对这个 token 进行验证。这种方法解决了使用 cookie 单一验证方式时，可能会被冒用的问题，但是这种方法存在一个缺点就是，我们需要给网站中的所有请求都添加上这个 token，操作比较繁琐。还有一个问题是一般不会只有一台网站服务器，如果请求经过负载平衡转移到了其他的服务器，但是这个服务器的 session 中没有保留这个 token 的话，就没有办法验证了。这种情况可以通过改变 token 的构建方式来解决。</li><li><strong>对 Cookie 进行双重验证</strong>，服务器在用户访问网站页面时，向请求域名注入一个Cookie，内容为随机字符串，然后当用户再次向服务器发送请求的时候，从 cookie 中取出这个字符串，添加到 URL 参数中，然后服务器通过对 cookie 中的数据和参数中的数据进行比较，来进行验证。使用这种方式是利用了攻击者只能利用 cookie，但是不能访问获取 cookie 的特点。并且这种方法比 CSRF Token 的方法更加方便，并且不涉及到分布式访问的问题。这种方法的缺点是如果网站存在 XSS 漏洞的，那么这种方式会失效。同时这种方式不能做到子域名的隔离。</li><li><strong>在设置 cookie 属性的时候设置 Samesite ，限制 cookie 不能作为被第三方使用</strong>，从而可以避免被攻击者利用。Samesite 一共有两种模式，一种是严格模式，在严格模式下 cookie 在任何情况下都不可能作为第三方 Cookie 使用，在宽松模式下，cookie 可以被请求是 GET 请求，且会发生页面跳转的请求所使用。</li></ul><h3 id="5-什么是中间人攻击？如何防范中间人攻击？"><a href="#5-什么是中间人攻击？如何防范中间人攻击？" class="headerlink" title="5. 什么是中间人攻击？如何防范中间人攻击？"></a>5. 什么是中间人攻击？如何防范中间人攻击？</h3><p>中间⼈ (Man-in-the-middle attack, MITM) 是指攻击者与通讯的两端分别创建独⽴的联系, 并交换其所收到的数据, 使通讯的两端认为他们正在通过⼀个私密的连接与对⽅直接对话, 但事实上整个会话都被攻击者完全控制。在中间⼈攻击中，攻击者可以拦截通讯双⽅的通话并插⼊新的内容。</p><p>攻击过程如下: </p><ul><li>客户端发送请求到服务端，请求被中间⼈截获 </li><li>服务器向客户端发送公钥 </li><li>中间⼈截获公钥，保留在⾃⼰⼿上。然后⾃⼰⽣成⼀个<strong>伪造的</strong>公钥，发给客户端 </li><li>客户端收到伪造的公钥后，⽣成加密hash值发给服务器 </li><li>中间⼈获得加密hash值，⽤⾃⼰的私钥解密获得真秘钥,同时⽣成假的加密hash值，发给服务器 </li><li>服务器⽤私钥解密获得假密钥,然后加密数据传输给客户端</li></ul><h3 id="6-有哪些可能引起前端安全的问题"><a href="#6-有哪些可能引起前端安全的问题" class="headerlink" title="6. 有哪些可能引起前端安全的问题?"></a>6. 有哪些可能引起前端安全的问题?</h3><ul><li>跨站脚本 (Cross-Site Scripting, XSS): ⼀种代码注⼊⽅式, 为了与 CSS 区分所以被称作 XSS。早期常⻅于⽹络论坛, 起因是⽹站没有对⽤户的输⼊进⾏严格的限制, 使得攻击者可以将脚本上传到帖⼦让其他⼈浏览到有恶意脚本的⻚⾯, 其注⼊⽅式很简单包括但不限于 JavaScript &#x2F; CSS &#x2F; Flash 等； </li><li>iframe的滥⽤: iframe中的内容是由第三⽅来提供的，默认情况下他们不受控制，他们可以在iframe中运⾏JavaScirpt脚本、Flash插件、弹出对话框等等，这可能会破坏前端⽤户体验；</li><li>跨站点请求伪造（Cross-Site Request Forgeries，CSRF）: 指攻击者通过设置好的陷阱，强制对已完成认证的⽤户进⾏⾮预期的个⼈信息或设定信息等某些状态更新，属于被动攻击 </li><li>恶意第三⽅库: ⽆论是后端服务器应⽤还是前端应⽤开发，绝⼤多数时候都是在借助开发框架和各种类库进⾏快速开发，⼀旦第三⽅库被植⼊恶意代码很容易引起安全问题。</li></ul><h3 id="7-网络劫持有哪几种，如何防范？"><a href="#7-网络劫持有哪几种，如何防范？" class="headerlink" title="7. 网络劫持有哪几种，如何防范？"></a>7. 网络劫持有哪几种，如何防范？</h3><p>⽹络劫持分为两种: </p><p>（1）<strong>DNS劫持</strong>: (输⼊京东被强制跳转到淘宝这就属于dns劫持) </p><ul><li>DNS强制解析: 通过修改运营商的本地DNS记录，来引导⽤户流量到缓存服务器</li><li>302跳转的⽅式: 通过监控⽹络出⼝的流量，分析判断哪些内容是可以进⾏劫持处理的,再对劫持的内存发起302跳转的回复，引导⽤户获取内容</li></ul><p>（2）<strong>HTTP劫持</strong>: (访问⾕歌但是⼀直有贪玩蓝⽉的⼴告),由于http明⽂传输,运营商会修改你的http响应内容(即加⼴告) </p><p>DNS劫持由于涉嫌违法，已经被监管起来，现在很少会有DNS劫持，⽽http劫持依然⾮常盛⾏，最有效的办法就是全站HTTPS，将HTTP加密，这使得运营商⽆法获取明⽂，就⽆法劫持你的响应内容。 </p><h2 id="二、进程与线程"><a href="#二、进程与线程" class="headerlink" title="二、进程与线程"></a>二、进程与线程</h2><h3 id="1-进程与线程的概念"><a href="#1-进程与线程的概念" class="headerlink" title="1. 进程与线程的概念"></a>1. 进程与线程的概念</h3><p>从本质上说，进程和线程都是 CPU 工作时间片的一个描述：</p><ul><li>进程描述了 CPU 在运行指令及加载和保存上下文所需的时间，放在应用上来说就代表了一个程序。</li><li>线程是进程中的更小单位，描述了执行一段指令所需的时间。</li></ul><p><strong>进程是资源分配的最小单位，线程是CPU调度的最小单位。</strong></p><p>一个进程就是一个程序的运行实例。详细解释就是，启动一个程序的时候，操作系统会为该程序创建一块内存，用来存放代码、运行中的数据和一个执行任务的主线程，我们把这样的一个运行环境叫<strong>进程</strong>。<strong>进程是运行在虚拟内存上的，虚拟内存是用来解决用户对硬件资源的无限需求和有限的硬件资源之间的矛盾的。从操作系统角度来看，虚拟内存即交换文件；从处理器角度看，虚拟内存即虚拟地址空间。</strong></p><p>如果程序很多时，内存可能会不够，操作系统为每个进程提供一套独立的虚拟地址空间，从而使得同一块物理内存在不同的进程中可以对应到不同或相同的虚拟地址，变相的增加了程序可以使用的内存。</p><p>进程和线程之间的关系有以下四个特点：</p><p><strong>（1）进程中的任意一线程执行出错，都会导致整个进程的崩溃。</strong></p><p><strong>（2）线程之间共享进程中的数据。</strong></p><p><strong>（3）当一个进程关闭之后，操作系统会回收进程所占用的内存，</strong> 当一个进程退出时，操作系统会回收该进程所申请的所有资源；即使其中任意线程因为操作不当导致内存泄漏，当进程退出时，这些内存也会被正确回收。</p><p><strong>（4）进程之间的内容相互隔离。</strong> 进程隔离就是为了使操作系统中的进程互不干扰，每一个进程只能访问自己占有的数据，也就避免出现进程 A 写入数据到进程 B 的情况。正是因为进程之间的数据是严格隔离的，所以一个进程如果崩溃了，或者挂起了，是不会影响到其他进程的。如果进程之间需要进行数据的通信，这时候，就需要使用用于进程间通信的机制了。</p><p><strong>Chrome浏览器的架构图</strong>：<br><img src="2.png" alt="img"><br>从图中可以看出，最新的 Chrome 浏览器包括：</p><ul><li>1 个浏览器主进程</li><li>1 个 GPU 进程</li><li>1 个网络进程</li><li>多个渲染进程</li><li>多个插件进程</li></ul><p>这些进程的功能：</p><ul><li><strong>浏览器进程</strong>：主要负责界面显示、用户交互、子进程管理，同时提供存储等功能。</li><li><strong>渲染进程</strong>：核心任务是将 HTML、CSS 和 JavaScript 转换为用户可以与之交互的网页，排版引擎 Blink 和 JavaScript 引擎 V8 都是运行在该进程中，默认情况下，Chrome 会为每个 Tab 标签创建一个渲染进程。出于安全考虑，渲染进程都是运行在沙箱模式下。</li><li><strong>GPU 进程</strong>：其实， GPU 的使用初衷是为了实现 3D CSS 的效果，只是随后网页、Chrome 的 UI 界面都选择采用 GPU 来绘制，这使得 GPU 成为浏览器普遍的需求。最后，Chrome 在其多进程架构上也引入了 GPU 进程。</li><li><strong>网络进程</strong>：主要负责页面的网络资源加载，之前是作为一个模块运行在浏览器进程里面的，直至最近才独立出来，成为一个单独的进程。</li><li><strong>插件进程</strong>：主要是负责插件的运行，因插件易崩溃，所以需要通过插件进程来隔离，以保证插件进程崩溃不会对浏览器和页面造成影响。</li></ul><p>所以，<strong>打开一个网页，最少需要四个进程</strong>：1 个网络进程、1 个浏览器进程、1 个 GPU 进程以及 1 个渲染进程。如果打开的页面有运行插件的话，还需要再加上 1 个插件进程。</p><p>虽然多进程模型提升了浏览器的稳定性、流畅性和安全性，但同样不可避免地带来了一些问题：</p><ul><li><strong>更高的资源占用</strong>：因为每个进程都会包含公共基础结构的副本（如 JavaScript 运行环境），这就意味着浏览器会消耗更多的内存资源。</li><li><strong>更复杂的体系架构</strong>：浏览器各模块之间耦合性高、扩展性差等问题，会导致现在的架构已经很难适应新的需求了。</li></ul><h3 id="2-进程和线程的区别"><a href="#2-进程和线程的区别" class="headerlink" title="2. 进程和线程的区别"></a>2. 进程和线程的区别</h3><ul><li>进程可以看做独立应用，线程不能</li><li>资源：进程是cpu资源分配的最小单位（是能拥有资源和独立运行的最小单位）；线程是cpu调度的最小单位（线程是建立在进程的基础上的一次程序运行单位，一个进程中可以有多个线程）。</li><li>通信方面：线程间可以通过直接共享同一进程中的资源，而进程通信需要借助 进程间通信。</li><li>调度：进程切换比线程切换的开销要大。线程是CPU调度的基本单位，线程的切换不会引起进程切换，但某个进程中的线程切换到另一个进程中的线程时，会引起进程切换。</li><li>系统开销：由于创建或撤销进程时，系统都要为之分配或回收资源，如内存、I&#x2F;O 等，其开销远大于创建或撤销线程时的开销。同理，在进行进程切换时，涉及当前执行进程 CPU 环境还有各种各样状态的保存及新调度进程状态的设置，而线程切换时只需保存和设置少量寄存器内容，开销较小。</li></ul><h3 id="3-浏览器渲染进程的线程有哪些"><a href="#3-浏览器渲染进程的线程有哪些" class="headerlink" title="3. 浏览器渲染进程的线程有哪些"></a>3. 浏览器渲染进程的线程有哪些</h3><p>浏览器的渲染进程的线程总共有五种：<br><img src="3.png" alt="img"><br><strong>（1)GUI渲染线程</strong><br>负责渲染浏览器页面，解析HTML、CSS，构建DOM树、构建CSSOM树、构建渲染树和绘制页面；当界面需要<strong>重绘</strong>或由于某种操作引发<strong>回流</strong>时，该线程就会执行。</p><p>注意：GUI渲染线程和JS引擎线程是互斥的，当JS引擎执行时GUI线程会被挂起，GUI更新会被保存在一个队列中等到JS引擎空闲时立即被执行。</p><p><strong>（2）JS引擎线程</strong><br>JS引擎线程也称为JS内核，负责处理Javascript脚本程序，解析Javascript脚本，运行代码；JS引擎线程一直等待着任务队列中任务的到来，然后加以处理，一个Tab页中无论什么时候都只有一个JS引擎线程在运行JS程序；</p><p>注意：GUI渲染线程与JS引擎线程的互斥关系，所以如果JS执行的时间过长，会造成页面的渲染不连贯，导致页面渲染加载阻塞。</p><p><strong>（3）时间触发线程</strong><br><strong>时间触发线程</strong>属于浏览器而不是JS引擎，用来控制事件循环；当JS引擎执行代码块如setTimeOut时（也可是来自浏览器内核的其他线程,如鼠标点击、AJAX异步请求等），会将对应任务添加到事件触发线程中；当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，等待JS引擎的处理；</p><p>注意：由于JS的单线程关系，所以这些待处理队列中的事件都得排队等待JS引擎处理（当JS引擎空闲时才会去执行）；</p><p><strong>（4）定时器触发进程</strong><br><strong>定时器触发进程</strong>即setInterval与setTimeout所在线程；浏览器定时计数器并不是由JS引擎计数的，因为JS引擎是单线程的，如果处于阻塞线程状态就会影响记计时的准确性；因此使用单独线程来计时并触发定时器，计时完毕后，添加到事件队列中，等待JS引擎空闲后执行，所以定时器中的任务在设定的时间点不一定能够准时执行，定时器只是在指定时间点将任务添加到事件队列中；</p><p>注意：W3C在HTML标准中规定，定时器的定时时间不能小于4ms，如果是小于4ms，则默认为4ms。</p><p><strong>（5）异步http请求线程</strong></p><ul><li>XMLHttpRequest连接后通过浏览器新开一个线程请求；</li><li>检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将回调函数放入事件队列中，等待JS引擎空闲后执行；</li></ul><h3 id="4-进程之前的通信方式"><a href="#4-进程之前的通信方式" class="headerlink" title="4. 进程之前的通信方式"></a>4. 进程之前的通信方式</h3><p><strong>（1）管道通信</strong></p><p>管道是一种最基本的进程间通信机制。<strong>管道就是操作系统在内核中开辟的一段缓冲区，进程1可以将需要交互的数据拷贝到这段缓冲区，进程2就可以读取了。</strong></p><p>管道的特点：</p><ul><li>只能单向通信</li><li>只能血缘关系的进程进行通信</li><li>依赖于文件系统</li><li>生命周期随进程</li><li>面向字节流的服务</li><li>管道内部提供了同步机制</li></ul><p><strong>（2）消息队列通信</strong></p><p>消息队列就是一个消息的列表。用户可以在消息队列中添加消息、读取消息等。消息队列提供了一种从一个进程向另一个进程发送一个数据块的方法。 每个数据块都被认为含有一个类型，接收进程可以独立地接收含有不同类型的数据结构。可以通过发送消息来避免命名管道的同步和阻塞问题。但是消息队列与命名管道一样，每个数据块都有一个最大长度的限制。</p><p>使用消息队列进行进程间通信，可能会收到数据块最大长度的限制约束等，这也是这种通信方式的缺点。如果频繁的发生进程间的通信行为，那么进程需要频繁地读取队列中的数据到内存，相当于间接地从一个进程拷贝到另一个进程，这需要花费时间。</p><p><strong>（3）信号量通信</strong></p><p>共享内存最大的问题就是多进程竞争内存的问题，就像类似于线程安全问题。我们可以使用信号量来解决这个问题。信号量的本质就是一个计数器，用来实现进程之间的互斥与同步。例如信号量的初始值是 1，然后 a 进程来访问内存1的时候，我们就把信号量的值设为 0，然后进程b 也要来访问内存1的时候，看到信号量的值为 0 就知道已经有进程在访问内存1了，这个时候进程 b 就会访问不了内存1。所以说，信号量也是进程之间的一种通信方式。</p><p><strong>（4）信号通信</strong></p><p>信号（Signals ）是Unix系统中使用的最古老的进程间通信的方法之一。操作系统通过信号来通知进程系统中发生了某种预先规定好的事件（一组事件中的一个），它也是用户进程之间通信和同步的一种原始机制。</p><p><strong>（5）共享内存通信</strong></p><p>共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问（使多个进程可以访问同一块内存空间）。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号量，配合使用，来实现进程间的同步和通信。</p><p><strong>（6）套接字通信</strong></p><p>上面说的共享内存、管道、信号量、消息队列，他们都是多个进程在一台主机之间的通信，那两个相隔几千里的进程能够进行通信吗？答是必须的，这个时候 Socket 这家伙就派上用场了，例如我们平时通过浏览器发起一个 http 请求，然后服务器给你返回对应的数据，这种就是采用 Socket 的通信方式了。</p><h3 id="5-僵尸进程和孤儿进程是什么？"><a href="#5-僵尸进程和孤儿进程是什么？" class="headerlink" title="5. 僵尸进程和孤儿进程是什么？"></a>5. 僵尸进程和孤儿进程是什么？</h3><ul><li><strong>孤儿进程</strong>：父进程退出了，而它的一个或多个进程还在运行，那这些子进程都会成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。</li><li><strong>僵尸进程</strong>：子进程比父进程先结束，而父进程又没有释放子进程占用的资源，那么子进程的进程描述符仍然保存在系统中，这种进程称之为僵死进程。</li></ul><h3 id="6-死锁产生的原因？-如果解决死锁的问题？"><a href="#6-死锁产生的原因？-如果解决死锁的问题？" class="headerlink" title="6. 死锁产生的原因？ 如果解决死锁的问题？"></a>6. 死锁产生的原因？ 如果解决死锁的问题？</h3><p>所谓死锁，是指多个进程在运行过程中因争夺资源而造成的一种僵局，当进程处于这种僵持状态时，若无外力作用，它们都将无法再向前推进。</p><p>系统中的资源可以分为两类：</p><ul><li>可剥夺资源，是指某进程在获得这类资源后，该资源可以再被其他进程或系统剥夺，CPU和主存均属于可剥夺性资源；</li><li>不可剥夺资源，当系统把这类资源分配给某进程后，再不能强行收回，只能在进程用完后自行释放，如磁带机、打印机等。</li></ul><p><strong>产生死锁的原因：</strong></p><p><strong>（1）竞争资源</strong></p><ul><li>产生死锁中的竞争资源之一指的是<strong>竞争不可剥夺资源</strong>（例如：系统中只有一台打印机，可供进程P1使用，假定P1已占用了打印机，若P2继续要求打印机打印将阻塞）</li><li>产生死锁中的竞争资源另外一种资源指的是<strong>竞争临时资源</strong>（临时资源包括硬件中断、信号、消息、缓冲区内的消息等），通常消息通信顺序进行不当，则会产生死锁</li></ul><p><strong>（2）进程间推进顺序非法</strong></p><p>若P1保持了资源R1，P2保持了资源R2，系统处于不安全状态，因为这两个进程再向前推进，便可能发生死锁。例如，当P1运行到P1：Request（R2）时，将因R2已被P2占用而阻塞；当P2运行到P2：Request（R1）时，也将因R1已被P1占用而阻塞，于是发生进程死锁</p><p><strong>产生死锁的必要条件：</strong></p><ul><li>互斥条件：进程要求对所分配的资源进行排它性控制，即在一段时间内某资源仅为一进程所占用。</li><li>请求和保持条件：当进程因请求资源而阻塞时，对已获得的资源保持不放。</li><li>不剥夺条件：进程已获得的资源在未使用完之前，不能剥夺，只能在使用完时由自己释放。</li><li>环路等待条件：在发生死锁时，必然存在一个进程——资源的环形链。</li></ul><p><strong>预防死锁的方法：</strong></p><ul><li>资源一次性分配：一次性分配所有资源，这样就不会再有请求了（破坏请求条件）</li><li>只要有一个资源得不到分配，也不给这个进程分配其他的资源（破坏请保持条件）</li><li>可剥夺资源：即当某进程获得了部分资源，但得不到其它资源，则释放已占有的资源（破坏不可剥夺条件）</li><li>资源有序分配法：系统给每类资源赋予一个编号，每一个进程按编号递增的顺序请求资源，释放则相反（破坏环路等待条件）</li></ul><h3 id="7-如何实现浏览器内多个标签页之间的通信"><a href="#7-如何实现浏览器内多个标签页之间的通信" class="headerlink" title="7. 如何实现浏览器内多个标签页之间的通信?"></a>7. 如何实现浏览器内多个标签页之间的通信?</h3><p>实现多个标签页之间的通信，本质上都是通过中介者模式来实现的。因为标签页之间没有办法直接通信，因此我们可以找一个中介者，让标签页和中介者进行通信，然后让这个中介者来进行消息的转发。通信方法如下：</p><ul><li><strong>使用 websocket 协议</strong>，因为 websocket 协议可以实现服务器推送，所以服务器就可以用来当做这个中介者。标签页通过向服务器发送数据，然后由服务器向其他标签页推送转发。</li><li><strong>使用 ShareWorker 的方式</strong>，shareWorker 会在页面存在的生命周期内创建一个唯一的线程，并且开启多个页面也只会使用同一个线程。这个时候共享线程就可以充当中介者的角色。标签页间通过共享一个线程，然后通过这个共享的线程来实现数据的交换。</li><li><strong>使用 localStorage 的方式</strong>，我们可以在一个标签页对 localStorage 的变化事件进行监听，然后当另一个标签页修改数据的时候，我们就可以通过这个监听事件来获取到数据。这个时候 localStorage 对象就是充当的中介者的角色。</li><li><strong>使用 postMessage 方法</strong>，如果我们能够获得对应标签页的引用，就可以使用postMessage 方法，进行通信。</li></ul><h3 id="8-对Service-Worker的理解"><a href="#8-对Service-Worker的理解" class="headerlink" title="8. 对Service Worker的理解"></a>8. 对Service Worker的理解</h3><p>Service Worker 是运行在浏览器背后的<strong>独立线程</strong>，一般可以用来实现缓存功能。使用 Service Worker的话，传输协议必须为 <strong>HTTPS</strong>。因为 Service Worker 中涉及到请求拦截，所以必须使用 HTTPS 协议来保障安全。</p><p>Service Worker 实现缓存功能一般分为三个步骤：首先需要先注册 Service Worker，然后监听到 <code>install</code> 事件以后就可以缓存需要的文件，那么在下次用户访问的时候就可以通过拦截请求的方式查询是否存在缓存，存在缓存的话就可以直接读取缓存文件，否则就去请求数据。以下是这个步骤的实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// index.js</span><br><span class="hljs-keyword">if</span> (navigator.<span class="hljs-property">serviceWorker</span>) &#123;<br>  navigator.<span class="hljs-property">serviceWorker</span><br>    .<span class="hljs-title function_">register</span>(<span class="hljs-string">&#x27;sw.js&#x27;</span>)<br>    .<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">registration</span>) &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;service worker 注册成功&#x27;</span>)<br>    &#125;)<br>    .<span class="hljs-title function_">catch</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">err</span>) &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;servcie worker 注册失败&#x27;</span>)<br>    &#125;)<br>&#125;<br><span class="hljs-comment">// sw.js</span><br><span class="hljs-comment">// 监听 `install` 事件，回调中缓存所需文件</span><br>self.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;install&#x27;</span>, <span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> &#123;<br>  e.<span class="hljs-title function_">waitUntil</span>(<br>    caches.<span class="hljs-title function_">open</span>(<span class="hljs-string">&#x27;my-cache&#x27;</span>).<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">cache</span>) &#123;<br>      <span class="hljs-keyword">return</span> cache.<span class="hljs-title function_">addAll</span>([<span class="hljs-string">&#x27;./index.html&#x27;</span>, <span class="hljs-string">&#x27;./index.js&#x27;</span>])<br>    &#125;)<br>  )<br>&#125;)<br><span class="hljs-comment">// 拦截所有请求事件</span><br><span class="hljs-comment">// 如果缓存中已经有请求的数据就直接用缓存，否则去请求数据</span><br>self.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;fetch&#x27;</span>, <span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> &#123;<br>  e.<span class="hljs-title function_">respondWith</span>(<br>    caches.<span class="hljs-title function_">match</span>(e.<span class="hljs-property">request</span>).<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">response</span>) &#123;<br>      <span class="hljs-keyword">if</span> (response) &#123;<br>        <span class="hljs-keyword">return</span> response<br>      &#125;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;fetch source&#x27;</span>)<br>    &#125;)<br>  )<br>&#125;)<br></code></pre></td></tr></table></figure><p>打开页面，可以在开发者工具中的 <code>Application</code> 看到 Service Worker 已经启动了：<br><img src="4.png" alt="img"><br>在 Cache 中也可以发现所需的文件已被缓存：<br><img src="5.png" alt="img"></p><h2 id="三、浏览器缓存"><a href="#三、浏览器缓存" class="headerlink" title="三、浏览器缓存"></a>三、浏览器缓存</h2><h3 id="1-对浏览器的缓存机制的理解"><a href="#1-对浏览器的缓存机制的理解" class="headerlink" title="1. 对浏览器的缓存机制的理解"></a>1. 对浏览器的缓存机制的理解</h3><p><strong>浏览器缓存的全过程：</strong></p><ul><li>浏览器第一次加载资源，服务器返回 200，浏览器从服务器下载资源文件，并缓存资源文件与 response header，以供下次加载时对比使用；</li><li>下一次加载资源时，由于强制缓存优先级较高，先比较当前时间与上一次返回 200 时的时间差，如果没有超过 cache-control 设置的 max-age，则没有过期，并命中强缓存，直接从本地读取资源。如果浏览器不支持HTTP1.1，则使用 expires 头判断是否过期；</li><li>如果资源已过期，则表明强制缓存没有被命中，则开始协商缓存，向服务器发送带有 If-None-Match 和 If-Modified-Since 的请求；</li><li>服务器收到请求后，优先根据 Etag 的值判断被请求的文件有没有做修改，Etag 值一致则没有修改，命中协商缓存，返回 304；如果不一致则有改动，直接返回新的资源文件带上新的 Etag 值并返回 200；</li><li>如果服务器收到的请求没有 Etag 值，则将 If-Modified-Since 和被请求文件的最后修改时间做比对，一致则命中协商缓存，返回 304；不一致则返回新的 last-modified 和文件并返回 200；</li></ul><p><img src="6.png" alt="img"><br>很多网站的资源后面都加了版本号，这样做的目的是：每次升级了 JS 或 CSS 文件后，为了防止浏览器进行缓存，强制改变版本号，客户端浏览器就会重新下载新的 JS 或 CSS 文件 ，以保证用户能够及时获得网站的最新更新。</p><h3 id="2-浏览器资源缓存的位置有哪些？"><a href="#2-浏览器资源缓存的位置有哪些？" class="headerlink" title="2. 浏览器资源缓存的位置有哪些？"></a>2. 浏览器资源缓存的位置有哪些？</h3><p>资源缓存的位置一共有 3 种，按优先级从高到低分别是：</p><ol><li><p><strong>Service Worker：</strong>Service Worker 运行在 JavaScript 主线程之外，虽然由于脱离了浏览器窗体无法直接访问 DOM，但是它可以完成离线缓存、消息推送、网络代理等功能。它可以让我们<strong>自由控制</strong>缓存哪些文件、如何匹配缓存、如何读取缓存，并且<strong>缓存是持续性的</strong>。当 Service Worker 没有命中缓存的时候，需要去调用 <code>fetch</code> 函数获取  数据。也就是说，如果没有在 Service Worker 命中缓存，会根据缓存查找优先级去查找数据。<strong>但是不管是从 Memory Cache 中还是从网络请求中获取的数据，浏览器都会显示是从 Service Worker 中获取的内容。</strong></p></li><li><p><strong>Memory Cache：</strong> Memory Cache 就是内存缓存，它的效率最快，<strong>但是内存缓存虽然读取高效，可是缓存持续性很短，会随着进程的释放而释放。</strong>一旦我们关闭 Tab 页面，内存中的缓存也就被释放了。</p></li><li><p><strong>Disk Cache：</strong> Disk Cache 也就是存储在硬盘中的缓存，读取速度慢点，但是什么都能存储到磁盘中，比之 Memory Cache <strong>胜在容量和存储时效性上。</strong>在所有浏览器缓存中，Disk Cache 覆盖面基本是最大的。它会根据 HTTP Herder 中的字段判断哪些资源需要缓存，哪些资源可以不请求直接使用，哪些资源已经过期需要重新请求。<strong>并且即使在跨站点的情况下，相同地址的资源一旦被硬盘缓存下来，就不会再次去请求数据。</strong></p></li></ol><p><strong>Disk Cache：</strong> Push Cache 是 HTTP&#x2F;2 中的内容，当以上三种缓存都没有命中时，它才会被使用。并且缓存时间也很短暂，只在会话（Session）中存在，一旦会话结束就被释放。其具有以下特点：</p><ul><li>所有的资源都能被推送，但是 Edge 和 Safari 浏览器兼容性不怎么好</li><li>可以推送 <code>no-cache</code> 和 <code>no-store</code> 的资源</li><li>一旦连接被关闭，Push Cache 就被释放</li><li>多个页面可以使用相同的 HTTP&#x2F;2 连接，也就是说能使用同样的缓存</li><li>Push Cache 中的缓存只能被使用一次</li><li>浏览器可以拒绝接受已经存在的资源推送</li><li>可以给其他域名推送资源<strong>​</strong></li></ul><h3 id="3-协商缓存和强缓存的区别"><a href="#3-协商缓存和强缓存的区别" class="headerlink" title="3. 协商缓存和强缓存的区别"></a>3. 协商缓存和强缓存的区别</h3><h4 id="（1）强缓存"><a href="#（1）强缓存" class="headerlink" title="（1）强缓存"></a>（1）强缓存</h4><p>使用强缓存策略时，如果缓存资源有效，则直接使用缓存资源，不必再向服务器发起请求。</p><p>强缓存策略可以通过两种方式来设置，分别是 http 头信息中的 Expires 属性和 Cache-Control 属性。</p><p>（1）服务器通过在响应头中添加 Expires 属性，来指定资源的过期时间。在过期时间以内，该资源可以被缓存使用，不必再向服务器发送请求。这个时间是一个绝对时间，它是服务器的时间，因此可能存在这样的问题，就是客户端的时间和服务器端的时间不一致，或者用户可以对客户端时间进行修改的情况，这样就可能会影响缓存命中的结果。</p><p>（2）Expires 是 http1.0 中的方式，因为它的一些缺点，在 HTTP 1.1 中提出了一个新的头部属性就是 Cache-Control 属性，它提供了对资源的缓存的更精确的控制。它有很多不同的值，</p><p><code>Cache-Control</code>可设置的字段：</p><ul><li><code>public</code>：设置了该字段值的资源表示可以被任何对象（包括：发送请求的客户端、代理服务器等等）缓存。这个字段值不常用，一般还是使用max-age&#x3D;来精确控制；</li><li><code>private</code>：设置了该字段值的资源只能被用户浏览器缓存，不允许任何代理服务器缓存。在实际开发当中，对于一些含有用户信息的HTML，通常都要设置这个字段值，避免代理服务器(CDN)缓存；</li><li><code>no-cache</code>：设置了该字段需要先和服务端确认返回的资源是否发生了变化，如果资源未发生变化，则直接使用缓存好的资源；</li><li><code>no-store</code>：设置了该字段表示禁止任何缓存，每次都会向服务端发起新的请求，拉取最新的资源；</li><li><code>max-age=</code>：设置缓存的最大有效期，单位为秒；</li><li><code>s-maxage=</code>：优先级高于max-age&#x3D;，仅适用于共享缓存(CDN)，优先级高于max-age或者Expires头；</li><li><code>max-stale[=]</code>：设置了该字段表明客户端愿意接收已经过期的资源，但是不能超过给定的时间限制。</li></ul><p>一般来说只需要设置其中一种方式就可以实现强缓存策略，当两种方式一起使用时，Cache-Control 的优先级要高于 Expires。</p><p><strong>no-cache和no-store很容易混淆：</strong></p><ul><li>no-cache 是指先要和服务器确认是否有资源更新，在进行判断。也就是说没有强缓存，但是会有协商缓存；</li><li>no-store 是指不使用任何缓存，每次请求都直接从服务器获取资源。</li></ul><h4 id="（2）协商缓存"><a href="#（2）协商缓存" class="headerlink" title="（2）协商缓存"></a>（2）协商缓存</h4><p>如果命中强制缓存，我们无需发起新的请求，直接使用缓存内容，如果没有命中强制缓存，如果设置了协商缓存，这个时候协商缓存就会发挥作用了。</p><p>上面已经说到了，命中协商缓存的条件有两个：</p><ul><li><code>max-age=xxx</code> 过期了</li><li>值为<code>no-store</code></li></ul><p>使用协商缓存策略时，会先向服务器发送一个请求，如果资源没有发生修改，则返回一个 304 状态，让浏览器使用本地的缓存副本。如果资源发生了修改，则返回修改后的资源。</p><p>协商缓存也可以通过两种方式来设置，分别是 http 头信息中的<strong>Etag</strong> 和<strong>Last-Modified</strong>属性。</p><p>（1）服务器通过在响应头中添加 Last-Modified 属性来指出资源最后一次修改的时间，当浏览器下一次发起请求时，会在请求头中添加一个 If-Modified-Since 的属性，属性值为上一次资源返回时的 Last-Modified 的值。当请求发送到服务器后服务器会通过这个属性来和资源的最后一次的修改时间来进行比较，以此来判断资源是否做了修改。如果资源没有修改，那么返回 304 状态，让客户端使用本地的缓存。如果资源已经被修改了，则返回修改后的资源。使用这种方法有一个缺点，就是 Last-Modified 标注的最后修改时间只能精确到秒级，如果某些文件在1秒钟以内，被修改多次的话，那么文件已将改变了但是 Last-Modified 却没有改变，这样会造成缓存命中的不准确。</p><p>（2）因为 Last-Modified 的这种可能发生的不准确性，http 中提供了另外一种方式，那就是 Etag 属性。服务器在返回资源的时候，在头信息中添加了 Etag 属性，这个属性是资源生成的唯一标识符，当资源发生改变的时候，这个值也会发生改变。在下一次资源请求时，浏览器会在请求头中添加一个 If-None-Match 属性，这个属性的值就是上次返回的资源的 Etag 的值。服务接收到请求后会根据这个值来和资源当前的 Etag 的值来进行比较，以此来判断资源是否发生改变，是否需要返回资源。通过这种方式，比 Last-Modified 的方式更加精确。</p><p>当 Last-Modified 和 Etag 属性同时出现的时候，Etag 的优先级更高。使用协商缓存的时候，服务器需要考虑负载平衡的问题，因此多个服务器上资源的 Last-Modified 应该保持一致，因为每个服务器上 Etag 的值都不一样，因此在考虑负载平衡时，最好不要设置 Etag 属性。</p><p><strong>总结：</strong></p><p>强缓存策略和协商缓存策略在缓存命中时都会直接使用本地的缓存副本，区别只在于协商缓存会向服务器发送一次请求。它们缓存不命中时，都会向服务器发送请求来获取资源。在实际的缓存机制中，强缓存策略和协商缓存策略是一起合作使用的。浏览器首先会根据请求的信息判断，强缓存是否命中，如果命中则直接使用资源。如果不命中则根据头信息向服务器发起请求，使用协商缓存，如果协商缓存命中的话，则服务器不返回资源，浏览器直接使用本地资源的副本，如果协商缓存不命中，则浏览器返回最新的资源给浏览器。</p><h3 id="4-为什么需要浏览器缓存？"><a href="#4-为什么需要浏览器缓存？" class="headerlink" title="4. 为什么需要浏览器缓存？"></a>4. 为什么需要浏览器缓存？</h3><p>对于浏览器的缓存，主要针对的是前端的静态资源，最好的效果就是，在发起请求之后，拉取相应的静态资源，并保存在本地。如果服务器的静态资源没有更新，那么在下次请求的时候，就直接从本地读取即可，如果服务器的静态资源已经更新，那么我们再次请求的时候，就到服务器拉取新的资源，并保存在本地。这样就大大的减少了请求的次数，提高了网站的性能。这就要用到浏览器的缓存策略了。</p><p>所谓的<strong>浏览器缓存</strong>指的是浏览器将用户请求过的静态资源，存储到电脑本地磁盘中，当浏览器再次访问时，就可以直接从本地加载，不需要再去服务端请求了。</p><p>使用浏览器缓存，有以下优点：</p><ul><li>减少了服务器的负担，提高了网站的性能</li><li>加快了客户端网页的加载速度</li><li>减少了多余网络数据传输</li></ul><h3 id="5-点击刷新按钮或者按-F5、按-Ctrl-F5-（强制刷新）、地址栏回车有什么区别？"><a href="#5-点击刷新按钮或者按-F5、按-Ctrl-F5-（强制刷新）、地址栏回车有什么区别？" class="headerlink" title="5. 点击刷新按钮或者按 F5、按 Ctrl+F5 （强制刷新）、地址栏回车有什么区别？"></a>5. 点击刷新按钮或者按 F5、按 Ctrl+F5 （强制刷新）、地址栏回车有什么区别？</h3><ul><li><strong>点击刷新按钮或者按 F5：</strong> 浏览器直接对本地的缓存文件过期，但是会带上If-Modifed-Since，If-None-Match，这就意味着服务器会对文件检查新鲜度，返回结果可能是 304，也有可能是 200。</li><li><strong>用户按 Ctrl+F5（强制刷新）：</strong> 浏览器不仅会对本地文件过期，而且不会带上 If-Modifed-Since，If-None-Match，相当于之前从来没有请求过，返回结果是 200。</li><li>地址栏回车： 浏览器发起请求，按照正常流程，本地检查是否过期，然后服务器检查新鲜度，最后返回内容。</li></ul><h2 id="四、浏览器组成"><a href="#四、浏览器组成" class="headerlink" title="四、浏览器组成"></a>四、浏览器组成</h2><h3 id="1-对浏览器的理解"><a href="#1-对浏览器的理解" class="headerlink" title="1. 对浏览器的理解"></a>1. 对浏览器的理解</h3><p>浏览器的主要功能是将用户选择的 web 资源呈现出来，它需要从服务器请求资源，并将其显示在浏览器窗口中，资源的格式通常是 HTML，也包括 PDF、image 及其他格式。用户用 URI（Uniform Resource Identifier 统一资源标识符）来指定所请求资源的位置。</p><p>HTML 和 CSS 规范中规定了浏览器解释 html 文档的方式，由 W3C 组织对这些规范进行维护，W3C 是负责制定 web 标准的组织。但是浏览器厂商纷纷开发自己的扩展，对规范的遵循并不完善，这为 web 开发者带来了严重的兼容性问题。</p><p>浏览器可以分为两部分，shell 和 内核。其中 shell 的种类相对比较多，内核则比较少。也有一些浏览器并不区分外壳和内核。从 Mozilla 将 Gecko 独立出来后，才有了外壳和内核的明确划分。</p><ul><li>shell 是指浏览器的外壳：例如菜单，工具栏等。主要是提供给用户界面操作，参数设置等等。它是调用内核来实现各种功能的。</li><li>内核是浏览器的核心。内核是基于标记语言显示内容的程序或模块。</li></ul><h3 id="2-对浏览器内核的理解"><a href="#2-对浏览器内核的理解" class="headerlink" title="2. 对浏览器内核的理解"></a>2. 对浏览器内核的理解</h3><p>浏览器内核主要分成两部分：</p><ul><li>渲染引擎的职责就是渲染，即在浏览器窗口中显示所请求的内容。默认情况下，渲染引擎可以显示 html、xml 文档及图片，它也可以借助插件显示其他类型数据，例如使用 PDF 阅读器插件，可以显示 PDF 格式。</li><li>JS 引擎：解析和执行 javascript 来实现网页的动态效果。</li></ul><p>最开始渲染引擎和 JS 引擎并没有区分的很明确，后来 JS 引擎越来越独立，内核就倾向于只指渲染引擎。</p><h3 id="3-常见的浏览器内核比较"><a href="#3-常见的浏览器内核比较" class="headerlink" title="3. 常见的浏览器内核比较"></a>3. 常见的浏览器内核比较</h3><ul><li><strong>Trident：</strong> 这种浏览器内核是 IE 浏览器用的内核，因为在早期 IE 占有大量的市场份额，所以这种内核比较流行，以前有很多网页也是根据这个内核的标准来编写的，但是实际上这个内核对真正的网页标准支持不是很好。但是由于 IE 的高市场占有率，微软也很长时间没有更新 Trident 内核，就导致了 Trident 内核和 W3C 标准脱节。还有就是 Trident 内核的大量 Bug 等安全问题没有得到解决，加上一些专家学者公开自己认为 IE 浏览器不安全的观点，使很多用户开始转向其他浏览器。</li><li><strong>Gecko：</strong> 这是 Firefox 和 Flock 所采用的内核，这个内核的优点就是功能强大、丰富，可以支持很多复杂网页效果和浏览器扩展接口，但是代价是也显而易见就是要消耗很多的资源，比如内存。</li><li><strong>Presto：</strong> Opera 曾经采用的就是 Presto 内核，Presto 内核被称为公认的浏览网页速度最快的内核，这得益于它在开发时的天生优势，在处理 JS 脚本等脚本语言时，会比其他的内核快3倍左右，缺点就是为了达到很快的速度而丢掉了一部分网页兼容性。</li><li><strong>Webkit：</strong> Webkit 是 Safari 采用的内核，它的优点就是网页浏览速度较快，虽然不及 Presto 但是也胜于 Gecko 和 Trident，缺点是对于网页代码的容错性不高，也就是说对网页代码的兼容性较低，会使一些编写不标准的网页无法正确显示。WebKit 前身是 KDE 小组的 KHTML 引擎，可以说 WebKit 是 KHTML 的一个开源的分支。</li><li><strong>Blink：</strong> 谷歌在 Chromium Blog 上发表博客，称将与苹果的开源浏览器核心 Webkit 分道扬镳，在 Chromium 项目中研发 Blink 渲染引擎（即浏览器核心），内置于 Chrome 浏览器之中。其实 Blink 引擎就是 Webkit 的一个分支，就像 webkit 是KHTML 的分支一样。Blink 引擎现在是谷歌公司与 Opera Software 共同研发，上面提到过的，Opera 弃用了自己的 Presto 内核，加入 Google 阵营，跟随谷歌一起研发 Blink。</li></ul><h3 id="4-常见浏览器所用内核"><a href="#4-常见浏览器所用内核" class="headerlink" title="4. 常见浏览器所用内核"></a>4. 常见浏览器所用内核</h3><p>  （1） IE 浏览器内核：Trident 内核，也是俗称的 IE 内核；</p><p> （2） Chrome 浏览器内核：统称为 Chromium 内核或 Chrome 内核，以前是 Webkit 内核，现在是 Blink内核；</p><p> （3） Firefox 浏览器内核：Gecko 内核，俗称 Firefox 内核；</p><p> （4） Safari 浏览器内核：Webkit 内核；</p><p> （5） Opera 浏览器内核：最初是自己的 Presto 内核，后来加入谷歌大军，从 Webkit 又到了 Blink 内核；</p><p> （6） 360浏览器、猎豹浏览器内核：IE + Chrome 双内核；</p><p> （7） 搜狗、遨游、QQ 浏览器内核：Trident（兼容模式）+ Webkit（高速模式）；</p><p> （8） 百度浏览器、世界之窗内核：IE 内核；</p><p> （9） 2345浏览器内核：好像以前是 IE 内核，现在也是 IE + Chrome 双内核了；</p><p> （10）UC 浏览器内核：这个众口不一，UC 说是他们自己研发的 U3 内核，但好像还是基于 Webkit 和 Trident ，还有说是基于火狐内核。</p><h3 id="5-浏览器的主要组成部分"><a href="#5-浏览器的主要组成部分" class="headerlink" title="5. 浏览器的主要组成部分"></a>5. 浏览器的主要组成部分</h3><ul><li><strong>⽤户界⾯</strong> 包括地址栏、前进&#x2F;后退按钮、书签菜单等。除了浏览器主窗⼝显示的您请求的⻚⾯外，其他显示的各个部分都属于⽤户界⾯。 </li><li><strong>浏览器引擎</strong> 在⽤户界⾯和呈现引擎之间传送指令。 </li><li><strong>呈现引擎</strong> 负责显示请求的内容。如果请求的内容是 HTML，它就负责解析 HTML 和 CSS 内容，并将解析后的内容显示在屏幕上。 </li><li><strong>⽹络</strong> ⽤于⽹络调⽤，⽐如 HTTP 请求。其接⼝与平台⽆关，并为所有平台提供底层实现。 </li><li><strong>⽤户界⾯后端</strong> ⽤于绘制基本的窗⼝⼩部件，⽐如组合框和窗⼝。其公开了与平台⽆关的通⽤接⼝，⽽在底层使⽤操作系统的⽤户界⾯⽅法。 </li><li><strong>JavaScript 解释器</strong>。⽤于解析和执⾏ JavaScript 代码。 </li><li><strong>数据存储</strong> 这是持久层。浏览器需要在硬盘上保存各种数据，例如 Cookie。新的 HTML 规范 (HTML5) 定义了“⽹络数据库”，这是⼀个完整（但是轻便）的浏览器内数据库。</li></ul><p>值得注意的是，和⼤多数浏览器不同，Chrome 浏览器的每个标签⻚都分别对应⼀个呈现引擎实例。每个标签⻚都是⼀个独⽴的进程。</p><h2 id="五、浏览器渲染原理"><a href="#五、浏览器渲染原理" class="headerlink" title="五、浏览器渲染原理"></a>五、浏览器渲染原理</h2><h3 id="1-浏览器的渲染过程"><a href="#1-浏览器的渲染过程" class="headerlink" title="1. 浏览器的渲染过程"></a>1. 浏览器的渲染过程</h3><p>浏览器渲染主要有以下步骤：</p><ul><li>首先解析收到的文档，根据文档定义构建一棵 DOM 树，DOM 树是由 DOM 元素及属性节点组成的。</li><li>然后对 CSS 进行解析，生成 CSSOM 规则树。</li><li>根据 DOM 树和 CSSOM 规则树构建渲染树。渲染树的节点被称为渲染对象，渲染对象是一个包含有颜色和大小等属性的矩形，渲染对象和 DOM 元素相对应，但这种对应关系不是一对一的，不可见的 DOM 元素不会被插入渲染树。还有一些 DOM元素对应几个可见对象，它们一般是一些具有复杂结构的元素，无法用一个矩形来描述。</li><li>当渲染对象被创建并添加到树中，它们并没有位置和大小，所以当浏览器生成渲染树以后，就会根据渲染树来进行布局（也可以叫做回流）。这一阶段浏览器要做的事情是要弄清楚各个节点在页面中的确切位置和大小。通常这一行为也被称为“自动重排”。</li><li>布局阶段结束后是绘制阶段，遍历渲染树并调用渲染对象的 paint 方法将它们的内容显示在屏幕上，绘制使用 UI 基础组件。</li></ul><p>大致过程如图所示：<br><img src="7.png" alt="img"></p><p><strong>注意：</strong> 这个过程是逐步完成的，为了更好的用户体验，渲染引擎将会尽可能早的将内容呈现到屏幕上，并不会等到所有的html 都解析完成之后再去构建和布局 render 树。它是解析完一部分内容就显示一部分内容，同时，可能还在通过网络下载其余内容。</p><h3 id="2-浏览器渲染优化"><a href="#2-浏览器渲染优化" class="headerlink" title="2. 浏览器渲染优化"></a>2. 浏览器渲染优化</h3><p><strong>（1）针对JavaScript：</strong> JavaScript既会阻塞HTML的解析，也会阻塞CSS的解析。因此我们可以对JavaScript的加载方式进行改变，来进行优化：</p><p>（1）尽量将JavaScript文件放在body的最后</p><p>（2） body中间尽量不要写<code>&lt;script&gt;</code>标签</p><p>（3）<code>&lt;script&gt;</code>标签的引入资源方式有三种，有一种就是我们常用的直接引入，还有两种就是使用 async 属性和 defer 属性来异步引入，两者都是去异步加载外部的JS文件，不会阻塞DOM的解析（尽量使用异步加载）。三者的区别如下：</p><ul><li><strong>script</strong> 立即停止页面渲染去加载资源文件，当资源加载完毕后立即执行js代码，js代码执行完毕后继续渲染页面；</li><li><strong>async</strong> 是在下载完成之后，立即异步加载，加载好后立即执行，多个带async属性的标签，不能保证加载的顺序；</li><li><strong>defer</strong> 是在下载完成之后，立即异步加载。加载好后，如果 DOM 树还没构建好，则先等 DOM 树解析好再执行；如果DOM树已经准备好，则立即执行。多个带defer属性的标签，按照顺序执行。</li></ul><p><strong>（2）针对CSS：</strong>使用CSS有三种方式：使用<strong>link、@import、内联样式</strong>，其中link和@import都是导入外部样式。它们之间的区别：</p><ul><li><strong>link</strong>：浏览器会派发一个新等线程(HTTP线程)去加载资源文件，与此同时GUI渲染线程会继续向下渲染代码</li><li><strong>@import</strong>：GUI渲染线程会暂时停止渲染，去服务器加载资源文件，资源文件没有返回之前不会继续渲染(阻碍浏览器渲染)</li><li><strong>style</strong>：GUI直接渲染</li></ul><p>外部样式如果长时间没有加载完毕，浏览器为了用户体验，会使用浏览器会默认样式，确保首次渲染的速度。所以CSS一般写在headr中，让浏览器尽快发送请求去获取css样式。</p><p>所以，在开发过程中，导入外部样式使用link，而不用@import。如果css少，尽可能采用内嵌样式，直接写在style标签中。</p><p><strong>（3）针对DOM树、CSSOM树：</strong><br>可以通过以下几种方式来减少渲染的时间：</p><ul><li>HTML文件的代码层级尽量不要太深</li><li>使用语义化的标签，来避免不标准语义化的特殊处理</li><li>减少CSSD代码的层级，因为选择器是从左向右进行解析的</li></ul><p><strong>（4）减少回流与重绘：</strong></p><ul><li>操作DOM时，尽量在低层级的DOM节点进行操作</li><li>不要使用<code>table</code>布局， 一个小的改动可能会使整个<code>table</code>进行重新布局</li><li>使用CSS的表达式</li><li>不要频繁操作元素的样式，对于静态页面，可以修改类名，而不是样式。</li><li>使用absolute或者fixed，使元素脱离文档流，这样他们发生变化就不会影响其他元素</li><li>避免频繁操作DOM，可以创建一个文档片段<code>documentFragment</code>，在它上面应用所有DOM操作，最后再把它添加到文档中</li><li>将元素先设置<code>display: none</code>，操作结束后再把它显示出来。因为在display属性为none的元素上进行的DOM操作不会引发回流和重绘。</li><li>将DOM的多个读操作（或者写操作）放在一起，而不是读写操作穿插着写。这得益于<strong>浏览器的渲染队列机制</strong>。</li></ul><p>浏览器针对页面的回流与重绘，进行了自身的优化——<strong>渲染队列</strong></p><p><strong>浏览器会将所有的回流、重绘的操作放在一个队列中，当队列中的操作到了一定的数量或者到了一定的时间间隔，浏览器就会对队列进行批处理。这样就会让多次的回流、重绘变成一次回流重绘。</strong></p><p>将多个读操作（或者写操作）放在一起，就会等所有的读操作进入队列之后执行，这样，原本应该是触发多次回流，变成了只触发一次回流。</p><h3 id="3-渲染过程中遇到-JS-文件如何处理？"><a href="#3-渲染过程中遇到-JS-文件如何处理？" class="headerlink" title="3. 渲染过程中遇到 JS 文件如何处理？"></a>3. 渲染过程中遇到 JS 文件如何处理？</h3><p>JavaScript 的加载、解析与执行会阻塞文档的解析，也就是说，在构建 DOM 时，HTML 解析器若遇到了 JavaScript，那么它会暂停文档的解析，将控制权移交给 JavaScript 引擎，等 JavaScript 引擎运行完毕，浏览器再从中断的地方恢复继续解析文档。也就是说，如果想要首屏渲染的越快，就越不应该在首屏就加载 JS 文件，这也是都建议将 script 标签放在 body 标签底部的原因。当然在当下，并不是说 script 标签必须放在底部，因为你可以给 script 标签添加 defer 或者 async 属性。</p><h3 id="4-什么是文档的预解析？"><a href="#4-什么是文档的预解析？" class="headerlink" title="4. 什么是文档的预解析？"></a>4. 什么是文档的预解析？</h3><p>Webkit 和 Firefox 都做了这个优化，当执行 JavaScript 脚本时，另一个线程解析剩下的文档，并加载后面需要通过网络加载的资源。这种方式可以使资源并行加载从而使整体速度更快。需要注意的是，预解析并不改变 DOM 树，它将这个工作留给主解析过程，自己只解析外部资源的引用，比如外部脚本、样式表及图片。</p><h3 id="5-CSS-如何阻塞文档解析？"><a href="#5-CSS-如何阻塞文档解析？" class="headerlink" title="5. CSS 如何阻塞文档解析？"></a>5. CSS 如何阻塞文档解析？</h3><p>理论上，既然样式表不改变 DOM 树，也就没有必要停下文档的解析等待它们。然而，存在一个问题，JavaScript 脚本执行时可能在文档的解析过程中请求样式信息，如果样式还没有加载和解析，脚本将得到错误的值，显然这将会导致很多问题。所以如果浏览器尚未完成 CSSOM 的下载和构建，而我们却想在此时运行脚本，那么浏览器将延迟 JavaScript 脚本执行和文档的解析，直至其完成 CSSOM 的下载和构建。也就是说，在这种情况下，浏览器会先下载和构建 CSSOM，然后再执行 JavaScript，最后再继续文档的解析。</p><h3 id="6-如何优化关键渲染路径？"><a href="#6-如何优化关键渲染路径？" class="headerlink" title="6. 如何优化关键渲染路径？"></a>6. 如何优化关键渲染路径？</h3><p>为尽快完成首次渲染，我们需要最大限度减小以下三种可变因素：</p><p> （1）关键资源的数量。</p><p> （2）关键路径长度。</p><p> （3）关键字节的数量。</p><p>关键资源是可能阻止网页首次渲染的资源。这些资源越少，浏览器的工作量就越小，对 CPU 以及其他资源的占用也就越少。同样，关键路径长度受所有关键资源与其字节大小之间依赖关系图的影响：某些资源只能在上一资源处理完毕之后才能开始下载，并且资源越大，下载所需的往返次数就越多。最后，浏览器需要下载的关键字节越少，处理内容并让其出现在屏幕上的速度就越快。要减少字节数，我们可以减少资源数（将它们删除或设为非关键资源），此外还要压缩和优化各项资源，确保最大限度减小传送大小。</p><p>优化关键渲染路径的常规步骤如下：</p><p>（1）对关键路径进行分析和特性描述：资源数、字节数、长度。</p><p> （2）最大限度减少关键资源的数量：删除它们，延迟它们的下载，将它们标记为异步等。</p><p>（3）优化关键字节数以缩短下载时间（往返次数）。</p><p> （4）优化其余关键资源的加载顺序：您需要尽早下载所有关键资产，以缩短关键路径长度</p><h3 id="7-什么情况会阻塞渲染？"><a href="#7-什么情况会阻塞渲染？" class="headerlink" title="7. 什么情况会阻塞渲染？"></a>7. 什么情况会阻塞渲染？</h3><p>首先渲染的前提是生成渲染树，所以 HTML 和 CSS 肯定会阻塞渲染。如果你想渲染的越快，你越应该降低一开始需要渲染的文件大小，并且扁平层级，优化选择器。然后当浏览器在解析到 script 标签时，会暂停构建 DOM，完成后才会从暂停的地方重新开始。也就是说，如果你想首屏渲染的越快，就越不应该在首屏就加载 JS 文件，这也是都建议将 script 标签放在 body 标签底部的原因。</p><p>当然在当下，并不是说 script 标签必须放在底部，因为你可以给 script 标签添加 defer 或者 async 属性。当 script 标签加上 defer 属性以后，表示该 JS 文件会并行下载，但是会放到 HTML 解析完成后顺序执行，所以对于这种情况你可以把 script 标签放在任意位置。对于没有任何依赖的 JS 文件可以加上 async 属性，表示 JS 文件下载和解析不会阻塞渲染。</p><h2 id="六、浏览器本地存储"><a href="#六、浏览器本地存储" class="headerlink" title="六、浏览器本地存储"></a>六、浏览器本地存储</h2><h3 id="1-浏览器本地存储方式及使用场景"><a href="#1-浏览器本地存储方式及使用场景" class="headerlink" title="1. 浏览器本地存储方式及使用场景"></a>1. 浏览器本地存储方式及使用场景</h3><h4 id="（1）Cookie"><a href="#（1）Cookie" class="headerlink" title="（1）Cookie"></a>（1）Cookie</h4><p>Cookie是最早被提出来的本地存储方式，在此之前，服务端是无法判断网络中的两个请求是否是同一用户发起的，为解决这个问题，Cookie就出现了。Cookie的大小只有4kb，它是一种纯文本文件，每次发起HTTP请求都会携带Cookie。</p><p><strong>Cookie的特性：</strong></p><ul><li>Cookie一旦创建成功，名称就无法修改</li><li>Cookie是无法跨域名的，也就是说a域名和b域名下的cookie是无法共享的，这也是由Cookie的隐私安全性决定的，这样就能够阻止非法获取其他网站的Cookie</li><li>每个域名下Cookie的数量不能超过20个，每个Cookie的大小不能超过4kb</li><li>有安全问题，如果Cookie被拦截了，那就可获得session的所有信息，即使加密也于事无补，无需知道cookie的意义，只要转发cookie就能达到目的</li><li>Cookie在请求一个新的页面的时候都会被发送过去</li></ul><p>如果需要域名之间跨域共享Cookie，有两种方法：</p><ol><li>使用Nginx反向代理</li><li>在一个站点登陆之后，往其他网站写Cookie。服务端的Session存储到一个节点，Cookie存储sessionId</li></ol><p><strong>Cookie的使用场景：</strong></p><ul><li>最常见的使用场景就是Cookie和session结合使用，我们将sessionId存储到Cookie中，每次发请求都会携带这个sessionId，这样服务端就知道是谁发起的请求，从而响应相应的信息。</li><li>可以用来统计页面的点击次数</li></ul><h4 id="（2）LocalStorage"><a href="#（2）LocalStorage" class="headerlink" title="（2）LocalStorage"></a>（2）LocalStorage</h4><p>LocalStorage是HTML5新引入的特性，由于有的时候我们存储的信息较大，Cookie就不能满足我们的需求，这时候LocalStorage就派上用场了。</p><p><strong>LocalStorage的优点：</strong></p><ul><li>在大小方面，LocalStorage的大小一般为5MB，可以储存更多的信息</li><li>LocalStorage是持久储存，并不会随着页面的关闭而消失，除非主动清理，不然会永久存在</li><li>仅储存在本地，不像Cookie那样每次HTTP请求都会被携带</li></ul><p><strong>LocalStorage的缺点：</strong></p><ul><li>存在浏览器兼容问题，IE8以下版本的浏览器不支持</li><li>如果浏览器设置为隐私模式，那我们将无法读取到LocalStorage</li><li>LocalStorage受到同源策略的限制，即端口、协议、主机地址有任何一个不相同，都不会访问</li></ul><p><strong>LocalStorage的常用API：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 保存数据到 localStorage</span><br><span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">setItem</span>(<span class="hljs-string">&#x27;key&#x27;</span>, <span class="hljs-string">&#x27;value&#x27;</span>);<br><br><span class="hljs-comment">// 从 localStorage 获取数据</span><br><span class="hljs-keyword">let</span> data = <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">getItem</span>(<span class="hljs-string">&#x27;key&#x27;</span>);<br><br><span class="hljs-comment">// 从 localStorage 删除保存的数据</span><br><span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">removeItem</span>(<span class="hljs-string">&#x27;key&#x27;</span>);<br><br><span class="hljs-comment">// 从 localStorage 删除所有保存的数据</span><br><span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">clear</span>();<br><br><span class="hljs-comment">// 获取某个索引的Key</span><br><span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">key</span>(index)<br></code></pre></td></tr></table></figure><p><strong>LocalStorage的使用场景：</strong></p><ul><li>有些网站有换肤的功能，这时候就可以将换肤的信息存储在本地的LocalStorage中，当需要换肤的时候，直接操作LocalStorage即可</li><li>在网站中的用户浏览信息也会存储在LocalStorage中，还有网站的一些不常变动的个人信息等也可以存储在本地的LocalStorage中</li></ul><h4 id="（3）SessionStorage"><a href="#（3）SessionStorage" class="headerlink" title="（3）SessionStorage"></a>（3）SessionStorage</h4><p>SessionStorage和LocalStorage都是在HTML5才提出来的存储方案，SessionStorage 主要用于临时保存同一窗口(或标签页)的数据，刷新页面时不会删除，关闭窗口或标签页之后将会删除这些数据。</p><p><strong>SessionStorage与LocalStorage对比：</strong></p><ul><li>SessionStorage和LocalStorage都在<strong>本地进行数据存储</strong>；</li><li>SessionStorage也有同源策略的限制，但是SessionStorage有一条更加严格的限制，SessionStorage<strong>只有在同一浏览器的同一窗口下才能够共享</strong>；</li><li>LocalStorage和SessionStorage<strong>都不能被爬虫爬取</strong>；</li></ul><p><strong>SessionStorage的常用API：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 保存数据到 sessionStorage</span><br>sessionStorage.<span class="hljs-title function_">setItem</span>(<span class="hljs-string">&#x27;key&#x27;</span>, <span class="hljs-string">&#x27;value&#x27;</span>);<br><br><span class="hljs-comment">// 从 sessionStorage 获取数据</span><br><span class="hljs-keyword">let</span> data = sessionStorage.<span class="hljs-title function_">getItem</span>(<span class="hljs-string">&#x27;key&#x27;</span>);<br><br><span class="hljs-comment">// 从 sessionStorage 删除保存的数据</span><br>sessionStorage.<span class="hljs-title function_">removeItem</span>(<span class="hljs-string">&#x27;key&#x27;</span>);<br><br><span class="hljs-comment">// 从 sessionStorage 删除所有保存的数据</span><br>sessionStorage.<span class="hljs-title function_">clear</span>();<br><br><span class="hljs-comment">// 获取某个索引的Key</span><br>sessionStorage.<span class="hljs-title function_">key</span>(index)<br></code></pre></td></tr></table></figure><p><strong>SessionStorage的使用场景</strong></p><ul><li>由于SessionStorage具有时效性，所以可以用来存储一些网站的游客登录的信息，还有临时的浏览记录的信息。当关闭网站之后，这些信息也就随之消除了。</li></ul><h3 id="2-Cookie有哪些字段，作用分别是什么"><a href="#2-Cookie有哪些字段，作用分别是什么" class="headerlink" title="2. Cookie有哪些字段，作用分别是什么"></a>2. Cookie有哪些字段，作用分别是什么</h3><p><strong>Cookie由以下字段组成：</strong></p><ul><li><strong>Name</strong>：cookie的名称</li><li><strong>Value</strong>：cookie的值，对于认证cookie，value值包括web服务器所提供的访问令牌；</li><li><strong>Size</strong>： cookie的大小</li><li><strong>Path</strong>：可以访问此cookie的页面路径。 比如domain是abc.com，path是<code>/test</code>，那么只有<code>/test</code>路径下的页面可以读取此cookie。</li><li><strong>Secure</strong>： 指定是否使用HTTPS安全协议发送Cookie。使用HTTPS安全协议，可以保护Cookie在浏览器和Web服务器间的传输过程中不被窃取和篡改。该方法也可用于Web站点的身份鉴别，即在HTTPS的连接建立阶段，浏览器会检查Web网站的SSL证书的有效性。但是基于兼容性的原因（比如有些网站使用自签署的证书）在检测到SSL证书无效时，浏览器并不会立即终止用户的连接请求，而是显示安全风险信息，用户仍可以选择继续访问该站点。</li><li><strong>Domain</strong>：可以访问该cookie的域名，Cookie 机制并未遵循严格的同源策略，允许一个子域可以设置或获取其父域的 Cookie。当需要实现单点登录方案时，Cookie 的上述特性非常有用，然而也增加了 Cookie受攻击的危险，比如攻击者可以借此发动会话定置攻击。因而，浏览器禁止在 Domain 属性中设置.org、.com 等通用顶级域名、以及在国家及地区顶级域下注册的二级域名，以减小攻击发生的范围。</li><li><strong>HTTP</strong>： 该字段包含<code>HTTPOnly</code> 属性 ，该属性用来设置cookie能否通过脚本来访问，默认为空，即可以通过脚本访问。在客户端是不能通过js代码去设置一个httpOnly类型的cookie的，这种类型的cookie只能通过服务端来设置。该属性用于防止客户端脚本通过<code>document.cookie</code>属性访问Cookie，有助于保护Cookie不被跨站脚本攻击窃取或篡改。但是，HTTPOnly的应用仍存在局限性，一些浏览器可以阻止客户端脚本对Cookie的读操作，但允许写操作；此外大多数浏览器仍允许通过XMLHTTP对象读取HTTP响应中的Set-Cookie头。</li><li><strong>Expires&#x2F;Max-size</strong> ： 此cookie的超时时间。若设置其值为一个时间，那么当到达此时间后，此cookie失效。不设置的话默认值是Session，意思是cookie会和session一起失效。当浏览器关闭(不是浏览器标签页，而是整个浏览器) 后，此cookie失效。</li></ul><p><strong>总结：</strong><br>服务器端可以使用 Set-Cookie 的响应头部来配置 cookie 信息。一条cookie 包括了5个属性值 expires、domain、path、secure、HttpOnly。其中 expires 指定了 cookie 失效的时间，domain 是域名、path是路径，domain 和 path 一起限制了 cookie 能够被哪些 url 访问。secure 规定了 cookie 只能在确保安全的情况下传输，HttpOnly 规定了这个 cookie 只能被服务器访问，不能使用 js 脚本访问。</p><h3 id="3-Cookie、LocalStorage、SessionStorage区别"><a href="#3-Cookie、LocalStorage、SessionStorage区别" class="headerlink" title="3. Cookie、LocalStorage、SessionStorage区别"></a>3. Cookie、LocalStorage、SessionStorage区别</h3><p>浏览器端常用的存储技术是 cookie 、localStorage 和 sessionStorage。</p><ul><li><strong>cookie：</strong> 其实最开始是服务器端用于记录用户状态的一种方式，由服务器设置，在客户端存储，然后每次发起同源请求时，发送给服务器端。cookie 最多能存储 4 k 数据，它的生存时间由 expires 属性指定，并且 cookie 只能被同源的页面访问共享。</li><li><strong>sessionStorage：</strong> html5 提供的一种浏览器本地存储的方法，它借鉴了服务器端 session 的概念，代表的是一次会话中所保存的数据。它一般能够存储 5M 或者更大的数据，它在当前窗口关闭后就失效了，并且 sessionStorage 只能被同一个窗口的同源页面所访问共享。</li><li><strong>localStorage：</strong> html5 提供的一种浏览器本地存储的方法，它一般也能够存储 5M 或者更大的数据。它和 sessionStorage 不同的是，除非手动删除它，否则它不会失效，并且 localStorage 也只能被同源页面所访问共享。</li></ul><p>上面几种方式都是存储少量数据的时候的存储方式，当需要在本地存储大量数据的时候，我们可以使用浏览器的 indexDB 这是浏览器提供的一种本地的数据库存储机制。它不是关系型数据库，它内部采用对象仓库的形式存储数据，它更接近 NoSQL 数据库。</p><h3 id="4-前端储存的⽅式有哪些？"><a href="#4-前端储存的⽅式有哪些？" class="headerlink" title="4. 前端储存的⽅式有哪些？"></a>4. 前端储存的⽅式有哪些？</h3><ul><li>cookies： 在HTML5标准前本地储存的主要⽅式，优点是兼容性好，请求头⾃带cookie⽅便，缺点是⼤⼩只有4k，⾃动请求头加⼊cookie浪费流量，每个domain限制20个cookie，使⽤起来麻烦，需要⾃⾏封装；</li><li>localStorage：HTML5加⼊的以键值对(Key-Value)为标准的⽅式，优点是操作⽅便，永久性储存（除⾮⼿动删除），⼤⼩为5M，兼容IE8+ ；</li><li>sessionStorage：与localStorage基本类似，区别是sessionStorage当⻚⾯关闭后会被清理，⽽且与cookie、localStorage不同，他不能在所有同源窗⼝中共享，是会话级别的储存⽅式； </li><li>Web SQL：2010年被W3C废弃的本地数据库数据存储⽅案，但是主流浏览器（⽕狐除外）都已经有了相关的实现，web sql类似于SQLite，是真正意义上的关系型数据库，⽤sql进⾏操作，当我们⽤JavaScript时要进⾏转换，较为繁琐； </li><li>IndexedDB： 是被正式纳⼊HTML5标准的数据库储存⽅案，它是NoSQL数据库，⽤键值对进⾏储存，可以进⾏快速读取操作，⾮常适合web场景，同时⽤JavaScript进⾏操作会⾮常便。</li></ul><h3 id="5-IndexedDB有哪些特点？"><a href="#5-IndexedDB有哪些特点？" class="headerlink" title="5. IndexedDB有哪些特点？"></a>5. IndexedDB有哪些特点？</h3><p>IndexedDB 具有以下特点：</p><ul><li><strong>键值对储存</strong>：IndexedDB 内部采用对象仓库（object store）存放数据。所有类型的数据都可以直接存入，包括 JavaScript 对象。对象仓库中，数据以”键值对”的形式保存，每一个数据记录都有对应的主键，主键是独一无二的，不能有重复，否则会抛出一个错误。</li><li><strong>异步</strong>：IndexedDB 操作时不会锁死浏览器，用户依然可以进行其他操作，这与 LocalStorage 形成对比，后者的操作是同步的。异步设计是为了防止大量数据的读写，拖慢网页的表现。</li><li><strong>支持事务</strong>：IndexedDB 支持事务（transaction），这意味着一系列操作步骤之中，只要有一步失败，整个事务就都取消，数据库回滚到事务发生之前的状态，不存在只改写一部分数据的情况。</li><li><strong>同源限制：</strong> IndexedDB 受到同源限制，每一个数据库对应创建它的域名。网页只能访问自身域名下的数据库，而不能访问跨域的数据库。</li><li><strong>储存空间大</strong>：IndexedDB 的储存空间比 LocalStorage 大得多，一般来说不少于 250MB，甚至没有上限。</li><li><strong>支持二进制储存</strong>：IndexedDB 不仅可以储存字符串，还可以储存二进制数据（ArrayBuffer 对象和 Blob 对象）。</li></ul><h2 id="七、浏览器同源策略"><a href="#七、浏览器同源策略" class="headerlink" title="七、浏览器同源策略"></a>七、浏览器同源策略</h2><h3 id="1-什么是同源策略"><a href="#1-什么是同源策略" class="headerlink" title="1. 什么是同源策略"></a>1. 什么是同源策略</h3><p>跨域问题其实就是浏览器的同源策略造成的。</p><blockquote><p>同源策略限制了从同一个源加载的文档或脚本如何与另一个源的资源进行交互。这是浏览器的一个用于隔离潜在恶意文件的重要的安全机制。同源指的是：<strong>协议</strong>、<strong>端口号</strong>、<strong>域名</strong>必须一致。</p></blockquote><p>下表给出了与 URL <a href="http://store.company.com/dir/page.html">http://store.company.com/dir/page.html</a> 的源进行对比的示例:</p><table><thead><tr><th>URL</th><th>是否跨域</th><th>原因</th></tr></thead><tbody><tr><td><a href="http://store.company.com/dir/page.html">http://store.company.com/dir/page.html</a></td><td>同源</td><td>完全相同</td></tr><tr><td><a href="http://store.company.com/dir/inner/another.html">http://store.company.com/dir/inner/another.html</a></td><td>同源</td><td>只有路径不同</td></tr><tr><td><a href="https://store.company.com/secure.html">https://store.company.com/secure.html</a></td><td>跨域</td><td>协议不同</td></tr><tr><td><a href="http://store.company.com:81/dir/etc.html">http://store.company.com:81/dir/etc.html</a></td><td>跨域</td><td>端口不同 ( http:&#x2F;&#x2F; 默认端口是80)</td></tr><tr><td><a href="http://news.company.com/dir/other.html">http://news.company.com/dir/other.html</a></td><td>跨域</td><td>主机不同</td></tr></tbody></table><p><strong>同源策略：protocol（协议）、domain（域名）、port（端口）三者必须一致。</strong></p><p><strong>同源政策主要限制了三个方面：</strong></p><ul><li>当前域下的 js 脚本不能够访问其他域下的 cookie、localStorage 和 indexDB。</li><li>当前域下的 js 脚本不能够操作访问操作其他域下的 DOM。</li><li>当前域下 ajax 无法发送跨域请求。</li></ul><p>同源政策的目的主要是为了保证用户的信息安全，它只是对 js 脚本的一种限制，并不是对浏览器的限制，对于一般的 img、或者script 脚本请求都不会有跨域的限制，这是因为这些操作都不会通过响应结果来进行可能出现安全问题的操作。</p><h3 id="2-如何解决跨越问题"><a href="#2-如何解决跨越问题" class="headerlink" title="2. 如何解决跨越问题"></a>2. 如何解决跨越问题</h3><h4 id="（1）CORS"><a href="#（1）CORS" class="headerlink" title="（1）CORS"></a>（1）CORS</h4><p>下面是MDN对于CORS的定义：</p><blockquote><p>跨域资源共享(CORS) 是一种机制，它使用额外的 HTTP 头来告诉浏览器  让运行在一个 origin (domain)上的Web应用被准许访问来自不同源服务器上的指定的资源。当一个资源从与该资源本身所在的服务器不同的域、协议或端口请求一个资源时，资源会发起一个跨域HTTP 请求。</p></blockquote><p>CORS需要浏览器和服务器同时支持，整个CORS过程都是浏览器完成的，无需用户参与。因此实现<strong>CORS的关键就是服务器，只要服务器实现了CORS请求</strong>，就可以跨源通信了。</p><p>浏览器将CORS分为<strong>简单请求</strong>和<strong>非简单请求</strong>：</p><p>简单请求不会触发CORS预检请求。若该请求满足以下两个条件，就可以看作是简单请求：</p><p><strong>1）请求方法是以下三种方法之一：</strong></p><ul><li>HEAD</li><li>GET</li><li>POST</li></ul><p><strong>2）HTTP的头信息不超出以下几种字段：</strong></p><ul><li>Accept</li><li>Accept-Language</li><li>Content-Language</li><li>Last-Event-ID</li><li>Content-Type：只限于三个值application&#x2F;x-www-form-urlencoded、multipart&#x2F;form-data、text&#x2F;plain</li></ul><p>若不满足以上条件，就属于非简单请求了。</p><p><strong>（1）简单请求过程：</strong></p><p>对于简单请求，浏览器会直接发出CORS请求，它会在请求的头信息中增加一个Orign字段，该字段用来说明本次请求来自哪个源（协议+端口+域名），服务器会根据这个值来决定是否同意这次请求。如果Orign指定的域名在许可范围之内，服务器返回的响应就会多出以下信息头：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Access</span>-<span class="hljs-title class_">Control</span>-<span class="hljs-title class_">Allow</span>-<span class="hljs-title class_">Origin</span>: <span class="hljs-attr">http</span>:<span class="hljs-comment">//api.bob.com  // 和Orign一直</span><br><span class="hljs-title class_">Access</span>-<span class="hljs-title class_">Control</span>-<span class="hljs-title class_">Allow</span>-<span class="hljs-title class_">Credentials</span>: <span class="hljs-literal">true</span>   <span class="hljs-comment">// 表示是否允许发送Cookie</span><br><span class="hljs-title class_">Access</span>-<span class="hljs-title class_">Control</span>-<span class="hljs-title class_">Expose</span>-<span class="hljs-title class_">Headers</span>: <span class="hljs-title class_">FooBar</span>   <span class="hljs-comment">// 指定返回其他字段的值</span><br><span class="hljs-title class_">Content</span>-<span class="hljs-title class_">Type</span>: text/html; charset=utf-<span class="hljs-number">8</span>   <span class="hljs-comment">// 表示文档类型</span><br></code></pre></td></tr></table></figure><p>如果Orign指定的域名不在许可范围之内，服务器会返回一个正常的HTTP回应，浏览器发现没有上面的Access-Control-Allow-Origin头部信息，就知道出错了。这个错误无法通过状态码识别，因为返回的状态码可能是200。</p><p><strong>在简单请求中，在服务器内，至少需要设置字段：</strong><code>Access-Control-Allow-Origin</code></p><p><strong>（2）非简单请求过程</strong></p><p>非简单请求是对服务器有特殊要求的请求，比如请求方法为DELETE或者PUT等。非简单请求的CORS请求会在正式通信之前进行一次HTTP查询请求，<strong>称为预检请求</strong>。</p><p>浏览器会询问服务器，当前所在的网页是否在服务器允许访问的范围内，以及可以使用哪些HTTP请求方式和头信息字段，只有得到肯定的回复，才会进行正式的HTTP请求，否则就会报错。</p><p>预检请求使用的<strong>请求方法是OPTIONS</strong>，表示这个请求是来询问的。他的头信息中的关键字段是Orign，表示请求来自哪个源。除此之外，头信息中还包括两个字段：</p><ul><li><strong>Access-Control-Request-Method</strong>：该字段是必须的，用来列出浏览器的CORS请求会用到哪些HTTP方法。</li><li><strong>Access-Control-Request-Headers</strong>： 该字段是一个逗号分隔的字符串，指定浏览器CORS请求会额外发送的头信息字段。</li></ul><p>服务器在收到浏览器的预检请求之后，会根据头信息的三个字段来进行判断，如果返回的头信息在中有Access-Control-Allow-Origin这个字段就是允许跨域请求，如果没有，就是不同意这个预检请求，就会报错。</p><p>服务器回应的CORS的字段如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Access</span>-<span class="hljs-title class_">Control</span>-<span class="hljs-title class_">Allow</span>-<span class="hljs-title class_">Origin</span>: <span class="hljs-attr">http</span>:<span class="hljs-comment">//api.bob.com  // 允许跨域的源地址</span><br><span class="hljs-title class_">Access</span>-<span class="hljs-title class_">Control</span>-<span class="hljs-title class_">Allow</span>-<span class="hljs-title class_">Methods</span>: <span class="hljs-variable constant_">GET</span>, <span class="hljs-variable constant_">POST</span>, <span class="hljs-variable constant_">PUT</span> <span class="hljs-comment">// 服务器支持的所有跨域请求的方法</span><br><span class="hljs-title class_">Access</span>-<span class="hljs-title class_">Control</span>-<span class="hljs-title class_">Allow</span>-<span class="hljs-title class_">Headers</span>: X-<span class="hljs-title class_">Custom</span>-<span class="hljs-title class_">Header</span>  <span class="hljs-comment">// 服务器支持的所有头信息字段</span><br><span class="hljs-title class_">Access</span>-<span class="hljs-title class_">Control</span>-<span class="hljs-title class_">Allow</span>-<span class="hljs-title class_">Credentials</span>: <span class="hljs-literal">true</span>   <span class="hljs-comment">// 表示是否允许发送Cookie</span><br><span class="hljs-title class_">Access</span>-<span class="hljs-title class_">Control</span>-<span class="hljs-title class_">Max</span>-<span class="hljs-title class_">Age</span>: <span class="hljs-number">1728000</span>  <span class="hljs-comment">// 用来指定本次预检请求的有效期，单位为秒</span><br></code></pre></td></tr></table></figure><p>只要服务器通过了预检请求，在以后每次的CORS请求都会自带一个Origin头信息字段。服务器的回应，也都会有一个Access-Control-Allow-Origin头信息字段。</p><p><strong>在非简单请求中，至少需要设置以下字段：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;Access-Control-Allow-Origin&#x27;</span>  <br><span class="hljs-string">&#x27;Access-Control-Allow-Methods&#x27;</span><br><span class="hljs-string">&#x27;Access-Control-Allow-Headers&#x27;</span><br></code></pre></td></tr></table></figure><h5 id="减少OPTIONS请求次数："><a href="#减少OPTIONS请求次数：" class="headerlink" title="减少OPTIONS请求次数："></a>减少OPTIONS请求次数：</h5><p>OPTIONS请求次数过多就会损耗页面加载的性能，降低用户体验度。所以尽量要减少OPTIONS请求次数，可以后端在请求的返回头部添加：Access-Control-Max-Age：number。它表示预检请求的返回结果可以被缓存多久，单位是秒。该字段只对完全一样的URL的缓存设置生效，所以设置了缓存时间，在这个时间范围内，再次发送请求就不需要进行预检请求了。</p><h5 id="CORS中Cookie相关问题："><a href="#CORS中Cookie相关问题：" class="headerlink" title="CORS中Cookie相关问题："></a>CORS中Cookie相关问题：</h5><p>在CORS请求中，如果想要传递Cookie，就要满足以下三个条件：</p><ul><li>在请求中设置 <code>withCredentials</code></li></ul><p>默认情况下在跨域请求，浏览器是不带 cookie 的。但是我们可以通过设置 withCredentials 来进行传递 cookie.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 原生 xml 的设置方式</span><br><span class="hljs-keyword">var</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>();<br>xhr.<span class="hljs-property">withCredentials</span> = <span class="hljs-literal">true</span>;<br><span class="hljs-comment">// axios 设置方式</span><br>axios.<span class="hljs-property">defaults</span>.<span class="hljs-property">withCredentials</span> = <span class="hljs-literal">true</span>;<br></code></pre></td></tr></table></figure><ul><li>Access-Control-Allow-Credentials 设置为 true</li><li>Access-Control-Allow-Origin 设置为非 <code>*</code></li></ul><h4 id="（2）JSONP"><a href="#（2）JSONP" class="headerlink" title="（2）JSONP"></a>（2）JSONP</h4><p><strong>jsonp</strong>的原理就是利用<code>&lt;script&gt;</code>标签没有跨域限制，通过<code>&lt;script&gt;</code>标签src属性，发送带有callback参数的GET请求，服务端将接口返回数据拼凑到callback函数中，返回给浏览器，浏览器解析执行，从而前端拿到callback函数返回的数据。<br>1）原生JS实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;script&gt;<br>    <span class="hljs-keyword">var</span> script = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;script&#x27;</span>);<br>    script.<span class="hljs-property">type</span> = <span class="hljs-string">&#x27;text/javascript&#x27;</span>;<br>    <span class="hljs-comment">// 传参一个回调函数名给后端，方便后端返回时执行这个在前端定义的回调函数</span><br>    script.<span class="hljs-property">src</span> = <span class="hljs-string">&#x27;http://www.domain2.com:8080/login?user=admin&amp;callback=handleCallback&#x27;</span>;<br>    <span class="hljs-variable language_">document</span>.<span class="hljs-property">head</span>.<span class="hljs-title function_">appendChild</span>(script);<br>    <span class="hljs-comment">// 回调执行函数</span><br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">handleCallback</span>(<span class="hljs-params">res</span>) &#123;<br>        <span class="hljs-title function_">alert</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(res));<br>    &#125;<br> &lt;/script&gt;<br></code></pre></td></tr></table></figure><p>服务端返回如下（返回时即执行全局函数）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">handleCallback</span>(&#123;<span class="hljs-string">&quot;success&quot;</span>: <span class="hljs-literal">true</span>, <span class="hljs-string">&quot;user&quot;</span>: <span class="hljs-string">&quot;admin&quot;</span>&#125;)<br></code></pre></td></tr></table></figure><p>2）Vue axios实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">this</span>.<span class="hljs-property">$http</span> = axios;<br><span class="hljs-variable language_">this</span>.<span class="hljs-property">$http</span>.<span class="hljs-title function_">jsonp</span>(<span class="hljs-string">&#x27;http://www.domain2.com:8080/login&#x27;</span>, &#123;<br>    <span class="hljs-attr">params</span>: &#123;&#125;,<br>    <span class="hljs-attr">jsonp</span>: <span class="hljs-string">&#x27;handleCallback&#x27;</span><br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res); <br>&#125;)<br></code></pre></td></tr></table></figure><p>后端node.js代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> querystring = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;querystring&#x27;</span>);<br><span class="hljs-keyword">var</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;http&#x27;</span>);<br><span class="hljs-keyword">var</span> server = http.<span class="hljs-title function_">createServer</span>();<br>server.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;request&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">req, res</span>) &#123;<br>    <span class="hljs-keyword">var</span> params = querystring.<span class="hljs-title function_">parse</span>(req.<span class="hljs-property">url</span>.<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27;?&#x27;</span>)[<span class="hljs-number">1</span>]);<br>    <span class="hljs-keyword">var</span> fn = params.<span class="hljs-property">callback</span>;<br>    <span class="hljs-comment">// jsonp返回设置</span><br>    res.<span class="hljs-title function_">writeHead</span>(<span class="hljs-number">200</span>, &#123; <span class="hljs-string">&#x27;Content-Type&#x27;</span>: <span class="hljs-string">&#x27;text/javascript&#x27;</span> &#125;);<br>    res.<span class="hljs-title function_">write</span>(fn + <span class="hljs-string">&#x27;(&#x27;</span> + <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(params) + <span class="hljs-string">&#x27;)&#x27;</span>);<br>    res.<span class="hljs-title function_">end</span>();<br>&#125;);<br>server.<span class="hljs-title function_">listen</span>(<span class="hljs-string">&#x27;8080&#x27;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Server is running at port 8080...&#x27;</span>);<br></code></pre></td></tr></table></figure><p><strong>JSONP的缺点：</strong></p><ul><li>具有局限性， 仅支持get方法</li><li>不安全，可能会遭受XSS攻击</li></ul><h4 id="（3）postMessage-跨域"><a href="#（3）postMessage-跨域" class="headerlink" title="（3）postMessage 跨域"></a>（3）postMessage 跨域</h4><p>postMessage是HTML5 XMLHttpRequest Level 2中的API，且是为数不多可以跨域操作的window属性之一，它可用于解决以下方面的问题：</p><ul><li>页面和其打开的新窗口的数据传递</li><li>多窗口之间消息传递</li><li>页面与嵌套的iframe消息传递</li><li>上面三个场景的跨域数据传递</li></ul><p>用法：postMessage(data,origin)方法接受两个参数：</p><ul><li><strong>data</strong>： html5规范支持任意基本类型或可复制的对象，但部分浏览器只支持字符串，所以传参时最好用JSON.stringify()序列化。</li><li><strong>origin</strong>： 协议+主机+端口号，也可以设置为”*”，表示可以传递给任意窗口，如果要指定和当前窗口同源的话设置为”&#x2F;“。</li></ul><p>1）a.html：(domain1.com&#x2F;a.html)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;iframe id=<span class="hljs-string">&quot;iframe&quot;</span> src=<span class="hljs-string">&quot;http://www.domain2.com/b.html&quot;</span> style=<span class="hljs-string">&quot;display:none;&quot;</span>&gt;&lt;/iframe&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript">       </span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">var</span> iframe = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;iframe&#x27;</span>);</span></span><br><span class="language-javascript"><span class="language-xml">    iframe.<span class="hljs-property">onload</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-keyword">var</span> data = &#123;</span></span><br><span class="language-javascript"><span class="language-xml">            <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;aym&#x27;</span></span></span><br><span class="language-javascript"><span class="language-xml">        &#125;;</span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-comment">// 向domain2传送跨域数据</span></span></span><br><span class="language-javascript"><span class="language-xml">        iframe.<span class="hljs-property">contentWindow</span>.<span class="hljs-title function_">postMessage</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(data), <span class="hljs-string">&#x27;http://www.domain2.com&#x27;</span>);</span></span><br><span class="language-javascript"><span class="language-xml">    &#125;;</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">// 接受domain2返回数据</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;message&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;data from domain2 ---&gt; &#x27;</span> + e.<span class="hljs-property">data</span>);</span></span><br><span class="language-javascript"><span class="language-xml">    &#125;, <span class="hljs-literal">false</span>);</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>2）b.html：(domain2.com&#x2F;b.html)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;script&gt;<br>    <span class="hljs-comment">// 接收domain1的数据</span><br>    <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;message&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) &#123;<br>        <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;data from domain1 ---&gt; &#x27;</span> + e.<span class="hljs-property">data</span>);<br>        <span class="hljs-keyword">var</span> data = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(e.<span class="hljs-property">data</span>);<br>        <span class="hljs-keyword">if</span> (data) &#123;<br>            data.<span class="hljs-property">number</span> = <span class="hljs-number">16</span>;<br>            <span class="hljs-comment">// 处理后再发回domain1</span><br>            <span class="hljs-variable language_">window</span>.<span class="hljs-property">parent</span>.<span class="hljs-title function_">postMessage</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(data), <span class="hljs-string">&#x27;http://www.domain1.com&#x27;</span>);<br>        &#125;<br>    &#125;, <span class="hljs-literal">false</span>);<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><h4 id="（4）nginx代理跨域"><a href="#（4）nginx代理跨域" class="headerlink" title="（4）nginx代理跨域"></a>（4）nginx代理跨域</h4><p>nginx代理跨域，实质和CORS跨域原理一样，通过配置文件设置请求响应头Access-Control-Allow-Origin…等字段。</p><p>1）nginx配置解决iconfont跨域<br>浏览器跨域访问js、css、img等常规静态资源被同源策略许可，但iconfont字体文件(eot|otf|ttf|woff|svg)例外，此时可在nginx的静态资源服务器中加入以下配置。</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs http">location / &#123;<br>  add_header Access-Control-Allow-Origin *;<br>&#125;<br></code></pre></td></tr></table></figure><p>2）nginx反向代理接口跨域<br>跨域问题：同源策略仅是针对浏览器的安全策略。服务器端调用HTTP接口只是使用HTTP协议，不需要同源策略，也就不存在跨域问题。<br>实现思路：通过Nginx配置一个代理服务器域名与domain1相同，端口不同）做跳板机，反向代理访问domain2接口，并且可以顺便修改cookie中domain信息，方便当前域cookie写入，实现跨域访问。</p><p>nginx具体配置：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript">#proxy服务器<br>server &#123;<br>    listen       <span class="hljs-number">81</span>;<br>    server_name  www.<span class="hljs-property">domain1</span>.<span class="hljs-property">com</span>;<br>    location / &#123;<br>        proxy_pass   <span class="hljs-attr">http</span>:<span class="hljs-comment">//www.domain2.com:8080;  #反向代理</span><br>        proxy_cookie_domain www.<span class="hljs-property">domain2</span>.<span class="hljs-property">com</span> www.<span class="hljs-property">domain1</span>.<span class="hljs-property">com</span>; #修改cookie里域名<br>        index  index.<span class="hljs-property">html</span> index.<span class="hljs-property">htm</span>;<br>        # 当用webpack-dev-server等中间件代理接口访问nignx时，此时无浏览器参与，故没有同源限制，下面的跨域配置可不启用<br>        add_header <span class="hljs-title class_">Access</span>-<span class="hljs-title class_">Control</span>-<span class="hljs-title class_">Allow</span>-<span class="hljs-title class_">Origin</span> <span class="hljs-attr">http</span>:<span class="hljs-comment">//www.domain1.com;  #当前端只跨域不带cookie时，可为*</span><br>        add_header <span class="hljs-title class_">Access</span>-<span class="hljs-title class_">Control</span>-<span class="hljs-title class_">Allow</span>-<span class="hljs-title class_">Credentials</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="（5）nodejs-中间件代理跨域"><a href="#（5）nodejs-中间件代理跨域" class="headerlink" title="（5）nodejs 中间件代理跨域"></a>（5）nodejs 中间件代理跨域</h4><p>node中间件实现跨域代理，原理大致与nginx相同，都是通过启一个代理服务器，实现数据的转发，也可以通过设置cookieDomainRewrite参数修改响应头中cookie中域名，实现当前域的cookie写入，方便接口登录认证。</p><p><strong>1）非vue框架的跨域</strong><br>使用node + express + http-proxy-middleware搭建一个proxy服务器。</p><ul><li>前端代码：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>();<br><span class="hljs-comment">// 前端开关：浏览器是否读写cookie</span><br>xhr.<span class="hljs-property">withCredentials</span> = <span class="hljs-literal">true</span>;<br><span class="hljs-comment">// 访问http-proxy-middleware代理服务器</span><br>xhr.<span class="hljs-title function_">open</span>(<span class="hljs-string">&#x27;get&#x27;</span>, <span class="hljs-string">&#x27;http://www.domain1.com:3000/login?user=admin&#x27;</span>, <span class="hljs-literal">true</span>);<br>xhr.<span class="hljs-title function_">send</span>();<br></code></pre></td></tr></table></figure><ul><li>中间件服务器代码：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>);<br><span class="hljs-keyword">var</span> proxy = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;http-proxy-middleware&#x27;</span>);<br><span class="hljs-keyword">var</span> app = <span class="hljs-title function_">express</span>();<br>app.<span class="hljs-title function_">use</span>(<span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-title function_">proxy</span>(&#123;<br>    <span class="hljs-comment">// 代理跨域目标接口</span><br>    <span class="hljs-attr">target</span>: <span class="hljs-string">&#x27;http://www.domain2.com:8080&#x27;</span>,<br>    <span class="hljs-attr">changeOrigin</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-comment">// 修改响应头信息，实现跨域并允许带cookie</span><br>    <span class="hljs-attr">onProxyRes</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">proxyRes, req, res</span>) &#123;<br>        res.<span class="hljs-title function_">header</span>(<span class="hljs-string">&#x27;Access-Control-Allow-Origin&#x27;</span>, <span class="hljs-string">&#x27;http://www.domain1.com&#x27;</span>);<br>        res.<span class="hljs-title function_">header</span>(<span class="hljs-string">&#x27;Access-Control-Allow-Credentials&#x27;</span>, <span class="hljs-string">&#x27;true&#x27;</span>);<br>    &#125;,<br>    <span class="hljs-comment">// 修改响应信息中的cookie域名</span><br>    <span class="hljs-attr">cookieDomainRewrite</span>: <span class="hljs-string">&#x27;www.domain1.com&#x27;</span>  <span class="hljs-comment">// 可以为false，表示不修改</span><br>&#125;));<br>app.<span class="hljs-title function_">listen</span>(<span class="hljs-number">3000</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Proxy server is listen at port 3000...&#x27;</span>);<br></code></pre></td></tr></table></figure><p><strong>2）vue框架的跨域</strong></p><p>node + vue + webpack + webpack-dev-server搭建的项目，跨域请求接口，直接修改webpack.config.js配置。开发环境下，vue渲染服务和接口代理服务都是webpack-dev-server同一个，所以页面与代理接口之间不再跨域。</p><p>webpack.config.js部分配置：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>    <span class="hljs-attr">entry</span>: &#123;&#125;,<br>    <span class="hljs-attr">module</span>: &#123;&#125;,<br>    ...<br>    <span class="hljs-attr">devServer</span>: &#123;<br>        <span class="hljs-attr">historyApiFallback</span>: <span class="hljs-literal">true</span>,<br>        <span class="hljs-attr">proxy</span>: [&#123;<br>            <span class="hljs-attr">context</span>: <span class="hljs-string">&#x27;/login&#x27;</span>,<br>            <span class="hljs-attr">target</span>: <span class="hljs-string">&#x27;http://www.domain2.com:8080&#x27;</span>,  <span class="hljs-comment">// 代理跨域目标接口</span><br>            <span class="hljs-attr">changeOrigin</span>: <span class="hljs-literal">true</span>,<br>            <span class="hljs-attr">secure</span>: <span class="hljs-literal">false</span>,  <span class="hljs-comment">// 当代理某些https服务报错时用</span><br>            <span class="hljs-attr">cookieDomainRewrite</span>: <span class="hljs-string">&#x27;www.domain1.com&#x27;</span>  <span class="hljs-comment">// 可以为false，表示不修改</span><br>        &#125;],<br>        <span class="hljs-attr">noInfo</span>: <span class="hljs-literal">true</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="（6）document-domain-iframe跨域"><a href="#（6）document-domain-iframe跨域" class="headerlink" title="（6）document.domain + iframe跨域"></a>（6）document.domain + iframe跨域</h4><p>此方案仅限主域相同，子域不同的跨域应用场景。实现原理：两个页面都通过js强制设置document.domain为基础主域，就实现了同域。<br>1）父窗口：(domain.com&#x2F;a.html)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;iframe id=<span class="hljs-string">&quot;iframe&quot;</span> src=<span class="hljs-string">&quot;http://child.domain.com/b.html&quot;</span>&gt;&lt;/iframe&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-variable language_">document</span>.<span class="hljs-property">domain</span> = <span class="hljs-string">&#x27;domain.com&#x27;</span>;</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">var</span> user = <span class="hljs-string">&#x27;admin&#x27;</span>;</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>1）子窗口：(child.domain.com&#x2F;a.html)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;script&gt;<br>    <span class="hljs-variable language_">document</span>.<span class="hljs-property">domain</span> = <span class="hljs-string">&#x27;domain.com&#x27;</span>;<br>    <span class="hljs-comment">// 获取父窗口中变量</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;get js data from parent ---&gt; &#x27;</span> + <span class="hljs-variable language_">window</span>.<span class="hljs-property">parent</span>.<span class="hljs-property">user</span>);<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><h4 id="（7）location-hash-iframe跨域"><a href="#（7）location-hash-iframe跨域" class="headerlink" title="（7）location.hash + iframe跨域"></a>（7）location.hash + iframe跨域</h4><p>实现原理：a欲与b跨域相互通信，通过中间页c来实现。 三个页面，不同域之间利用iframe的location.hash传值，相同域之间直接js访问来通信。</p><p>具体实现：A域：a.html -&gt; B域：b.html -&gt; A域：c.html，a与b不同域只能通过hash值单向通信，b与c也不同域也只能单向通信，但c与a同域，所以c可通过parent.parent访问a页面所有对象。</p><p>1）a.html：(domain1.com&#x2F;a.html)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;iframe id=<span class="hljs-string">&quot;iframe&quot;</span> src=<span class="hljs-string">&quot;http://www.domain2.com/b.html&quot;</span> style=<span class="hljs-string">&quot;display:none;&quot;</span>&gt;&lt;/iframe&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">var</span> iframe = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;iframe&#x27;</span>);</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">// 向b.html传hash值</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">        iframe.<span class="hljs-property">src</span> = iframe.<span class="hljs-property">src</span> + <span class="hljs-string">&#x27;#user=admin&#x27;</span>;</span></span><br><span class="language-javascript"><span class="language-xml">    &#125;, <span class="hljs-number">1000</span>);</span></span><br><span class="language-javascript"><span class="language-xml">    </span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">// 开放给同域c.html的回调方法</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">function</span> <span class="hljs-title function_">onCallback</span>(<span class="hljs-params">res</span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;data from c.html ---&gt; &#x27;</span> + res);</span></span><br><span class="language-javascript"><span class="language-xml">    &#125;</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>2）b.html：(.domain2.com&#x2F;b.html)</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">iframe</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;iframe&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;http://www.domain1.com/c.html&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;display:none;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">iframe</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-keyword">var</span> iframe = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;iframe&#x27;</span>);</span><br><span class="language-javascript">    <span class="hljs-comment">// 监听a.html传来的hash值，再传给c.html</span></span><br><span class="language-javascript">    <span class="hljs-variable language_">window</span>.<span class="hljs-property">onhashchange</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">        iframe.<span class="hljs-property">src</span> = iframe.<span class="hljs-property">src</span> + location.<span class="hljs-property">hash</span>;</span><br><span class="language-javascript">    &#125;;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>3）c.html：(<a href="https://link.zhihu.com/?target=http://www.domain1.com/c.html">http://www.domain1.com/c.html</a>)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;script&gt;<br>    <span class="hljs-comment">// 监听b.html传来的hash值</span><br>    <span class="hljs-variable language_">window</span>.<span class="hljs-property">onhashchange</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-comment">// 再通过操作同域a.html的js回调，将结果传回</span><br>        <span class="hljs-variable language_">window</span>.<span class="hljs-property">parent</span>.<span class="hljs-property">parent</span>.<span class="hljs-title function_">onCallback</span>(<span class="hljs-string">&#x27;hello: &#x27;</span> + location.<span class="hljs-property">hash</span>.<span class="hljs-title function_">replace</span>(<span class="hljs-string">&#x27;#user=&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>));<br>    &#125;;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><h4 id="（8）window-name-iframe跨域"><a href="#（8）window-name-iframe跨域" class="headerlink" title="（8）window.name + iframe跨域"></a>（8）window.name + iframe跨域</h4><p>window.name属性的独特之处：name值在不同的页面（甚至不同域名）加载后依旧存在，并且可以支持非常长的 name 值（2MB）。</p><p>1）a.html：(domain1.com&#x2F;a.html)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> proxy = <span class="hljs-keyword">function</span>(<span class="hljs-params">url, callback</span>) &#123;<br>    <span class="hljs-keyword">var</span> state = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">var</span> iframe = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;iframe&#x27;</span>);<br>    <span class="hljs-comment">// 加载跨域页面</span><br>    iframe.<span class="hljs-property">src</span> = url;<br>    <span class="hljs-comment">// onload事件会触发2次，第1次加载跨域页，并留存数据于window.name</span><br>    iframe.<span class="hljs-property">onload</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">if</span> (state === <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-comment">// 第2次onload(同域proxy页)成功后，读取同域window.name中数据</span><br>            <span class="hljs-title function_">callback</span>(iframe.<span class="hljs-property">contentWindow</span>.<span class="hljs-property">name</span>);<br>            <span class="hljs-title function_">destoryFrame</span>();<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (state === <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// 第1次onload(跨域页)成功后，切换到同域代理页面</span><br>            iframe.<span class="hljs-property">contentWindow</span>.<span class="hljs-property">location</span> = <span class="hljs-string">&#x27;http://www.domain1.com/proxy.html&#x27;</span>;<br>            state = <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;;<br>    <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">appendChild</span>(iframe);<br>    <span class="hljs-comment">// 获取数据以后销毁这个iframe，释放内存；这也保证了安全（不被其他域frame js访问）</span><br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">destoryFrame</span>(<span class="hljs-params"></span>) &#123;<br>        iframe.<span class="hljs-property">contentWindow</span>.<span class="hljs-property">document</span>.<span class="hljs-title function_">write</span>(<span class="hljs-string">&#x27;&#x27;</span>);<br>        iframe.<span class="hljs-property">contentWindow</span>.<span class="hljs-title function_">close</span>();<br>        <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">removeChild</span>(iframe);<br>    &#125;<br>&#125;;<br><span class="hljs-comment">// 请求跨域b页面数据</span><br><span class="hljs-title function_">proxy</span>(<span class="hljs-string">&#x27;http://www.domain2.com/b.html&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">data</span>)&#123;<br>    <span class="hljs-title function_">alert</span>(data);<br>&#125;);<br></code></pre></td></tr></table></figure><p>2）proxy.html：(domain1.com&#x2F;proxy.html)</p><p>中间代理页，与a.html同域，内容为空即可。<br>3）b.html：(domain2.com&#x2F;b.html)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;script&gt;    <br>    <span class="hljs-variable language_">window</span>.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;This is domain2 data!&#x27;</span>;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p>通过iframe的src属性由外域转向本地域，跨域数据即由iframe的window.name从外域传递到本地域。这个就巧妙地绕过了浏览器的跨域访问限制，但同时它又是安全操作。</p><h4 id="（9）WebSocket协议跨域"><a href="#（9）WebSocket协议跨域" class="headerlink" title="（9）WebSocket协议跨域"></a>（9）WebSocket协议跨域</h4><p>WebSocket protocol是HTML5一种新的协议。它实现了浏览器与服务器全双工通信，同时允许跨域通讯，是server push技术的一种很好的实现。</p><p>原生WebSocket API使用起来不太方便，我们使用Socket.io，它很好地封装了webSocket接口，提供了更简单、灵活的接口，也对不支持webSocket的浏览器提供了向下兼容。</p><p>1）前端代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;div&gt;user input：&lt;input type=<span class="hljs-string">&quot;text&quot;</span>&gt;&lt;/div&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://cdn.bootcss.com/socket.io/2.2.0/socket.io.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">var</span> socket = <span class="hljs-title function_">io</span>(<span class="hljs-string">&#x27;http://www.domain2.com:8080&#x27;</span>);</span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-comment">// 连接成功处理</span></span></span><br><span class="language-javascript"><span class="language-xml">socket.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;connect&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">// 监听服务端消息</span></span></span><br><span class="language-javascript"><span class="language-xml">    socket.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;message&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">msg</span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;data from server: ---&gt; &#x27;</span> + msg); </span></span><br><span class="language-javascript"><span class="language-xml">    &#125;);</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">// 监听服务端关闭</span></span></span><br><span class="language-javascript"><span class="language-xml">    socket.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;disconnect&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; </span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Server socket has closed.&#x27;</span>); </span></span><br><span class="language-javascript"><span class="language-xml">    &#125;);</span></span><br><span class="language-javascript"><span class="language-xml">&#125;);</span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementsByTagName</span>(<span class="hljs-string">&#x27;input&#x27;</span>)[<span class="hljs-number">0</span>].<span class="hljs-property">onblur</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">    socket.<span class="hljs-title function_">send</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>);</span></span><br><span class="language-javascript"><span class="language-xml">&#125;;</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>2）Nodejs socket后台：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;http&#x27;</span>);<br><span class="hljs-keyword">var</span> socket = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;socket.io&#x27;</span>);<br><span class="hljs-comment">// 启http服务</span><br><span class="hljs-keyword">var</span> server = http.<span class="hljs-title function_">createServer</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">req, res</span>) &#123;<br>    res.<span class="hljs-title function_">writeHead</span>(<span class="hljs-number">200</span>, &#123;<br>        <span class="hljs-string">&#x27;Content-type&#x27;</span>: <span class="hljs-string">&#x27;text/html&#x27;</span><br>    &#125;);<br>    res.<span class="hljs-title function_">end</span>();<br>&#125;);<br>server.<span class="hljs-title function_">listen</span>(<span class="hljs-string">&#x27;8080&#x27;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Server is running at port 8080...&#x27;</span>);<br><span class="hljs-comment">// 监听socket连接</span><br>socket.<span class="hljs-title function_">listen</span>(server).<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;connection&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">client</span>) &#123;<br>    <span class="hljs-comment">// 接收信息</span><br>    client.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;message&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">msg</span>) &#123;<br>        client.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;hello：&#x27;</span> + msg);<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;data from client: ---&gt; &#x27;</span> + msg);<br>    &#125;);<br>    <span class="hljs-comment">// 断开处理</span><br>    client.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;disconnect&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Client socket has closed.&#x27;</span>); <br>    &#125;);<br>&#125;);<br></code></pre></td></tr></table></figure><h3 id="3-正向代理和反向代理的区别"><a href="#3-正向代理和反向代理的区别" class="headerlink" title="3. 正向代理和反向代理的区别"></a>3. 正向代理和反向代理的区别</h3><ul><li><strong>正向代理：</strong></li></ul><p>客户端想获得一个服务器的数据，但是因为种种原因无法直接获取。于是客户端设置了一个代理服务器，并且指定目标服务器，之后代理服务器向目标服务器转交请求并将获得的内容发送给客户端。这样本质上起到了对真实服务器隐藏真实客户端的目的。实现正向代理需要修改客户端，比如修改浏览器配置。</p><ul><li><strong>反向代理：</strong></li></ul><p>服务器为了能够将工作负载分不到多个服务器来提高网站性能 (负载均衡)等目的，当其受到请求后，会首先根据转发规则来确定请求应该被转发到哪个服务器上，然后将请求转发到对应的真实服务器上。这样本质上起到了对客户端隐藏真实服务器的作用。<br>一般使用反向代理后，需要通过修改 DNS 让域名解析到代理服务器 IP，这时浏览器无法察觉到真正服务器的存在，当然也就不需要修改配置了。</p><p>两者区别如图示：<br><img src="8.png" alt="img"><br>正向代理和反向代理的结构是一样的，都是 client-proxy-server 的结构，它们主要的区别就在于中间这个 proxy 是哪一方设置的。在正向代理中，proxy 是 client 设置的，用来隐藏 client；而在反向代理中，proxy 是 server 设置的，用来隐藏 server。</p><h3 id="4-Nginx的概念及其工作原理"><a href="#4-Nginx的概念及其工作原理" class="headerlink" title="4. Nginx的概念及其工作原理"></a>4. Nginx的概念及其工作原理</h3><p>Nginx 是一款轻量级的 Web 服务器，也可以用于反向代理、负载平衡和 HTTP 缓存等。Nginx 使用异步事件驱动的方法来处理请求，是一款面向性能设计的 HTTP 服务器。</p><p>传统的 Web 服务器如 Apache 是 process-based 模型的，而 Nginx 是基于event-driven模型的。正是这个主要的区别带给了 Nginx 在性能上的优势。</p><p>Nginx 架构的最顶层是一个 master process，这个 master process 用于产生其他的 worker process，这一点和Apache 非常像，但是 Nginx 的 worker process 可以同时处理大量的HTTP请求，而每个 Apache process 只能处理一个。</p><h2 id="八、浏览器事件机制"><a href="#八、浏览器事件机制" class="headerlink" title="八、浏览器事件机制"></a>八、浏览器事件机制</h2><h3 id="1-事件是什么？事件模型？"><a href="#1-事件是什么？事件模型？" class="headerlink" title="1. 事件是什么？事件模型？"></a>1. 事件是什么？事件模型？</h3><p>事件是用户操作网页时发生的交互动作，比如 click&#x2F;move， 事件除了用户触发的动作外，还可以是文档加载，窗口滚动和大小调整。事件被封装成一个 event 对象，包含了该事件发生时的所有相关信息（ event 的属性）以及可以对事件进行的操作（ event 的方法）。</p><p>事件是用户操作网页时发生的交互动作或者网页本身的一些操作，现代浏览器一共有三种事件模型：</p><ul><li><strong>DOM0 级事件模型</strong>，这种模型不会传播，所以没有事件流的概念，但是现在有的浏览器支持以冒泡的方式实现，它可以在网页中直接定义监听函数，也可以通过 js 属性来指定监听函数。所有浏览器都兼容这种方式。直接在dom对象上注册事件名称，就是DOM0写法。</li><li><strong>IE 事件模型</strong>，在该事件模型中，一次事件共有两个过程，事件处理阶段和事件冒泡阶段。事件处理阶段会首先执行目标元素绑定的监听事件。然后是事件冒泡阶段，冒泡指的是事件从目标元素冒泡到 document，依次检查经过的节点是否绑定了事件监听函数，如果有则执行。这种模型通过attachEvent 来添加监听函数，可以添加多个监听函数，会按顺序依次执行。</li><li><strong>DOM2 级事件模型</strong>，在该事件模型中，一次事件共有三个过程，第一个过程是事件捕获阶段。捕获指的是事件从 document 一直向下传播到目标元素，依次检查经过的节点是否绑定了事件监听函数，如果有则执行。后面两个阶段和 IE 事件模型的两个阶段相同。这种事件模型，事件绑定的函数是addEventListener，其中第三个参数可以指定事件是否在捕获阶段执行。</li></ul><h3 id="2-如何阻止事件冒泡"><a href="#2-如何阻止事件冒泡" class="headerlink" title="2. 如何阻止事件冒泡"></a>2. 如何阻止事件冒泡</h3><ul><li>普通浏览器使用：event.stopPropagation() </li><li>IE浏览器使用：event.cancelBubble &#x3D; true;</li></ul><h3 id="3-对事件委托的理解"><a href="#3-对事件委托的理解" class="headerlink" title="3. 对事件委托的理解"></a>3. 对事件委托的理解</h3><h4 id="（1）事件委托的概念"><a href="#（1）事件委托的概念" class="headerlink" title="（1）事件委托的概念"></a>（1）事件委托的概念</h4><p>事件委托本质上是利用了<strong>浏览器事件冒泡</strong>的机制。因为事件在冒泡过程中会上传到父节点，父节点可以通过事件对象获取到目标节点，因此可以把子节点的监听函数定义在父节点上，由父节点的监听函数统一处理多个子元素的事件，这种方式称为事件委托（事件代理）。</p><p>使用事件委托可以不必要为每一个子元素都绑定一个监听事件，这样减少了内存上的消耗。并且使用事件代理还可以实现事件的动态绑定，比如说新增了一个子节点，并不需要单独地为它添加一个监听事件，它绑定的事件会交给父元素中的监听函数来处理。</p><h4 id="（2）事件委托的特点"><a href="#（2）事件委托的特点" class="headerlink" title="（2）事件委托的特点"></a>（2）事件委托的特点</h4><ul><li><strong>减少内存消耗</strong></li></ul><p>如果有一个列表，列表之中有大量的列表项，需要在点击列表项的时候响应一个事件：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;list&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>item 1<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>item 2<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>item 3<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>  ......<br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>item n<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br></code></pre></td></tr></table></figure><p>如果给每个列表项一一都绑定一个函数，那对于内存消耗是非常大的，效率上需要消耗很多性能。因此，比较好的方法就是把这个点击事件绑定到他的父层，也就是 ul 上，然后在执行事件时再去匹配判断目标元素，所以事件委托可以减少大量的内存消耗，节约效率。</p><ul><li><strong>动态绑定事件</strong></li></ul><p>给上述的例子中每个列表项都绑定事件，在很多时候，需要通过 AJAX 或者用户操作动态的增加或者去除列表项元素，那么在每一次改变的时候都需要重新给新增的元素绑定事件，给即将删去的元素解绑事件；如果用了事件委托就没有这种麻烦了，因为事件是绑定在父层的，和目标元素的增减是没有关系的，执行到目标元素是在真正响应执行事件函数的过程中去匹配的，所以使用事件在动态绑定事件的情况下是可以减少很多重复工作的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 来实现把 #list 下的 li 元素的事件代理委托到它的父层元素也就是 #list 上：</span><br><span class="hljs-comment">// 给父层元素绑定事件</span><br><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;list&#x27;</span>).<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) &#123;<br>  <span class="hljs-comment">// 兼容性处理</span><br>  <span class="hljs-keyword">var</span> event = e || <span class="hljs-variable language_">window</span>.<span class="hljs-property">event</span>;<br>  <span class="hljs-keyword">var</span> target = event.<span class="hljs-property">target</span> || event.<span class="hljs-property">srcElement</span>;<br>  <span class="hljs-comment">// 判断是否匹配目标元素</span><br>  <span class="hljs-keyword">if</span> (target.<span class="hljs-property">nodeName</span>.<span class="hljs-property">toLocaleLowerCase</span> === <span class="hljs-string">&#x27;li&#x27;</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;the content is: &#x27;</span>, target.<span class="hljs-property">innerHTML</span>);<br>  &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><p>在上述代码中， target 元素则是在 #list 元素之下具体被点击的元素，然后通过判断 target 的一些属性（比如：nodeName，id 等等）可以更精确地匹配到某一类 #list li 元素之上；</p><h4 id="（3）局限性"><a href="#（3）局限性" class="headerlink" title="（3）局限性"></a>（3）局限性</h4><p>当然，事件委托也是有局限的。比如 focus、blur 之类的事件没有事件冒泡机制，所以无法实现事件委托；mousemove、mouseout 这样的事件，虽然有事件冒泡，但是只能不断通过位置去计算定位，对性能消耗高，因此也是不适合于事件委托的。</p><p>当然事件委托不是只有优点，它也是有<strong>缺点</strong>的，事件委托会影响页面性能，主要影响因素有：</p><ul><li>元素中，绑定事件委托的次数；</li><li>点击的最底层元素，到绑定事件元素之间的<code>DOM</code>层数；</li></ul><p>在必须使用事件委托的地方，可以进行如下的处理：</p><ul><li>只在必须的地方，使用事件委托，比如：<code>ajax</code>的局部刷新区域</li><li>尽量的减少绑定的层级，不在<code>body</code>元素上，进行绑定</li><li>减少绑定的次数，如果可以，那么把多个事件的绑定，合并到一次事件委托中去，由这个事件委托的回调，来进行分发。</li></ul><h3 id="4-事件委托的使用场景"><a href="#4-事件委托的使用场景" class="headerlink" title="4. 事件委托的使用场景"></a>4. 事件委托的使用场景</h3><p>场景：给页面的所有的a标签添加click事件，代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;click&quot;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) &#123;<br><span class="hljs-keyword">if</span> (e.<span class="hljs-property">target</span>.<span class="hljs-property">nodeName</span> == <span class="hljs-string">&quot;A&quot;</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;a&quot;</span>);<br>&#125;, <span class="hljs-literal">false</span>);<br></code></pre></td></tr></table></figure><p>但是这些a标签可能包含一些像span、img等元素，如果点击到了这些a标签中的元素，就不会触发click事件，因为事件绑定上在a标签元素上，而触发这些内部的元素时，e.target指向的是触发click事件的元素（span、img等其他元素）。</p><p>这种情况下就可以使用事件委托来处理，将事件绑定在a标签的内部元素上，当点击它的时候，就会逐级向上查找，知道找到a标签为止，代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;click&quot;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) &#123;<br><span class="hljs-keyword">var</span> node = e.<span class="hljs-property">target</span>;<br><span class="hljs-keyword">while</span> (node.<span class="hljs-property">parentNode</span>.<span class="hljs-property">nodeName</span> != <span class="hljs-string">&quot;BODY&quot;</span>) &#123;<br><span class="hljs-keyword">if</span> (node.<span class="hljs-property">nodeName</span> == <span class="hljs-string">&quot;A&quot;</span>) &#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;a&quot;</span>);<br><span class="hljs-keyword">break</span>;<br>&#125;<br>node = node.<span class="hljs-property">parentNode</span>;<br>&#125;<br>&#125;, <span class="hljs-literal">false</span>);<br></code></pre></td></tr></table></figure><h3 id="5-同步和异步的区别"><a href="#5-同步和异步的区别" class="headerlink" title="5. 同步和异步的区别"></a>5. 同步和异步的区别</h3><ul><li><strong>同步</strong>指的是当一个进程在执行某个请求时，如果这个请求需要等待一段时间才能返回，那么这个进程会一直等待下去，直到消息返回为止再继续向下执行。</li><li><strong>异步</strong>指的是当一个进程在执行某个请求时，如果这个请求需要等待一段时间才能返回，这个时候进程会继续往下执行，不会阻塞等待消息的返回，当消息返回时系统再通知进程进行处理。</li></ul><h3 id="6-对事件循环的理解"><a href="#6-对事件循环的理解" class="headerlink" title="6. 对事件循环的理解"></a>6. 对事件循环的理解</h3><p>因为 js 是单线程运行的，在代码执行时，通过将不同函数的执行上下文压入执行栈中来保证代码的有序执行。在执行同步代码时，如果遇到异步事件，js 引擎并不会一直等待其返回结果，而是会将这个事件挂起，继续执行执行栈中的其他任务。当异步事件执行完毕后，再将异步事件对应的回调加入到一个任务队列中等待执行。任务队列可以分为宏任务队列和微任务队列，当当前执行栈中的事件执行完毕后，js 引擎首先会判断微任务队列中是否有任务可以执行，如果有就将微任务队首的事件压入栈中执行。当微任务队列中的任务都执行完成后再去执行宏任务队列中的任务。</p><p><img src="9.png" alt="img"></p><p>Event Loop 执行顺序如下所示：</p><ul><li>首先执行同步代码，这属于宏任务</li><li>当执行完所有同步代码后，执行栈为空，查询是否有异步代码需要执行</li><li>执行所有微任务</li><li>当执行完所有微任务后，如有必要会渲染页面</li><li>然后开始下一轮 Event Loop，执行宏任务中的异步代码</li></ul><h3 id="7-宏任务和微任务分别有哪些"><a href="#7-宏任务和微任务分别有哪些" class="headerlink" title="7. 宏任务和微任务分别有哪些"></a>7. 宏任务和微任务分别有哪些</h3><ul><li>微任务包括： promise 的回调、node 中的 process.nextTick 、对 Dom 变化监听的 MutationObserver。</li><li>宏任务包括： script 脚本的执行、setTimeout ，setInterval ，setImmediate 一类的定时事件，还有如 I&#x2F;O 操作、UI 渲染等。</li></ul><h3 id="8-什么是执行栈"><a href="#8-什么是执行栈" class="headerlink" title="8. 什么是执行栈"></a>8. 什么是执行栈</h3><p>可以把执行栈认为是一个存储函数调用的<strong>栈结构</strong>，遵循先进后出的原则。<br><img src="10.gif" alt="img"><br>当开始执行 JS 代码时，根据先进后出的原则，后执行的函数会先弹出栈，可以看到，<code>foo</code> 函数后执行，当执行完毕后就从栈中弹出了。</p><p>平时在开发中，可以在报错中找到执行栈的痕迹：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;error&#x27;</span>)<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">bar</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-title function_">foo</span>()<br>&#125;<br><span class="hljs-title function_">bar</span>()<br></code></pre></td></tr></table></figure><p><img src="11.png" alt="img"><br>可以看到报错在 <code>foo</code> 函数，<code>foo</code> 函数又是在 <code>bar</code> 函数中调用的。当使用递归时，因为栈可存放的函数是有<strong>限制</strong>的，一旦存放了过多的函数且没有得到释放的话，就会出现爆栈的问题</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">bar</span>(<span class="hljs-params"></span>) &#123;  <span class="hljs-title function_">bar</span>()&#125;<span class="hljs-title function_">bar</span>()<br></code></pre></td></tr></table></figure><p><img src="12.png" alt="img"></p><h3 id="9-Node-中的-Event-Loop-和浏览器中的有什么区别？process-nextTick-执行顺序？"><a href="#9-Node-中的-Event-Loop-和浏览器中的有什么区别？process-nextTick-执行顺序？" class="headerlink" title="9. Node 中的 Event Loop 和浏览器中的有什么区别？process.nextTick 执行顺序？"></a>9. Node 中的 Event Loop 和浏览器中的有什么区别？process.nextTick 执行顺序？</h3><p>Node 中的 Event Loop 和浏览器中的是完全不相同的东西。</p><p>Node 的 Event Loop 分为 6 个阶段，它们会按照<strong>顺序</strong>反复运行。每当进入某一个阶段的时候，都会从对应的回调队列中取出函数去执行。当队列为空或者执行的回调函数数量到达系统设定的阈值，就会进入下一阶段。<br><img src="13.png" alt="img"></p><p>（1）<strong>Timers（计时器阶段）</strong>：初次进入事件循环，会从计时器阶段开始。此阶段会判断是否存在过期的计时器回调（包含 setTimeout 和 setInterval），如果存在则会执行所有过期的计时器回调，执行完毕后，如果回调中触发了相应的微任务，会接着执行所有微任务，执行完微任务后再进入 Pending callbacks 阶段。</p><p>（2）<strong>Pending callbacks</strong>：执行推迟到下一个循环迭代的I &#x2F; O回调（系统调用相关的回调）。</p><p>（3）<strong>Idle&#x2F;Prepare</strong>：仅供内部使用。</p><p>（4）<strong>Poll（轮询阶段）</strong>：</p><ul><li>当回调队列不为空时：会执行回调，若回调中触发了相应的微任务，这里的微任务执行时机和其他地方有所不同，不会等到所有回调执行完毕后才执行，而是针对每一个回调执行完毕后，就执行相应微任务。执行完所有的回调后，变为下面的情况。</li><li>当回调队列为空时（没有回调或所有回调执行完毕）：但如果存在有计时器（setTimeout、setInterval和setImmediate）没有执行，会结束轮询阶段，进入 Check 阶段。否则会阻塞并等待任何正在执行的I&#x2F;O操作完成，并马上执行相应的回调，直到所有回调执行完毕。</li></ul><p>（5）<strong>Check（查询阶段）</strong>：会检查是否存在 setImmediate 相关的回调，如果存在则执行所有回调，执行完毕后，如果回调中触发了相应的微任务，会接着执行所有微任务，执行完微任务后再进入 Close callbacks 阶段。</p><p>（6）<strong>Close callbacks</strong>：执行一些关闭回调，比如socket.on(‘close’, …)等。</p><p>下面来看一个例子，首先在有些情况下，定时器的执行顺序其实是<strong>随机</strong>的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;setTimeout&#x27;</span>)&#125;, <span class="hljs-number">0</span>)<span class="hljs-title function_">setImmediate</span>(<span class="hljs-function">() =&gt;</span> &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;setImmediate&#x27;</span>)&#125;)<br></code></pre></td></tr></table></figure><p>对于以上代码来说，<code>setTimeout</code> 可能执行在前，也可能执行在后</p><ul><li>首先 <code>setTimeout(fn, 0) === setTimeout(fn, 1)</code>，这是由源码决定的</li><li>进入事件循环也是需要成本的，如果在准备时候花费了大于 1ms 的时间，那么在 timer 阶段就会直接执行 <code>setTimeout</code> 回调</li><li>那么如果准备时间花费小于 1ms，那么就是 <code>setImmediate</code> 回调先执行了</li></ul><p>当然在某些情况下，他们的执行顺序一定是固定的，比如以下代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>)<br>fs.<span class="hljs-title function_">readFile</span>(__filename, <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;timeout&#x27;</span>);<br>    &#125;, <span class="hljs-number">0</span>)<br>    <span class="hljs-title function_">setImmediate</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;immediate&#x27;</span>)<br>    &#125;)<br>&#125;)<br></code></pre></td></tr></table></figure><p>在上述代码中，<code>setImmediate</code> 永远<strong>先执行</strong>。因为两个代码写在 IO 回调中，IO 回调是在 poll 阶段执行，当回调执行完毕后队列为空，发现存在 <code>setImmediate</code> 回调，所以就直接跳转到 check 阶段去执行回调了。</p><p>上面都是 macrotask 的执行情况，对于 microtask 来说，它会在以上每个阶段完成前<strong>清空</strong> microtask 队列，下图中的 Tick 就代表了 microtask<br><img src="14.png" alt="img"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;timer21&#x27;</span>)<br>&#125;, <span class="hljs-number">0</span>)<br><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>().<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;promise1&#x27;</span>)<br>&#125;)<br></code></pre></td></tr></table></figure><p>对于以上代码来说，其实和浏览器中的输出是一样的，microtask 永远执行在 macrotask 前面。</p><p>最后来看 Node 中的 <code>process.nextTick</code>，这个函数其实是独立于 Event Loop 之外的，它有一个自己的队列，当每个阶段完成后，如果存在 nextTick 队列，就会<strong>清空队列中的所有回调函数</strong>，并且优先于其他 microtask 执行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;timer1&#x27;</span>)<br> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>().<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>   <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;promise1&#x27;</span>)<br> &#125;)<br>&#125;, <span class="hljs-number">0</span>)<br>process.<span class="hljs-title function_">nextTick</span>(<span class="hljs-function">() =&gt;</span> &#123;<br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;nextTick&#x27;</span>)<br> process.<span class="hljs-title function_">nextTick</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>   <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;nextTick&#x27;</span>)<br>   process.<span class="hljs-title function_">nextTick</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>     <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;nextTick&#x27;</span>)<br>     process.<span class="hljs-title function_">nextTick</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>       <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;nextTick&#x27;</span>)<br>     &#125;)<br>   &#125;)<br> &#125;)<br>&#125;)<br></code></pre></td></tr></table></figure><p>对于以上代码，永远都是先把 nextTick 全部打印出来。</p><h3 id="10-事件触发的过程是怎样的"><a href="#10-事件触发的过程是怎样的" class="headerlink" title="10. 事件触发的过程是怎样的"></a>10. 事件触发的过程是怎样的</h3><p>事件触发有三个阶段：</p><ul><li><code>window</code> 往事件触发处传播，遇到注册的捕获事件会触发</li><li>传播到事件触发处时触发注册的事件</li><li>从事件触发处往 <code>window</code> 传播，遇到注册的冒泡事件会触发</li></ul><p>事件触发一般来说会按照上面的顺序进行，但是也有特例，<strong>如果给一个 <strong><code>body</code></strong> 中的子节点同时注册冒泡和捕获事件，事件触发会按照注册的顺序执行。</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 以下会先打印冒泡然后是捕获</span><br>node.<span class="hljs-title function_">addEventListener</span>(<br>  <span class="hljs-string">&#x27;click&#x27;</span>,<br>  <span class="hljs-function"><span class="hljs-params">event</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;冒泡&#x27;</span>)<br>  &#125;,<br>  <span class="hljs-literal">false</span><br>)<br>node.<span class="hljs-title function_">addEventListener</span>(<br>  <span class="hljs-string">&#x27;click&#x27;</span>,<br>  <span class="hljs-function"><span class="hljs-params">event</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;捕获 &#x27;</span>)<br>  &#125;,<br>  <span class="hljs-literal">true</span><br>)<br></code></pre></td></tr></table></figure><p>通常使用 <code>addEventListener</code> 注册事件，该函数的第三个参数可以是布尔值，也可以是对象。对于布尔值 <code>useCapture</code> 参数来说，该参数默认值为 <code>false</code> ，<code>useCapture</code> 决定了注册的事件是捕获事件还是冒泡事件。对于对象参数来说，可以使用以下几个属性：</p><ul><li><code>capture</code>：布尔值，和 <code>useCapture</code> 作用一样</li><li><code>once</code>：布尔值，值为 <code>true</code> 表示该回调只会调用一次，调用后会移除监听</li><li><code>passive</code>：布尔值，表示永远不会调用 <code>preventDefault</code></li></ul><p>一般来说，如果只希望事件只触发在目标上，这时候可以使用 <code>stopPropagation</code> 来阻止事件的进一步传播。通常认为 <code>stopPropagation</code> 是用来阻止事件冒泡的，其实该函数也可以阻止捕获事件。</p><p><code>stopImmediatePropagation</code> 同样也能实现阻止事件，但是还能阻止该事件目标执行别的注册事件。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript">node.<span class="hljs-title function_">addEventListener</span>(<br>  <span class="hljs-string">&#x27;click&#x27;</span>,<br>  <span class="hljs-function"><span class="hljs-params">event</span> =&gt;</span> &#123;<br>    event.<span class="hljs-title function_">stopImmediatePropagation</span>()<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;冒泡&#x27;</span>)<br>  &#125;,<br>  <span class="hljs-literal">false</span><br>)<br><span class="hljs-comment">// 点击 node 只会执行上面的函数，该函数不会执行</span><br>node.<span class="hljs-title function_">addEventListener</span>(<br>  <span class="hljs-string">&#x27;click&#x27;</span>,<br>  <span class="hljs-function"><span class="hljs-params">event</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;捕获 &#x27;</span>)<br>  &#125;,<br>  <span class="hljs-literal">true</span><br>)<br></code></pre></td></tr></table></figure><h2 id="九、浏览器垃圾回收机制"><a href="#九、浏览器垃圾回收机制" class="headerlink" title="九、浏览器垃圾回收机制"></a>九、浏览器垃圾回收机制</h2><h3 id="1-V8的垃圾回收机制是怎样的"><a href="#1-V8的垃圾回收机制是怎样的" class="headerlink" title="1. V8的垃圾回收机制是怎样的"></a>1. V8的垃圾回收机制是怎样的</h3><p>V8 实现了准确式 GC，GC 算法采用了分代式垃圾回收机制。因此，V8 将内存（堆）分为新生代和老生代两部分。</p><p><strong>（1）新生代算法</strong></p><p>新生代中的对象一般存活时间较短，使用 Scavenge GC 算法。</p><p>在新生代空间中，内存空间分为两部分，分别为 From 空间和 To 空间。在这两个空间中，必定有一个空间是使用的，另一个空间是空闲的。新分配的对象会被放入 From 空间中，当 From 空间被占满时，新生代 GC 就会启动了。算法会检查 From 空间中存活的对象并复制到 To 空间中，如果有失活的对象就会销毁。当复制完成后将 From 空间和 To 空间互换，这样 GC 就结束了。</p><p><strong>（2）老生代算法</strong></p><p>老生代中的对象一般存活时间较长且数量也多，使用了两个算法，分别是标记清除算法和标记压缩算法。</p><p>先来说下什么情况下对象会出现在老生代空间中：</p><ul><li>新生代中的对象是否已经经历过一次 Scavenge 算法，如果经历过的话，会将对象从新生代空间移到老生代空间中。</li><li>To 空间的对象占比大小超过 25 %。在这种情况下，为了不影响到内存分配，会将对象从新生代空间移到老生代空间中。</li></ul><p>老生代中的空间很复杂，有如下几个空间</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript">enum <span class="hljs-title class_">AllocationSpace</span> &#123;<br>  <span class="hljs-comment">// TODO(v8:7464): Actually map this space&#x27;s memory as read-only.</span><br>  <span class="hljs-variable constant_">RO_SPACE</span>,    <span class="hljs-comment">// 不变的对象空间</span><br>  <span class="hljs-variable constant_">NEW_SPACE</span>,   <span class="hljs-comment">// 新生代用于 GC 复制算法的空间</span><br>  <span class="hljs-variable constant_">OLD_SPACE</span>,   <span class="hljs-comment">// 老生代常驻对象空间</span><br>  <span class="hljs-variable constant_">CODE_SPACE</span>,  <span class="hljs-comment">// 老生代代码对象空间</span><br>  <span class="hljs-variable constant_">MAP_SPACE</span>,   <span class="hljs-comment">// 老生代 map 对象</span><br>  <span class="hljs-variable constant_">LO_SPACE</span>,    <span class="hljs-comment">// 老生代大空间对象</span><br>  <span class="hljs-variable constant_">NEW_LO_SPACE</span>,  <span class="hljs-comment">// 新生代大空间对象</span><br>  <span class="hljs-variable constant_">FIRST_SPACE</span> = <span class="hljs-variable constant_">RO_SPACE</span>,<br>  <span class="hljs-variable constant_">LAST_SPACE</span> = <span class="hljs-variable constant_">NEW_LO_SPACE</span>,<br>  <span class="hljs-variable constant_">FIRST_GROWABLE_PAGED_SPACE</span> = <span class="hljs-variable constant_">OLD_SPACE</span>,<br>  <span class="hljs-variable constant_">LAST_GROWABLE_PAGED_SPACE</span> = <span class="hljs-variable constant_">MAP_SPACE</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>在老生代中，以下情况会先启动标记清除算法：</p><ul><li>某一个空间没有分块的时候</li><li>空间中被对象超过一定限制</li><li>空间不能保证新生代中的对象移动到老生代中</li></ul><p>在这个阶段中，会遍历堆中所有的对象，然后标记活的对象，在标记完成后，销毁所有没有被标记的对象。在标记大型对内存时，可能需要几百毫秒才能完成一次标记。这就会导致一些性能上的问题。为了解决这个问题，2011 年，V8 从 stop-the-world 标记切换到增量标志。在增量标记期间，GC 将标记工作分解为更小的模块，可以让 JS 应用逻辑在模块间隙执行一会，从而不至于让应用出现停顿情况。但在 2018 年，GC 技术又有了一个重大突破，这项技术名为并发标记。该技术可以让 GC 扫描和标记对象时，同时允许 JS 运行。</p><p>清除对象后会造成堆内存出现碎片的情况，当碎片超过一定限制后会启动压缩算法。在压缩过程中，将活的对象向一端移动，直到所有对象都移动完成然后清理掉不需要的内存。</p><h3 id="2-哪些操作会造成内存泄漏？"><a href="#2-哪些操作会造成内存泄漏？" class="headerlink" title="2. 哪些操作会造成内存泄漏？"></a>2. 哪些操作会造成内存泄漏？</h3><ul><li>第一种情况是由于使用未声明的变量，而意外的创建了一个全局变量，而使这个变量一直留在内存中无法被回收。</li><li>第二种情况是设置了 setInterval 定时器，而忘记取消它，如果循环函数有对外部变量的引用的话，那么这个变量会被一直留在内存中，而无法被回收。</li><li>第三种情况是获取一个 DOM 元素的引用，而后面这个元素被删除，由于我们一直保留了对这个元素的引用，所以它也无法被回收。</li><li>第四种情况是不合理的使用闭包，从而导致某些变量一直被留在内存当中。</li></ul>]]></content>
    
    
    <categories>
      
      <category>BGW</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>BGW-计网</title>
    <link href="/2023/04/18/BGW-%E8%AE%A1%E7%BD%91/"/>
    <url>/2023/04/18/BGW-%E8%AE%A1%E7%BD%91/</url>
    
    <content type="html"><![CDATA[<p>BGW-计网</p><p><img src="1.png" alt="img"></p><h2 id="一、HTTP协议"><a href="#一、HTTP协议" class="headerlink" title="一、HTTP协议"></a>一、HTTP协议</h2><h3 id="1-GET和POST的请求的区别"><a href="#1-GET和POST的请求的区别" class="headerlink" title="1. GET和POST的请求的区别"></a>1. GET和POST的请求的区别</h3><p>Post 和 Get 是 HTTP 请求的两种方法，其区别如下：</p><ul><li><strong>应用场景：</strong> GET 请求是一个幂等的请求，一般 Get 请求用于对服务器资源不会产生影响的场景，比如说请求一个网页的资源。而 Post 不是一个幂等的请求，一般用于对服务器资源会产生影响的情景，比如注册用户这一类的操作。</li><li><strong>是否缓存：</strong> 因为两者应用场景不同，浏览器一般会对 Get 请求缓存，但很少对 Post 请求缓存。</li><li><strong>发送的报文格式：</strong> Get 请求的报文中实体部分为空，Post 请求的报文中实体部分一般为向服务器发送的数据。</li><li><strong>安全性：</strong> Get 请求可以将请求的参数放入 url 中向服务器发送，这样的做法相对于 Post 请求来说是不太安全的，因为请求的 url 会被保留在历史记录中。</li><li><strong>请求长度：</strong> 浏览器由于对 url 长度的限制，所以会影响 get 请求发送数据时的长度。这个限制是浏览器规定的，并不是 RFC 规定的。</li><li><strong>参数类型：</strong> post 的参数传递支持更多的数据类型。</li></ul><h3 id="2-POST和PUT请求的区别"><a href="#2-POST和PUT请求的区别" class="headerlink" title="2. POST和PUT请求的区别"></a>2. POST和PUT请求的区别</h3><ul><li>PUT请求是向服务器端发送数据，从而修改数据的内容，但是不会增加数据的种类等，也就是说无论进行多少次PUT操作，其结果并没有不同。（可以理解为时<strong>更新数据</strong>）</li><li>POST请求是向服务器端发送数据，该请求会改变数据的种类等资源，它会创建新的内容。（可以理解为是<strong>创建数据</strong>）</li></ul><h3 id="3-常见的HTTP请求头和响应头"><a href="#3-常见的HTTP请求头和响应头" class="headerlink" title="3. 常见的HTTP请求头和响应头"></a>3. 常见的HTTP请求头和响应头</h3><p><strong>HTTP Request Header 常见的请求头：</strong></p><ul><li>Accept:浏览器能够处理的内容类型</li><li>Accept-Charset:浏览器能够显示的字符集</li><li>Accept-Encoding：浏览器能够处理的压缩编码</li><li>Accept-Language：浏览器当前设置的语言</li><li>Connection：浏览器与服务器之间连接的类型</li><li>Cookie：当前页面设置的任何Cookie</li><li>Host：发出请求的页面所在的域</li><li>Referer：发出请求的页面的URL</li><li>User-Agent：浏览器的用户代理字符串</li></ul><p><strong>HTTP Responses Header 常见的响应头：</strong></p><ul><li>Date：表示消息发送的时间，时间的描述格式由rfc822定义</li><li>server:服务器名称</li><li>Connection：浏览器与服务器之间连接的类型</li><li>Cache-Control：控制HTTP缓存</li><li>content-type:表示后面的文档属于什么MIME类型</li></ul><p>常见的 Content-Type 属性值有以下四种：</p><p>（1）application&#x2F;x-www-form-urlencoded：浏览器的原生 form 表单，如果不设置 enctype 属性，那么最终就会以 application&#x2F;x-www-form-urlencoded 方式提交数据。该种方式提交的数据放在 body 里面，数据按照 key1&#x3D;val1&amp;key2&#x3D;val2 的方式进行编码，key 和 val 都进行了 URL转码。</p><p>（2）multipart&#x2F;form-data：该种方式也是一个常见的 POST 提交方式，通常表单上传文件时使用该种方式。</p><p>（3）application&#x2F;json：服务器消息主体是序列化后的 JSON 字符串。</p><p>（4）text&#x2F;xml：该种方式主要用来提交 XML 格式的数据。</p><h3 id="4-HTTP状态码304是多好还是少好"><a href="#4-HTTP状态码304是多好还是少好" class="headerlink" title="4. HTTP状态码304是多好还是少好"></a>4. HTTP状态码304是多好还是少好</h3><p>服务器为了提高网站访问速度，对之前访问的部分页面指定缓存机制，当客户端在此对这些页面进行请求，服务器会根据缓存内容判断页面与之前是否相同，若相同便直接返回304，此时客户端调用缓存内容，不必进行二次下载。</p><p>状态码304不应该认为是一种错误，而是对客户端<strong>有缓存情况下</strong>服务端的一种响应。</p><p>搜索引擎蜘蛛会更加青睐内容源更新频繁的网站。通过特定时间内对网站抓取返回的状态码来调节对该网站的抓取频次。若网站在一定时间内一直处于304的状态，那么蜘蛛可能会降低对网站的抓取次数。相反，若网站变化的频率非常之快，每次抓取都能获取新内容，那么日积月累，的回访率也会提高。</p><p><strong>产生较多304状态码的原因：</strong></p><ul><li>页面更新周期长或不更新</li><li>纯静态页面或强制生成静态html</li></ul><p><strong>304状态码出现过多会造成以下问题：</strong></p><ul><li>网站快照停止；</li><li>收录减少；</li><li>权重下降。</li></ul><h3 id="5-常见的HTTP请求方法"><a href="#5-常见的HTTP请求方法" class="headerlink" title="5. 常见的HTTP请求方法"></a>5. 常见的HTTP请求方法</h3><ul><li>GET: 向服务器获取数据；</li><li>POST：将实体提交到指定的资源，通常会造成服务器资源的修改；</li><li>PUT：上传文件，更新数据；</li><li>DELETE：删除服务器上的对象；</li><li>HEAD：获取报文首部，与GET相比，不返回报文主体部分；</li><li>OPTIONS：询问支持的请求方法，用来跨域请求；</li><li>CONNECT：要求在与代理服务器通信时建立隧道，使用隧道进行TCP通信；</li><li>TRACE: 回显服务器收到的请求，主要⽤于测试或诊断。</li></ul><h3 id="6-OPTIONS请求方法及使用场景"><a href="#6-OPTIONS请求方法及使用场景" class="headerlink" title="6. OPTIONS请求方法及使用场景"></a>6. OPTIONS请求方法及使用场景</h3><p>OPTIONS是除了GET和POST之外的其中一种 HTTP请求方法。</p><p>OPTIONS方法是用于请求获得由<code>Request-URI</code>标识的资源在请求&#x2F;响应的通信过程中可以使用的功能选项。通过这个方法，客户端可以<strong>在采取具体资源请求之前，决定对该资源采取何种必要措施，或者了解服务器的性能</strong>。该请求方法的响应不能缓存。</p><p>OPTIONS请求方法的<strong>主要用途</strong>有两个：</p><ul><li>获取服务器支持的所有HTTP请求方法；</li><li>用来检查访问权限。例如：在进行 CORS 跨域资源共享时，对于复杂请求，就是使用 OPTIONS 方法发送嗅探请求，以判断是否有对指定资源的访问权限。</li></ul><h3 id="7-HTTP-1-0-和-HTTP-1-1-之间有哪些区别？"><a href="#7-HTTP-1-0-和-HTTP-1-1-之间有哪些区别？" class="headerlink" title="7. HTTP 1.0 和 HTTP 1.1 之间有哪些区别？"></a>7. HTTP 1.0 和 HTTP 1.1 之间有哪些区别？</h3><p><strong>HTTP 1.0和 HTTP 1.1 有以下区别</strong>：</p><ul><li><strong>连接方面</strong>，http1.0 默认使用非持久连接，而 http1.1 默认使用持久连接。http1.1 通过使用持久连接来使多个 http 请求复用同一个 TCP 连接，以此来避免使用非持久连接时每次需要建立连接的时延。</li><li><strong>资源请求方面</strong>，在 http1.0 中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，http1.1 则在请求头引入了 range 头域，它允许只请求资源的某个部分，即返回码是 206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。</li><li><strong>缓存方面</strong>，在 http1.0 中主要使用 header 里的 If-Modified-Since、Expires 来做为缓存判断的标准，http1.1 则引入了更多的缓存控制策略，例如 Etag、If-Unmodified-Since、If-Match、If-None-Match 等更多可供选择的缓存头来控制缓存策略。</li><li>http1.1 中<strong>新增了 host 字段</strong>，用来指定服务器的域名。http1.0 中认为每台服务器都绑定一个唯一的 IP 地址，因此，请求消息中的 URL 并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机，并且它们共享一个IP地址。因此有了 host 字段，这样就可以将请求发往到同一台服务器上的不同网站。</li><li>http1.1 相对于 http1.0 还新增了很多<strong>请求方法</strong>，如 PUT、HEAD、OPTIONS 等。</li></ul><h3 id="8-HTTP-1-1-和-HTTP-2-0-的区别"><a href="#8-HTTP-1-1-和-HTTP-2-0-的区别" class="headerlink" title="8. HTTP 1.1 和 HTTP 2.0 的区别"></a>8. HTTP 1.1 和 HTTP 2.0 的区别</h3><ul><li><strong>二进制协议</strong>：HTTP&#x2F;2 是一个二进制协议。在 HTTP&#x2F;1.1 版中，报文的头信息必须是文本（ASCII 编码），数据体可以是文本，也可以是二进制。HTTP&#x2F;2 则是一个彻底的二进制协议，头信息和数据体都是二进制，并且统称为”帧”，可以分为头信息帧和数据帧。 帧的概念是它实现多路复用的基础。</li><li><strong>多路复用：</strong> HTTP&#x2F;2 实现了多路复用，HTTP&#x2F;2 仍然复用 TCP 连接，但是在一个连接里，客户端和服务器都可以同时发送多个请求或回应，而且不用按照顺序一一发送，这样就避免了”队头堵塞”【1】的问题。</li><li><strong>数据流：</strong> HTTP&#x2F;2 使用了数据流的概念，因为 HTTP&#x2F;2 的数据包是不按顺序发送的，同一个连接里面连续的数据包，可能属于不同的请求。因此，必须要对数据包做标记，指出它属于哪个请求。HTTP&#x2F;2 将每个请求或回应的所有数据包，称为一个数据流。每个数据流都有一个独一无二的编号。数据包发送时，都必须标记数据流 ID ，用来区分它属于哪个数据流。</li><li><strong>头信息压缩：</strong> HTTP&#x2F;2 实现了头信息压缩，由于 HTTP 1.1 协议不带状态，每次请求都必须附上所有信息。所以，请求的很多字段都是重复的，比如 Cookie 和 User Agent ，一模一样的内容，每次请求都必须附带，这会浪费很多带宽，也影响速度。HTTP&#x2F;2 对这一点做了优化，引入了头信息压缩机制。一方面，头信息使用 gzip 或 compress 压缩后再发送；另一方面，客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就能提高速度了。</li><li><strong>服务器推送：</strong> HTTP&#x2F;2 允许服务器未经请求，主动向客户端发送资源，这叫做服务器推送。使用服务器推送提前给客户端推送必要的资源，这样就可以相对减少一些延迟时间。这里需要注意的是 http2 下服务器主动推送的是静态资源，和 WebSocket 以及使用 SSE 等方式向客户端发送即时数据的推送是不同的。</li></ul><p><strong>【1】队头堵塞：</strong></p><blockquote><p>队头阻塞是由 HTTP 基本的“请求 - 应答”模型所导致的。HTTP 规定报文必须是“一发一收”，这就形成了一个先进先出的“串行”队列。队列里的请求是没有优先级的，只有入队的先后顺序，排在最前面的请求会被最优先处理。如果队首的请求因为处理的太慢耽误了时间，那么队列里后面的所有请求也不得不跟着一起等待，结果就是其他的请求承担了不应有的时间成本，造成了队头堵塞的现象。</p></blockquote><h3 id="9-HTTP和HTTPS协议的区别"><a href="#9-HTTP和HTTPS协议的区别" class="headerlink" title="9. HTTP和HTTPS协议的区别"></a>9. HTTP和HTTPS协议的区别</h3><p>HTTP和HTTPS协议的主要区别如下：</p><ul><li>HTTPS协议需要CA证书，费用较高；而HTTP协议不需要；</li><li>HTTP协议是超文本传输协议，信息是明文传输的，HTTPS则是具有安全性的SSL加密传输协议；</li><li>使用不同的连接方式，端口也不同，HTTP协议端口是80，HTTPS协议端口是443；</li><li>HTTP协议连接很简单，是无状态的；HTTPS协议是有SSL和HTTP协议构建的可进行加密传输、身份认证的网络协议，比HTTP更加安全。</li></ul><h3 id="10-GET方法URL长度限制的原因"><a href="#10-GET方法URL长度限制的原因" class="headerlink" title="10. GET方法URL长度限制的原因"></a>10. GET方法URL长度限制的原因</h3><p>实际上HTTP协议规范并没有对get方法请求的url长度进行限制，这个限制是特定的浏览器及服务器对它的限制。<br>IE对URL长度的限制是2083字节(2K+35)。由于IE浏览器对URL长度的允许值是最小的，所以开发过程中，只要URL不超过2083字节，那么在所有浏览器中工作都不会有问题。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable constant_">GET</span>的长度值 = <span class="hljs-variable constant_">URL</span>（<span class="hljs-number">2083</span>）- （你的<span class="hljs-title class_">Domain</span>+<span class="hljs-title class_">Path</span>）-<span class="hljs-number">2</span>（<span class="hljs-number">2</span>是get请求中?=两个字符的长度）<br></code></pre></td></tr></table></figure><p>下面看一下主流浏览器对get方法中url的长度限制范围：</p><ul><li>Microsoft Internet Explorer (Browser)：IE浏览器对URL的最大限制为2083个字符，如果超过这个数字，提交按钮没有任何反应。</li><li>Firefox (Browser)：对于Firefox浏览器URL的长度限制为 65,536 个字符。</li><li>Safari (Browser)：URL最大长度限制为 80,000 个字符。</li><li>Opera (Browser)：URL最大长度限制为 190,000 个字符。</li><li>Google (chrome)：URL最大长度限制为 8182 个字符。</li></ul><p>主流的服务器对get方法中url的长度限制范围：</p><ul><li>Apache (Server)：能接受最大url长度为8192个字符。</li><li>Microsoft Internet Information Server(IIS)：能接受最大url的长度为16384个字符。</li></ul><p>根据上面的数据，可以知道，get方法中的URL长度最长不超过2083个字符，这样所有的浏览器和服务器都可能正常工作。</p><h3 id="11-当在浏览器中输入-Google-com-并且按下回车之后发生了什么？"><a href="#11-当在浏览器中输入-Google-com-并且按下回车之后发生了什么？" class="headerlink" title="11. 当在浏览器中输入 Google.com 并且按下回车之后发生了什么？"></a>11. 当在浏览器中输入 Google.com 并且按下回车之后发生了什么？</h3><p>（1）<strong>解析URL：</strong> 首先会对 URL 进行解析，分析所需要使用的传输协议和请求的资源的路径。如果输入的 URL 中的协议或者主机名不合法，将会把地址栏中输入的内容传递给搜索引擎。如果没有问题，浏览器会检查 URL 中是否出现了非法字符，如果存在非法字符，则对非法字符进行转义后再进行下一过程。</p><p>（2）<strong>缓存判断：</strong> 浏览器会判断所请求的资源是否在缓存里，如果请求的资源在缓存里并且没有失效，那么就直接使用，否则向服务器发起新的请求。</p><p>（3）<strong>DNS解析：</strong> 下一步首先需要获取的是输入的 URL 中的域名的 IP 地址，首先会判断本地是否有该域名的 IP 地址的缓存，如果有则使用，如果没有则向本地 DNS 服务器发起请求。本地 DNS 服务器也会先检查是否存在缓存，如果没有就会先向根域名服务器发起请求，获得负责的顶级域名服务器的地址后，再向顶级域名服务器请求，然后获得负责的权威域名服务器的地址后，再向权威域名服务器发起请求，最终获得域名的 IP 地址后，本地 DNS 服务器再将这个 IP 地址返回给请求的用户。用户向本地 DNS 服务器发起请求属于递归请求，本地 DNS 服务器向各级域名服务器发起请求属于迭代请求。</p><p>（4）<strong>获取MAC地址：</strong> 当浏览器得到 IP 地址后，数据传输还需要知道目的主机 MAC 地址，因为应用层下发数据给传输层，TCP 协议会指定源端口号和目的端口号，然后下发给网络层。网络层会将本机地址作为源地址，获取的 IP 地址作为目的地址。然后将下发给数据链路层，数据链路层的发送需要加入通信双方的 MAC 地址，本机的 MAC 地址作为源 MAC 地址，目的 MAC 地址需要分情况处理。通过将 IP 地址与本机的子网掩码相与，可以判断是否与请求主机在同一个子网里，如果在同一个子网里，可以使用 APR 协议获取到目的主机的 MAC 地址，如果不在一个子网里，那么请求应该转发给网关，由它代为转发，此时同样可以通过 ARP 协议来获取网关的 MAC 地址，此时目的主机的 MAC 地址应该为网关的地址。</p><p>（5）<strong>TCP三次握手：</strong> 下面是 TCP 建立连接的三次握手的过程，首先客户端向服务器发送一个 SYN 连接请求报文段和一个随机序号，服务端接收到请求后向服务器端发送一个 SYN ACK报文段，确认连接请求，并且也向客户端发送一个随机序号。客户端接收服务器的确认应答后，进入连接建立的状态，同时向服务器也发送一个ACK 确认报文段，服务器端接收到确认后，也进入连接建立状态，此时双方的连接就建立起来了。</p><p>（6）<strong>HTTPS握手：</strong> 如果使用的是 HTTPS 协议，在通信前还存在 TLS 的一个四次握手的过程。首先由客户端向服务器端发送使用的协议的版本号、一个随机数和可以使用的加密方法。服务器端收到后，确认加密的方法，也向客户端发送一个随机数和自己的数字证书。客户端收到后，首先检查数字证书是否有效，如果有效，则再生成一个随机数，并使用证书中的公钥对随机数加密，然后发送给服务器端，并且还会提供一个前面所有内容的 hash 值供服务器端检验。服务器端接收后，使用自己的私钥对数据解密，同时向客户端发送一个前面所有内容的 hash 值供客户端检验。这个时候双方都有了三个随机数，按照之前所约定的加密方法，使用这三个随机数生成一把秘钥，以后双方通信前，就使用这个秘钥对数据进行加密后再传输。</p><p>（7）<strong>返回数据：</strong> 当页面请求发送到服务器端后，服务器端会返回一个 html 文件作为响应，浏览器接收到响应后，开始对 html 文件进行解析，开始页面的渲染过程。</p><p>（8）<strong>页面渲染：</strong> 浏览器首先会根据 html 文件构建 DOM 树，根据解析到的 css 文件构建 CSSOM 树，如果遇到 script 标签，则判端是否含有 defer 或者 async 属性，要不然 script 的加载和执行会造成页面的渲染的阻塞。当 DOM 树和 CSSOM 树建立好后，根据它们来构建渲染树。渲染树构建好后，会根据渲染树来进行布局。布局完成后，最后使用浏览器的 UI 接口对页面进行绘制。这个时候整个页面就显示出来了。</p><p> （9）<strong>TCP四次挥手：</strong> 最后一步是 TCP 断开连接的四次挥手过程。若客户端认为数据发送完成，则它需要向服务端发送连接释放请求。服务端收到连接释放请求后，会告诉应用层要释放 TCP 链接。然后会发送 ACK 包，并进入 CLOSE_WAIT 状态，此时表明客户端到服务端的连接已经释放，不再接收客户端发的数据了。但是因为 TCP 连接是双向的，所以服务端仍旧可以发送数据给客户端。服务端如果此时还有没发完的数据会继续发送，完毕后会向客户端发送连接释放请求，然后服务端便进入 LAST-ACK 状态。客户端收到释放请求后，向服务端发送确认应答，此时客户端进入 TIME-WAIT 状态。该状态会持续 2MSL（最大段生存期，指报文段在网络中生存的时间，超时会被抛弃） 时间，若该时间段内没有服务端的重发请求的话，就进入 CLOSED 状态。当服务端收到确认应答后，也便进入 CLOSED 状态。</p><h3 id="12-对keep-alive的理解"><a href="#12-对keep-alive的理解" class="headerlink" title="12. 对keep-alive的理解"></a>12. 对keep-alive的理解</h3><p>HTTP1.0 中默认是在每次请求&#x2F;应答，客户端和服务器都要新建一个连接，完成之后立即断开连接，这就是<strong>短连接</strong>。当使用Keep-Alive模式时，Keep-Alive功能使客户端到服务器端的连接持续有效，当出现对服务器的后继请求时，Keep-Alive功能避免了建立或者重新建立连接，这就是<strong>长连接</strong>。其使用方法如下：</p><ul><li>HTTP1.0版本是默认没有Keep-alive的（也就是默认会发送keep-alive），所以要想连接得到保持，必须手动配置发送<code>Connection: keep-alive</code>字段。若想断开keep-alive连接，需发送<code>Connection:close</code>字段；</li><li>HTTP1.1规定了默认保持长连接，数据传输完成了保持TCP连接不断开，等待在同域名下继续用这个通道传输数据。如果需要关闭，需要客户端发送<code>Connection：close</code>首部字段。</li></ul><p>Keep-Alive的<strong>建立过程</strong>：</p><ul><li>客户端向服务器在发送请求报文同时在首部添加发送Connection字段</li><li>服务器收到请求并处理 Connection字段</li><li>服务器回送Connection:Keep-Alive字段给客户端</li><li>客户端接收到Connection字段</li><li>Keep-Alive连接建立成功</li></ul><p><strong>服务端自动断开过程（也就是没有keep-alive）</strong>：</p><ul><li>客户端向服务器只是发送内容报文（不包含Connection字段）</li><li>服务器收到请求并处理</li><li>服务器返回客户端请求的资源并关闭连接</li><li>客户端接收资源，发现没有Connection字段，断开连接</li></ul><p><strong>客户端请求断开连接过程</strong>：</p><ul><li>客户端向服务器发送Connection:close字段</li><li>服务器收到请求并处理connection字段</li><li>服务器回送响应资源并断开连接</li><li>客户端接收资源并断开连接</li></ul><p>开启Keep-Alive的<strong>优点：</strong></p><ul><li>较少的CPU和内存的使⽤（由于同时打开的连接的减少了）；</li><li>允许请求和应答的HTTP管线化； </li><li>降低拥塞控制 （TCP连接减少了）； </li><li>减少了后续请求的延迟（⽆需再进⾏握⼿）； </li><li>报告错误⽆需关闭TCP连；</li></ul><p>开启Keep-Alive的<strong>缺点</strong>：</p><ul><li>长时间的Tcp连接容易导致系统资源无效占用，浪费系统资源。</li></ul><h3 id="13-页面有多张图片，HTTP是怎样的加载表现？"><a href="#13-页面有多张图片，HTTP是怎样的加载表现？" class="headerlink" title="13. 页面有多张图片，HTTP是怎样的加载表现？"></a>13. 页面有多张图片，HTTP是怎样的加载表现？</h3><ul><li>在<code>HTTP 1</code>下，浏览器对一个域名下最大TCP连接数为6，所以会请求多次。可以用<strong>多域名部署</strong>解决。这样可以提高同时请求的数目，加快页面图片的获取速度。</li><li>在<code>HTTP 2</code>下，可以一瞬间加载出来很多资源，因为，HTTP2支持多路复用，可以在一个TCP连接中发送多个HTTP请求。</li></ul><h3 id="14-HTTP2的头部压缩算法是怎样的？"><a href="#14-HTTP2的头部压缩算法是怎样的？" class="headerlink" title="14. HTTP2的头部压缩算法是怎样的？"></a>14. HTTP2的头部压缩算法是怎样的？</h3><p>HTTP2的头部压缩是HPACK算法。在客户端和服务器两端建立“字典”，用索引号表示重复的字符串，采用哈夫曼编码来压缩整数和字符串，可以达到50%~90%的高压缩率。</p><p>具体来说:</p><ul><li>在客户端和服务器端使用“首部表”来跟踪和存储之前发送的键值对，对于相同的数据，不再通过每次请求和响应发送；</li><li>首部表在HTTP&#x2F;2的连接存续期内始终存在，由客户端和服务器共同渐进地更新；</li><li>每个新的首部键值对要么被追加到当前表的末尾，要么替换表中之前的值。</li></ul><p>例如下图中的两个请求， 请求一发送了所有的头部字段，第二个请求则只需要发送差异数据，这样可以减少冗余数据，降低开销。<br><img src="2.png" alt="img"></p><h3 id="15-HTTP请求报文的是什么样的？"><a href="#15-HTTP请求报文的是什么样的？" class="headerlink" title="15. HTTP请求报文的是什么样的？"></a>15. HTTP请求报文的是什么样的？</h3><p>请求报⽂有4部分组成: </p><ul><li>请求⾏ </li><li>请求头部 </li><li>空⾏</li><li>请求体</li></ul><p><img src="3.png" alt="img"><br><strong>其中：</strong><br>（1）请求⾏包括：请求⽅法字段、URL字段、HTTP协议版本字段。它们⽤空格分隔。例如，GET &#x2F;index.html HTTP&#x2F;1.1。<br>（2）请求头部:请求头部由关键字&#x2F;值对组成，每⾏⼀对，关键字和值⽤英⽂冒号“:”分隔  </p><ul><li>User-Agent：产⽣请求的浏览器类型。 </li><li>Accept：客户端可识别的内容类型列表。 </li><li>Host：请求的主机名，允许多个域名同处⼀个IP地址，即虚拟主机。</li></ul><p>（3）请求体: post put等请求携带的数据<br><img src="4.png" alt="img"></p><h3 id="16-HTTP响应报文的是什么样的？"><a href="#16-HTTP响应报文的是什么样的？" class="headerlink" title="16. HTTP响应报文的是什么样的？"></a>16. HTTP响应报文的是什么样的？</h3><p>请求报⽂有4部分组成: </p><ul><li>响应⾏ </li><li>响应头 </li><li>空⾏</li><li>响应体</li></ul><p><img src="5.png" alt="img"></p><ul><li>响应⾏：由网络协议版本，状态码和状态码的原因短语组成，例如 HTTP&#x2F;1.1 200 OK 。 </li><li>响应头：响应部⾸组成 </li><li>响应体：服务器响应的数据</li></ul><h3 id="17-HTTP协议的优点和缺点"><a href="#17-HTTP协议的优点和缺点" class="headerlink" title="17. HTTP协议的优点和缺点"></a>17. HTTP协议的优点和缺点</h3><p>HTTP 是超文本传输协议，它定义了客户端和服务器之间交换报文的格式和方式，默认使用 80 端口。它使用 TCP 作为传输层协议，保证了数据传输的可靠性。</p><p>HTTP协议具有以下<strong>优点</strong>：</p><ul><li>支持客户端&#x2F;服务器模式</li><li><strong>简单快速</strong>：客户向服务器请求服务时，只需传送请求方法和路径。由于 HTTP 协议简单，使得 HTTP 服务器的程序规模小，因而通信速度很快。</li><li><strong>无连接</strong>：无连接就是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接，采用这种方式可以节省传输时间。</li><li><strong>无状态</strong>：HTTP 协议是无状态协议，这里的状态是指通信过程的上下文信息。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能会导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就比较快。</li><li><strong>灵活</strong>：HTTP 允许传输任意类型的数据对象。正在传输的类型由 Content-Type 加以标记。</li></ul><p>HTTP协议具有以下<strong>缺点</strong>：</p><ul><li><strong>无状态：</strong> HTTP 是一个无状态的协议，HTTP 服务器不会保存关于客户的任何信息。</li><li><strong>明文传输：</strong> 协议中的报文使用的是文本形式，这就直接暴露给外界，不安全。</li><li><strong>不安全</strong></li></ul><p>（1）通信使用明文（不加密），内容可能会被窃听；<br>（2）不验证通信方的身份，因此有可能遭遇伪装；<br>（3）无法证明报文的完整性，所以有可能已遭篡改；</p><h3 id="18-说一下HTTP-3-0"><a href="#18-说一下HTTP-3-0" class="headerlink" title="18. 说一下HTTP 3.0"></a>18. 说一下HTTP 3.0</h3><p>HTTP&#x2F;3基于UDP协议实现了类似于TCP的多路复用数据流、传输可靠性等功能，这套功能被称为QUIC协议。<br><img src="6.webp" alt="img"></p><ol><li>流量控制、传输可靠性功能：QUIC在UDP的基础上增加了一层来保证数据传输可靠性，它提供了数据包重传、拥塞控制、以及其他一些TCP中的特性。</li><li>集成TLS加密功能：目前QUIC使用TLS1.3，减少了握手所花费的RTT数。</li><li>多路复用：同一物理连接上可以有多个独立的逻辑数据流，实现了数据流的单独传输，解决了TCP的队头阻塞问题。</li></ol><p><img src="7.webp" alt="img"></p><ol start="4"><li>快速握手：由于基于UDP，可以实现使用0 ~ 1个RTT来建立连接。</li></ol><h3 id="19-HTTP协议的性能怎么样"><a href="#19-HTTP协议的性能怎么样" class="headerlink" title="19. HTTP协议的性能怎么样"></a>19. HTTP协议的性能怎么样</h3><p>HTTP 协议是基于 TCP&#x2F;IP，并且使用了<strong>请求-应答</strong>的通信模式，所以性能的关键就在这两点里。</p><ul><li><strong>长连接</strong></li></ul><p>HTTP协议有两种连接模式，一种是持续连接，一种非持续连接。<br>（1）非持续连接指的是服务器必须为每一个请求的对象建立和维护一个全新的连接。<br>（2）持续连接下，TCP 连接默认不关闭，可以被多个请求复用。采用持续连接的好处是可以避免每次建立 TCP 连接三次握手时所花费的时间。</p><p>对于不同版本的采用不同的连接方式：</p><ul><li>在HTTP&#x2F;1.0 每发起一个请求，都要新建一次 TCP 连接（三次握手），而且是串行请求，做了无畏的 TCP 连接建立和断开，增加了通信开销。该版本使用的非持续的连接，但是可以在请求时，加上 Connection: keep-a live 来要求服务器不要关闭 TCP 连接。</li><li>在HTTP&#x2F;1.1 提出了<strong>长连接</strong>的通信方式，也叫持久连接。这种方式的好处在于减少了 TCP 连接的重复建立和断开所造成的额外开销，减轻了服务器端的负载。该版本及以后版本默认采用的是持续的连接。目前对于同一个域，大多数浏览器支持同时建立 6 个持久连接。</li></ul><p><img src="8.png" alt="img"></p><ul><li><strong>管道网络传输</strong></li></ul><p>HTTP&#x2F;1.1 采用了长连接的方式，这使得管道（pipeline）网络传输成为了可能。</p><p>管道（pipeline）网络传输是指：可以在同一个 TCP 连接里面，客户端可以发起多个请求，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以减少整体的响应时间。但是服务器还是按照顺序回应请求。如果前面的回应特别慢，后面就会有许多请求排队等着。这称为队头堵塞。</p><ul><li><strong>队头堵塞</strong></li></ul><p>HTTP 传输的报文必须是一发一收，但是，里面的任务被放在一个任务队列中串行执行，一旦队首的请求处理太慢，就会阻塞后面请求的处理。这就是HTTP队头阻塞问题。</p><p><strong>队头阻塞的解决方案：</strong><br>（1）并发连接：对于一个域名允许分配多个长连接，那么相当于增加了任务队列，不至于一个队伍的任务阻塞其它所有任务。<br>（2）域名分片：将域名分出很多二级域名，它们都指向同样的一台服务器，能够并发的长连接数变多，解决了队头阻塞的问题。</p><h3 id="20-URL有哪些组成部分"><a href="#20-URL有哪些组成部分" class="headerlink" title="20. URL有哪些组成部分"></a>20. URL有哪些组成部分</h3><p>以下面的URL为例：<strong><a href="http://www.aspxfans.com:8080/news/index.asp?boardID=5&ID=24618&page=1#name">http://www.aspxfans.com:8080/news/index.asp?boardID=5&amp;ID=24618&amp;page=1#name</a></strong></p><p>从上面的URL可以看出，一个完整的URL包括以下几部分：</p><ul><li><strong>协议部分</strong>：该URL的协议部分为“http：”，这代表网页使用的是HTTP协议。在Internet中可以使用多种协议，如HTTP，FTP等等本例中使用的是HTTP协议。在”HTTP”后面的“&#x2F;&#x2F;”为分隔符；</li><li><strong>域名部分</strong>：该URL的域名部分为“<a href="http://www.aspxfans.com”.一个url中,也可以使用ip地址作为域名使用/">www.aspxfans.com”。一个URL中，也可以使用IP地址作为域名使用</a></li><li><strong>端口部分</strong>：跟在域名后面的是端口，域名和端口之间使用“:”作为分隔符。端口不是一个URL必须的部分，如果省略端口部分，将采用默认端口（HTTP协议默认端口是80，HTTPS协议默认端口是443）；</li><li><strong>虚拟目录部分</strong>：从域名后的第一个“&#x2F;”开始到最后一个“&#x2F;”为止，是虚拟目录部分。虚拟目录也不是一个URL必须的部分。本例中的虚拟目录是“&#x2F;news&#x2F;”；</li><li><strong>文件名部分</strong>：从域名后的最后一个“&#x2F;”开始到“？”为止，是文件名部分，如果没有“?”,则是从域名后的最后一个“&#x2F;”开始到“#”为止，是文件部分，如果没有“？”和“#”，那么从域名后的最后一个“&#x2F;”开始到结束，都是文件名部分。本例中的文件名是“index.asp”。文件名部分也不是一个URL必须的部分，如果省略该部分，则使用默认的文件名；</li><li><strong>锚部分</strong>：从“#”开始到最后，都是锚部分。本例中的锚部分是“name”。锚部分也不是一个URL必须的部分；</li><li><strong>参数部分</strong>：从“？”开始到“#”为止之间的部分为参数部分，又称搜索部分、查询部分。本例中的参数部分为“boardID&#x3D;5&amp;ID&#x3D;24618&amp;page&#x3D;1”。参数可以允许有多个参数，参数与参数之间用“&amp;”作为分隔符。</li></ul><h3 id="21-与缓存相关的HTTP请求头有哪些"><a href="#21-与缓存相关的HTTP请求头有哪些" class="headerlink" title="21. 与缓存相关的HTTP请求头有哪些"></a>21. 与缓存相关的HTTP请求头有哪些</h3><p>强缓存：</p><ul><li>Expires</li><li>Cache-Control</li></ul><p>协商缓存：</p><ul><li>Etag、If-None-Match</li><li>Last-Modified、If-Modified-Since</li></ul><h2 id="二、HTTPS协议"><a href="#二、HTTPS协议" class="headerlink" title="二、HTTPS协议"></a>二、HTTPS协议</h2><h3 id="1-什么是HTTPS协议？"><a href="#1-什么是HTTPS协议？" class="headerlink" title="1. 什么是HTTPS协议？"></a>1. 什么是HTTPS协议？</h3><p>超文本传输安全协议（Hypertext Transfer Protocol Secure，简称：HTTPS）是一种通过计算机网络进行安全通信的传输协议。HTTPS经由HTTP进行通信，利用SSL&#x2F;TLS来加密数据包。HTTPS的主要目的是提供对网站服务器的身份认证，保护交换数据的隐私与完整性。<br><img src="9.png" alt="img"><br>HTTP协议采用<strong>明文传输</strong>信息，存在<strong>信息窃听</strong>、<strong>信息篡改</strong>和<strong>信息劫持</strong>的风险，而协议TLS&#x2F;SSL具有<strong>身份验证</strong>、<strong>信息加密</strong>和<strong>完整性校验</strong>的功能，可以避免此类问题发生。</p><p>安全层的主要职责就是<strong>对发起的HTTP请求的数据进行加密操作</strong> 和 <strong>对接收到的HTTP的内容进行解密操作</strong>。</p><h3 id="2-TLS-x2F-SSL的工作原理"><a href="#2-TLS-x2F-SSL的工作原理" class="headerlink" title="2. TLS&#x2F;SSL的工作原理"></a>2. TLS&#x2F;SSL的工作原理</h3><p><strong>TLS&#x2F;SSL</strong>全称<strong>安全传输层协议</strong>（Transport Layer Security）, 是介于TCP和HTTP之间的一层安全协议，不影响原有的TCP协议和HTTP协议，所以使用HTTPS基本上不需要对HTTP页面进行太多的改造。</p><p>TLS&#x2F;SSL的功能实现主要依赖三类基本算法：<strong>散列函数hash</strong>、<strong>对称加密</strong>、<strong>非对称加密</strong>。这三类算法的作用如下：</p><ul><li>基于散列函数验证信息的完整性</li><li>对称加密算法采用协商的秘钥对数据加密</li><li>非对称加密实现身份认证和秘钥协商</li></ul><p><img src="10.png" alt="img"></p><h4 id="（1）散列函数hash"><a href="#（1）散列函数hash" class="headerlink" title="（1）散列函数hash"></a>（1）散列函数hash</h4><p>常见的散列函数有MD5、SHA1、SHA256。该函数的特点是单向不可逆，对输入数据非常敏感，输出的长度固定，任何数据的修改都会改变散列函数的结果，可以用于防止信息篡改并验证数据的完整性。</p><p><strong>特点：</strong> 在信息传输过程中，散列函数不能三都实现信息防篡改，由于传输是明文传输，中间人可以修改信息后重新计算信息的摘要，所以需要对传输的信息和信息摘要进行加密。</p><h4 id="（2）对称加密"><a href="#（2）对称加密" class="headerlink" title="（2）对称加密"></a>（2）对称加密</h4><p>对称加密的方法是，双方使用同一个秘钥对数据进行加密和解密。但是对称加密的存在一个问题，就是如何保证秘钥传输的安全性，因为秘钥还是会通过网络传输的，一旦秘钥被其他人获取到，那么整个加密过程就毫无作用了。 这就要用到非对称加密的方法。</p><p>常见的对称加密算法有AES-CBC、DES、3DES、AES-GCM等。相同的秘钥可以用于信息的加密和解密。掌握秘钥才能获取信息，防止信息窃听，其通讯方式是一对一。</p><p><strong>特点：</strong> 对称加密的优势就是信息传输使用一对一，需要共享相同的密码，密码的安全是保证信息安全的基础，服务器和N个客户端通信，需要维持N个密码记录且不能修改密码。</p><h4 id="（3）非对称加密"><a href="#（3）非对称加密" class="headerlink" title="（3）非对称加密"></a>（3）非对称加密</h4><p>非对称加密的方法是，我们拥有两个秘钥，一个是公钥，一个是私钥。公钥是公开的，私钥是保密的。用私钥加密的数据，只有对应的公钥才能解密，用公钥加密的数据，只有对应的私钥才能解密。我们可以将公钥公布出去，任何想和我们通信的客户， 都可以使用我们提供的公钥对数据进行加密，这样我们就可以使用私钥进行解密，这样就能保证数据的安全了。但是非对称加密有一个缺点就是加密的过程很慢，因此如果每次通信都使用非对称加密的方式的话，反而会造成等待时间过长的问题。</p><p>常见的非对称加密算法有RSA、ECC、DH等。秘钥成对出现，一般称为公钥（公开）和私钥（保密）。公钥加密的信息只有私钥可以解开，私钥加密的信息只能公钥解开，因此掌握公钥的不同客户端之间不能相互解密信息，只能和服务器进行加密通信，服务器可以实现一对多的的通信，客户端也可以用来验证掌握私钥的服务器的身份。</p><p><strong>特点：</strong> 非对称加密的特点就是信息一对多，服务器只需要维持一个私钥就可以和多个客户端进行通信，但服务器发出的信息能够被所有的客户端解密，且该算法的计算复杂，加密的速度慢。</p><p>综合上述算法特点，TLS&#x2F;SSL的工作方式就是客户端使用非对称加密与服务器进行通信，实现身份的验证并协商对称加密使用的秘钥。对称加密算法采用协商秘钥对信息以及信息摘要进行加密通信，不同节点之间采用的对称秘钥不同，从而保证信息只能通信双方获取。这样就解决了两个方法各自存在的问题。</p><h3 id="3-数字证书是什么？"><a href="#3-数字证书是什么？" class="headerlink" title="3. 数字证书是什么？"></a>3. 数字证书是什么？</h3><p>现在的方法也不一定是安全的，因为没有办法确定得到的公钥就一定是安全的公钥。可能存在一个中间人，截取了对方发给我们的公钥，然后将他自己的公钥发送给我们，当我们使用他的公钥加密后发送的信息，就可以被他用自己的私钥解密。然后他伪装成我们以同样的方法向对方发送信息，这样我们的信息就被窃取了，然而自己还不知道。为了解决这样的问题，可以使用数字证书。</p><p>首先使用一种 Hash 算法来对公钥和其他信息进行加密，生成一个信息摘要，然后让有公信力的认证中心（简称 CA ）用它的私钥对消息摘要加密，形成签名。最后将原始的信息和签名合在一起，称为数字证书。当接收方收到数字证书的时候，先根据原始信息使用同样的 Hash 算法生成一个摘要，然后使用公证处的公钥来对数字证书中的摘要进行解密，最后将解密的摘要和生成的摘要进行对比，就能发现得到的信息是否被更改了。</p><p>这个方法最要的是认证中心的可靠性，一般浏览器里会内置一些顶层的认证中心的证书，相当于我们自动信任了他们，只有这样才能保证数据的安全。<br><img src="11.png" alt="img"></p><h3 id="4-HTTPS通信（握手）过程"><a href="#4-HTTPS通信（握手）过程" class="headerlink" title="4. HTTPS通信（握手）过程"></a>4. HTTPS通信（握手）过程</h3><p>HTTPS的通信过程如下：</p><ol><li>客户端向服务器发起请求，请求中包含使用的协议版本号、生成的一个随机数、以及客户端支持的加密方法。</li><li>服务器端接收到请求后，确认双方使用的加密方法、并给出服务器的证书、以及一个服务器生成的随机数。</li><li>客户端确认服务器证书有效后，生成一个新的随机数，并使用数字证书中的公钥，加密这个随机数，然后发给服 务器。并且还会提供一个前面所有内容的 hash 的值，用来供服务器检验。</li><li>服务器使用自己的私钥，来解密客户端发送过来的随机数。并提供前面所有内容的 hash 值来供客户端检验。</li><li>客户端和服务器端根据约定的加密方法使用前面的三个随机数，生成对话秘钥，以后的对话过程都使用这个秘钥来加密信息。</li></ol><h3 id="5-HTTPS的特点"><a href="#5-HTTPS的特点" class="headerlink" title="5. HTTPS的特点"></a>5. HTTPS的特点</h3><p>HTTPS的<strong>优点</strong>如下：</p><ul><li>使用HTTPS协议可以认证用户和服务器，确保数据发送到正确的客户端和服务器；</li><li>使用HTTPS协议可以进行加密传输、身份认证，通信更加安全，防止数据在传输过程中被窃取、修改，确保数据安全性；</li><li>HTTPS是现行架构下最安全的解决方案，虽然不是绝对的安全，但是大幅增加了中间人攻击的成本；</li></ul><p>HTTPS的<strong>缺点</strong>如下：</p><ul><li>HTTPS需要做服务器和客户端双方的加密个解密处理，耗费更多服务器资源，过程复杂；</li><li>HTTPS协议握手阶段比较费时，增加页面的加载时间；</li><li>SSL证书是收费的，功能越强大的证书费用越高；</li><li>HTTPS连接服务器端资源占用高很多，支持访客稍多的网站需要投入更大的成本；</li><li>SSL证书需要绑定IP，不能再同一个IP上绑定多个域名。</li></ul><h3 id="6-HTTPS是如何保证安全的？"><a href="#6-HTTPS是如何保证安全的？" class="headerlink" title="6. HTTPS是如何保证安全的？"></a>6. <strong>HTTPS</strong>是如何保证安全的？</h3><p>先理解两个概念：</p><ul><li>对称加密：即通信的双⽅都使⽤同⼀个秘钥进⾏加解密，对称加密虽然很简单性能也好，但是⽆法解决⾸次把秘钥发给对⽅的问题，很容易被⿊客拦截秘钥。 </li><li>⾮对称加密：</li></ul><ol><li>私钥 + 公钥&#x3D; 密钥对 </li><li>即⽤私钥加密的数据,只有对应的公钥才能解密,⽤公钥加密的数据,只有对应的私钥才能解密 </li><li>因为通信双⽅的⼿⾥都有⼀套⾃⼰的密钥对,通信之前双⽅会先把⾃⼰的公钥都先发给对⽅ </li><li>然后对⽅再拿着这个公钥来加密数据响应给对⽅,等到到了对⽅那⾥,对⽅再⽤⾃⼰的私钥进⾏解密</li></ol><p>⾮对称加密虽然安全性更⾼，但是带来的问题就是速度很慢，影响性能。 </p><p><strong>解决⽅案：</strong></p><p>结合两种加密⽅式，将对称加密的密钥使⽤⾮对称加密的公钥进⾏加密，然后发送出去，接收⽅使⽤私钥进⾏解密得到对称加密的密钥，然后双⽅可以使⽤对称加密来进⾏沟通。 </p><p>此时⼜带来⼀个问题，中间⼈问题：<br>如果此时在客户端和服务器之间存在⼀个中间⼈,这个中间⼈只需要把原本双⽅通信互发的公钥,换成⾃⼰的公钥,这样中间⼈就可以轻松解密通信双⽅所发送的所有数据。 </p><p>所以这个时候需要⼀个安全的第三⽅颁发证书（CA），证明身份的身份，防⽌被中间⼈攻击。 证书中包括：签发者、证书⽤途、使⽤者公钥、使⽤者私钥、使⽤者的HASH算法、证书到期时间等。</p><p>但是问题来了，如果中间⼈篡改了证书，那么身份证明是不是就⽆效了？这个证明就⽩买了，这个时候需要⼀个新的技术，数字签名。 </p><p>数字签名就是⽤CA⾃带的HASH算法对证书的内容进⾏HASH得到⼀个摘要，再⽤CA的私钥加密，最终组成数字签名。当别⼈把他的证书发过来的时候,我再⽤同样的Hash算法,再次⽣成消息摘要，然后⽤CA的公钥对数字签名解密,得到CA创建的消息摘要,两者⼀⽐,就知道中间有没有被⼈篡改了。这个时候就能最⼤程度保证通信的安全了。 </p><h2 id="三、HTTP状态码"><a href="#三、HTTP状态码" class="headerlink" title="三、HTTP状态码"></a>三、HTTP状态码</h2><p>状态码的类别：</p><table><thead><tr><th><strong>类别</strong></th><th><strong>原因</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>1xx</td><td>Informational(信息性状态码)</td><td>接受的请求正在处理</td></tr><tr><td>2xx</td><td>Success(成功状态码)</td><td>请求正常处理完毕</td></tr><tr><td>3xx</td><td>Redirection(重定向状态码)</td><td>需要进行附加操作一完成请求</td></tr><tr><td>4xx</td><td>Client Error (客户端错误状态码)</td><td>服务器无法处理请求</td></tr><tr><td>5xx</td><td>Server Error(服务器错误状态码)</td><td>服务器处理请求出错</td></tr></tbody></table><h3 id="1-2XX-Success-成功状态码"><a href="#1-2XX-Success-成功状态码" class="headerlink" title="1. 2XX (Success 成功状态码)"></a>1. 2XX (Success 成功状态码)</h3><p>状态码2XX表示请求被正常处理了。</p><h4 id="（1）200-OK"><a href="#（1）200-OK" class="headerlink" title="（1）200 OK"></a>（1）200 OK</h4><p>200 OK表示客户端发来的请求被服务器端正常处理了。</p><h4 id="（2）204-No-Content"><a href="#（2）204-No-Content" class="headerlink" title="（2）204 No Content"></a>（2）204 No Content</h4><p>该状态码表示客户端发送的请求已经在服务器端正常处理了，但是没有返回的内容，响应报文中不包含实体的主体部分。一般在只需要从客户端往服务器端发送信息，而服务器端不需要往客户端发送内容时使用。</p><h4 id="（3）206-Partial-Content"><a href="#（3）206-Partial-Content" class="headerlink" title="（3）206 Partial Content"></a>（3）206 Partial Content</h4><p>该状态码表示客户端进行了范围请求，而服务器端执行了这部分的 GET 请求。响应报文中包含由 Content-Range 指定范围的实体内容。</p><h3 id="2-3XX-Redirection-重定向状态码"><a href="#2-3XX-Redirection-重定向状态码" class="headerlink" title="2. 3XX (Redirection 重定向状态码)"></a>2. 3XX (Redirection 重定向状态码)</h3><p>3XX 响应结果表明浏览器需要执行某些特殊的处理以正确处理请求。</p><h4 id="（1）301-Moved-Permanently"><a href="#（1）301-Moved-Permanently" class="headerlink" title="（1）301 Moved Permanently"></a>（1）301 Moved Permanently</h4><p><strong>永久重定向。</strong><br>该状态码表示请求的资源已经被分配了新的 URI，以后应使用资源指定的 URI。新的 URI 会在 HTTP 响应头中的 Location 首部字段指定。若用户已经把原来的URI保存为书签，此时会按照 Location 中新的URI重新保存该书签。同时，搜索引擎在抓取新内容的同时也将旧的网址替换为重定向之后的网址。</p><p><strong>使用场景：</strong></p><ul><li>当我们想换个域名，旧的域名不再使用时，用户访问旧域名时用301就重定向到新的域名。其实也是告诉搜索引擎收录的域名需要对新的域名进行收录。</li><li>在搜索引擎的搜索结果中出现了不带www的域名，而带www的域名却没有收录，这个时候可以用301重定向来告诉搜索引擎我们目标的域名是哪一个。</li></ul><h4 id="（2）302-Found"><a href="#（2）302-Found" class="headerlink" title="（2）302 Found"></a>（2）302 Found</h4><p><strong>临时重定向。</strong><br>该状态码表示请求的资源被分配到了新的 URI，希望用户（本次）能使用新的 URI 访问资源。和 301 Moved Permanently 状态码相似，但是 302 代表的资源不是被永久重定向，只是临时性质的。也就是说已移动的资源对应的 URI 将来还有可能发生改变。若用户把 URI 保存成书签，但不会像 301 状态码出现时那样去更新书签，而是仍旧保留返回 302 状态码的页面对应的 URI。同时，搜索引擎会抓取新的内容而保留旧的网址。因为服务器返回302代码，搜索引擎认为新的网址只是暂时的。</p><p><strong>使用场景：</strong></p><ul><li>当我们在做活动时，登录到首页自动重定向，进入活动页面。</li><li>未登陆的用户访问用户中心重定向到登录页面。</li><li>访问404页面重新定向到首页。</li></ul><h4 id="（3）303-See-Other"><a href="#（3）303-See-Other" class="headerlink" title="（3）303 See Other"></a>（3）303 See Other</h4><p>该状态码表示由于请求对应的资源存在着另一个 URI，应使用 GET 方法定向获取请求的资源。<br>303 状态码和 302 Found 状态码有着相似的功能，但是 303 状态码明确表示客户端应当采用 GET 方法获取资源。</p><p>303 状态码通常作为 PUT 或 POST 操作的返回结果，它表示重定向链接指向的不是新上传的资源，而是另外一个页面，比如消息确认页面或上传进度页面。而请求重定向页面的方法要总是使用 GET。</p><p>注意：</p><ul><li>当 301、302、303 响应状态码返回时，几乎所有的浏览器都会把 POST 改成GET，并删除请求报文内的主体，之后请求会再次自动发送。</li><li>301、302 标准是禁止将 POST 方法变成 GET方法的，但实际大家都会这么做。</li></ul><h4 id="（4）304-Not-Modified"><a href="#（4）304-Not-Modified" class="headerlink" title="（4）304 Not Modified"></a>（4）304 Not Modified</h4><p><strong>浏览器缓存相关。</strong><br>该状态码表示客户端发送附带条件的请求时，服务器端允许请求访问资源，但未满足条件的情况。304 状态码返回时，不包含任何响应的主体部分。304 虽然被划分在 3XX 类别中，但是和重定向没有关系。</p><p>带条件的请求（Http 条件请求）：使用 Get方法 请求，请求报文中包含（<code>if-match</code>、<code>if-none-match</code>、<code>if-modified-since</code>、<code>if-unmodified-since</code>、<code>if-range</code>）中任意首部。</p><p>状态码304并不是一种错误，而是告诉客户端有缓存，直接使用缓存中的数据。返回页面的只有头部信息，是没有内容部分的，这样在一定程度上提高了网页的性能。</p><h4 id="（5）307-Temporary-Redirect"><a href="#（5）307-Temporary-Redirect" class="headerlink" title="（5）307 Temporary Redirect"></a>（5）307 Temporary Redirect</h4><p><strong>307表示临时重定向。</strong> 该状态码与 302 Found 有着相同含义，尽管 302 标准禁止 POST 变成 GET，但是实际使用时还是这样做了。</p><p>307 会遵守浏览器标准，<strong>不会从 POST 变成 GET</strong>。但是对于处理请求的行为时，不同浏览器还是会出现不同的情况。规范要求浏览器继续向 Location 的地址 POST 内容。规范要求浏览器继续向 Location 的地址 POST 内容。</p><h3 id="3-4XX-Client-Error-客户端错误状态码"><a href="#3-4XX-Client-Error-客户端错误状态码" class="headerlink" title="3. 4XX (Client Error 客户端错误状态码)"></a>3. 4XX (Client Error 客户端错误状态码)</h3><p>4XX 的响应结果表明客户端是发生错误的原因所在。</p><h4 id="（1）400-Bad-Request"><a href="#（1）400-Bad-Request" class="headerlink" title="（1）400 Bad Request"></a>（1）400 Bad Request</h4><p>该状态码表示请求报文中存在语法错误。当错误发生时，需修改请求的内容后再次发送请求。另外，浏览器会像 200 OK 一样对待该状态码。</p><h4 id="（2）401-Unauthorized"><a href="#（2）401-Unauthorized" class="headerlink" title="（2）401 Unauthorized"></a>（2）401 Unauthorized</h4><p>该状态码表示发送的请求需要有通过 HTTP 认证(BASIC 认证、DIGEST 认证)的认证信息。若之前已进行过一次请求，则表示用户认证失败</p><p>返回含有 401 的响应必须包含一个适用于被请求资源的 WWW-Authenticate 首部用以质询(challenge)用户信息。当浏览器初次接收到 401 响应，会弹出认证用的对话窗口。</p><p>以下情况会出现401：</p><ul><li>401.1 - 登录失败。</li><li>401.2 - 服务器配置导致登录失败。</li><li>401.3 - 由于 ACL 对资源的限制而未获得授权。</li><li>401.4 - 筛选器授权失败。</li><li>401.5 - ISAPI&#x2F;CGI 应用程序授权失败。</li><li>401.7 - 访问被 Web 服务器上的 URL 授权策略拒绝。这个错误代码为 IIS 6.0 所专用。</li></ul><h4 id="（3）403-Forbidden"><a href="#（3）403-Forbidden" class="headerlink" title="（3）403 Forbidden"></a>（3）403 Forbidden</h4><p>该状态码表明请求资源的访问被服务器拒绝了，服务器端没有必要给出详细理由，但是可以在响应报文实体的主体中进行说明。进入该状态后，不能再继续进行验证。该访问是永久禁止的，并且与应用逻辑密切相关。</p><p>IIS 定义了许多不同的 403 错误，它们指明更为具体的错误原因：</p><ul><li>403.1 - 执行访问被禁止。</li><li>403.2 - 读访问被禁止。</li><li>403.3 - 写访问被禁止。</li><li>403.4 - 要求 SSL。</li><li>403.5 - 要求 SSL 128。</li><li>403.6 - IP 地址被拒绝。</li><li>403.7 - 要求客户端证书。</li><li>403.8 - 站点访问被拒绝。</li><li>403.9 - 用户数过多。</li><li>403.10 - 配置无效。</li><li>403.11 - 密码更改。</li><li>403.12 - 拒绝访问映射表。</li><li>403.13 - 客户端证书被吊销。</li><li>403.14 - 拒绝目录列表。</li><li>403.15 - 超出客户端访问许可。</li><li>403.16 - 客户端证书不受信任或无效。</li><li>403.17 - 客户端证书已过期或尚未生效</li><li>403.18 - 在当前的应用程序池中不能执行所请求的 URL。这个错误代码为 IIS 6.0 所专用。</li><li>403.19 - 不能为这个应用程序池中的客户端执行 CGI。这个错误代码为 IIS 6.0 所专用。</li><li>403.20 - Passport 登录失败。这个错误代码为 IIS 6.0 所专用。</li></ul><h4 id="（4）404-Not-Found"><a href="#（4）404-Not-Found" class="headerlink" title="（4）404 Not Found"></a>（4）404 Not Found</h4><p>该状态码表明服务器上无法找到请求的资源。除此之外，也可以在服务器端拒绝请求且不想说明理由时使用。<br>以下情况会出现404：</p><ul><li>404.0 -（无） – 没有找到文件或目录。</li><li>404.1 - 无法在所请求的端口上访问 Web 站点。</li><li>404.2 - Web 服务扩展锁定策略阻止本请求。</li><li>404.3 - MIME 映射策略阻止本请求。</li></ul><h4 id="（5）405-Method-Not-Allowed"><a href="#（5）405-Method-Not-Allowed" class="headerlink" title="（5）405 Method Not Allowed"></a>（5）405 Method Not Allowed</h4><p>该状态码表示客户端请求的方法虽然能被服务器识别，但是服务器禁止使用该方法。GET 和 HEAD 方法，服务器应该总是允许客户端进行访问。客户端可以通过 OPTIONS 方法（预检）来查看服务器允许的访问方法, 如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Access</span>-<span class="hljs-title class_">Control</span>-<span class="hljs-title class_">Allow</span>-<span class="hljs-title class_">Methods</span>: <span class="hljs-variable constant_">GET</span>,<span class="hljs-variable constant_">HEAD</span>,<span class="hljs-variable constant_">PUT</span>,<span class="hljs-variable constant_">PATCH</span>,<span class="hljs-variable constant_">POST</span>,<span class="hljs-variable constant_">DELETE</span><br></code></pre></td></tr></table></figure><h3 id="4-5XX-Server-Error-服务器错误状态码"><a href="#4-5XX-Server-Error-服务器错误状态码" class="headerlink" title="4. 5XX (Server Error 服务器错误状态码)"></a>4. 5XX (Server Error 服务器错误状态码)</h3><p>5XX 的响应结果表明服务器本身发生错误.</p><h4 id="（1）500-Internal-Server-Error"><a href="#（1）500-Internal-Server-Error" class="headerlink" title="（1）500 Internal Server Error"></a>（1）500 Internal Server Error</h4><p>该状态码表明服务器端在执行请求时发生了错误。也有可能是 Web 应用存在的 bug 或某些临时的故障。</p><h4 id="（2）502-Bad-Gateway"><a href="#（2）502-Bad-Gateway" class="headerlink" title="（2）502 Bad Gateway"></a>（2）502 Bad Gateway</h4><p>该状态码表明扮演网关或代理角色的服务器，从上游服务器中接收到的响应是无效的。注意，502 错误通常不是客户端能够修复的，而是需要由途经的 Web 服务器或者代理服务器对其进行修复。以下情况会出现502：</p><ul><li>502.1 - CGI （通用网关接口）应用程序超时。</li><li>502.2 - CGI （通用网关接口）应用程序出错。</li></ul><h4 id="（3）503-Service-Unavailable"><a href="#（3）503-Service-Unavailable" class="headerlink" title="（3）503 Service Unavailable"></a>（3）503 Service Unavailable</h4><p>该状态码表明服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。如果事先得知解除以上状况需要的时间，最好写入 RetryAfter 首部字段再返回给客户端。</p><p><strong>使用场景：</strong></p><ul><li>服务器停机维护时，主动用503响应请求；</li><li>nginx 设置限速，超过限速，会返回503。</li></ul><h4 id="（4）504-Gateway-Timeout"><a href="#（4）504-Gateway-Timeout" class="headerlink" title="（4）504 Gateway Timeout"></a>（4）504 Gateway Timeout</h4><p>该状态码表示网关或者代理的服务器无法在规定的时间内获得想要的响应。他是HTTP 1.1中新加入的。</p><p>使用场景：代码执行时间超时，或者发生了死循环。</p><h3 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h3><p><strong>（1）2XX 成功</strong></p><ul><li>200 OK，表示从客户端发来的请求在服务器端被正确处理</li><li>204 No content，表示请求成功，但响应报文不含实体的主体部分</li><li>205 Reset Content，表示请求成功，但响应报文不含实体的主体部分，但是与 204 响应不同在于要求请求方重置内容</li><li>206 Partial Content，进行范围请求</li></ul><p><strong>（2）3XX 重定向</strong></p><ul><li>301 moved permanently，永久性重定向，表示资源已被分配了新的 URL</li><li>302 found，临时性重定向，表示资源临时被分配了新的 URL</li><li>303 see other，表示资源存在着另一个 URL，应使用 GET 方法获取资源</li><li>304 not modified，表示服务器允许访问资源，但因发生请求未满足条件的情况</li><li>307 temporary redirect，临时重定向，和302含义类似，但是期望客户端保持请求方法不变向新的地址发出请求</li></ul><p><strong>（3）4XX 客户端错误</strong></p><ul><li>400 bad request，请求报文存在语法错误</li><li>401 unauthorized，表示发送的请求需要有通过 HTTP 认证的认证信息</li><li>403 forbidden，表示对请求资源的访问被服务器拒绝</li><li>404 not found，表示在服务器上没有找到请求的资源</li></ul><p><strong>（4）5XX 服务器错误</strong></p><ul><li>500 internal sever error，表示服务器端在执行请求时发生了错误</li><li>501 Not Implemented，表示服务器不支持当前请求所需要的某个功能</li><li>503 service unavailable，表明服务器暂时处于超负载或正在停机维护，无法处理请求</li></ul><h3 id="6-同样是重定向，307，303，302的区别？"><a href="#6-同样是重定向，307，303，302的区别？" class="headerlink" title="6. 同样是重定向，307，303，302的区别？"></a>6. 同样是重定向，<strong>307</strong>，<strong>303</strong>，<strong>302</strong>的区别？</h3><p>302是http1.0的协议状态码，在http1.1版本的时候为了细化302状态码⼜出来了两个303和307。 303明确表示客户端应当采⽤get⽅法获取资源，他会把POST请求变为GET请求进⾏重定向。 307会遵照浏览器标准，不会从post变为get。 </p><h2 id="四、DNS协议介绍"><a href="#四、DNS协议介绍" class="headerlink" title="四、DNS协议介绍"></a>四、DNS协议介绍</h2><h3 id="1-DNS-协议是什么"><a href="#1-DNS-协议是什么" class="headerlink" title="1. DNS 协议是什么"></a>1. DNS 协议是什么</h3><p><strong>概念</strong>： DNS 是域名系统 (Domain Name System) 的缩写，提供的是一种主机名到 IP 地址的转换服务，就是我们常说的域名系统。它是一个由分层的 DNS 服务器组成的分布式数据库，是定义了主机如何查询这个分布式数据库的方式的应用层协议。能够使人更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。</p><p><strong>作用</strong>： 将域名解析为IP地址，客户端向DNS服务器（DNS服务器有自己的IP地址）发送域名查询请求，DNS服务器告知客户机Web服务器的 IP 地址。</p><h3 id="2-DNS同时使用TCP和UDP协议？"><a href="#2-DNS同时使用TCP和UDP协议？" class="headerlink" title="2. DNS同时使用TCP和UDP协议？"></a>2. DNS同时使用TCP和UDP协议？</h3><p><strong>DNS占用53号端口，同时使用TCP和UDP协议。</strong><br>（1）在区域传输的时候使用TCP协议</p><ul><li>辅域名服务器会定时（一般3小时）向主域名服务器进行查询以便了解数据是否有变动。如有变动，会执行一次区域传送，进行数据同步。区域传送使用TCP而不是UDP，因为数据同步传送的数据量比一个请求应答的数据量要多得多。</li><li>TCP是一种可靠连接，保证了数据的准确性。</li></ul><p>（2）在域名解析的时候使用UDP协议</p><ul><li>客户端向DNS服务器查询域名，一般返回的内容都不超过512字节，用UDP传输即可。不用经过三次握手，这样DNS服务器负载更低，响应更快。理论上说，客户端也可以指定向DNS服务器查询时用TCP，但事实上，很多DNS服务器进行配置的时候，仅支持UDP查询包。</li></ul><h3 id="3-DNS完整的查询过程"><a href="#3-DNS完整的查询过程" class="headerlink" title="3. DNS完整的查询过程"></a>3. DNS完整的查询过程</h3><p>DNS服务器解析域名的过程：</p><ul><li>首先会在<strong>浏览器的缓存</strong>中查找对应的IP地址，如果查找到直接返回，若找不到继续下一步</li><li>将请求发送给<strong>本地DNS服务器</strong>，在本地域名服务器缓存中查询，如果查找到，就直接将查找结果返回，若找不到继续下一步</li><li>本地DNS服务器向<strong>根域名服务器</strong>发送请求，根域名服务器会返回一个所查询域的顶级域名服务器地址</li><li>本地DNS服务器向<strong>顶级域名服务器</strong>发送请求，接受请求的服务器查询自己的缓存，如果有记录，就返回查询结果，如果没有就返回相关的下一级的权威域名服务器的地址</li><li>本地DNS服务器向<strong>权威域名服务器</strong>发送请求，域名服务器返回对应的结果</li><li>本地DNS服务器将返回结果保存在缓存中，便于下次使用</li><li>本地DNS服务器将返回结果返回给浏览器</li></ul><p>比如要查询 <a href="http://www.baidu.com/">www.baidu.com</a> 的 IP 地址，首先会在浏览器的缓存中查找是否有该域名的缓存，如果不存在就将请求发送到本地的 DNS 服务器中，本地DNS服务器会判断是否存在该域名的缓存，如果不存在，则向根域名服务器发送一个请求，根域名服务器返回负责 .com 的顶级域名服务器的 IP 地址的列表。然后本地 DNS 服务器再向其中一个负责 .com 的顶级域名服务器发送一个请求，负责 .com 的顶级域名服务器返回负责 .baidu 的权威域名服务器的 IP 地址列表。然后本地 DNS 服务器再向其中一个权威域名服务器发送一个请求，最后权威域名服务器返回一个对应的主机名的 IP 地址列表。</p><h3 id="4-迭代查询与递归查询"><a href="#4-迭代查询与递归查询" class="headerlink" title="4. 迭代查询与递归查询"></a>4. 迭代查询与递归查询</h3><p>实际上，DNS解析是一个包含迭代查询和递归查询的过程。</p><ul><li><strong>递归查询</strong>指的是查询请求发出后，域名服务器代为向下一级域名服务器发出请求，最后向用户返回查询的最终结果。使用递归 查询，用户只需要发出一次查询请求。</li><li><strong>迭代查询</strong>指的是查询请求后，域名服务器返回单次查询的结果。下一级的查询由用户自己请求。使用迭代查询，用户需要发出 多次的查询请求。</li></ul><p>一般我们向本地 DNS 服务器发送请求的方式就是递归查询，因为我们只需要发出一次请求，然后本地 DNS 服务器返回给我 们最终的请求结果。而本地 DNS 服务器向其他域名服务器请求的过程是迭代查询的过程，因为每一次域名服务器只返回单次 查询的结果，下一级的查询由本地 DNS 服务器自己进行。</p><h3 id="5-DNS-记录和报文"><a href="#5-DNS-记录和报文" class="headerlink" title="5. DNS 记录和报文"></a>5. DNS 记录和报文</h3><p>DNS 服务器中以资源记录的形式存储信息，每一个 DNS 响应报文一般包含多条资源记录。一条资源记录的具体的格式为</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs http">（Name，Value，Type，TTL）<br></code></pre></td></tr></table></figure><p>其中 TTL 是资源记录的生存时间，它定义了资源记录能够被其他的 DNS 服务器缓存多长时间。</p><p>常用的一共有四种 Type 的值，分别是 A、NS、CNAME 和 MX ，不同 Type 的值，对应资源记录代表的意义不同：</p><ul><li>如果 Type &#x3D; A，则 Name 是主机名，Value 是主机名对应的 IP 地址。因此一条记录为 A 的资源记录，提供了标 准的主机名到 IP 地址的映射。</li><li>如果 Type &#x3D; NS，则 Name 是个域名，Value 是负责该域名的 DNS 服务器的主机名。这个记录主要用于 DNS 链式 查询时，返回下一级需要查询的 DNS 服务器的信息。</li><li>如果 Type &#x3D; CNAME，则 Name 为别名，Value 为该主机的规范主机名。该条记录用于向查询的主机返回一个主机名 对应的规范主机名，从而告诉查询主机去查询这个主机名的 IP 地址。主机别名主要是为了通过给一些复杂的主机名提供 一个便于记忆的简单的别名。</li><li>如果 Type &#x3D; MX，则 Name 为一个邮件服务器的别名，Value 为邮件服务器的规范主机名。它的作用和 CNAME 是一 样的，都是为了解决规范主机名不利于记忆的缺点。</li></ul><h2 id="五、网络模型"><a href="#五、网络模型" class="headerlink" title="五、网络模型"></a>五、网络模型</h2><h3 id="1-OSI七层模型"><a href="#1-OSI七层模型" class="headerlink" title="1. OSI七层模型"></a>1. OSI七层模型</h3><p><code>ISO</code>为了更好的使网络应用更为普及，推出了<code>OSI</code>参考模型。<br><img src="12.webp" alt="img"></p><h4 id="（1）应用层"><a href="#（1）应用层" class="headerlink" title="（1）应用层"></a>（1）应用层</h4><p><code>OSI</code>参考模型中最靠近用户的一层，是为计算机用户提供应用接口，也为用户直接提供各种网络服务。我们常见应用层的网络服务协议有：<code>HTTP</code>，<code>HTTPS</code>，<code>FTP</code>，<code>POP3</code>、<code>SMTP</code>等。</p><ul><li>在客户端与服务器中经常会有数据的请求，这个时候就是会用到<code>http(hyper text transfer protocol)(超文本传输协议)</code>或者<code>https</code>.在后端设计数据接口时，我们常常使用到这个协议。</li><li><code>FTP</code>是文件传输协议，在开发过程中，个人并没有涉及到，但是我想，在一些资源网站，比如<code>百度网盘``迅雷</code>应该是基于此协议的。</li><li><code>SMTP</code>是<code>simple mail transfer protocol（简单邮件传输协议）</code>。在一个项目中，在用户邮箱验证码登录的功能时，使用到了这个协议。</li></ul><h4 id="（2）表示层"><a href="#（2）表示层" class="headerlink" title="（2）表示层"></a>（2）表示层</h4><p>表示层提供各种用于应用层数据的编码和转换功能,确保一个系统的应用层发送的数据能被另一个系统的应用层识别。如果必要，该层可提供一种标准表示形式，用于将计算机内部的多种数据格式转换成通信中采用的标准表示形式。数据压缩和加密也是表示层可提供的转换功能之一。</p><p>在项目开发中，为了方便数据传输，可以使用<code>base64</code>对数据进行编解码。如果按功能来划分，<code>base64</code>应该是工作在表示层。</p><h4 id="（3）会话层"><a href="#（3）会话层" class="headerlink" title="（3）会话层"></a>（3）会话层</h4><p>会话层就是负责建立、管理和终止表示层实体之间的通信会话。该层的通信由不同设备中的应用程序之间的服务请求和响应组成。</p><h4 id="（4）传输层"><a href="#（4）传输层" class="headerlink" title="（4）传输层"></a>（4）传输层</h4><p>传输层建立了主机端到端的链接，传输层的作用是为上层协议提供端到端的可靠和透明的数据传输服务，包括处理差错控制和流量控制等问题。该层向高层屏蔽了下层数据通信的细节，使高层用户看到的只是在两个传输实体间的一条主机到主机的、可由用户控制和设定的、可靠的数据通路。我们通常说的，<code>TCP</code> <code>UDP</code>就是在这一层。端口号既是这里的“端”。</p><h4 id="（5）网络层"><a href="#（5）网络层" class="headerlink" title="（5）网络层"></a>（5）网络层</h4><p>本层通过<code>IP</code>寻址来建立两个节点之间的连接，为源端的运输层送来的分组，选择合适的路由和交换节点，正确无误地按照地址传送给目的端的运输层。就是通常说的<code>IP</code>层。这一层就是我们经常说的<code>IP</code>协议层。<code>IP</code>协议是<code>Internet</code>的基础。我们可以这样理解，网络层规定了数据包的传输路线，而传输层则规定了数据包的传输方式。</p><h4 id="（6）数据链路层"><a href="#（6）数据链路层" class="headerlink" title="（6）数据链路层"></a>（6）数据链路层</h4><p>将比特组合成字节,再将字节组合成帧,使用链路层地址 (以太网使用MAC地址)来访问介质,并进行差错检测。<br>网络层与数据链路层的对比，通过上面的描述，我们或许可以这样理解，网络层是规划了数据包的传输路线，而数据链路层就是传输路线。不过，在数据链路层上还增加了差错控制的功能。</p><h4 id="（7）物理层"><a href="#（7）物理层" class="headerlink" title="（7）物理层"></a>（7）物理层</h4><p>实际最终信号的传输是通过物理层实现的。通过物理介质传输比特流。规定了电平、速度和电缆针脚。常用设备有（各种物理设备）集线器、中继器、调制解调器、网线、双绞线、同轴电缆。这些都是物理层的传输介质。</p><p><strong>OSI七层模型通信特点：对等通信</strong><br>对等通信，为了使数据分组从源传送到目的地，源端OSI模型的每一层都必须与目的端的对等层进行通信，这种通信方式称为对等层通信。在每一层通信过程中，使用本层自己协议进行通信。</p><h3 id="2-TCP-x2F-IP五层协议"><a href="#2-TCP-x2F-IP五层协议" class="headerlink" title="2. TCP&#x2F;IP五层协议"></a>2. TCP&#x2F;IP五层协议</h3><p><code>TCP/IP</code>五层协议和<code>OSI</code>的七层协议对应关系如下：<br><img src="13.png" alt="img"></p><ul><li>**应用层 (application layer)**：直接为应用进程提供服务。应用层协议定义的是应用进程间通讯和交互的规则，不同的应用有着不同的应用层协议，如 HTTP协议（万维网服务）、FTP协议（文件传输）、SMTP协议（电子邮件）、DNS（域名查询）等。</li><li>**传输层 (transport layer)**：有时也译为运输层，它负责为两台主机中的进程提供通信服务。该层主要有以下两种协议：<ul><li>传输控制协议 (Transmission Control Protocol，TCP)：提供面向连接的、可靠的数据传输服务，数据传输的基本单位是报文段（segment）；</li><li>用户数据报协议 (User Datagram Protocol，UDP)：提供无连接的、尽最大努力的数据传输服务，但不保证数据传输的可靠性，数据传输的基本单位是用户数据报。</li></ul></li><li>**网络层 (internet layer)**：有时也译为网际层，它负责为两台主机提供通信服务，并通过选择合适的路由将数据传递到目标主机。</li><li>**数据链路层 (data link layer)**：负责将网络层交下来的 IP 数据报封装成帧，并在链路的两个相邻节点间传送帧，每一帧都包含数据和必要的控制信息（如同步信息、地址信息、差错控制等）。</li><li>**物理层 (physical Layer)**：确保数据可以在各种物理媒介上进行传输，为数据的传输提供可靠的环境。</li></ul><p>从上图中可以看出，<code>TCP/IP</code>模型比<code>OSI</code>模型更加简洁，它把<code>应用层/表示层/会话层</code>全部整合为了<code>应用层</code>。</p><p>在每一层都工作着不同的设备，比如我们常用的交换机就工作在数据链路层的，一般的路由器是工作在网络层的。<br><img src="14.webp" alt="img"><br>在每一层实现的协议也各不同，即每一层的服务也不同，下图列出了每层主要的传输协议：<br><img src="15.webp" alt="img"></p><p>同样，<code>TCP/IP</code>五层协议的通信方式也是对等通信：<br><img src="16.png" alt="img"></p><h2 id="六、TCP与UDP"><a href="#六、TCP与UDP" class="headerlink" title="六、TCP与UDP"></a>六、TCP与UDP</h2><h3 id="1-TCP-和-UDP的概念及特点"><a href="#1-TCP-和-UDP的概念及特点" class="headerlink" title="1. TCP 和 UDP的概念及特点"></a>1. TCP 和 UDP的概念及特点</h3><p>TCP 和 UDP都是传输层协议，他们都属于TCP&#x2F;IP协议族：</p><p><strong>（1）UDP</strong></p><p>UDP的全称是<strong>用户数据报协议</strong>，在网络中它与TCP协议一样用于处理数据包，是一种无连接的协议。在OSI模型中，在传输层，处于IP协议的上一层。UDP有不提供数据包分组、组装和不能对数据包进行排序的缺点，也就是说，当报文发送之后，是无法得知其是否安全完整到达的。</p><p>它的特点如下：</p><p><strong>1）面向无连接</strong></p><p>首先 UDP 是不需要和 TCP一样在发送数据前进行三次握手建立连接的，想发数据就可以开始发送了。并且也只是数据报文的搬运工，不会对数据报文进行任何拆分和拼接操作。</p><p>具体来说就是：</p><ul><li>在发送端，应用层将数据传递给传输层的 UDP 协议，UDP 只会给数据增加一个 UDP 头标识下是 UDP 协议，然后就传递给网络层了</li><li>在接收端，网络层将数据传递给传输层，UDP 只去除 IP 报文头就传递给应用层，不会任何拼接操作</li></ul><p><strong>2）有单播，多播，广播的功能</strong></p><p>UDP 不止支持一对一的传输方式，同样支持一对多，多对多，多对一的方式，也就是说 UDP 提供了单播，多播，广播的功能。</p><p><strong>3）面向报文</strong></p><p>发送方的UDP对应用程序交下来的报文，在添加首部后就向下交付IP层。UDP对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。因此，应用程序必须选择合适大小的报文</p><p><strong>4）不可靠性</strong></p><p>首先不可靠性体现在无连接上，通信都不需要建立连接，想发就发，这样的情况肯定不可靠。</p><p>并且收到什么数据就传递什么数据，并且也不会备份数据，发送数据也不会关心对方是否已经正确接收到数据了。</p><p>再者网络环境时好时坏，但是 UDP 因为没有拥塞控制，一直会以恒定的速度发送数据。即使网络条件不好，也不会对发送速率进行调整。这样实现的弊端就是在网络条件不好的情况下可能会导致丢包，但是优点也很明显，在某些实时性要求高的场景（比如电话会议）就需要使用 UDP 而不是 TCP。</p><p><strong>5）头部开销小，传输数据报文时是很高效的。</strong><br><img src="17.png" alt="img"></p><p>UDP 头部包含了以下几个数据：</p><ul><li>两个十六位的端口号，分别为源端口（可选字段）和目标端口</li><li>整个数据报文的长度</li><li>整个数据报文的检验和（IPv4 可选字段），该字段用于发现头部信息和数据中的错误</li></ul><p>因此 UDP 的头部开销小，只有8字节，相比 TCP 的至少20字节要少得多，在传输数据报文时是很高效的。</p><p><strong>（2）TCP</strong><br>TCP的全称是传输控制协议是一种面向连接的、可靠的、基于字节流的传输层通信协议。TCP 是面向连接的、可靠的流协议（流就是指不间断的数据结构）。</p><p>它有以下几个特点：</p><p><strong>1）面向连接</strong></p><p>面向连接，是指发送数据之前必须在两端建立连接。建立连接的方法是“三次握手”，这样能建立可靠的连接。建立连接，是为数据的可靠传输打下了基础。</p><p><strong>2）仅支持单播传输</strong></p><p>每条TCP传输连接只能有两个端点，只能进行点对点的数据传输，不支持多播和广播传输方式。</p><p><strong>3）面向字节流</strong></p><p>TCP不像UDP一样那样一个个报文独立地传输，而是在不保留报文边界的情况下以字节流方式进行传输。</p><p><strong>4）可靠传输</strong></p><p>对于可靠传输，判断丢包、误码靠的是TCP的段编号以及确认号。TCP为了保证报文传输的可靠，就给每个包一个序号，同时序号也保证了传送到接收端实体的包的按序接收。然后接收端实体对已成功收到的字节发回一个相应的确认(ACK)；如果发送端实体在合理的往返时延(RTT)内未收到确认，那么对应的数据（假设丢失了）将会被重传。</p><p><strong>5）提供拥塞控制</strong></p><p>当网络出现拥塞的时候，TCP能够减小向网络注入数据的速率和数量，缓解拥塞。</p><p><strong>6）提供全双工通信</strong></p><p>TCP允许通信双方的应用程序在任何时候都能发送数据，因为TCP连接的两端都设有缓存，用来临时存放双向通信的数据。当然，TCP可以立即发送一个数据段，也可以缓存一段时间以便一次发送更多的数据段（最大的数据段大小取决于MSS）</p><h3 id="2-TCP和UDP的区别"><a href="#2-TCP和UDP的区别" class="headerlink" title="2. TCP和UDP的区别"></a>2. TCP和UDP的区别</h3><table><thead><tr><th></th><th>UDP</th><th>TCP</th></tr></thead><tbody><tr><td>是否连接</td><td>无连接</td><td>面向连接</td></tr><tr><td>是否可靠</td><td>不可靠传输，不使用流量控制和拥塞控制</td><td>可靠传输（数据顺序和正确性），使用流量控制和拥塞控制</td></tr><tr><td>连接对象个数</td><td>支持一对一，一对多，多对一和多对多交互通信</td><td>只能是一对一通信</td></tr><tr><td>传输方式</td><td>面向报文</td><td>面向字节流</td></tr><tr><td>首部开销</td><td>首部开销小，仅8字节</td><td>首部最小20字节，最大60字节</td></tr><tr><td>适用场景</td><td>适用于实时应用，例如视频会议、直播</td><td>适用于要求可靠传输的应用，例如文件传输</td></tr></tbody></table><h3 id="3-TCP和UDP的使用场景"><a href="#3-TCP和UDP的使用场景" class="headerlink" title="3. TCP和UDP的使用场景"></a>3. TCP和UDP的使用场景</h3><ul><li><strong>TCP应用场景：</strong> 效率要求相对低，但对准确性要求相对高的场景。因为传输中需要对数据确认、重发、排序等操作，相比之下效率没有UDP高。例如：文件传输（准确高要求高、但是速度可以相对慢）、接受邮件、远程登录。</li><li><strong>UDP应用场景：</strong> 效率要求相对高，对准确性要求相对低的场景。例如：QQ聊天、在线视频、网络语音电话（即时通讯，速度要求高，但是出现偶尔断续不是太大问题，并且此处完全不可以使用重发机制）、广播通信（广播、多播）。</li></ul><h3 id="4-UDP协议为什么不可靠？"><a href="#4-UDP协议为什么不可靠？" class="headerlink" title="4. UDP协议为什么不可靠？"></a>4. UDP协议为什么不可靠？</h3><p>UDP在传输数据之前不需要先建立连接，远地主机的运输层在接收到UDP报文后，不需要确认，提供不可靠交付。总结就以下四点：</p><ul><li>不保证消息交付：不确认，不重传，无超时</li><li>不保证交付顺序：不设置包序号，不重排，不会发生队首阻塞</li><li>不跟踪连接状态：不必建立连接或重启状态机</li><li>不进行拥塞控制：不内置客户端或网络反馈机制</li></ul><h3 id="5-TCP的重传机制"><a href="#5-TCP的重传机制" class="headerlink" title="5. TCP的重传机制"></a>5. TCP的重传机制</h3><p>由于TCP的下层网络（网络层）可能出现<strong>丢失、重复或失序</strong>的情况，TCP协议提供可靠数据传输服务。为保证数据传输的正确性，TCP会重传其认为已丢失（包括报文中的比特错误）的包。TCP使用两套独立的机制来完成重传，一是<strong>基于时间</strong>，二是<strong>基于确认信息</strong>。</p><p>TCP在发送一个数据之后，就开启一个定时器，若是在这个时间内没有收到发送数据的ACK确认报文，则对该报文进行重传，在达到一定次数还没有成功时放弃并发送一个复位信号。</p><h3 id="6-TCP的拥塞控制机制"><a href="#6-TCP的拥塞控制机制" class="headerlink" title="6. TCP的拥塞控制机制"></a>6. TCP的拥塞控制机制</h3><p>TCP的拥塞控制机制主要是以下四种机制：</p><ul><li>慢启动（慢开始）</li><li>拥塞避免</li><li>快速重传</li><li>快速恢复</li></ul><p><strong>（1）慢启动（慢开始）</strong></p><ul><li>在开始发送的时候设置cwnd &#x3D; 1（cwnd指的是拥塞窗口）</li><li>思路：开始的时候不要发送大量数据，而是先测试一下网络的拥塞程度，由小到大增加拥塞窗口的大小。</li><li>为了防止cwnd增长过大引起网络拥塞，设置一个慢开始门限(ssthresh 状态变量)<ul><li>当cnwd &lt; ssthresh，使用慢开始算法</li><li>当cnwd &#x3D; ssthresh，既可使用慢开始算法，也可以使用拥塞避免算法</li><li>当cnwd &gt; ssthresh，使用拥塞避免算法</li></ul></li></ul><p><strong>（2）拥塞避免</strong></p><ul><li>拥塞避免未必能够完全避免拥塞，是说在拥塞避免阶段将拥塞窗口控制为按线性增长，使网络不容易出现阻塞。</li><li>思路： 让拥塞窗口cwnd缓慢的增大，即每经过一个返回时间RTT就把发送方的拥塞控制窗口加一</li><li>无论是在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞，就把慢开始门限设置为出现拥塞时的发送窗口大小的一半。然后把拥塞窗口设置为1，执行慢开始算法。如图所示:<br><img src="18.png" alt="img"><br>其中，判断网络出现拥塞的根据就是没有收到确认，虽然没有收到确认可能是其他原因的分组丢失，但是因为无法判定，所以都当做拥塞来处理。</li></ul><p><strong>（3）快速重传</strong></p><ul><li>快重传要求接收方在收到一个失序的报文段后就立即发出重复确认(为的是使发送方及早知道有报文段没有到达对方)。发送方只要连续收到三个重复确认就立即重传对方尚未收到的报文段，而不必继续等待设置的重传计时器时间到期。</li><li>由于不需要等待设置的重传计时器到期，能尽早重传未被确认的报文段，能提高整个网络的吞吐量</li></ul><p><strong>（4）快速恢复</strong></p><ul><li>当发送方连续收到三个重复确认时，就执行“乘法减小”算法，把ssthresh门限减半。但是接下去并不执行慢开始算法。</li><li>考虑到如果网络出现拥塞的话就不会收到好几个重复的确认，所以发送方现在认为网络可能没有出现拥塞。所以此时不执行慢开始算法，而是将cwnd设置为ssthresh的大小，然后执行拥塞避免算法。<br><img src="19.png" alt="img"></li></ul><h3 id="7-TCP的流量控制机制"><a href="#7-TCP的流量控制机制" class="headerlink" title="7. TCP的流量控制机制"></a>7. TCP的流量控制机制</h3><p>一般来说，流量控制就是为了让发送方发送数据的速度不要太快，要让接收方来得及接收。TCP采用大小可变的<strong>滑动窗口</strong>进行流量控制，窗口大小的单位是字节。这里说的窗口大小其实就是每次传输的数据大小。</p><ul><li>当一个连接建立时，连接的每一端分配一个缓冲区来保存输入的数据，并将缓冲区的大小发送给另一端。</li><li>当数据到达时，接收方发送确认，其中包含了自己剩余的缓冲区大小。（剩余的缓冲区空间的大小被称为窗口，指出窗口大小的通知称为窗口通告 。接收方在发送的每一确认中都含有一个窗口通告。）</li><li>如果接收方应用程序读数据的速度能够与数据到达的速度一样快，接收方将在每一确认中发送一个正的窗口通告。</li><li>如果发送方操作的速度快于接收方，接收到的数据最终将充满接收方的缓冲区，导致接收方通告一个零窗口 。发送方收到一个零窗口通告时，必须停止发送，直到接收方重新通告一个正的窗口。</li></ul><h3 id="8-TCP的可靠传输机制"><a href="#8-TCP的可靠传输机制" class="headerlink" title="8. TCP的可靠传输机制"></a>8. TCP的可靠传输机制</h3><p>TCP 的可靠传输机制是基于连续 ARQ 协议和滑动窗口协议的。</p><p>TCP 协议在发送方维持了一个发送窗口，发送窗口以前的报文段是已经发送并确认了的报文段，发送窗口中包含了已经发送但 未确认的报文段和允许发送但还未发送的报文段，发送窗口以后的报文段是缓存中还不允许发送的报文段。当发送方向接收方发 送报文时，会依次发送窗口内的所有报文段，并且设置一个定时器，这个定时器可以理解为是最早发送但未收到确认的报文段。 如果在定时器的时间内收到某一个报文段的确认回答，则滑动窗口，将窗口的首部向后滑动到确认报文段的后一个位置，此时如 果还有已发送但没有确认的报文段，则重新设置定时器，如果没有了则关闭定时器。如果定时器超时，则重新发送所有已经发送 但还未收到确认的报文段，并将超时的间隔设置为以前的两倍。当发送方收到接收方的三个冗余的确认应答后，这是一种指示， 说明该报文段以后的报文段很有可能发生丢失了，那么发送方会启用快速重传的机制，就是当前定时器结束前，发送所有的已发 送但确认的报文段。</p><p>接收方使用的是累计确认的机制，对于所有按序到达的报文段，接收方返回一个报文段的肯定回答。如果收到了一个乱序的报文 段，那么接方会直接丢弃，并返回一个最近的按序到达的报文段的肯定回答。使用累计确认保证了返回的确认号之前的报文段都 已经按序到达了，所以发送窗口可以移动到已确认报文段的后面。</p><p>发送窗口的大小是变化的，它是由接收窗口剩余大小和网络中拥塞程度来决定的，TCP 就是通过控制发送窗口的长度来控制报文 段的发送速率。</p><p>但是 TCP 协议并不完全和滑动窗口协议相同，因为许多的 TCP 实现会将失序的报文段给缓存起来，并且发生重传时，只会重 传一个报文段，因此 TCP 协议的可靠传输机制更像是窗口滑动协议和选择重传协议的一个混合体。</p><h3 id="9-TCP的三次握手和四次挥手"><a href="#9-TCP的三次握手和四次挥手" class="headerlink" title="9. TCP的三次握手和四次挥手"></a>9. TCP的三次握手和四次挥手</h3><h4 id="（1）三次握手"><a href="#（1）三次握手" class="headerlink" title="（1）三次握手"></a>（1）三次握手</h4><p><img src="20.png" alt="img"><br>三次握手（Three-way Handshake）其实就是指建立一个TCP连接时，需要客户端和服务器总共发送3个包。进行三次握手的主要作用就是为了确认双方的接收能力和发送能力是否正常、指定自己的初始化序列号为后面的可靠性传送做准备。实质上其实就是连接服务器指定端口，建立TCP连接，并同步连接双方的序列号和确认号，交换TCP窗口大小信息。</p><p>刚开始客户端处于 Closed 的状态，服务端处于 Listen 状态。</p><ul><li>第一次握手：客户端给服务端发一个 SYN 报文，并指明客户端的初始化序列号 ISN，此时客户端处于 SYN_SEND 状态。</li></ul><blockquote><p>首部的同步位SYN&#x3D;1，初始序号seq&#x3D;x，SYN&#x3D;1的报文段不能携带数据，但要消耗掉一个序号。</p></blockquote><ul><li>第二次握手：服务器收到客户端的 SYN 报文之后，会以自己的 SYN 报文作为应答，并且也是指定了自己的初始化序列号 ISN。同时会把客户端的 ISN + 1 作为ACK 的值，表示自己已经收到了客户端的 SYN，此时服务器处于 SYN_REVD 的状态。</li></ul><blockquote><p>在确认报文段中SYN&#x3D;1，ACK&#x3D;1，确认号ack&#x3D;x+1，初始序号seq&#x3D;y</p></blockquote><ul><li>第三次握手：客户端收到 SYN 报文之后，会发送一个 ACK 报文，当然，也是一样把服务器的 ISN + 1 作为 ACK 的值，表示已经收到了服务端的 SYN 报文，此时客户端处于 ESTABLISHED 状态。服务器收到 ACK 报文之后，也处于 ESTABLISHED 状态，此时，双方已建立起了连接。</li></ul><blockquote><p>确认报文段ACK&#x3D;1，确认号ack&#x3D;y+1，序号seq&#x3D;x+1（初始为seq&#x3D;x，第二个报文段所以要+1），ACK报文段可以携带数据，不携带数据则不消耗序号。</p></blockquote><p><strong>那为什么要三次握手呢？两次不行吗？</strong></p><ul><li>为了确认双方的接收能力和发送能力都正常</li><li>如果是用两次握手，则会出现下面这种情况：</li></ul><blockquote><p>如客户端发出连接请求，但因连接请求报文丢失而未收到确认，于是客户端再重传一次连接请求。后来收到了确认，建立了连接。数据传输完毕后，就释放了连接，客户端共发出了两个连接请求报文段，其中第一个丢失，第二个到达了服务端，但是第一个丢失的报文段只是在某些网络结点长时间滞留了，延误到连接释放以后的某个时间才到达服务端，此时服务端误认为客户端又发出一次新的连接请求，于是就向客户端发出确认报文段，同意建立连接，不采用三次握手，只要服务端发出确认，就建立新的连接了，此时客户端忽略服务端发来的确认，也不发送数据，则服务端一致等待客户端发送数据，浪费资源。</p></blockquote><p><strong>简单来说就是以下三步：</strong></p><ul><li><strong>第一次握手：</strong> 客户端向服务端发送连接请求报文段。该报文段中包含自身的数据通讯初始序号。请求发送后，客户端便进入 SYN-SENT 状态。</li><li><strong>第二次握手：</strong> 服务端收到连接请求报文段后，如果同意连接，则会发送一个应答，该应答中也会包含自身的数据通讯初始序号，发送完成后便进入 SYN-RECEIVED 状态。</li><li><strong>第三次握手：</strong> 当客户端收到连接同意的应答后，还要向服务端发送一个确认报文。客户端发完这个报文段后便进入 ESTABLISHED 状态，服务端收到这个应答后也进入 ESTABLISHED 状态，此时连接建立成功。</li></ul><p>TCP 三次握手的建立连接的过程就是相互确认初始序号的过程，告诉对方，什么样序号的报文段能够被正确接收。 第三次握手的作用是客户端对服务器端的初始序号的确认。如果只使用两次握手，那么服务器就没有办法知道自己的序号是否 已被确认。同时这样也是为了防止失效的请求报文段被服务器接收，而出现错误的情况。</p><h4 id="（2）四次挥手"><a href="#（2）四次挥手" class="headerlink" title="（2）四次挥手"></a>（2）四次挥手</h4><p><img src="21.png" alt="img"><br>刚开始双方都处于 ESTABLISHED 状态，假如是客户端先发起关闭请求。四次挥手的过程如下：</p><ul><li>第一次挥手： 客户端会发送一个 FIN 报文，报文中会指定一个序列号。此时客户端处于 FIN_WAIT1 状态。</li></ul><blockquote><p>即发出连接释放报文段（FIN&#x3D;1，序号seq&#x3D;u），并停止再发送数据，主动关闭TCP连接，进入FIN_WAIT1（终止等待1）状态，等待服务端的确认。</p></blockquote><ul><li>第二次挥手：服务端收到 FIN 之后，会发送 ACK 报文，且把客户端的序列号值 +1 作为 ACK 报文的序列号值，表明已经收到客户端的报文了，此时服务端处于 CLOSE_WAIT 状态。</li></ul><blockquote><p>即服务端收到连接释放报文段后即发出确认报文段（ACK&#x3D;1，确认号ack&#x3D;u+1，序号seq&#x3D;v），服务端进入CLOSE_WAIT（关闭等待）状态，此时的TCP处于半关闭状态，客户端到服务端的连接释放。客户端收到服务端的确认后，进入FIN_WAIT2（终止等待2）状态，等待服务端发出的连接释放报文段。</p></blockquote><ul><li>第三次挥手：如果服务端也想断开连接了，和客户端的第一次挥手一样，发给 FIN 报文，且指定一个序列号。此时服务端处于 LAST_ACK 的状态。</li></ul><blockquote><p>即服务端没有要向客户端发出的数据，服务端发出连接释放报文段（FIN&#x3D;1，ACK&#x3D;1，序号seq&#x3D;w，确认号ack&#x3D;u+1），服务端进入LAST_ACK（最后确认）状态，等待客户端的确认。</p></blockquote><ul><li>第四次挥手：客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答，且把服务端的序列号值 +1 作为自己 ACK 报文的序列号值，此时客户端处于 TIME_WAIT 状态。需要过一阵子以确保服务端收到自己的 ACK 报文之后才会进入 CLOSED 状态，服务端收到 ACK 报文之后，就处于关闭连接了，处于 CLOSED 状态。</li></ul><blockquote><p>即客户端收到服务端的连接释放报文段后，对此发出确认报文段（ACK&#x3D;1，seq&#x3D;u+1，ack&#x3D;w+1），客户端进入TIME_WAIT（时间等待）状态。此时TCP未释放掉，需要经过时间等待计时器设置的时间2MSL后，客户端才进入CLOSED状态。</p></blockquote><p><strong>那为什么需要四次挥手呢？</strong></p><blockquote><p>因为当服务端收到客户端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当服务端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉客户端，“你发的FIN报文我收到了”。只有等到我服务端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送，故需要四次挥手。</p></blockquote><p><strong>简单来说就是以下四步：</strong></p><ul><li><strong>第一次挥手：</strong> 若客户端认为数据发送完成，则它需要向服务端发送连接释放请求。</li><li><strong>第二次挥手</strong>：服务端收到连接释放请求后，会告诉应用层要释放 TCP 链接。然后会发送 ACK 包，并进入 CLOSE_WAIT 状态，此时表明客户端到服务端的连接已经释放，不再接收客户端发的数据了。但是因为 TCP 连接是双向的，所以服务端仍旧可以发送数据给客户端。</li><li><strong>第三次挥手</strong>：服务端如果此时还有没发完的数据会继续发送，完毕后会向客户端发送连接释放请求，然后服务端便进入 LAST-ACK 状态。</li><li><strong>第四次挥手：</strong> 客户端收到释放请求后，向服务端发送确认应答，此时客户端进入 TIME-WAIT 状态。该状态会持续 2MSL（最大段生存期，指报文段在网络中生存的时间，超时会被抛弃） 时间，若该时间段内没有服务端的重发请求的话，就进入 CLOSED 状态。当服务端收到确认应答后，也便进入 CLOSED 状态。</li></ul><p>TCP 使用四次挥手的原因是因为 TCP 的连接是全双工的，所以需要双方分别释放到对方的连接，单独一方的连接释放，只代 表不能再向对方发送数据，连接处于的是半释放的状态。</p><p>最后一次挥手中，客户端会等待一段时间再关闭的原因，是为了防止发送给服务器的确认报文段丢失或者出错，从而导致服务器 端不能正常关闭。</p><h3 id="10-TCP粘包是怎么回事，如何处理"><a href="#10-TCP粘包是怎么回事，如何处理" class="headerlink" title="10. TCP粘包是怎么回事，如何处理?"></a>10. TCP粘包是怎么回事，如何处理?</h3><p>默认情况下, TCP 连接会启⽤延迟传送算法 (Nagle 算法), 在数据发送之前缓存他们. 如果短时间有多个数据发送, 会缓冲到⼀起作⼀次发送 (缓冲⼤⼩⻅ socket.bufferSize ), 这样可以减少 IO 消耗提⾼性能. </p><p>如果是传输⽂件的话, 那么根本不⽤处理粘包的问题, 来⼀个包拼⼀个包就好了。但是如果是多条消息, 或者是别的⽤途的数据那么就需要处理粘包. </p><p>下面看⼀个例⼦, 连续调⽤两次 send 分别发送两段数据 data1 和 data2, 在接收端有以下⼏种常⻅的情况:<br>A. 先接收到 data1, 然后接收到 data2 .<br>B. 先接收到 data1 的部分数据, 然后接收到 data1 余下的部分以及 data2 的全部.<br>C. 先接收到了 data1 的全部数据和 data2 的部分数据, 然后接收到了 data2 的余下的数据.<br>D. ⼀次性接收到了 data1 和 data2 的全部数据. </p><p>其中的 BCD 就是我们常⻅的粘包的情况. ⽽对于处理粘包的问题, 常⻅的解决⽅案有: </p><ul><li><strong>多次发送之前间隔⼀个等待时间</strong>：只需要等上⼀段时间再进⾏下⼀次 send 就好, 适⽤于交互频率特别低的场景. 缺点也很明显, 对于⽐较频繁的场景⽽⾔传输效率实在太低，不过⼏乎不⽤做什么处理. </li><li><strong>关闭 Nagle 算法</strong>：关闭 Nagle 算法, 在 Node.js 中你可以通过 socket.setNoDelay() ⽅法来关闭 Nagle 算法, 让每⼀次 send 都不缓冲直接发送。该⽅法⽐较适⽤于每次发送的数据都⽐较⼤ (但不是⽂件那么⼤), 并且频率不是特别⾼的场景。如果是每次发送的数据量⽐较⼩, 并且频率特别⾼的, 关闭 Nagle 纯属⾃废武功。另外, 该⽅法不适⽤于⽹络较差的情况, 因为 Nagle 算法是在服务端进⾏的包合并情况, 但是如果短时间内客户端的⽹络情况不好, 或者应⽤层由于某些原因不能及时将 TCP 的数据 recv, 就会造成多个包在客户端缓冲从⽽粘包的情况。 (如果是在稳定的机房内部通信那么这个概率是⽐较⼩可以选择忽略的)  </li><li><strong>进⾏封包&#x2F;拆包：</strong> 封包&#x2F;拆包是⽬前业内常⻅的解决⽅案了。即给每个数据包在发送之前, 于其前&#x2F;后放⼀些有特征的数据, 然后收到数据的时 候根据特征数据分割出来各个数据包。</li></ul><h3 id="11-为什么udp不会粘包？"><a href="#11-为什么udp不会粘包？" class="headerlink" title="11. 为什么udp不会粘包？"></a>11. 为什么<strong>udp</strong>不会粘包？</h3><ul><li>TCP协议是⾯向流的协议，UDP是⾯向消息的协议。UDP段都是⼀条消息，应⽤程序必须以消息为单位提取数据，不能⼀次提取任意字节的数据 </li><li>UDP具有保护消息边界，在每个UDP包中就有了消息头（消息来源地址，端⼝等信息），这样对于接收端来说就容易进⾏区分处理了。传输协议把数据当作⼀条独⽴的消息在⽹上传输，接收端只能接收独⽴的消息。接收端⼀次只能接收发送端发出的⼀个数据包,如果⼀次接受数据的⼤⼩⼩于发送端⼀次发送的数据⼤⼩，就会丢失⼀部分数据，即使丢失，接受端也不会分两次去接收。</li></ul><h2 id="七、WebSocket"><a href="#七、WebSocket" class="headerlink" title="七、WebSocket"></a>七、WebSocket</h2><h3 id="1-对-WebSocket-的理解"><a href="#1-对-WebSocket-的理解" class="headerlink" title="1. 对 WebSocket 的理解"></a>1. 对 WebSocket 的理解</h3><p>WebSocket是HTML5提供的一种浏览器与服务器进行<strong>全双工通讯</strong>的网络技术，属于应用层协议。它基于TCP传输协议，并复用HTTP的握手通道。浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接， 并进行双向数据传输。</p><p>WebSocket 的出现就解决了半双工通信的弊端。它最大的特点是：<strong>服务器可以向客户端主动推动消息，客户端也可以主动向服务器推送消息。</strong></p><p><strong>WebSocket原理</strong>：客户端向 WebSocket 服务器通知（notify）一个带有所有接收者ID（recipients IDs）的事件（event），服务器接收后立即通知所有活跃的（active）客户端，只有ID在接收者ID序列中的客户端才会处理这个事件。<br>​</p><p><strong>WebSocket 特点的如下：</strong></p><ul><li>支持双向通信，实时性更强</li><li>可以发送文本，也可以发送二进制数据‘’</li><li>建立在TCP协议之上，服务端的实现比较容易</li><li>数据格式比较轻量，性能开销小，通信高效</li><li>没有同源限制，客户端可以与任意服务器通信</li><li>协议标识符是ws（如果加密，则为wss），服务器网址就是 URL</li><li>与 HTTP 协议有着良好的兼容性。默认端口也是80和443，并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器。</li></ul><p><strong>Websocket的使用方法如下：</strong><br>​</p><p>在客户端中：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 在index.html中直接写WebSocket，设置服务端的端口号为 9999</span><br><span class="hljs-keyword">let</span> ws = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WebSocket</span>(<span class="hljs-string">&#x27;ws://localhost:9999&#x27;</span>);<br><span class="hljs-comment">// 在客户端与服务端建立连接后触发</span><br>ws.<span class="hljs-property">onopen</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Connection open.&quot;</span>); <br>    ws.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;hello&#x27;</span>);<br>&#125;;<br><span class="hljs-comment">// 在服务端给客户端发来消息的时候触发</span><br>ws.<span class="hljs-property">onmessage</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">res</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res);       <span class="hljs-comment">// 打印的是MessageEvent对象</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res.<span class="hljs-property">data</span>);  <span class="hljs-comment">// 打印的是收到的消息</span><br>&#125;;<br><span class="hljs-comment">// 在客户端与服务端建立关闭后触发</span><br>ws.<span class="hljs-property">onclose</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">evt</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Connection closed.&quot;</span>);<br>&#125;; <br></code></pre></td></tr></table></figure><h3 id="2-即时通讯的实现：短轮询、长轮询、SSE-和-WebSocket-间的区别？"><a href="#2-即时通讯的实现：短轮询、长轮询、SSE-和-WebSocket-间的区别？" class="headerlink" title="2. 即时通讯的实现：短轮询、长轮询、SSE 和 WebSocket 间的区别？"></a>2. 即时通讯的实现：短轮询、长轮询、SSE 和 WebSocket 间的区别？</h3><p>短轮询和长轮询的目的都是用于实现客户端和服务器端的一个即时通讯。</p><p><strong>短轮询的基本思路：</strong> 浏览器每隔一段时间向浏览器发送 http 请求，服务器端在收到请求后，不论是否有数据更新，都直接进行响应。这种方式实现的即时通信，本质上还是浏览器发送请求，服务器接受请求的一个过程，通过让客户端不断的进行请求，使得客户端能够模拟实时地收到服务器端的数据的变化。这种方式的优点是比较简单，易于理解。缺点是这种方式由于需要不断的建立 http 连接，严重浪费了服务器端和客户端的资源。当用户增加时，服务器端的压力就会变大，这是很不合理的。</p><p><strong>长轮询的基本思路：</strong> 首先由客户端向服务器发起请求，当服务器收到客户端发来的请求后，服务器端不会直接进行响应，而是先将这个请求挂起，然后判断服务器端数据是否有更新。如果有更新，则进行响应，如果一直没有数据，则到达一定的时间限制才返回。客户端 JavaScript 响应处理函数会在处理完服务器返回的信息后，再次发出请求，重新建立连接。长轮询和短轮询比起来，它的优点是明显减少了很多不必要的 http 请求次数，相比之下节约了资源。长轮询的缺点在于，连接挂起也会导致资源的浪费。</p><p><strong>SSE 的基本思想：</strong> 服务器使用流信息向服务器推送信息。严格地说，http 协议无法做到服务器主动推送信息。但是，有一种变通方法，就是服务器向客户端声明，接下来要发送的是流信息。也就是说，发送的不是一次性的数据包，而是一个数据流，会连续不断地发送过来。这时，客户端不会关闭连接，会一直等着服务器发过来的新的数据流，视频播放就是这样的例子。SSE 就是利用这种机制，使用流信息向浏览器推送信息。它基于 http 协议，目前除了 IE&#x2F;Edge，其他浏览器都支持。它相对于前面两种方式来说，不需要建立过多的 http 请求，相比之下节约了资源。</p><p><strong>WebSocket</strong> 是 HTML5 定义的一个新协议议，与传统的 http 协议不同，该协议允许由服务器主动的向客户端推送信息。使用 WebSocket 协议的缺点是在服务器端的配置比较复杂。WebSocket 是一个全双工的协议，也就是通信双方是平等的，可以相互发送消息，而 SSE 的方式是单向通信的，只能由服务器端向客户端推送信息，如果客户端需要发送信息就是属于下一个 http 请求了。</p><p><strong>上面的四个通信协议，前三个都是基于HTTP协议的。</strong></p><p>对于这四种即使通信协议，从性能的角度来看：<br><strong>WebSocket &gt; 长连接（SEE） &gt; 长轮询 &gt; 短轮询</strong><br>但是，我们如果考虑浏览器的兼容性问题，顺序就恰恰相反了：<br><strong>短轮询 &gt; 长轮询 &gt; 长连接（SEE） &gt; WebSocket</strong><br>所以，还是要根据具体的使用场景来判断使用哪种方式。</p>]]></content>
    
    
    <categories>
      
      <category>BGW</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>BGW-React2</title>
    <link href="/2023/04/18/BGW-React2/"/>
    <url>/2023/04/18/BGW-React2/</url>
    
    <content type="html"><![CDATA[<p>BGW-React2</p><p><img src="1.png" alt="img"></p><h2 id="六、Redux"><a href="#六、Redux" class="headerlink" title="六、Redux"></a>六、Redux</h2><h3 id="1-对-Redux-的理解，主要解决什么问题"><a href="#1-对-Redux-的理解，主要解决什么问题" class="headerlink" title="1. 对 Redux 的理解，主要解决什么问题"></a>1. 对 Redux 的理解，主要解决什么问题</h3><p>React是视图层框架。Redux是一个用来管理数据状态和UI状态的JavaScript应用工具。随着JavaScript单页应用（SPA）开发日趋复杂， JavaScript需要管理比任何时候都要多的state（状态）， Redux就是降低管理难度的。（Redux支持React、Angular、jQuery甚至纯JavaScript）。</p><p>在 React 中，UI 以组件的形式来搭建，组件之间可以嵌套组合。但 React 中组件间通信的数据流是单向的，顶层组件可以通过 props 属性向下层组件传递数据，而下层组件不能向上层组件传递数据，兄弟组件之间同样不能。这样简单的单向数据流支撑起了 React 中的数据可控性。</p><p>当项目越来越大的时候，管理数据的事件或回调函数将越来越多，也将越来越不好管理。管理不断变化的 state 非常困难。如果一个 model 的变化会引起另一个 model 变化，那么当 view 变化时，就可能引起对应 model 以及另一个 model 的变化，依次地，可能会引起另一个 view 的变化。直至你搞不清楚到底发生了什么。state 在什么时候，由于什么原因，如何变化已然不受控制。 当系统变得错综复杂的时候，想重现问题或者添加新功能就会变得举步维艰。如果这还不够糟糕，考虑一些来自前端开发领域的新需求，如更新调优、服务端渲染、路由跳转前请求数据等。state 的管理在大项目中相当复杂。</p><p>Redux 提供了一个叫 store 的统一仓储库，组件通过 dispatch 将 state 直接传入store，不用通过其他的组件。并且组件通过 subscribe 从 store获取到 state 的改变。使用了 Redux，所有的组件都可以从 store 中获取到所需的 state，他们也能从store 获取到 state 的改变。这比组件之间互相传递数据清晰明朗的多。</p><p><strong>主要解决的问题：</strong><br>单纯的Redux只是一个状态机，是没有UI呈现的，react- redux作用是将Redux的状态机和React的UI呈现绑定在一起，当你dispatch action改变state的时候，会自动更新页面。</p><h3 id="2-Redux-原理及工作流程"><a href="#2-Redux-原理及工作流程" class="headerlink" title="2. Redux 原理及工作流程"></a>2. Redux 原理及工作流程</h3><p><strong>（1）原理</strong><br>Redux源码主要分为以下几个模块文件</p><ul><li>compose.js 提供从右到左进行函数式编程</li><li>createStore.js 提供作为生成唯一store的函数</li><li>combineReducers.js 提供合并多个reducer的函数，保证store的唯一性</li><li>bindActionCreators.js 可以让开发者在不直接接触dispacth的前提下进行更改state的操作</li><li>applyMiddleware.js 这个方法通过中间件来增强dispatch的功能</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> actionTypes = &#123;<br>    <span class="hljs-attr">ADD</span>: <span class="hljs-string">&#x27;ADD&#x27;</span>,<br>    <span class="hljs-attr">CHANGEINFO</span>: <span class="hljs-string">&#x27;CHANGEINFO&#x27;</span>,<br>&#125;<br><br><span class="hljs-keyword">const</span> initState = &#123;<br>    <span class="hljs-attr">info</span>: <span class="hljs-string">&#x27;初始化&#x27;</span>,<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">initReducer</span>(<span class="hljs-params">state=initState, action</span>) &#123;<br>    <span class="hljs-keyword">switch</span>(action.<span class="hljs-property">type</span>) &#123;<br>        <span class="hljs-keyword">case</span> actionTypes.<span class="hljs-property">CHANGEINFO</span>:<br>            <span class="hljs-keyword">return</span> &#123;<br>                ...state,<br>                <span class="hljs-attr">info</span>: action.<span class="hljs-property">preload</span>.<span class="hljs-property">info</span> || <span class="hljs-string">&#x27;&#x27;</span>,<br>            &#125;<br>        <span class="hljs-attr">default</span>:<br>            <span class="hljs-keyword">return</span> &#123; ...state &#125;;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">createStore</span>(<span class="hljs-params">reducer, initialState, middleFunc</span>) &#123;<br><br>    <span class="hljs-keyword">if</span> (initialState &amp;&amp; <span class="hljs-keyword">typeof</span> initialState === <span class="hljs-string">&#x27;function&#x27;</span>) &#123;<br>        middleFunc = initialState;<br>        initialState = <span class="hljs-literal">undefined</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">let</span> currentState = initialState;<br><br>    <span class="hljs-keyword">const</span> listeners = [];<br><br>    <span class="hljs-keyword">if</span> (middleFunc &amp;&amp; <span class="hljs-keyword">typeof</span> middleFunc === <span class="hljs-string">&#x27;function&#x27;</span>) &#123;<br>        <span class="hljs-comment">// 封装dispatch </span><br>        <span class="hljs-keyword">return</span> <span class="hljs-title function_">middleFunc</span>(createStore)(reducer, initialState);<br>    &#125;<br><br>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">getState</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>        <span class="hljs-keyword">return</span> currentState;<br>    &#125;<br><br>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">dispatch</span> = (<span class="hljs-params">action</span>) =&gt; &#123;<br>        currentState = <span class="hljs-title function_">reducer</span>(currentState, action);<br><br>        listeners.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">listener</span> =&gt;</span> &#123;<br>            <span class="hljs-title function_">listener</span>();<br>        &#125;)<br>    &#125;<br><br>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">subscribe</span> = (<span class="hljs-params">listener</span>) =&gt; &#123;<br>        listeners.<span class="hljs-title function_">push</span>(listener);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> &#123;<br>        getState,<br>        dispatch,<br>        subscribe<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>（2）工作流程</strong></p><ul><li>const store&#x3D; createStore（fn）生成数据; </li><li>action: {type: Symble(‘action01), payload:’payload’ }定义行为; </li><li>dispatch发起action：store.dispatch(doSomething(‘action001’)); </li><li>reducer：处理action，返回新的state;</li></ul><p>通俗点解释：</p><ul><li>首先，用户（通过View）发出Action，发出方式就用到了dispatch方法</li><li>然后，Store自动调用Reducer，并且传入两个参数：当前State和收到的Action，Reducer会返回新的State</li><li>State—旦有变化，Store就会调用监听函数，来更新View</li></ul><p>以 store 为核心，可以把它看成数据存储中心，但是他要更改数据的时候不能直接修改，数据修改更新的角色由Reducers来担任，store只做存储，中间人，当Reducers的更新完成以后会通过store的订阅来通知react component，组件把新的状态重新获取渲染，组件中也能主动发送action，创建action后这个动作是不会执行的，所以要dispatch这个action，让store通过reducers去做更新React Component 就是react的每个组件。</p><h3 id="3-Redux-中异步的请求怎么处理"><a href="#3-Redux-中异步的请求怎么处理" class="headerlink" title="3. Redux 中异步的请求怎么处理"></a>3. Redux 中异步的请求怎么处理</h3><p>可以在 componentDidmount 中直接进⾏请求⽆须借助redux。但是在⼀定规模的项⽬中,上述⽅法很难进⾏异步流的管理,通常情况下我们会借助redux的异步中间件进⾏异步处理。redux异步流中间件其实有很多，当下主流的异步中间件有两种redux-thunk、redux-saga。</p><p><strong>（1）使用react-thunk中间件</strong></p><p><strong>redux-thunk</strong>优点: </p><ul><li>体积⼩: redux-thunk的实现⽅式很简单,只有不到20⾏代码 </li><li>使⽤简单: redux-thunk没有引⼊像redux-saga或者redux-observable额外的范式,上⼿简单</li></ul><p><strong>redux-thunk</strong>缺陷: </p><ul><li>样板代码过多: 与redux本身⼀样,通常⼀个请求需要⼤量的代码,⽽且很多都是重复性质的 </li><li>耦合严重: 异步操作与redux的action偶合在⼀起,不⽅便管理 </li><li>功能孱弱: 有⼀些实际开发中常⽤的功能需要⾃⼰进⾏封装</li></ul><p>使用步骤：</p><ul><li>配置中间件，在store的创建中配置</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123;createStore, applyMiddleware, compose&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;redux&#x27;</span>;<br><span class="hljs-keyword">import</span> reducer <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./reducer&#x27;</span>;<br><span class="hljs-keyword">import</span> thunk <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;redux-thunk&#x27;</span><br><br><span class="hljs-comment">// 设置调试工具</span><br><span class="hljs-keyword">const</span> composeEnhancers = <span class="hljs-variable language_">window</span>.<span class="hljs-property">__REDUX_DEVTOOLS_EXTENSION_COMPOSE__</span> ? <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">__REDUX_DEVTOOLS_EXTENSION_COMPOSE__</span>(&#123;&#125;) : compose;<br><span class="hljs-comment">// 设置中间件</span><br><span class="hljs-keyword">const</span> enhancer = <span class="hljs-title function_">composeEnhancers</span>(<br>  <span class="hljs-title function_">applyMiddleware</span>(thunk)<br>);<br><br><span class="hljs-keyword">const</span> store = <span class="hljs-title function_">createStore</span>(reducer, enhancer);<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> store;<br></code></pre></td></tr></table></figure><ul><li>添加一个返回函数的actionCreator，将异步请求逻辑放在里面</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment">  发送get请求，并生成相应action，更新store的函数</span><br><span class="hljs-comment">  <span class="hljs-doctag">@param</span> url &#123;string&#125; 请求地址</span><br><span class="hljs-comment">  <span class="hljs-doctag">@param</span> func &#123;function&#125; 真正需要生成的action对应的actionCreator</span><br><span class="hljs-comment">  <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">function</span>&#125; </span><br><span class="hljs-comment">*/</span><br><span class="hljs-comment">// dispatch为自动接收的store.dispatch函数 </span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">getHttpAction</span> = (<span class="hljs-params">url, func</span>) =&gt; <span class="hljs-function">(<span class="hljs-params">dispatch</span>) =&gt;</span> &#123;<br>    axios.<span class="hljs-title function_">get</span>(url).<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">res</span>)&#123;<br>        <span class="hljs-keyword">const</span> action = <span class="hljs-title function_">func</span>(res.<span class="hljs-property">data</span>)<br>        <span class="hljs-title function_">dispatch</span>(action)<br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>生成action，并发送action</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">componentDidMount</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">var</span> action = <span class="hljs-title function_">getHttpAction</span>(<span class="hljs-string">&#x27;/getData&#x27;</span>, getInitTodoItemAction)<br>    <span class="hljs-comment">// 发送函数类型的action时，该action的函数体会自动执行</span><br>    store.<span class="hljs-title function_">dispatch</span>(action)<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>（2）使用redux-saga中间件</strong></p><p><strong>redux-saga</strong>优点: </p><ul><li>异步解耦: 异步操作被被转移到单独 saga.js 中，不再是掺杂在 action.js 或 component.js 中 </li><li>action摆脱thunk function: dispatch 的参数依然是⼀个纯粹的 action (FSA)，⽽不是充满 “⿊魔法” thunk function </li><li>异常处理: 受益于 generator function 的 saga 实现，代码异常&#x2F;请求失败 都可以直接通过 try&#x2F;catch 语法直接捕获处理</li><li>功能强⼤: redux-saga提供了⼤量的Saga 辅助函数和Effect 创建器供开发者使⽤,开发者⽆须封装或者简单封装即可使⽤ </li><li>灵活: redux-saga可以将多个Saga可以串⾏&#x2F;并⾏组合起来,形成⼀个⾮常实⽤的异步flow </li><li>易测试，提供了各种case的测试⽅案，包括mock task，分⽀覆盖等等</li></ul><p><strong>redux-saga</strong>缺陷: </p><ul><li>额外的学习成本: redux-saga不仅在使⽤难以理解的 generator function,⽽且有数⼗个API,学习成本远超redux-thunk,最重要的是你的额外学习成本是只服务于这个库的,与redux-observable不同,redux-observable虽然也有额外学习成本但是背后是rxjs和⼀整套思想 </li><li>体积庞⼤: 体积略⼤,代码近2000⾏，min版25KB左右 </li><li>功能过剩: 实际上并发控制等功能很难⽤到,但是我们依然需要引⼊这些代码 </li><li>ts⽀持不友好: yield⽆法返回TS类型</li></ul><p>redux-saga可以捕获action，然后执行一个函数，那么可以把异步代码放在这个函数中，使用步骤如下：</p><ul><li>配置中间件</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123;createStore, applyMiddleware, compose&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;redux&#x27;</span>;<br><span class="hljs-keyword">import</span> reducer <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./reducer&#x27;</span>;<br><span class="hljs-keyword">import</span> createSagaMiddleware <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;redux-saga&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">TodoListSaga</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./sagas&#x27;</span><br><br><span class="hljs-keyword">const</span> composeEnhancers = <span class="hljs-variable language_">window</span>.<span class="hljs-property">__REDUX_DEVTOOLS_EXTENSION_COMPOSE__</span> ? <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">__REDUX_DEVTOOLS_EXTENSION_COMPOSE__</span>(&#123;&#125;) : compose;<br><span class="hljs-keyword">const</span> sagaMiddleware = <span class="hljs-title function_">createSagaMiddleware</span>()<br><br><span class="hljs-keyword">const</span> enhancer = <span class="hljs-title function_">composeEnhancers</span>(<br>  <span class="hljs-title function_">applyMiddleware</span>(sagaMiddleware)<br>);<br><br><span class="hljs-keyword">const</span> store = <span class="hljs-title function_">createStore</span>(reducer, enhancer);<br>sagaMiddleware.<span class="hljs-title function_">run</span>(<span class="hljs-title class_">TodoListSaga</span>)<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> store;<br></code></pre></td></tr></table></figure><ul><li>将异步请求放在sagas.js中</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123;takeEvery, put&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;redux-saga/effects&#x27;</span><br><span class="hljs-keyword">import</span> &#123;initTodoList&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./actionCreator&#x27;</span><br><span class="hljs-keyword">import</span> &#123;<span class="hljs-variable constant_">GET_INIT_ITEM</span>&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./actionTypes&#x27;</span><br><span class="hljs-keyword">import</span> axios <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;axios&#x27;</span><br><br><span class="hljs-keyword">function</span>* <span class="hljs-title function_">func</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">try</span>&#123;<br>        <span class="hljs-comment">// 可以获取异步返回数据</span><br>        <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">yield</span> axios.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/getData&#x27;</span>)<br>        <span class="hljs-keyword">const</span> action = <span class="hljs-title function_">initTodoList</span>(res.<span class="hljs-property">data</span>)<br>        <span class="hljs-comment">// 将action发送到reducer</span><br>        <span class="hljs-keyword">yield</span> <span class="hljs-title function_">put</span>(action)<br>    &#125;<span class="hljs-keyword">catch</span>(e)&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;网络请求失败&#x27;</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">function</span>* <span class="hljs-title function_">mySaga</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-comment">// 自动捕获GET_INIT_ITEM类型的action，并执行func</span><br>    <span class="hljs-keyword">yield</span> <span class="hljs-title function_">takeEvery</span>(<span class="hljs-variable constant_">GET_INIT_ITEM</span>, func)<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> mySaga<br></code></pre></td></tr></table></figure><ul><li>发送action</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">componentDidMount</span>(<span class="hljs-params"></span>)&#123;<br>  <span class="hljs-keyword">const</span> action = <span class="hljs-title function_">getInitTodoItemAction</span>()<br>  store.<span class="hljs-title function_">dispatch</span>(action)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-Redux-怎么实现属性传递，介绍下原理"><a href="#4-Redux-怎么实现属性传递，介绍下原理" class="headerlink" title="4. Redux 怎么实现属性传递，介绍下原理"></a>4. Redux 怎么实现属性传递，介绍下原理</h3><p>react-redux 数据传输∶ view–&gt;action–&gt;reducer–&gt;store–&gt;view。看下点击事件的数据是如何通过redux传到view上：</p><ul><li>view 上的AddClick 事件通过mapDispatchToProps 把数据传到action —&gt; click:()&#x3D;&gt;dispatch(ADD)</li><li>action 的ADD 传到reducer上</li><li>reducer传到store上 const store &#x3D; createStore(reducer);</li><li>store再通过 mapStateToProps 映射穿到view上text:State.text</li></ul><p>代码示例∶</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-title class_">ReactDOM</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-dom&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123; createStore &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;redux&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">Provider</span>, connect &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-redux&#x27;</span>;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span>&#123;<br>    <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-keyword">let</span> &#123; text, click, clickR &#125; = <span class="hljs-variable language_">this</span>.<span class="hljs-property">props</span>;<br>        <span class="hljs-keyword">return</span>(<br>            <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">                <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>数据:已有人&#123;text&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">                <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;click&#125;</span>&gt;</span>加人<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">                <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;clickR&#125;</span>&gt;</span>减人<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>        )<br>    &#125;<br>&#125;<br><span class="hljs-keyword">const</span> initialState = &#123;<br>    <span class="hljs-attr">text</span>:<span class="hljs-number">5</span><br>&#125;<br><span class="hljs-keyword">const</span> reducer = <span class="hljs-keyword">function</span>(<span class="hljs-params">state,action</span>)&#123;<br>    <span class="hljs-keyword">switch</span>(action.<span class="hljs-property">type</span>)&#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;ADD&#x27;</span>:<br>            <span class="hljs-keyword">return</span> &#123;<span class="hljs-attr">text</span>:state.<span class="hljs-property">text</span>+<span class="hljs-number">1</span>&#125;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;REMOVE&#x27;</span>:<br>            <span class="hljs-keyword">return</span> &#123;<span class="hljs-attr">text</span>:state.<span class="hljs-property">text</span>-<span class="hljs-number">1</span>&#125;<br>        <span class="hljs-attr">default</span>:<br>            <span class="hljs-keyword">return</span> initialState;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> <span class="hljs-variable constant_">ADD</span> = &#123;<br>    <span class="hljs-attr">type</span>:<span class="hljs-string">&#x27;ADD&#x27;</span><br>&#125;<br><span class="hljs-keyword">let</span> <span class="hljs-title class_">Remove</span> = &#123;<br>    <span class="hljs-attr">type</span>:<span class="hljs-string">&#x27;REMOVE&#x27;</span><br>&#125;<br><br><span class="hljs-keyword">const</span> store = <span class="hljs-title function_">createStore</span>(reducer);<br><br><span class="hljs-keyword">let</span> mapStateToProps = <span class="hljs-keyword">function</span> (<span class="hljs-params">state</span>)&#123;<br>    <span class="hljs-keyword">return</span>&#123;<br>        <span class="hljs-attr">text</span>:state.<span class="hljs-property">text</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> mapDispatchToProps = <span class="hljs-keyword">function</span>(<span class="hljs-params">dispatch</span>)&#123;<br>    <span class="hljs-keyword">return</span>&#123;<br>        <span class="hljs-attr">click</span>:<span class="hljs-function">()=&gt;</span><span class="hljs-title function_">dispatch</span>(<span class="hljs-variable constant_">ADD</span>),<br>        <span class="hljs-attr">clickR</span>:<span class="hljs-function">()=&gt;</span><span class="hljs-title function_">dispatch</span>(<span class="hljs-title class_">Remove</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">App1</span> = <span class="hljs-title function_">connect</span>(mapStateToProps,mapDispatchToProps)(<span class="hljs-title class_">App</span>);<br><br><span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">render</span>(<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Provider</span> <span class="hljs-attr">store</span> = <span class="hljs-string">&#123;store&#125;</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">App1</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">App1</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">Provider</span>&gt;</span></span>,<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;root&#x27;</span>)<br>)<br></code></pre></td></tr></table></figure><h3 id="5-Redux-中间件是什么？接受几个参数？柯里化函数两端的参数具体是什么？"><a href="#5-Redux-中间件是什么？接受几个参数？柯里化函数两端的参数具体是什么？" class="headerlink" title="5. Redux 中间件是什么？接受几个参数？柯里化函数两端的参数具体是什么？"></a>5. Redux 中间件是什么？接受几个参数？柯里化函数两端的参数具体是什么？</h3><p>Redux 的中间件提供的是位于 action 被发起之后，到达 reducer 之前的扩展点，换而言之，原本 view -→&gt; action -&gt; reducer -&gt; store 的数据流加上中间件后变成了 view -&gt; action -&gt; middleware -&gt; reducer -&gt; store ，在这一环节可以做一些”副作用”的操作，如异步请求、打印日志等。</p><p>applyMiddleware源码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">applyMiddleware</span>(<span class="hljs-params">...middlewares</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-params">createStore</span> =&gt;</span> <span class="hljs-function">(<span class="hljs-params">...args</span>) =&gt;</span> &#123;<br>        <span class="hljs-comment">// 利用传入的createStore和reducer和创建一个store</span><br>        <span class="hljs-keyword">const</span> store = <span class="hljs-title function_">createStore</span>(...args)<br>        <span class="hljs-keyword">let</span> <span class="hljs-title function_">dispatch</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>()<br>        &#125;<br>        <span class="hljs-keyword">const</span> middlewareAPI = &#123;<br>            <span class="hljs-attr">getState</span>: store.<span class="hljs-property">getState</span>,<br>            <span class="hljs-attr">dispatch</span>: <span class="hljs-function">(<span class="hljs-params">...args</span>) =&gt;</span> <span class="hljs-title function_">dispatch</span>(...args)<br>        &#125;<br>        <span class="hljs-comment">// 让每个 middleware 带着 middlewareAPI 这个参数分别执行一遍</span><br>        <span class="hljs-keyword">const</span> chain = middlewares.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">middleware</span> =&gt;</span> <span class="hljs-title function_">middleware</span>(middlewareAPI))<br>        <span class="hljs-comment">// 接着 compose 将 chain 中的所有匿名函数，组装成一个新的函数，即新的 dispatch</span><br>        dispatch = <span class="hljs-title function_">compose</span>(...chain)(store.<span class="hljs-property">dispatch</span>)<br>        <span class="hljs-keyword">return</span> &#123;<br>            ...store,<br>            dispatch<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>从applyMiddleware中可以看出∶</p><ul><li>redux中间件接受一个对象作为参数，对象的参数上有两个字段 dispatch 和 getState，分别代表着 Redux Store 上的两个同名函数。</li><li>柯里化函数两端一个是 middewares，一个是store.dispatch</li></ul><h3 id="6-Redux-请求中间件如何处理并发"><a href="#6-Redux-请求中间件如何处理并发" class="headerlink" title="6. Redux 请求中间件如何处理并发"></a>6. Redux 请求中间件如何处理并发</h3><p><strong>使用redux-Saga</strong><br>redux-saga是一个管理redux应用异步操作的中间件，用于代替 redux-thunk 的。它通过创建 Sagas 将所有异步操作逻辑存放在一个地方进行集中处理，以此将react中的同步操作与异步操作区分开来，以便于后期的管理与维护。 redux-saga如何处理并发：</p><ul><li><strong>takeEvery</strong></li></ul><p>可以让多个 saga 任务并行被 fork 执行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123;<br>    fork,<br>    take<br>&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;redux-saga/effects&quot;</span><br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">takeEvery</span> = (<span class="hljs-params">pattern, saga, ...args</span>) =&gt; <span class="hljs-title function_">fork</span>(<span class="hljs-keyword">function</span>*() &#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>        <span class="hljs-keyword">const</span> action = <span class="hljs-keyword">yield</span> <span class="hljs-title function_">take</span>(pattern)<br>        <span class="hljs-keyword">yield</span> <span class="hljs-title function_">fork</span>(saga, ...args.<span class="hljs-title function_">concat</span>(action))<br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><ul><li><strong>takeLatest</strong></li></ul><p>takeLatest 不允许多个 saga 任务并行地执行。一旦接收到新的发起的 action，它就会取消前面所有 fork 过的任务（如果这些任务还在执行的话）。<br>在处理 AJAX 请求的时候，如果只希望获取最后那个请求的响应， takeLatest 就会非常有用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123;<br>    cancel,<br>    fork,<br>    take<br>&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;redux-saga/effects&quot;</span><br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">takeLatest</span> = (<span class="hljs-params">pattern, saga, ...args</span>) =&gt; <span class="hljs-title function_">fork</span>(<span class="hljs-keyword">function</span>*() &#123;<br>    <span class="hljs-keyword">let</span> lastTask<br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>        <span class="hljs-keyword">const</span> action = <span class="hljs-keyword">yield</span> <span class="hljs-title function_">take</span>(pattern)<br>        <span class="hljs-keyword">if</span> (lastTask) &#123;<br>            <span class="hljs-keyword">yield</span> <span class="hljs-title function_">cancel</span>(lastTask) <span class="hljs-comment">// 如果任务已经结束，则 cancel 为空操作</span><br>        &#125;<br>        lastTask = <span class="hljs-keyword">yield</span> <span class="hljs-title function_">fork</span>(saga, ...args.<span class="hljs-title function_">concat</span>(action))<br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="7-Redux-状态管理器和变量挂载到-window-中有什么区别"><a href="#7-Redux-状态管理器和变量挂载到-window-中有什么区别" class="headerlink" title="7. Redux 状态管理器和变量挂载到 window 中有什么区别"></a>7. Redux 状态管理器和变量挂载到 window 中有什么区别</h3><p>两者都是存储数据以供后期使用。但是Redux状态更改可回溯——Time travel，数据多了的时候可以很清晰的知道改动在哪里发生，完整的提供了一套状态管理模式。</p><p>随着 JavaScript 单页应用开发日趋复杂，JavaScript 需要管理比任何时候都要多的 state （状态）。 这些 state 可能包括服务器响应、缓存数据、本地生成尚未持久化到服务器的数据，也包括 UI状态，如激活的路由，被选中的标签，是否显示加载动效或者分页器等等。</p><p>管理不断变化的 state 非常困难。如果一个 model 的变化会引起另一个 model 变化，那么当 view 变化时，就可能引起对应 model 以及另一个model 的变化，依次地，可能会引起另一个 view 的变化。直至你搞不清楚到底发生了什么。state 在什么时候，由于什么原因，如何变化已然不受控制。 当系统变得错综复杂的时候，想重现问题或者添加新功能就会变得举步维艰。<br>如果这还不够糟糕，考虑一些来自前端开发领域的新需求，如更新调优、服务端渲染、路由跳转前请求数据等等。前端开发者正在经受前所未有的复杂性，难道就这么放弃了吗?当然不是。</p><p>这里的复杂性很大程度上来自于：我们总是将两个难以理清的概念混淆在一起：变化和异步。 可以称它们为曼妥思和可乐。如果把二者分开，能做的很好，但混到一起，就变得一团糟。一些库如 React 视图在视图层禁止异步和直接操作 DOM来解决这个问题。美中不足的是，React 依旧把处理 state 中数据的问题留给了你。Redux就是为了帮你解决这个问题。</p><h3 id="8-mobox-和-redux-有什么区别？"><a href="#8-mobox-和-redux-有什么区别？" class="headerlink" title="8. mobox 和 redux 有什么区别？"></a>8. mobox 和 redux 有什么区别？</h3><p><strong>（1）共同点</strong></p><ul><li>为了解决状态管理混乱，无法有效同步的问题统一维护管理应用状态;</li><li>某一状态只有一个可信数据来源（通常命名为store，指状态容器）;</li><li>操作更新状态方式统一，并且可控（通常以action方式提供更新状态的途径）;</li><li>支持将store与React组件连接，如react-redux，mobx- react;</li></ul><p><strong>（2）区别</strong><br>Redux更多的是遵循Flux模式的一种实现，是一个 JavaScript库，它关注点主要是以下几方面∶ </p><ul><li><p>Action∶ 一个JavaScript对象，描述动作相关信息，主要包含type属性和payload属性∶ </p><pre><code class="hljs">o type∶ action 类型; o payload∶ 负载数据;</code></pre></li><li><p>Reducer∶ 定义应用状态如何响应不同动作（action），如何更新状态;</p></li><li><p>Store∶ 管理action和reducer及其关系的对象，主要提供以下功能∶ </p><pre><code class="hljs">o 维护应用状态并支持访问状态(getState());o 支持监听action的分发，更新状态(dispatch(action)); o 支持订阅store的变更(subscribe(listener));</code></pre></li><li><p>异步流∶ 由于Redux所有对store状态的变更，都应该通过action触发，异步任务（通常都是业务或获取数据任务）也不例外，而为了不将业务或数据相关的任务混入React组件中，就需要使用其他框架配合管理异步任务流程，如redux-thunk，redux-saga等;</p></li></ul><p>Mobx是一个透明函数响应式编程的状态管理库，它使得状态管理简单可伸缩∶</p><ul><li>Action∶定义改变状态的动作函数，包括如何变更状态;</li><li>Store∶ 集中管理模块状态（State）和动作(action)</li><li>Derivation（衍生）∶ 从应用状态中派生而出，且没有任何其他影响的数据</li></ul><p><strong>对比总结：</strong></p><ul><li>redux将数据保存在单一的store中，mobx将数据保存在分散的多个store中</li><li>redux使用plain object保存数据，需要手动处理变化后的操作;mobx适用observable保存数据，数据变化后自动处理响应的操作</li><li>redux使用不可变状态，这意味着状态是只读的，不能直接去修改它，而是应该返回一个新的状态，同时使用纯函数;mobx中的状态是可变的，可以直接对其进行修改</li><li>mobx相对来说比较简单，在其中有很多的抽象，mobx更多的使用面向对象的编程思维;redux会比较复杂，因为其中的函数式编程思想掌握起来不是那么容易，同时需要借助一系列的中间件来处理异步和副作用</li><li>mobx中有更多的抽象和封装，调试会比较困难，同时结果也难以预测;而redux提供能够进行时间回溯的开发工具，同时其纯函数以及更少的抽象，让调试变得更加的容易</li></ul><h3 id="9-Redux-和-Vuex-有什么区别，它们的共同思想"><a href="#9-Redux-和-Vuex-有什么区别，它们的共同思想" class="headerlink" title="9. Redux 和 Vuex 有什么区别，它们的共同思想"></a>9. Redux 和 Vuex 有什么区别，它们的共同思想</h3><p><strong>（1）Redux 和 Vuex区别</strong></p><ul><li>Vuex改进了Redux中的Action和Reducer函数，以mutations变化函数取代Reducer，无需switch，只需在对应的mutation函数里改变state值即可</li><li>Vuex由于Vue自动重新渲染的特性，无需订阅重新渲染函数，只要生成新的State即可</li><li>Vuex数据流的顺序是∶View调用store.commit提交对应的请求到Store中对应的mutation函数-&gt;store改变（vue检测到数据变化自动渲染）</li></ul><p>通俗点理解就是，vuex 弱化 dispatch，通过commit进行 store状态的一次更变；取消了action概念，不必传入特定的 action形式进行指定变更；弱化reducer，基于commit参数直接对数据进行转变，使得框架更加简易; </p><p><strong>（2）共同思想</strong></p><ul><li>单—的数据源 </li><li>变化可以预测</li></ul><p>本质上∶ redux与vuex都是对mvvm思想的服务，将数据从视图中抽离的一种方案。</p><h3 id="10-Redux-中间件是怎么拿到store-和-action-然后怎么处理"><a href="#10-Redux-中间件是怎么拿到store-和-action-然后怎么处理" class="headerlink" title="10. Redux 中间件是怎么拿到store 和 action? 然后怎么处理?"></a>10. Redux 中间件是怎么拿到store 和 action? 然后怎么处理?</h3><p>redux中间件本质就是一个函数柯里化。redux applyMiddleware Api 源码中每个middleware 接受2个参数， Store 的getState 函数和dispatch 函数，分别获得store和action，最终返回一个函数。该函数会被传入 next 的下一个 middleware 的 dispatch 方法，并返回一个接收 action 的新函数，这个函数可以直接调用 next（action），或者在其他需要的时刻调用，甚至根本不去调用它。调用链中最后一个 middleware 会接受真实的 store的 dispatch 方法作为 next 参数，并借此结束调用链。所以，middleware 的函数签名是（{ getState，dispatch })&#x3D;&gt; next &#x3D;&gt; action。</p><h3 id="11-Redux中的connect有什么作用"><a href="#11-Redux中的connect有什么作用" class="headerlink" title="11. Redux中的connect有什么作用"></a>11. Redux中的connect有什么作用</h3><p>connect负责连接React和Redux</p><p><strong>（1）获取state</strong></p><p>connect 通过 context获取 Provider 中的 store，通过<code> store.getState()</code> 获取整个store tree 上所有state </p><p><strong>（2）包装原组件</strong></p><p>将state和action通过props的方式传入到原组件内部 wrapWithConnect 返回—个 ReactComponent 对 象 Connect，Connect 重 新 render 外部传入的原组件 WrappedComponent ，并把 connect 中传入的 mapStateToProps，mapDispatchToProps与组件上原有的 props合并后，通过属性的方式传给WrappedComponent </p><p><strong>（3）监听store tree变化</strong></p><p>connect缓存了store tree中state的状态，通过当前state状态 和变更前 state 状态进行比较，从而确定是否调用 <code>this.setState()</code>方法触发Connect及其子组件的重新渲染</p><h2 id="七、Hooks"><a href="#七、Hooks" class="headerlink" title="七、Hooks"></a>七、Hooks</h2><h3 id="1-对-React-Hook-的理解，它的实现原理是什么"><a href="#1-对-React-Hook-的理解，它的实现原理是什么" class="headerlink" title="1. 对 React Hook 的理解，它的实现原理是什么"></a>1. 对 React Hook 的理解，它的实现原理是什么</h3><p>React-Hooks 是 React 团队在 React 组件开发实践中，逐渐认知到的一个改进点，这背后其实涉及对<strong>类组件</strong>和<strong>函数组件</strong>两种组件形式的思考和侧重。</p><p><strong>（1）类组件：</strong> 所谓类组件，就是基于 ES6 Class 这种写法，通过继承 React.Component 得来的 React 组件。以下是一个类组件：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">DemoClass</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;<br>  state = &#123;<br>    <span class="hljs-attr">text</span>: <span class="hljs-string">&quot;&quot;</span><br>  &#125;;<br>  <span class="hljs-title function_">componentDidMount</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">//...</span><br>  &#125;<br>  changeText = <span class="hljs-function">(<span class="hljs-params">newText</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123;<br>      <span class="hljs-attr">text</span>: newText<br>    &#125;);<br>  &#125;;<br><br>  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> (<br>      <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;demoClass&quot;</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>&#123;this.state.text&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;this.changeText&#125;</span>&gt;</span>修改<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>    );<br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>可以看出，React 类组件内部预置了相当多的“现成的东西”等着我们去调度&#x2F;定制，state 和生命周期就是这些“现成东西”中的典型。要想得到这些东西，难度也不大，只需要继承一个 React.Component 即可。</p><p>当然，这也是类组件的一个不便，它太繁杂了，对于解决许多问题来说，编写一个类组件实在是一个过于复杂的姿势。复杂的姿势必然带来高昂的理解成本，这也是我们所不想看到的。除此之外，由于开发者编写的逻辑在封装后是和组件粘在一起的，这就使得<strong>类组件内部的逻辑难以实现拆分和复用。</strong></p><p><strong>（2）函数组件</strong>：函数组件就是以函数的形态存在的 React 组件。早期并没有 React-Hooks，函数组件内部无法定义和维护 state，因此它还有一个别名叫“无状态组件”。以下是一个函数组件：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">DemoFunction</span>(<span class="hljs-params">props</span>) &#123;<br>  <span class="hljs-keyword">const</span> &#123; text &#125; = props<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;demoFunction&quot;</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>&#123;`函数组件接收的内容：[$&#123;text&#125;]`&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><p>相比于类组件，函数组件肉眼可见的特质自然包括轻量、灵活、易于组织和维护、较低的学习成本等。</p><p>通过对比，从形态上可以对两种组件做区分，它们之间的区别如下：</p><ul><li>类组件需要继承 class，函数组件不需要；</li><li>类组件可以访问生命周期方法，函数组件不能；</li><li>类组件中可以获取到实例化后的 this，并基于这个 this 做各种各样的事情，而函数组件不可以；</li><li>类组件中可以定义并维护 state（状态），而函数组件不可以；</li></ul><p>除此之外，还有一些其他的不同。通过上面的区别，我们不能说谁好谁坏，它们各有自己的优势。在 React-Hooks 出现之前，<strong>类组件的能力边界明显强于函数组件。</strong></p><p>实际上，类组件和函数组件之间，是面向对象和函数式编程这两套不同的设计思想之间的差异。而函数组件更加契合 React 框架的设计理念：<br><img src="2.png" alt="img"><br>React 组件本身的定位就是函数，一个输入数据、输出 UI 的函数。作为开发者，我们编写的是声明式的代码，而 React 框架的主要工作，就是及时地把声明式的代码转换为命令式的 DOM 操作，把数据层面的描述映射到用户可见的 UI 变化中去。这就意味着从原则上来讲，React 的数据应该总是紧紧地和渲染绑定在一起的，而类组件做不到这一点。<strong>函数组件就真正地将数据和渲染绑定到了一起。函数组件是一个更加匹配其设计理念、也更有利于逻辑拆分与重用的组件表达形式。</strong></p><p>为了能让开发者更好的的去编写函数式组件。于是，React-Hooks 便应运而生。</p><p>React-Hooks 是一套能够使函数组件更强大、更灵活的“钩子”。</p><p>函数组件比起类组件少了很多东西，比如生命周期、对 state 的管理等。这就给函数组件的使用带来了非常多的局限性，导致我们并不能使用函数这种形式，写出一个真正的全功能的组件。而React-Hooks 的出现，就是为了帮助函数组件补齐这些（相对于类组件来说）缺失的能力。</p><p>如果说函数组件是一台轻巧的快艇，那么 React-Hooks 就是一个内容丰富的零部件箱。“重装战舰”所预置的那些设备，这个箱子里基本全都有，同时它还不强制你全都要，而是允许你自由地选择和使用你需要的那些能力，然后将这些能力以 Hook（钩子）的形式“钩”进你的组件里，从而定制出一个最适合你的“专属战舰”。</p><h3 id="2-为什么-useState-要使用数组而不是对象"><a href="#2-为什么-useState-要使用数组而不是对象" class="headerlink" title="2. 为什么 useState 要使用数组而不是对象"></a>2. 为什么 useState 要使用数组而不是对象</h3><p>useState 的用法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> [count, setCount] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><p>可以看到 useState 返回的是一个数组，那么为什么是返回数组而不是返回对象呢？</p><p>这里用到了解构赋值，所以先来看一下ES6 的解构赋值：</p><h5 id="数组的解构赋值"><a href="#数组的解构赋值" class="headerlink" title="数组的解构赋值"></a>数组的解构赋值</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> foo = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><span class="hljs-keyword">const</span> [one, two, three] = foo;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(one);<span class="hljs-comment">// 1</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(two);<span class="hljs-comment">// 2</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(three);<span class="hljs-comment">// 3</span><br></code></pre></td></tr></table></figure><h5 id="对象的解构赋值"><a href="#对象的解构赋值" class="headerlink" title="对象的解构赋值"></a>对象的解构赋值</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> user = &#123;<br>  <span class="hljs-attr">id</span>: <span class="hljs-number">888</span>,<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;xiaoxin&quot;</span><br>&#125;;<br><span class="hljs-keyword">const</span> &#123; id, name &#125; = user;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(id);<span class="hljs-comment">// 888</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(name);<span class="hljs-comment">// &quot;xiaoxin&quot;</span><br></code></pre></td></tr></table></figure><p>看完这两个例子，答案应该就出来了：</p><ul><li>如果 useState 返回的是数组，那么使用者可以对数组中的元素命名，代码看起来也比较干净</li><li>如果 useState 返回的是对象，在解构对象的时候必须要和 useState 内部实现返回的对象同名，想要使用多次的话，必须得设置别名才能使用返回值</li></ul><p>下面来看看如果 useState 返回对象的情况：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 第一次使用</span><br><span class="hljs-keyword">const</span> &#123; state, setState &#125; = <span class="hljs-title function_">useState</span>(<span class="hljs-literal">false</span>);<br><span class="hljs-comment">// 第二次使用</span><br><span class="hljs-keyword">const</span> &#123; <span class="hljs-attr">state</span>: counter, <span class="hljs-attr">setState</span>: setCounter &#125; = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>) <br></code></pre></td></tr></table></figure><p>这里可以看到，返回对象的使用方式还是挺麻烦的，更何况实际项目中会使用的更频繁。<br><strong>总结：</strong>useState 返回的是 array 而不是 object 的原因就是为了<strong>降低使用的复杂度</strong>，返回数组的话可以直接根据顺序解构，而返回对象的话要想使用多次就需要定义别名了。</p><h3 id="3-React-Hooks-解决了哪些问题？"><a href="#3-React-Hooks-解决了哪些问题？" class="headerlink" title="3. React Hooks 解决了哪些问题？"></a>3. React Hooks 解决了哪些问题？</h3><p>React Hooks 主要解决了以下问题：</p><p><strong>（1）在组件之间复用状态逻辑很难</strong></p><p>React 没有提供将可复用性行为“附加”到组件的途径（例如，把组件连接到 store）解决此类问题可以使用 render props 和 高阶组件。但是这类方案需要重新组织组件结构，这可能会很麻烦，并且会使代码难以理解。由 providers，consumers，高阶组件，render props 等其他抽象层组成的组件会形成“嵌套地狱”。尽管可以在 DevTools 过滤掉它们，但这说明了一个更深层次的问题：React 需要为共享状态逻辑提供更好的原生途径。</p><p>可以使用 Hook 从组件中提取状态逻辑，使得这些逻辑可以单独测试并复用。Hook 使我们在无需修改组件结构的情况下复用状态逻辑。 这使得在组件间或社区内共享 Hook 变得更便捷。</p><p><strong>（2）复杂组件变得难以理解</strong></p><p>在组件中，每个生命周期常常包含一些不相关的逻辑。例如，组件常常在 componentDidMount 和 componentDidUpdate 中获取数据。但是，同一个 componentDidMount 中可能也包含很多其它的逻辑，如设置事件监听，而之后需在 componentWillUnmount 中清除。相互关联且需要对照修改的代码被进行了拆分，而完全不相关的代码却在同一个方法中组合在一起。如此很容易产生 bug，并且导致逻辑不一致。</p><p>在多数情况下，不可能将组件拆分为更小的粒度，因为状态逻辑无处不在。这也给测试带来了一定挑战。同时，这也是很多人将 React 与状态管理库结合使用的原因之一。但是，这往往会引入了很多抽象概念，需要你在不同的文件之间来回切换，使得复用变得更加困难。</p><p>为了解决这个问题，Hook 将组件中相互关联的部分拆分成更小的函数（比如设置订阅或请求数据），而并非强制按照生命周期划分。你还可以使用 reducer 来管理组件的内部状态，使其更加可预测。</p><p><strong>（3）难以理解的 class</strong></p><p>除了代码复用和代码管理会遇到困难外，class 是学习 React 的一大屏障。我们必须去理解 JavaScript 中 this 的工作方式，这与其他语言存在巨大差异。还不能忘记绑定事件处理器。没有稳定的语法提案，这些代码非常冗余。大家可以很好地理解 props，state 和自顶向下的数据流，但对 class 却一筹莫展。即便在有经验的 React 开发者之间，对于函数组件与 class 组件的差异也存在分歧，甚至还要区分两种组件的使用场景。</p><p>为了解决这些问题，Hook 使你在非 class 的情况下可以使用更多的 React 特性。 从概念上讲，React 组件一直更像是函数。而 Hook 则拥抱了函数，同时也没有牺牲 React 的精神原则。Hook 提供了问题的解决方案，无需学习复杂的函数式或响应式编程技术</p><h3 id="4-React-Hook-的使用限制有哪些？"><a href="#4-React-Hook-的使用限制有哪些？" class="headerlink" title="4. React Hook 的使用限制有哪些？"></a>4. React Hook 的使用限制有哪些？</h3><p>React Hooks 的限制主要有两条：</p><ul><li>不要在循环、条件或嵌套函数中调用 Hook；</li><li>在 React 的函数组件中调用 Hook。</li></ul><p>那为什么会有这样的限制呢？Hooks 的设计初衷是为了改进 React 组件的开发模式。在旧有的开发模式下遇到了三个问题。</p><ul><li>组件之间难以复用状态逻辑。过去常见的解决方案是高阶组件、render props 及状态管理框架。</li><li>复杂的组件变得难以理解。生命周期函数与业务逻辑耦合太深，导致关联部分难以拆分。</li><li>人和机器都很容易混淆类。常见的有 this 的问题，但在 React 团队中还有类难以优化的问题，希望在编译优化层面做出一些改进。</li></ul><p>这三个问题在一定程度上阻碍了 React 的后续发展，所以为了解决这三个问题，Hooks <strong>基于函数组件</strong>开始设计。然而第三个问题决定了 Hooks 只支持函数组件。</p><p>那为什么不要在循环、条件或嵌套函数中调用 Hook 呢？因为 Hooks 的设计是基于数组实现。在调用时按顺序加入数组中，如果使用循环、条件或嵌套函数很有可能导致数组取值错位，执行错误的 Hook。当然，实质上 React 的源码里不是数组，是链表。</p><p>这些限制会在编码上造成一定程度的心智负担，新手可能会写错，为了避免这样的情况，可以引入 ESLint 的 Hooks 检查插件进行预防。</p><h3 id="5-useEffect-与-useLayoutEffect-的区别"><a href="#5-useEffect-与-useLayoutEffect-的区别" class="headerlink" title="5. useEffect 与 useLayoutEffect 的区别"></a>5. useEffect 与 useLayoutEffect 的区别</h3><p><strong>（1）共同点</strong></p><ul><li><strong>运用效果：</strong> useEffect 与 useLayoutEffect 两者都是用于处理副作用，这些副作用包括改变 DOM、设置订阅、操作定时器等。在函数组件内部操作副作用是不被允许的，所以需要使用这两个函数去处理。</li><li><strong>使用方式：</strong> useEffect 与 useLayoutEffect 两者底层的函数签名是完全一致的，都是调用的 mountEffectImpl方法，在使用上也没什么差异，基本可以直接替换。</li></ul><p><strong>（2）不同点</strong></p><ul><li><strong>使用场景：</strong> useEffect 在 React 的渲染过程中是被异步调用的，用于绝大多数场景；而 useLayoutEffect 会在所有的 DOM 变更之后同步调用，主要用于处理 DOM 操作、调整样式、避免页面闪烁等问题。也正因为是同步处理，所以需要避免在 useLayoutEffect 做计算量较大的耗时任务从而造成阻塞。</li><li><strong>使用效果：</strong> useEffect是按照顺序执行代码的，改变屏幕像素之后执行（先渲染，后改变DOM），当改变屏幕内容时可能会产生闪烁；useLayoutEffect是改变屏幕像素之前就执行了（会推迟页面显示的事件，先改变DOM后渲染），不会产生闪烁。<strong>useLayoutEffect总是比useEffect先执行。</strong></li></ul><p>在未来的趋势上，两个 API 是会长期共存的，暂时没有删减合并的计划，需要开发者根据场景去自行选择。React 团队的建议非常实用，如果实在分不清，先用 useEffect，一般问题不大；如果页面有异常，再直接替换为 useLayoutEffect 即可。</p><h3 id="6-React-Hooks在平时开发中需要注意的问题和原因"><a href="#6-React-Hooks在平时开发中需要注意的问题和原因" class="headerlink" title="6. React Hooks在平时开发中需要注意的问题和原因"></a>6. React Hooks在平时开发中需要注意的问题和原因</h3><p>（1）<strong>不要在循环，条件或嵌套函数中调用Hook，必须始终在 React函数的顶层使用Hook</strong></p><p>这是因为React需要利用调用顺序来正确更新相应的状态，以及调用相应的钩子函数。一旦在循环或条件分支语句中调用Hook，就容易导致调用顺序的不一致性，从而产生难以预料到的后果。</p><p><strong>（2）使用useState时候，使用push，pop，splice等直接更改数组对象的坑</strong></p><p>使用push直接更改数组无法获取到新值，应该采用析构方式，但是在class里面不会有这个问题。代码示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Indicatorfilter</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">let</span> [num,setNums] = <span class="hljs-title function_">useState</span>([<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>])<br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">test</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-comment">// 这里坑是直接采用push去更新num</span><br>    <span class="hljs-comment">// setNums(num)是无法更新num的</span><br>    <span class="hljs-comment">// 必须使用num = [...num ,1]</span><br>    num.<span class="hljs-title function_">push</span>(<span class="hljs-number">1</span>)<br>    <span class="hljs-comment">// num = [...num ,1]</span><br>    <span class="hljs-title function_">setNums</span>(num)<br>  &#125;<br><span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&#x27;filter&#x27;</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;test&#125;</span>&gt;</span>测试<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">          &#123;num.map((item,index) =&gt; (</span><br><span class="language-xml">              <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&#123;index&#125;</span>&gt;</span>&#123;item&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">          ))&#125;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  )<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Indicatorfilter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span>&lt;any,any&gt;&#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">props:any</span>)&#123;<br>      <span class="hljs-variable language_">super</span>(props)<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = &#123;<br>          <span class="hljs-attr">nums</span>:[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<br>      &#125;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">test</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">test</span>.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>)<br>  &#125;<br><br>  <span class="hljs-title function_">test</span>(<span class="hljs-params"></span>)&#123;<br>      <span class="hljs-comment">// class采用同样的方式是没有问题的</span><br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">nums</span>.<span class="hljs-title function_">push</span>(<span class="hljs-number">1</span>)<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123;<br>          <span class="hljs-attr">nums</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">nums</span><br>      &#125;)<br>  &#125;<br><br>  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>)&#123;<br>      <span class="hljs-keyword">let</span> &#123;nums&#125; = <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span><br>      <span class="hljs-keyword">return</span>(<br>          <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">              <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;this.test&#125;</span>&gt;</span>测试<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">                  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">                      &#123;nums.map((item:any,index:number) =&gt; (</span><br><span class="language-xml">                          <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&#123;index&#125;</span>&gt;</span>&#123;item&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">                      ))&#125;</span><br><span class="language-xml">                  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">          <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><br>      )<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>（3）<strong>useState设置状态的时候，只有第一次生效，后期需要更新状态，必须通过useEffect</strong></p><p>TableDeail是一个公共组件，在调用它的父组件里面，我们通过set改变columns的值，以为传递给TableDeail 的 columns是最新的值，所以tabColumn每次也是最新的值，但是实际tabColumn是最开始的值，不会随着columns的更新而更新：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">TableDeail</span> = (<span class="hljs-params">&#123;</span><br><span class="hljs-params">    columns,</span><br><span class="hljs-params">&#125;:TableData</span>) =&gt; &#123;<br>    <span class="hljs-keyword">const</span> [tabColumn, setTabColumn] = <span class="hljs-title function_">useState</span>(columns) <br>&#125;<br><br><span class="hljs-comment">// 正确的做法是通过useEffect改变这个值</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">TableDeail</span> = (<span class="hljs-params">&#123;</span><br><span class="hljs-params">    columns,</span><br><span class="hljs-params">&#125;:TableData</span>) =&gt; &#123;<br>    <span class="hljs-keyword">const</span> [tabColumn, setTabColumn] = <span class="hljs-title function_">useState</span>(columns) <br>    <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span>&#123;<span class="hljs-title function_">setTabColumn</span>(columns)&#125;,[columns])<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>（4）善用useCallback</strong></p><p>父组件传递给子组件事件句柄时，如果我们没有任何参数变动可能会选用useMemo。但是每一次父组件渲染子组件即使没变化也会跟着渲染一次。 </p><p><strong>（5）不要滥用useContext</strong></p><p>可以使用基于 useContext 封装的状态管理工具。</p><h3 id="7-React-Hooks-和生命周期的关系？"><a href="#7-React-Hooks-和生命周期的关系？" class="headerlink" title="7. React Hooks 和生命周期的关系？"></a>7. React Hooks 和生命周期的关系？</h3><p><strong>函数组件</strong> 的本质是函数，没有 state 的概念的，因此<strong>不存在生命周期</strong>一说，仅仅是一个 <strong>render 函数</strong>而已。<br>但是引入 <strong>Hooks</strong> 之后就变得不同了，它能让组件在不使用 class 的情况下拥有 state，所以就有了生命周期的概念，所谓的生命周期其实就是 <code>useState</code>、 <code>useEffect()</code> 和 <code>useLayoutEffect()</code> 。</p><p>即：<strong>Hooks 组件（使用了Hooks的函数组件）有生命周期，而函数组件（未使用Hooks的函数组件）是没有生命周期的</strong>。</p><p>下面是具体的 class 与 Hooks 的<strong>生命周期对应关系</strong>：</p><ul><li><code>constructor</code>：函数组件不需要构造函数，可以通过调用 <code>**useState 来初始化 state**</code>。如果计算的代价比较昂贵，也可以传一个函数给 <code>useState</code>。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> [num, <span class="hljs-title class_">UpdateNum</span>] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><ul><li><code>getDerivedStateFromProps</code>：一般情况下，我们不需要使用它，可以在<strong>渲染过程中更新 state</strong>，以达到实现 <code>getDerivedStateFromProps</code> 的目的。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">ScrollView</span>(<span class="hljs-params">&#123;row&#125;</span>) &#123;<br>  <span class="hljs-keyword">let</span> [isScrollingDown, setIsScrollingDown] = <span class="hljs-title function_">useState</span>(<span class="hljs-literal">false</span>);<br>  <span class="hljs-keyword">let</span> [prevRow, setPrevRow] = <span class="hljs-title function_">useState</span>(<span class="hljs-literal">null</span>);<br>  <span class="hljs-keyword">if</span> (row !== prevRow) &#123;<br>    <span class="hljs-comment">// Row 自上次渲染以来发生过改变。更新 isScrollingDown。</span><br>    <span class="hljs-title function_">setIsScrollingDown</span>(prevRow !== <span class="hljs-literal">null</span> &amp;&amp; row &gt; prevRow);<br>    <span class="hljs-title function_">setPrevRow</span>(row);<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">`Scrolling down: <span class="hljs-subst">$&#123;isScrollingDown&#125;</span>`</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>React 会立即退出第一次渲染并用更新后的 state 重新运行组件以避免耗费太多性能。</p><ul><li><code>shouldComponentUpdate</code>：可以用 <code>**React.memo**</code> 包裹一个组件来对它的 <code>props</code> 进行浅比较</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title class_">Button</span> = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">memo</span>(<span class="hljs-function">(<span class="hljs-params">props</span>) =&gt;</span> &#123;  <span class="hljs-comment">// 具体的组件&#125;);</span><br></code></pre></td></tr></table></figure><p>注意：<code>**React.memo 等效于 **``**PureComponent**</code>，它只浅比较 props。这里也可以使用 <code>useMemo</code> 优化每一个节点。</p><ul><li><code>render</code>：这是函数组件体本身。</li><li><code>componentDidMount</code>, <code>componentDidUpdate</code>： <code>useLayoutEffect</code> 与它们两的调用阶段是一样的。但是，我们推荐你<strong>一开始先用 useEffect</strong>，只有当它出问题的时候再尝试使用 <code>useLayoutEffect</code>。<code>useEffect</code> 可以表达所有这些的组合。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// componentDidMount</span><br><span class="hljs-title function_">useEffect</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>  <span class="hljs-comment">// 需要在 componentDidMount 执行的内容</span><br>&#125;, [])<br><span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123; <br>  <span class="hljs-comment">// 在 componentDidMount，以及 count 更改时 componentDidUpdate 执行的内容</span><br>  <span class="hljs-variable language_">document</span>.<span class="hljs-property">title</span> = <span class="hljs-string">`You clicked <span class="hljs-subst">$&#123;count&#125;</span> times`</span>; <br>  <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-comment">// 需要在 count 更改时 componentDidUpdate（先于 document.title = ... 执行，遵守先清理后更新）</span><br>    <span class="hljs-comment">// 以及 componentWillUnmount 执行的内容       </span><br>  &#125; <span class="hljs-comment">// 当函数中 Cleanup 函数会按照在代码中定义的顺序先后执行，与函数本身的特性无关</span><br>&#125;, [count]); <span class="hljs-comment">// 仅在 count 更改时更新</span><br></code></pre></td></tr></table></figure><p><strong>请记得 React 会等待浏览器完成画面渲染之后才会延迟调用 ，因此会使得额外操作很方便</strong></p><ul><li><code>componentWillUnmount</code>：相当于 <code>useEffect </code>里面返回的 <code>cleanup</code> 函数</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// componentDidMount/componentWillUnmount</span><br><span class="hljs-title function_">useEffect</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>  <span class="hljs-comment">// 需要在 componentDidMount 执行的内容</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">cleanup</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// 需要在 componentWillUnmount 执行的内容      </span><br>  &#125;<br>&#125;, [])<br></code></pre></td></tr></table></figure><ul><li><code>componentDidCatch</code> and <code>getDerivedStateFromError</code>：目前<strong>还没有</strong>这些方法的 Hook 等价写法，但很快会加上。</li></ul><table><thead><tr><th><strong>class 组件</strong></th><th><strong>Hooks 组件</strong></th></tr></thead><tbody><tr><td>constructor</td><td>useState</td></tr><tr><td>getDerivedStateFromProps</td><td>useState 里面 update 函数</td></tr><tr><td>shouldComponentUpdate</td><td>useMemo</td></tr><tr><td>render</td><td>函数本身</td></tr><tr><td>componentDidMount</td><td>useEffect</td></tr><tr><td>componentDidUpdate</td><td>useEffect</td></tr><tr><td>componentWillUnmount</td><td>useEffect 里面返回的函数</td></tr><tr><td>componentDidCatch</td><td>无</td></tr><tr><td>getDerivedStateFromError</td><td>无</td></tr></tbody></table><h2 id="八、虚拟DOM"><a href="#八、虚拟DOM" class="headerlink" title="八、虚拟DOM"></a>八、虚拟DOM</h2><h3 id="1-对虚拟-DOM-的理解？虚拟-DOM-主要做了什么？虚拟-DOM-本身是什么？"><a href="#1-对虚拟-DOM-的理解？虚拟-DOM-主要做了什么？虚拟-DOM-本身是什么？" class="headerlink" title="1. 对虚拟 DOM 的理解？虚拟 DOM 主要做了什么？虚拟 DOM 本身是什么？"></a>1. 对虚拟 DOM 的理解？虚拟 DOM 主要做了什么？虚拟 DOM 本身是什么？</h3><p>从本质上来说，Virtual Dom是一个JavaScript对象，通过对象的方式来表示DOM结构。将页面的状态抽象为JS对象的形式，配合不同的渲染工具，使跨平台渲染成为可能。通过事务处理机制，将多次DOM修改的结果一次性的更新到页面上，从而有效的减少页面渲染的次数，减少修改DOM的重绘重排次数，提高渲染性能。</p><p>虚拟DOM是对DOM的抽象，这个对象是更加轻量级的对DOM的描述。它设计的最初目的，就是更好的跨平台，比如node.js就没有DOM，如果想实现SSR，那么一个方式就是借助虚拟dom，因为虚拟dom本身是js对象。 在代码渲染到页面之前，vue或者react会把代码转换成一个对象（虚拟DOM）。以对象的形式来描述真实dom结构，最终渲染到页面。在每次数据发生变化前，虚拟dom都会缓存一份，变化之时，现在的虚拟dom会与缓存的虚拟dom进行比较。在vue或者react内部封装了diff算法，通过这个算法来进行比较，渲染时修改改变的变化，原先没有发生改变的通过原先的数据进行渲染。</p><p>另外现代前端框架的一个基本要求就是无须手动操作DOM，一方面是因为手动操作DOM无法保证程序性能，多人协作的项目中如果review不严格，可能会有开发者写出性能较低的代码，另一方面更重要的是省略手动DOM操作可以大大提高开发效率。</p><p><strong>为什么要用 Virtual DOM：</strong></p><p><strong>（1）保证性能下限，在不进行手动优化的情况下，提供过得去的性能</strong></p><p>下面对比一下修改DOM时真实DOM操作和Virtual DOM的过程，来看一下它们重排重绘的性能消耗∶</p><ul><li>真实DOM∶ 生成HTML字符串＋ 重建所有的DOM元素</li><li>Virtual DOM∶ 生成vNode＋ DOMDiff＋必要的DOM更新</li></ul><p>Virtual DOM的更新DOM的准备工作耗费更多的时间，也就是JS层面，相比于更多的DOM操作它的消费是极其便宜的。尤雨溪在社区论坛中说道∶ 框架给你的保证是，你不需要手动优化的情况下，我依然可以给你提供过得去的性能。<br><strong>（2）跨平台</strong><br>Virtual DOM本质上是JavaScript的对象，它可以很方便的跨平台操作，比如服务端渲染、uniapp等。</p><h3 id="2-React-diff-算法的原理是什么？"><a href="#2-React-diff-算法的原理是什么？" class="headerlink" title="2. React diff 算法的原理是什么？"></a>2. React diff 算法的原理是什么？</h3><p>实际上，diff 算法探讨的就是虚拟 DOM 树发生变化后，生成 DOM 树更新补丁的方式。它通过对比新旧两株虚拟 DOM 树的变更差异，将更新补丁作用于真实 DOM，以最小成本完成视图更新。<br><img src="3.jpg" alt="img"><br>具体的流程如下：</p><ul><li>真实的 DOM 首先会映射为虚拟 DOM；</li><li>当虚拟 DOM 发生变化后，就会根据差距计算生成 patch，这个 patch 是一个结构化的数据，内容包含了增加、更新、移除等；</li><li>根据 patch 去更新真实的 DOM，反馈到用户的界面上。</li></ul><p><img src="4.jpg" alt="img"><br>一个简单的例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ExampleComponent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;<br>  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">props</span>.<span class="hljs-property">isVisible</span>) &#123;<br>       <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;visible&quot;</span>&gt;</span>visbile<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;<br>    &#125;<br>     <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;hidden&quot;</span>&gt;</span>hidden<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里，首先假定 ExampleComponent 可见，然后再改变它的状态，让它不可见 。映射为真实的 DOM 操作是这样的，React 会创建一个 div 节点。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;div <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;visible&quot;</span>&gt;visbile&lt;/div&gt;<br></code></pre></td></tr></table></figure><p>当把 visbile 的值变为 false 时，就会替换 class 属性为 hidden，并重写内部的 innerText 为 hidden。<strong>这样一个生成补丁、更新差异的过程统称为 diff 算法。</strong></p><p>diff算法可以总结为三个策略，分别从树、组件及元素三个层面进行复杂度的优化：</p><p><strong>策略一：忽略节点跨层级操作场景，提升比对效率。（基于树进行对比）</strong></p><p>这一策略需要进行树比对，即对树进行分层比较。树比对的处理手法是非常“暴力”的，即两棵树只对同一层次的节点进行比较，如果发现节点已经不存在了，则该节点及其子节点会被完全删除掉，不会用于进一步的比较，这就提升了比对效率。</p><p><strong>策略二：如果组件的 class 一致，则默认为相似的树结构，否则默认为不同的树结构。（基于组件进行对比）</strong></p><p>在组件比对的过程中：</p><ul><li>如果组件是同一类型则进行树比对；</li><li>如果不是则直接放入补丁中。</li></ul><p>只要父组件类型不同，就会被重新渲染。这也就是为什么 shouldComponentUpdate、PureComponent 及 React.memo 可以提高性能的原因。</p><p><strong>策略三：同一层级的子节点，可以通过标记 key 的方式进行列表对比。（基于节点进行对比）</strong></p><p>元素比对主要发生在同层级中，通过标记节点操作生成补丁。节点操作包含了插入、移动、删除等。其中节点重新排序同时涉及插入、移动、删除三个操作，所以效率消耗最大，此时策略三起到了至关重要的作用。通过标记 key 的方式，React 可以直接移动 DOM 节点，降低内耗。</p><h3 id="3-React-key-是干嘛用的-为什么要加？key-主要是解决哪一类问题的"><a href="#3-React-key-是干嘛用的-为什么要加？key-主要是解决哪一类问题的" class="headerlink" title="3. React key 是干嘛用的 为什么要加？key 主要是解决哪一类问题的"></a>3. React key 是干嘛用的 为什么要加？key 主要是解决哪一类问题的</h3><p>Keys 是 React 用于追踪哪些列表中元素被修改、被添加或者被移除的辅助标识。在开发过程中，我们需要保证某个元素的 key 在其同级元素中具有唯一性。</p><p>在 React Diff 算法中 React 会借助元素的 Key 值来判断该元素是新近创建的还是被移动而来的元素，从而减少不必要的元素重渲染此外，React 还需要借助 Key 值来判断元素与本地状态的关联关系。</p><p>注意事项：</p><ul><li>key值一定要和具体的元素—一对应；</li><li>尽量不要用数组的index去作为key；</li><li>不要在render的时候用随机数或者其他操作给元素加上不稳定的key，这样造成的性能开销比不加key的情况下更糟糕。</li></ul><h3 id="4-虚拟-DOM-的引入与直接操作原生-DOM-相比，哪一个效率更高，为什么"><a href="#4-虚拟-DOM-的引入与直接操作原生-DOM-相比，哪一个效率更高，为什么" class="headerlink" title="4. 虚拟 DOM 的引入与直接操作原生 DOM 相比，哪一个效率更高，为什么"></a>4. 虚拟 DOM 的引入与直接操作原生 DOM 相比，哪一个效率更高，为什么</h3><p>虚拟DOM相对原生的DOM不一定是效率更高，如果只修改一个按钮的文案，那么虚拟 DOM 的操作无论如何都不可能比真实的 DOM 操作更快。在首次渲染大量DOM时，由于多了一层虚拟DOM的计算，虚拟DOM也会比innerHTML插入慢。它能保证性能下限，在真实DOM操作的时候进行针对性的优化时，还是更快的。所以要根据具体的场景进行探讨。</p><p>在整个 DOM 操作的演化过程中，其实主要矛盾并不在于性能，而在于开发者写得爽不爽，在于研发体验&#x2F;研发效率。虚拟 DOM 不是别的，正是前端开发们为了追求更好的研发体验和研发效率而创造出来的高阶产物。虚拟 DOM 并不一定会带来更好的性能，React 官方也从来没有把虚拟 DOM 作为性能层面的卖点对外输出过。<strong>虚拟 DOM 的优越之处在于，它能够在提供更爽、更高效的研发模式（也就是函数式的 UI 编程方式）的同时，仍然保持一个还不错的性能。</strong></p><h3 id="5-React-与-Vue-的-diff-算法有何不同？"><a href="#5-React-与-Vue-的-diff-算法有何不同？" class="headerlink" title="5. React 与 Vue 的 diff 算法有何不同？"></a>5. React 与 Vue 的 diff 算法有何不同？</h3><p>diff 算法是指生成更新补丁的方式，主要应用于虚拟 DOM 树变化后，更新真实 DOM。所以 diff 算法一定存在这样一个过程：触发更新 → 生成补丁 → 应用补丁。</p><p>React 的 diff 算法，触发更新的时机主要在 state 变化与 hooks 调用之后。此时触发虚拟 DOM 树变更遍历，采用了深度优先遍历算法。但传统的遍历方式，效率较低。为了优化效率，使用了分治的方式。将单一节点比对转化为了 3 种类型节点的比对，分别是树、组件及元素，以此提升效率。</p><ul><li>树比对：由于网页视图中较少有跨层级节点移动，两株虚拟 DOM 树只对同一层次的节点进行比较。</li><li>组件比对：如果组件是同一类型，则进行树比对，如果不是，则直接放入到补丁中。</li><li>元素比对：主要发生在同层级中，通过标记节点操作生成补丁，节点操作对应真实的 DOM 剪裁操作。</li></ul><p>以上是经典的 React diff 算法内容。自 React 16 起，引入了 Fiber 架构。为了使整个更新过程可随时暂停恢复，节点与树分别采用了 FiberNode 与 FiberTree 进行重构。fiberNode 使用了双链表的结构，可以直接找到兄弟节点与子节点。整个更新过程由 current 与 workInProgress 两株树双缓冲完成。workInProgress 更新完成后，再通过修改 current 相关指针指向新节点。</p><p>Vue 的整体 diff 策略与 React 对齐，虽然缺乏时间切片能力，但这并不意味着 Vue 的性能更差，因为在 Vue 3 初期引入过，后期因为收益不高移除掉了。除了高帧率动画，在 Vue 中其他的场景几乎都可以使用防抖和节流去提高响应性能。</p><h2 id="九、其他"><a href="#九、其他" class="headerlink" title="九、其他"></a>九、其他</h2><h3 id="1-React组件命名推荐的方式是哪个？"><a href="#1-React组件命名推荐的方式是哪个？" class="headerlink" title="1. React组件命名推荐的方式是哪个？"></a>1. React组件命名推荐的方式是哪个？</h3><p>通过引用而不是使用来命名组件displayName。</p><p>使用displayName命名组件：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">React</span>.<span class="hljs-title function_">createClass</span>(&#123;  <span class="hljs-attr">displayName</span>: <span class="hljs-string">&#x27;TodoApp&#x27;</span>,  <span class="hljs-comment">// ...&#125;)</span><br></code></pre></td></tr></table></figure><p>React推荐的方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TodoApp</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;  <span class="hljs-comment">// ...&#125;</span><br></code></pre></td></tr></table></figure><h3 id="2-react-最新版本解决了什么问题，增加了哪些东西"><a href="#2-react-最新版本解决了什么问题，增加了哪些东西" class="headerlink" title="2. react 最新版本解决了什么问题，增加了哪些东西"></a>2. react 最新版本解决了什么问题，增加了哪些东西</h3><p>React 16.x的三大新特性 Time Slicing、Suspense、 hooks</p><ul><li><strong>Time Slicing（解决CPU速度问题</strong>）使得在执行任务的期间可以随时暂停，跑去干别的事情，这个特性使得react能在性能极其差的机器跑时，仍然保持有良好的性能</li><li><strong>Suspense （解决网络IO问题）</strong> 和lazy配合，实现异步加载组件。 能暂停当前组件的渲染， 当完成某件事以后再继续渲染，解决从react出生到现在都存在的「异步副作用」的问题，而且解决得非的优雅，使用的是 T异步但是同步的写法，这是最好的解决异步问题的方式</li><li>提供了一个<strong>内置函数componentDidCatch</strong>，当有错误发生时，可以友好地展示 fallback 组件; 可以捕捉到它的子元素（包括嵌套子元素）抛出的异常; 可以复用错误组件。</li></ul><p><strong>（1）React16.8</strong><br>加入hooks，让React函数式组件更加灵活，hooks之前，React存在很多问题：</p><ul><li>在组件间复用状态逻辑很难</li><li>复杂组件变得难以理解，高阶组件和函数组件的嵌套过深。</li><li>class组件的this指向问题 </li><li>难以记忆的生命周期</li></ul><p>hooks很好的解决了上述问题，hooks提供了很多方法</p><ul><li>useState 返回有状态值，以及更新这个状态值的函数</li><li>useEffect 接受包含命令式，可能有副作用代码的函数。</li><li>useContext 接受上下文对象（从 React.createContext返回的值）并返回当前上下文值，</li><li>useReducer useState 的替代方案。接受类型为 （state，action）&#x3D;&gt; newState的reducer，并返回与dispatch方法配对的当前状态。</li><li>useCalLback 返回一个回忆的memoized版本，该版本仅在其中一个输入发生更改时才会更改。纯函数的输入输出确定性 o useMemo 纯的一个记忆函数 o useRef 返回一个可变的ref对象，其Current 属性被初始化为传递的参数，返回的 ref 对象在组件的整个生命周期内保持不变。</li><li>useImperativeMethods 自定义使用ref时公开给父组件的实例值</li><li>useMutationEffect 更新兄弟组件之前，它在React执行其DOM改变的同一阶段同步触发</li><li>useLayoutEffect DOM改变后同步触发。使用它来从DOM读取布局并同步重新渲染</li></ul><p><strong>（2）React16.9</strong></p><ul><li>重命名 Unsafe 的生命周期方法。新的 UNSAFE_前缀将有助于在代码 review 和 debug 期间，使这些有问题的字样更突出</li><li>废弃 javascrip:形式的 URL。以javascript:开头的URL 非常容易遭受攻击，造成安全漏洞。</li><li>废弃”Factory”组件。 工厂组件会导致 React 变大且变慢。</li><li>act（）也支持异步函数，并且你可以在调用它时使用 await。</li><li>使用 &lt;React.ProfiLer&gt; 进行性能评估。在较大的应用中追踪性能回归可能会很方便</li></ul><p><strong>（3）React16.13.0</strong></p><ul><li>支持在渲染期间调用setState，但仅适用于同一组件</li><li>可检测冲突的样式规则并记录警告</li><li>废弃 unstable_createPortal，使用CreatePortal</li><li>将组件堆栈添加到其开发警告中，使开发人员能够隔离bug并调试其程序，这可以清楚地说明问题所在，并更快地定位和修复错误。</li></ul><h3 id="3-react-实现一个全局的-dialog"><a href="#3-react-实现一个全局的-dialog" class="headerlink" title="3. react 实现一个全局的 dialog"></a>3. react 实现一个全局的 dialog</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; <span class="hljs-title class_">Component</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123; is, fromJS &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;immutable&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-title class_">ReactDOM</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-dom&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-title class_">ReactCSSTransitionGroup</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-addons-css-transition-group&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;./dialog.css&#x27;</span>;<br><span class="hljs-keyword">let</span> defaultState = &#123;<br>  <span class="hljs-attr">alertStatus</span>:<span class="hljs-literal">false</span>,<br>  <span class="hljs-attr">alertTip</span>:<span class="hljs-string">&quot;提示&quot;</span>,<br>  <span class="hljs-attr">closeDialog</span>:<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;&#125;,<br>  <span class="hljs-attr">childs</span>:<span class="hljs-string">&#x27;&#x27;</span><br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dialog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Component</span>&#123;<br>  state = &#123;<br>    ...defaultState<br>  &#125;;<br>  <span class="hljs-comment">// css动画组件设置为目标组件</span><br>  <span class="hljs-title class_">FirstChild</span> = <span class="hljs-function"><span class="hljs-params">props</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> childrenArray = <span class="hljs-title class_">React</span>.<span class="hljs-property">Children</span>.<span class="hljs-title function_">toArray</span>(props.<span class="hljs-property">children</span>);<br>    <span class="hljs-keyword">return</span> childrenArray[<span class="hljs-number">0</span>] || <span class="hljs-literal">null</span>;<br>  &#125;<br>  <span class="hljs-comment">//打开弹窗</span><br>  open =<span class="hljs-function">(<span class="hljs-params">options</span>)=&gt;</span>&#123;<br>    options = options || &#123;&#125;;<br>    options.<span class="hljs-property">alertStatus</span> = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">var</span> props = options.<span class="hljs-property">props</span> || &#123;&#125;;<br>    <span class="hljs-keyword">var</span> childs = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">renderChildren</span>(props,options.<span class="hljs-property">childrens</span>) || <span class="hljs-string">&#x27;&#x27;</span>;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(childs);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123;<br>      ...defaultState,<br>      ...options,<br>      childs<br>    &#125;)<br>  &#125;<br>  <span class="hljs-comment">//关闭弹窗</span><br>  <span class="hljs-title function_">close</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-title function_">closeDialog</span>();<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123;<br>      ...defaultState<br>    &#125;)<br>  &#125;<br>  <span class="hljs-title function_">renderChildren</span>(<span class="hljs-params">props,childrens</span>) &#123;<br>    <span class="hljs-comment">//遍历所有子组件</span><br>    <span class="hljs-keyword">var</span> childs = [];<br>    childrens = childrens || [];<br>    <span class="hljs-keyword">var</span> ps = &#123;<br>        ...props,  <span class="hljs-comment">//给子组件绑定props</span><br>        <span class="hljs-attr">_close</span>:<span class="hljs-variable language_">this</span>.<span class="hljs-property">close</span>  <span class="hljs-comment">//给子组件也绑定一个关闭弹窗的事件    </span><br>       &#125;;<br>    childrens.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">currentItem,index</span>) =&gt;</span> &#123;<br>        childs.<span class="hljs-title function_">push</span>(<span class="hljs-title class_">React</span>.<span class="hljs-title function_">createElement</span>(<br>            currentItem,<br>            &#123;<br>                ...ps,<br>                <span class="hljs-attr">key</span>:index<br>            &#125;<br>        ));<br>    &#125;)<br>    <span class="hljs-keyword">return</span> childs;<br>  &#125;<br>  <span class="hljs-title function_">shouldComponentUpdate</span>(<span class="hljs-params">nextProps, nextState</span>)&#123;<br>    <span class="hljs-keyword">return</span> !<span class="hljs-title function_">is</span>(<span class="hljs-title function_">fromJS</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">props</span>), <span class="hljs-title function_">fromJS</span>(nextProps)) || !<span class="hljs-title function_">is</span>(<span class="hljs-title function_">fromJS</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>), <span class="hljs-title function_">fromJS</span>(nextState))<br>  &#125;<br>   <br>  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">return</span> (<br>      <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">ReactCSSTransitionGroup</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">component</span>=<span class="hljs-string">&#123;this.FirstChild&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">transitionName</span>=<span class="hljs-string">&#x27;hide&#x27;</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">transitionEnterTimeout</span>=<span class="hljs-string">&#123;300&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">transitionLeaveTimeout</span>=<span class="hljs-string">&#123;300&#125;</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;dialog-con&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&#123;this.state.alertStatus?</span> &#123;<span class="hljs-attr">display:</span>&#x27;<span class="hljs-attr">block</span>&#x27;&#125;<span class="hljs-attr">:</span>&#123;<span class="hljs-attr">display:</span>&#x27;<span class="hljs-attr">none</span>&#x27;&#125;&#125;&gt;</span></span><br><span class="language-xml">            &#123;this.state.childs&#125;</span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">ReactCSSTransitionGroup</span>&gt;</span></span><br>    );<br>  &#125;<br>&#125;<br><span class="hljs-keyword">let</span> div = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;div&#x27;</span>);<br><span class="hljs-keyword">let</span> props = &#123;<br>   <br>&#125;;<br><span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">appendChild</span>(div);<br><span class="hljs-keyword">let</span> <span class="hljs-title class_">Box</span> = <span class="hljs-title class_">ReactD</span><br></code></pre></td></tr></table></figure><p>子类：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//子类jsx</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; <span class="hljs-title class_">Component</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Child</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Component</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">props</span>)&#123;<br>        <span class="hljs-variable language_">super</span>(props);<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = &#123;<span class="hljs-attr">date</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>()&#125;;<br>  &#125;<br>  showValue=<span class="hljs-function">()=&gt;</span>&#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">props</span>.<span class="hljs-property">showValue</span> &amp;&amp; <span class="hljs-variable language_">this</span>.<span class="hljs-property">props</span>.<span class="hljs-title function_">showValue</span>()<br>  &#125;<br>  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> (<br>      <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;Child&quot;</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;content&quot;</span>&gt;</span></span><br><span class="language-xml">           Child</span><br><span class="language-xml">           <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;this.showValue&#125;</span>&gt;</span>调用父的方法<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>    );<br>  &#125;<br>&#125;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">Child</span>;<br></code></pre></td></tr></table></figure><p>css：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.dialog-con</span>&#123;<br>    <span class="hljs-attribute">position</span>: fixed;<br>    <span class="hljs-attribute">top</span>: <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">left</span>: <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">100%</span>;<br>    <span class="hljs-attribute">background</span>: <span class="hljs-built_in">rgba</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0.3</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-React-数据持久化有什么实践吗？"><a href="#4-React-数据持久化有什么实践吗？" class="headerlink" title="4. React 数据持久化有什么实践吗？"></a>4. React 数据持久化有什么实践吗？</h3><p>封装数据持久化组件：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript">】<span class="hljs-keyword">let</span> storage=&#123;<br>    <span class="hljs-comment">// 增加</span><br>    <span class="hljs-title function_">set</span>(<span class="hljs-params">key, value</span>)&#123;<br>        <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">setItem</span>(key, <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(value));<br>    &#125;,<br>    <span class="hljs-comment">// 获取</span><br>    <span class="hljs-title function_">get</span>(<span class="hljs-params">key</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(<span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">getItem</span>(key));<br>    &#125;,<br>    <span class="hljs-comment">// 删除</span><br>    <span class="hljs-title function_">remove</span>(<span class="hljs-params">key</span>)&#123;<br>        <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">removeItem</span>(key);<br>    &#125;<br>&#125;;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">Storage</span>;<br></code></pre></td></tr></table></figure><p>在React项目中，通过redux存储全局数据时，会有一个问题，如果用户刷新了网页，那么通过redux存储的全局数据就会被全部清空，比如登录信息等。这时就会有全局数据持久化存储的需求。首先想到的就是localStorage，localStorage是没有时间限制的数据存储，可以通过它来实现数据的持久化存储。</p><p>但是在已经使用redux来管理和存储全局数据的基础上，再去使用localStorage来读写数据，这样不仅是工作量巨大，还容易出错。那么有没有结合redux来达到持久数据存储功能的框架呢？当然，它就是<strong>redux-persist</strong>。redux-persist会将redux的store中的数据缓存到浏览器的localStorage中。其使用步骤如下：</p><p><strong>（1）首先要安装redux-persist：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">npm i redux-persist<br></code></pre></td></tr></table></figure><p><strong>（2）对于reducer和action的处理不变，只需修改store的生成代码，修改如下：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123;createStore&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;redux&#x27;</span><br><span class="hljs-keyword">import</span> reducers <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../reducers/index&#x27;</span><br><span class="hljs-keyword">import</span> &#123;persistStore, persistReducer&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;redux-persist&#x27;</span>;<br><span class="hljs-keyword">import</span> storage <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;redux-persist/lib/storage&#x27;</span>;<br><span class="hljs-keyword">import</span> autoMergeLevel2 <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;redux-persist/lib/stateReconciler/autoMergeLevel2&#x27;</span>;<br><span class="hljs-keyword">const</span> persistConfig = &#123;<br>    <span class="hljs-attr">key</span>: <span class="hljs-string">&#x27;root&#x27;</span>,<br>    <span class="hljs-attr">storage</span>: storage,<br>    <span class="hljs-attr">stateReconciler</span>: autoMergeLevel2 <span class="hljs-comment">// 查看 &#x27;Merge Process&#x27; 部分的具体情况</span><br>&#125;;<br><span class="hljs-keyword">const</span> myPersistReducer = <span class="hljs-title function_">persistReducer</span>(persistConfig, reducers)<br><span class="hljs-keyword">const</span> store = <span class="hljs-title function_">createStore</span>(myPersistReducer)<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> persistor = <span class="hljs-title function_">persistStore</span>(store)<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> store<br></code></pre></td></tr></table></figure><p><strong>（3）在index.js中，将PersistGate标签作为网页内容的父标签：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-title class_">ReactDOM</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-dom&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123;<span class="hljs-title class_">Provider</span>&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-redux&#x27;</span><br><span class="hljs-keyword">import</span> store <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./redux/store/store&#x27;</span><br><span class="hljs-keyword">import</span> &#123;persistor&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./redux/store/store&#x27;</span><br><span class="hljs-keyword">import</span> &#123;<span class="hljs-title class_">PersistGate</span>&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;redux-persist/lib/integration/react&#x27;</span>;<br><span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">render</span>(<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Provider</span> <span class="hljs-attr">store</span>=<span class="hljs-string">&#123;store&#125;</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">PersistGate</span> <span class="hljs-attr">loading</span>=<span class="hljs-string">&#123;null&#125;</span> <span class="hljs-attr">persistor</span>=<span class="hljs-string">&#123;persistor&#125;</span>&gt;</span></span><br><span class="language-xml">                &#123;/*网页内容*/&#125;</span><br><span class="language-xml">            <span class="hljs-tag">&lt;/<span class="hljs-name">PersistGate</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">Provider</span>&gt;</span></span>, <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;root&#x27;</span>));<br></code></pre></td></tr></table></figure><p>这就完成了通过redux-persist实现React持久化本地数据存储的简单应用。</p><h3 id="5-对-React-和-Vue-的理解，它们的异同"><a href="#5-对-React-和-Vue-的理解，它们的异同" class="headerlink" title="5. 对 React 和 Vue 的理解，它们的异同"></a>5. 对 React 和 Vue 的理解，它们的异同</h3><p><strong>相似之处：</strong></p><ul><li>都将注意力集中保持在核心库，而将其他功能如路由和全局状态管理交给相关的库</li><li>都有自己的构建工具，能让你得到一个根据最佳实践设置的项目模板。</li><li>都使用了Virtual DOM（虚拟DOM）提高重绘性能</li><li>都有props的概念，允许组件间的数据传递</li><li>都鼓励组件化应用，将应用分拆成一个个功能明确的模块，提高复用性</li></ul><p><strong>不同之处：</strong></p><p><strong>1）数据流</strong></p><p>Vue默认支持数据双向绑定，而React一直提倡单向数据流 </p><p><strong>2）虚拟DOM</strong></p><p>Vue2.x开始引入”Virtual DOM”，消除了和React在这方面的差异，但是在具体的细节还是有各自的特点。 </p><ul><li>Vue宣称可以更快地计算出Virtual DOM的差异，这是由于它在渲染过程中，会跟踪每一个组件的依赖关系，不需要重新渲染整个组件树。</li><li>对于React而言，每当应用的状态被改变时，全部子组件都会重新渲染。当然，这可以通过 PureComponent&#x2F;shouldComponentUpdate这个生命周期方法来进行控制，但Vue将此视为默认的优化。</li></ul><p><strong>3）组件化</strong></p><p>React与Vue最大的不同是模板的编写。</p><ul><li>Vue鼓励写近似常规HTML的模板。写起来很接近标准 HTML元素，只是多了一些属性。</li><li>React推荐你所有的模板通用JavaScript的语法扩展——JSX书写。</li></ul><p>具体来讲：React中render函数是支持闭包特性的，所以我们import的组件在render中可以直接调用。但是在Vue中，由于模板中使用的数据都必须挂在 this 上进行一次中转，所以 import 完组件之后，还需要在 components 中再声明下。</p><p><strong>4）监听数据变化的实现原理不同</strong></p><ul><li>Vue 通过 getter&#x2F;setter 以及一些函数的劫持，能精确知道数据变化，不需要特别的优化就能达到很好的性能</li><li>React 默认是通过比较引用的方式进行的，如果不优化（PureComponent&#x2F;shouldComponentUpdate）可能导致大量不必要的vDOM的重新渲染。这是因为 Vue 使用的是可变数据，而React更强调数据的不可变。</li></ul><p><strong>5）高阶组件</strong></p><p>react可以通过高阶组件（Higher Order Components– HOC）来扩展，而vue需要通过mixins来扩展。</p><p>原因高阶组件就是高阶函数，而React的组件本身就是纯粹的函数，所以高阶函数对React来说易如反掌。相反Vue.js使用HTML模板创建视图组件，这时模板无法有效的编译，因此Vue不采用HOC来实现。</p><p><strong>6）构建工具</strong></p><p>两者都有自己的构建工具</p><ul><li>React &#x3D;&#x3D;&gt; Create React APP</li><li>Vue &#x3D;&#x3D;&gt; vue-cli</li></ul><p><strong>7）跨平台</strong></p><ul><li>React &#x3D;&#x3D;&gt; React Native</li><li>Vue &#x3D;&#x3D;&gt; Weex</li></ul><h3 id="6-可以使用TypeScript写React应用吗？怎么操作？"><a href="#6-可以使用TypeScript写React应用吗？怎么操作？" class="headerlink" title="6. 可以使用TypeScript写React应用吗？怎么操作？"></a>6. 可以使用TypeScript写React应用吗？怎么操作？</h3><p><strong>（1）如果还未创建 Create React App 项目</strong></p><ul><li>直接创建一个具有 typescript 的 Create React App 项目：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">npx create-react-app demo --typescript<br></code></pre></td></tr></table></figure><p><strong>（2）如果已经创建了 Create React App 项目，需要将 typescript 引入到已有项目中</strong></p><ul><li>通过命令将 typescript 引入项目：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">npm install --save typescript @types/node @types/react @types/react-dom @types/jest<br></code></pre></td></tr></table></figure><ul><li>将项目中任何 后缀名为 ‘.js’ 的 JavaScript 文件重命名为 TypeScript 文件即后缀名为 ‘.tsx’（例如 src&#x2F;index.js 重命名为 src&#x2F;index.tsx ）</li></ul><h3 id="7-React-设计思路，它的理念是什么？"><a href="#7-React-设计思路，它的理念是什么？" class="headerlink" title="7. React 设计思路，它的理念是什么？"></a>7. React 设计思路，它的理念是什么？</h3><p><strong>（1）编写简单直观的代码</strong></p><p>React最大的价值不是高性能的虚拟DOM、封装的事件机制、服务器端渲染，而是声明式的直观的编码方式。react文档第一条就是声明式，React 使创建交互式 UI 变得轻而易举。为应用的每一个状态设计简洁的视图，当数据改变时 React 能有效地更新并正确地渲染组件。 以声明式编写 UI，可以让代码更加可靠，且方便调试。</p><p><strong>（2）简化可复用的组件</strong></p><p>React框架里面使用了简化的组件模型，但更彻底地使用了组件化的概念。React将整个UI上的每一个功能模块定义成组件，然后将小的组件通过组合或者嵌套的方式构成更大的组件。React的组件具有如下的特性∶</p><ul><li>可组合：简单组件可以组合为复杂的组件</li><li>可重用：每个组件都是独立的，可以被多个组件使用 </li><li>可维护：和组件相关的逻辑和UI都封装在了组件的内部，方便维护</li><li>可测试：因为组件的独立性，测试组件就变得方便很多。</li></ul><p><strong>（3) Virtual DOM</strong></p><p>真实页面对应一个 DOM 树。在传统页面的开发模式中，每次需要更新页面时，都要手动操作 DOM 来进行更新。 DOM 操作非常昂贵。在前端开发中，性能消耗最大的就是 DOM 操作，而且这部分代码会让整体项目的代码变得难 以维护。React 把真实 DOM 树转换成 JavaScript 对象树，也就是 Virtual DOM，每次数据更新后，重新计算 Virtual DOM，并和上一次生成的 Virtual DOM 做对比，对发生变化的部分做批量更新。React 也提供了直观的 shouldComponentUpdate 生命周期回调，来减少数据变化后不必要的 Virtual DOM 对比过程，以保证性能。</p><p><strong>（4）函数式编程</strong></p><p>React 把过去不断重复构建 UI 的过程抽象成了组件，且在给定参数的情况下约定渲染对应的 UI 界面。React 能充分利用很多函数式方法去减少冗余代码。此外，由于它本身就是简单函数，所以易于测试。</p><p><strong>（5）一次学习，随处编写</strong></p><p>无论现在正在使用什么技术栈，都可以随时引入 React来开发新特性，而不需要重写现有代码。</p><p>React 还可以使用 Node 进行服务器渲染，或使用 React Native 开发原生移动应用。因为 React 组件可以映射为对应的原生控件。在输出的时候，是输出 Web DOM，还是 Android 控件，还是 iOS 控件，就由平台本身决定了。所以，react很方便和其他平台集成</p><h3 id="8-React中props-children和React-Children的区别"><a href="#8-React中props-children和React-Children的区别" class="headerlink" title="8. React中props.children和React.Children的区别"></a>8. React中props.children和React.Children的区别</h3><p>在React中，当涉及组件嵌套，在父组件中使用<code>props.children</code>把所有子组件显示出来。如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">ParentComponent</span>(<span class="hljs-params">props</span>)&#123;<br><span class="hljs-keyword">return</span> (<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">&#123;props.children&#125;</span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>)<br>&#125;<br></code></pre></td></tr></table></figure><p>如果想把父组件中的属性传给所有的子组件，需要使用<code>React.Children</code>方法。</p><p>比如，把几个Radio组合起来，合成一个RadioGroup，这就要求所有的Radio具有同样的name属性值。可以这样：把Radio看做子组件，RadioGroup看做父组件，name的属性值在RadioGroup这个父组件中设置。</p><p>首先是子组件：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//子组件</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">RadioOption</span>(<span class="hljs-params">props</span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;props.value&#125;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&#123;props.name&#125;</span> /&gt;</span></span><br><span class="language-xml">      &#123;props.label&#125;</span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span></span><br>  )<br>&#125;<br></code></pre></td></tr></table></figure><p>然后是父组件，不仅需要把它所有的子组件显示出来，还需要为每个子组件赋上name属性和值：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//父组件用,props是指父组件的props</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">renderChildren</span>(<span class="hljs-params">props</span>) &#123;<br>    <br>  <span class="hljs-comment">//遍历所有子组件</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-title class_">React</span>.<span class="hljs-property">Children</span>.<span class="hljs-title function_">map</span>(props.<span class="hljs-property">children</span>, <span class="hljs-function"><span class="hljs-params">child</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (child.<span class="hljs-property">type</span> === <span class="hljs-title class_">RadioOption</span>)<br>      <span class="hljs-keyword">return</span> <span class="hljs-title class_">React</span>.<span class="hljs-title function_">cloneElement</span>(child, &#123;<br>        <span class="hljs-comment">//把父组件的props.name赋值给每个子组件</span><br>        <span class="hljs-attr">name</span>: props.<span class="hljs-property">name</span><br>      &#125;)<br>    <span class="hljs-keyword">else</span><br>      <span class="hljs-keyword">return</span> child<br>  &#125;)<br>&#125;<br><span class="hljs-comment">//父组件</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">RadioGroup</span>(<span class="hljs-params">props</span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      &#123;renderChildren(props)&#125;</span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  )<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">RadioGroup</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;hello&quot;</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">RadioOption</span> <span class="hljs-attr">label</span>=<span class="hljs-string">&quot;选项一&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;1&quot;</span> /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">RadioOption</span> <span class="hljs-attr">label</span>=<span class="hljs-string">&quot;选项二&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;2&quot;</span> /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">RadioOption</span> <span class="hljs-attr">label</span>=<span class="hljs-string">&quot;选项三&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;3&quot;</span> /&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">RadioGroup</span>&gt;</span></span><br>  )<br>&#125;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">App</span>;<br></code></pre></td></tr></table></figure><p>以上，<code>React.Children.map</code>让我们对父组件的所有子组件又更灵活的控制。</p><h3 id="9-React的状态提升是什么？使用场景有哪些？"><a href="#9-React的状态提升是什么？使用场景有哪些？" class="headerlink" title="9. React的状态提升是什么？使用场景有哪些？"></a>9. React的状态提升是什么？使用场景有哪些？</h3><p>React的状态提升就是用户对子组件操作，子组件不改变自己的状态，通过自己的props把这个操作改变的数据传递给父组件，改变父组件的状态，从而改变受父组件控制的所有子组件的状态，这也是React单项数据流的特性决定的。官方的原话是：共享 state(状态) 是通过将其移动到需要它的组件的最接近的共同祖先组件来实现的。 这被称为“状态提升(Lifting State Up)”。</p><p>概括来说就是<strong>将多个组件需要共享的状态提升到它们最近的父组件上</strong>，<strong>在父组件上改变这个状态然后通过props分发给子组件。</strong></p><p>一个简单的例子，父组件中有两个input子组件，如果想在第一个输入框输入数据，来改变第二个输入框的值，这就需要用到状态提升。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Father</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">props</span>) &#123;<br>        <span class="hljs-variable language_">super</span>(props)<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = &#123;<br>            <span class="hljs-title class_">Value1</span>: <span class="hljs-string">&#x27;&#x27;</span>,<br>            <span class="hljs-title class_">Value2</span>: <span class="hljs-string">&#x27;&#x27;</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-title function_">value1Change</span>(<span class="hljs-params">aa</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123;<br>            <span class="hljs-title class_">Value1</span>: aa<br>        &#125;)<br>    &#125;<br>    <span class="hljs-title function_">value2Change</span>(<span class="hljs-params">bb</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123;<br>            <span class="hljs-title class_">Value2</span>: bb<br>        &#125;)<br>    &#125;<br>    <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> (<br>            <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&#123;&#123;</span> <span class="hljs-attr">padding:</span> &quot;<span class="hljs-attr">100px</span>&quot; &#125;&#125;&gt;</span></span><br><span class="language-xml">                <span class="hljs-tag">&lt;<span class="hljs-name">Child1</span> <span class="hljs-attr">value1</span>=<span class="hljs-string">&#123;this.state.Value1&#125;</span> <span class="hljs-attr">onvalue1Change</span>=<span class="hljs-string">&#123;this.value1Change.bind(this)&#125;</span> /&gt;</span></span><br><span class="language-xml">                </span><br><span class="language-xml"></span><br><span class="language-xml">                <span class="hljs-tag">&lt;<span class="hljs-name">Child2</span> <span class="hljs-attr">value2</span>=<span class="hljs-string">&#123;this.state.Value1&#125;</span> /&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>        )<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Child1</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">props</span>) &#123;<br>        <span class="hljs-variable language_">super</span>(props)<br>    &#125;<br>    <span class="hljs-title function_">changeValue</span>(<span class="hljs-params">e</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">props</span>.<span class="hljs-title function_">onvalue1Change</span>(e.<span class="hljs-property">target</span>.<span class="hljs-property">value</span>)<br>    &#125;<br>    <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> (<br>            <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;this.props.Value1&#125;</span> <span class="hljs-attr">onChange</span>=<span class="hljs-string">&#123;this.changeValue.bind(this)&#125;</span> /&gt;</span></span><br>        )<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Child2</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">props</span>) &#123;<br>        <span class="hljs-variable language_">super</span>(props)<br>    &#125;<br>    <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> (<br>            <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;this.props.value2&#125;</span> /&gt;</span></span><br>        )<br>    &#125;<br>&#125;<br> <br><span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">render</span>(<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Father</span> /&gt;</span></span>,<br>    <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;root&#x27;</span>)<br>)<br></code></pre></td></tr></table></figure><h3 id="10-React中constructor和getInitialState的区别"><a href="#10-React中constructor和getInitialState的区别" class="headerlink" title="10. React中constructor和getInitialState的区别?"></a>10. React中constructor和getInitialState的区别?</h3><p>两者都是用来初始化state的。前者是ES6中的语法，后者是ES5中的语法，新版本的React中已经废弃了该方法。</p><p>getInitialState是ES5中的方法，如果使用createClass方法创建一个Component组件，可以自动调用它的getInitialState方法来获取初始化的State对象，</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> <span class="hljs-variable constant_">APP</span> = <span class="hljs-title class_">React</span>.<span class="hljs-property">creatClass</span> (&#123;<br>  <span class="hljs-title function_">getInitialState</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> &#123; <br>        <span class="hljs-attr">userName</span>: <span class="hljs-string">&#x27;hi&#x27;</span>,<br>        <span class="hljs-attr">userId</span>: <span class="hljs-number">0</span><br>     &#125;;<br>　&#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p>React在ES6的实现中去掉了getInitialState这个hook函数，规定state在constructor中实现，如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Class</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">React</span>.<span class="hljs-property">Component</span>&#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">props</span>)&#123;<br>      <span class="hljs-variable language_">super</span>(props);<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>=&#123;&#125;;<br>    &#125;<br>  &#125;<br></code></pre></td></tr></table></figure><h3 id="11-React的严格模式如何使用，有什么用处？"><a href="#11-React的严格模式如何使用，有什么用处？" class="headerlink" title="11. React的严格模式如何使用，有什么用处？"></a>11. React的严格模式如何使用，有什么用处？</h3><p><code>StrictMode</code> 是一个用来突出显示应用程序中潜在问题的工具。与 <code>Fragment</code> 一样，<code>StrictMode</code> 不会渲染任何可见的 UI。它为其后代元素触发额外的检查和警告。<br>可以为应用程序的任何部分启用严格模式。例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">ExampleApplication</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Header</span> /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">React.StrictMode</span>&gt;</span>        </span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">          <span class="hljs-tag">&lt;<span class="hljs-name">ComponentOne</span> /&gt;</span></span><br><span class="language-xml">          <span class="hljs-tag">&lt;<span class="hljs-name">ComponentTwo</span> /&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">React.StrictMode</span>&gt;</span>      </span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Footer</span> /&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><p>在上述的示例中，不会对 <code>Header</code> 和 <code>Footer</code> 组件运行严格模式检查。但是，<code>ComponentOne</code> 和 <code>ComponentTwo</code> 以及它们的所有后代元素都将进行检查。</p><p><code>StrictMode</code> 目前有助于：</p><ul><li>识别不安全的生命周期</li><li>关于使用过时字符串 ref API 的警告</li><li>关于使用废弃的 findDOMNode 方法的警告</li><li>检测意外的副作用</li><li>检测过时的 context API</li></ul><h3 id="12-在React中遍历的方法有哪些？"><a href="#12-在React中遍历的方法有哪些？" class="headerlink" title="12. 在React中遍历的方法有哪些？"></a>12. 在React中遍历的方法有哪些？</h3><p><strong>（1）遍历数组：map &amp;&amp; forEach</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;<br>  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">let</span> arr = [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27;d&#x27;</span>];<br>    <span class="hljs-keyword">return</span> (<br>      <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span></span><br><span class="language-xml">        &#123;</span><br><span class="language-xml">          arr.map((item, index) =&gt; &#123;</span><br><span class="language-xml">            return <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&#123;index&#125;</span>&gt;</span>&#123;item&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br><span class="language-xml">          &#125;)</span><br><span class="language-xml">        &#125;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span><br>    )<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;<br>  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">let</span> arr = [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27;d&#x27;</span>];<br>    <span class="hljs-keyword">return</span> (<br>      <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span></span><br><span class="language-xml">        &#123;</span><br><span class="language-xml">          arr.forEach((item, index) =&gt; &#123;</span><br><span class="language-xml">            return <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&#123;index&#125;</span>&gt;</span>&#123;item&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br><span class="language-xml">          &#125;)</span><br><span class="language-xml">        &#125;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span><br>    )<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>（2）遍历对象：map &amp;&amp; for in</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;<br>  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">let</span> obj = &#123;<br>      <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>,<br>      <span class="hljs-attr">b</span>: <span class="hljs-number">2</span>,<br>      <span class="hljs-attr">c</span>: <span class="hljs-number">3</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> (<br>      <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span></span><br><span class="language-xml">        &#123;</span><br><span class="language-xml">          (() =&gt; &#123;</span><br><span class="language-xml">            let domArr = [];</span><br><span class="language-xml">            for(const key in obj) &#123;</span><br><span class="language-xml">              if(obj.hasOwnProperty(key)) &#123;</span><br><span class="language-xml">                const value = obj[key]</span><br><span class="language-xml">                domArr.push(<span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&#123;key&#125;</span>&gt;</span>&#123;value&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>)</span><br><span class="language-xml">              &#125;</span><br><span class="language-xml">            &#125;</span><br><span class="language-xml">            return domArr;</span><br><span class="language-xml">          &#125;)()</span><br><span class="language-xml">        &#125;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span><br>    )<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// Object.entries() 把对象转换成数组</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;<br>  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">let</span> obj = &#123;<br>      <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>,<br>      <span class="hljs-attr">b</span>: <span class="hljs-number">2</span>,<br>      <span class="hljs-attr">c</span>: <span class="hljs-number">3</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> (<br>      <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span></span><br><span class="language-xml">        &#123;</span><br><span class="language-xml">          Object.entries(obj).map(([key, value], index) =&gt; &#123;   // item是一个数组，把item解构，写法是[key, value]</span><br><span class="language-xml">            return <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&#123;key&#125;</span>&gt;</span>&#123;value&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br><span class="language-xml">          &#125;) </span><br><span class="language-xml">        &#125;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span><br>    )<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="13-在React中页面重新加载时怎样保留数据？"><a href="#13-在React中页面重新加载时怎样保留数据？" class="headerlink" title="13. 在React中页面重新加载时怎样保留数据？"></a>13. 在React中页面重新加载时怎样保留数据？</h3><p>这个问题就设计到了<strong>数据持久化，</strong> 主要的实现方式有以下几种：</p><ul><li><strong>Redux：</strong> 将页面的数据存储在redux中，在重新加载页面时，获取Redux中的数据；</li><li><strong>data.js：</strong> 使用webpack构建的项目，可以建一个文件，data.js，将数据保存data.js中，跳转页面后获取；</li><li><strong>sessionStorge：</strong> 在进入选择地址页面之前，componentWillUnMount的时候，将数据存储到sessionStorage中，每次进入页面判断sessionStorage中有没有存储的那个值，有，则读取渲染数据；没有，则说明数据是初始化的状态。返回或进入除了选择地址以外的页面，清掉存储的sessionStorage，保证下次进入是初始化的数据</li><li><strong>history API：</strong> History API 的 <code>pushState</code> 函数可以给历史记录关联一个任意的可序列化 <code>state</code>，所以可以在路由 <code>push</code> 的时候将当前页面的一些信息存到 <code>state</code> 中，下次返回到这个页面的时候就能从 <code>state</code> 里面取出离开前的数据重新渲染。react-router 直接可以支持。这个方法适合一些需要临时存储的场景。</li></ul><h3 id="14-同时引用这三个库react-js、react-dom-js和babel-js它们都有什么作用？"><a href="#14-同时引用这三个库react-js、react-dom-js和babel-js它们都有什么作用？" class="headerlink" title="14. 同时引用这三个库react.js、react-dom.js和babel.js它们都有什么作用？"></a>14. 同时引用这三个库react.js、react-dom.js和babel.js它们都有什么作用？</h3><ul><li>react：包含react所必须的核心代码</li><li>react-dom：react渲染在不同平台所需要的核心代码</li><li>babel：将jsx转换成React代码的工具</li></ul><h3 id="15-React必须使用JSX吗？"><a href="#15-React必须使用JSX吗？" class="headerlink" title="15. React必须使用JSX吗？"></a>15. React必须使用JSX吗？</h3><p>React 并不强制要求使用 JSX。当不想在构建环境中配置有关 JSX 编译时，不在 React 中使用 JSX 会更加方便。</p><p>每个 JSX 元素只是调用 <code>React.createElement(component, props, ...children)</code> 的语法糖。因此，使用 JSX 可以完成的任何事情都可以通过纯 JavaScript 完成。</p><p>例如，用 JSX 编写的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Hello</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;<br>  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>Hello &#123;this.props.toWhat&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;<br>  &#125;<br>&#125;<br><span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">render</span>(<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Hello</span> <span class="hljs-attr">toWhat</span>=<span class="hljs-string">&quot;World&quot;</span> /&gt;</span></span>,<br>  <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;root&#x27;</span>)<br>);<br></code></pre></td></tr></table></figure><p>可以编写为不使用 JSX 的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Hello</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;<br>  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">React</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;div&#x27;</span>, <span class="hljs-literal">null</span>, <span class="hljs-string">`Hello <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.props.toWhat&#125;</span>`</span>);<br>  &#125;<br>&#125;<br><span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">render</span>(<br>  <span class="hljs-title class_">React</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-title class_">Hello</span>, &#123;<span class="hljs-attr">toWhat</span>: <span class="hljs-string">&#x27;World&#x27;</span>&#125;, <span class="hljs-literal">null</span>),<br>  <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;root&#x27;</span>)<br>);<br></code></pre></td></tr></table></figure><h3 id="16-为什么使用jsx的组件中没有看到使用react却需要引入react？"><a href="#16-为什么使用jsx的组件中没有看到使用react却需要引入react？" class="headerlink" title="16. 为什么使用jsx的组件中没有看到使用react却需要引入react？"></a>16. 为什么使用jsx的组件中没有看到使用react却需要引入react？</h3><p>本质上来说JSX是<code>React.createElement(component, props, ...children)</code>方法的语法糖。在React 17之前，如果使用了JSX，其实就是在使用React， <code>babel</code> 会把组件转换为 <code>CreateElement</code> 形式。在React 17之后，就不再需要引入，因为 <code>babel</code> 已经可以帮我们自动引入react。</p><h3 id="17-在React中怎么使用async-x2F-await？"><a href="#17-在React中怎么使用async-x2F-await？" class="headerlink" title="17. 在React中怎么使用async&#x2F;await？"></a>17. 在React中怎么使用async&#x2F;await？</h3><p>async&#x2F;await是ES7标准中的新特性。如果是使用React官方的脚手架创建的项目，就可以直接使用。如果是在自己搭建的webpack配置的项目中使用，可能会遇到 <strong>regeneratorRuntime is not defined</strong> 的异常错误。那么我们就需要引入babel，并在babel中配置使用async&#x2F;await。可以利用babel的 transform-async-to-module-method 插件来转换其成为浏览器支持的语法，虽然没有性能的提升，但对于代码编写体验要更好。</p><h3 id="18-React-Children-map和js的map有什么区别？"><a href="#18-React-Children-map和js的map有什么区别？" class="headerlink" title="18. React.Children.map和js的map有什么区别？"></a>18. React.Children.map和js的map有什么区别？</h3><p>JavaScript中的map不会对为null或者undefined的数据进行处理，而React.Children.map中的map可以处理React.Children为null或者undefined的情况。</p><h3 id="19-对React-SSR的理解"><a href="#19-对React-SSR的理解" class="headerlink" title="19. 对React SSR的理解"></a>19. 对React SSR的理解</h3><p>服务端渲染是数据与模版组成的html，即 HTML &#x3D; 数据 ＋ 模版。将组件或页面通过服务器生成html字符串，再发送到浏览器，最后将静态标记”混合”为客户端上完全交互的应用程序。页面没使用服务渲染，当请求页面时，返回的body里为空，之后执行js将html结构注入到body里，结合css显示出来;</p><p><strong>SSR的优势：</strong></p><ul><li>对SEO友好</li><li>所有的模版、图片等资源都存在服务器端 </li><li>一个html返回所有数据 </li><li>减少HTTP请求</li><li>响应快、用户体验好、首屏渲染快</li></ul><p><strong>1）更利于SEO</strong></p><p> 不同爬虫工作原理类似，只会爬取源码，不会执行网站的任何脚本使用了React或者其它MVVM框架之后，页面大多数DOM元素都是在客户端根据js动态生成，可供爬虫抓取分析的内容大大减少。另外，浏览器爬虫不会等待我们的数据完成之后再去抓取页面数据。服务端渲染返回给客户端的是已经获取了异步数据并执行JavaScript脚本的最终HTML，网络爬中就可以抓取到完整页面的信息。</p><p><strong>2）更利于首屏渲染</strong></p><p>首屏的渲染是node发送过来的html字符串，并不依赖于js文件了，这就会使用户更快的看到页面的内容。尤其是针对大型单页应用，打包后文件体积比较大，普通客户端渲染加载所有所需文件时间较长，首页就会有一个很长的白屏等待时间。</p><p><strong>SSR的局限：</strong></p><p><strong>1）服务端压力较大</strong></p><p>本来是通过客户端完成渲染，现在统一到服务端node服务去做。尤其是高并发访问的情况，会大量占用服务端CPU资源;</p><p><strong>2）开发条件受限</strong></p><p>在服务端渲染中，只会执行到componentDidMount之前的生命周期钩子，因此项目引用的第三方的库也不可用其它生命周期钩子，这对引用库的选择产生了很大的限制; </p><p><strong>3）学习成本相对较高</strong><br>除了对webpack、MVVM框架要熟悉，还需要掌握node、 Koa2等相关技术。相对于客户端渲染，项目构建、部署过程更加复杂。</p><p><strong>时间耗时比较：</strong></p><p><strong>1）数据请求</strong></p><p>由服务端请求首屏数据，而不是客户端请求首屏数据，这是”快”的一个主要原因。服务端在内网进行请求，数据响应速度快。客户端在不同网络环境进行数据请求，且外网http请求开销大，导致时间差 </p><ul><li>客户端数据请求</li></ul><p><img src="5.jpg" alt="img"></p><ul><li>服务端数据请求</li></ul><p><img src="6.jpg" alt="img"><br><strong>2)html渲染</strong><br>服务端渲染是先向后端服务器请求数据，然后生成完整首屏 html返回给浏览器；而客户端渲染是等js代码下载、加载、解析完成后再请求数据渲染，等待的过程页面是什么都没有的，就是用户看到的白屏。就是服务端渲染不需要等待js代码下载完成并请求数据，就可以返回一个已有完整数据的首屏页面。</p><ul><li>非ssr html渲染</li></ul><p><img src="7.jpg" alt="img"></p><ul><li>ssr html渲染</li></ul><p><img src="8.jpg" alt="img"></p><h3 id="20-为什么-React-要用-JSX？"><a href="#20-为什么-React-要用-JSX？" class="headerlink" title="20. 为什么 React 要用 JSX？"></a>20. 为什么 React 要用 JSX？</h3><p>JSX 是一个 JavaScript 的语法扩展，或者说是一个类似于 XML 的 ECMAScript 语法扩展。它本身没有太多的语法定义，也不期望引入更多的标准。</p><p>其实 React 本身并不强制使用 JSX。在没有 JSX 的时候，React 实现一个组件依赖于使用 React.createElement 函数。代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Hello</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;<br>  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">React</span>.<span class="hljs-title function_">createElement</span>(<br>        <span class="hljs-string">&#x27;div&#x27;</span>,<br>        <span class="hljs-literal">null</span>, <br>        <span class="hljs-string">`Hello <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.props.toWhat&#125;</span>`</span><br>      );<br>  &#125;<br>&#125;<br><span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">render</span>(<br>  <span class="hljs-title class_">React</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-title class_">Hello</span>, &#123;<span class="hljs-attr">toWhat</span>: <span class="hljs-string">&#x27;World&#x27;</span>&#125;, <span class="hljs-literal">null</span>),<br>  <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;root&#x27;</span>)<br>);<br></code></pre></td></tr></table></figure><p>而 JSX 更像是一种语法糖，通过类似 XML 的描述方式，描写函数对象。在采用 JSX 之后，这段代码会这样写：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Hello</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;<br>  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>Hello &#123;this.props.toWhat&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;<br>  &#125;<br>&#125;<br><span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">render</span>(<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Hello</span> <span class="hljs-attr">toWhat</span>=<span class="hljs-string">&quot;World&quot;</span> /&gt;</span></span>,<br>  <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;root&#x27;</span>)<br>);<br></code></pre></td></tr></table></figure><p>通过对比，可以清晰地发现，代码变得更为简洁，而且代码结构层次更为清晰。</p><p>因为 React 需要将组件转化为虚拟 DOM 树，所以在编写代码时，实际上是在手写一棵结构树。而<strong>XML 在树结构的描述上天生具有可读性强的优势。</strong></p><p>但这样可读性强的代码仅仅是给写程序的同学看的，实际上在运行的时候，会使用 Babel 插件将 JSX 语法的代码还原为 React.createElement 的代码。</p><p><strong>总结：</strong><br>JSX 是一个 JavaScript 的语法扩展，结构类似 XML。JSX 主要用于声明 React 元素，但 React 中并不强制使用 JSX。即使使用了 JSX，也会在构建过程中，通过 Babel 插件编译为 React.createElement。所以 JSX 更像是 React.createElement 的一种语法糖。</p><p>React 团队并不想引入 JavaScript 本身以外的开发体系。而是希望通过合理的关注点分离保持组件开发的纯粹性。</p><h3 id="21-HOC相比-mixins-有什么优点？"><a href="#21-HOC相比-mixins-有什么优点？" class="headerlink" title="21. HOC相比 mixins 有什么优点？"></a>21. HOC相比 mixins 有什么优点？</h3><p>HOC 和 Vue 中的 mixins 作用是一致的，并且在早期 React 也是使用 mixins 的方式。但是在使用 class 的方式创建组件以后，mixins 的方式就不能使用了，并且其实 mixins 也是存在一些问题的，比如：</p><ul><li>隐含了一些依赖，比如我在组件中写了某个 <code>state</code> 并且在 <code>mixin</code> 中使用了，就这存在了一个依赖关系。万一下次别人要移除它，就得去 <code>mixin</code> 中查找依赖</li><li>多个 <code>mixin</code> 中可能存在相同命名的函数，同时代码组件中也不能出现相同命名的函数，否则就是重写了，其实我一直觉得命名真的是一件麻烦事。。</li><li>雪球效应，虽然我一个组件还是使用着同一个 <code>mixin</code>，但是一个 <code>mixin</code> 会被多个组件使用，可能会存在需求使得 <code>mixin</code> 修改原本的函数或者新增更多的函数，这样可能就会产生一个维护成本</li></ul><p>HOC 解决了这些问题，并且它们达成的效果也是一致的，同时也更加的政治正确（毕竟更加函数式了）。</p><h3 id="22-React-中的高阶组件运用了什么设计模式？"><a href="#22-React-中的高阶组件运用了什么设计模式？" class="headerlink" title="22. React 中的高阶组件运用了什么设计模式？"></a>22. React 中的高阶组件运用了什么设计模式？</h3><p>使用了装饰模式，高阶组件的运用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">withWindowWidth</span>(<span class="hljs-params">BaseComponent</span>) &#123;<br>  <span class="hljs-keyword">class</span> <span class="hljs-title class_">DerivedClass</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;<br>    state = &#123;<br>      <span class="hljs-attr">windowWidth</span>: <span class="hljs-variable language_">window</span>.<span class="hljs-property">innerWidth</span>,<br>    &#125;<br>    onResize = <span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123;<br>        <span class="hljs-attr">windowWidth</span>: <span class="hljs-variable language_">window</span>.<span class="hljs-property">innerWidth</span>,<br>      &#125;)<br>    &#125;<br>    <span class="hljs-title function_">componentDidMount</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;resize&#x27;</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">onResize</span>)<br>    &#125;<br>    <span class="hljs-title function_">componentWillUnmount</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">removeEventListener</span>(<span class="hljs-string">&#x27;resize&#x27;</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">onResize</span>);<br>    &#125;<br>    <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">BaseComponent</span> &#123;<span class="hljs-attr">...this.props</span>&#125; &#123;<span class="hljs-attr">...this.state</span>&#125;/&gt;</span></span><br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title class_">DerivedClass</span>;<br>&#125;<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">MyComponent</span> = (<span class="hljs-params">props</span>) =&gt; &#123;<br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>Window width is: &#123;props.windowWidth&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>&#125;;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">withWindowWidth</span>(<span class="hljs-title class_">MyComponent</span>);<br></code></pre></td></tr></table></figure><p>装饰模式的特点是不需要改变 被装饰对象 本身，而只是在外面套一个外壳接口。JavaScript 目前已经有了原生装饰器的提案，其用法如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript">@testable<br>   <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyTestableClass</span> &#123;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>BGW</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>BGW-React1</title>
    <link href="/2023/04/18/BGW-React1/"/>
    <url>/2023/04/18/BGW-React1/</url>
    
    <content type="html"><![CDATA[<p>BGW-React1</p><p><img src="1.png" alt="img"></p><h2 id="一、组件基础"><a href="#一、组件基础" class="headerlink" title="一、组件基础"></a>一、组件基础</h2><h3 id="1-React-事件机制"><a href="#1-React-事件机制" class="headerlink" title="1. React 事件机制"></a>1. React 事件机制</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;div onClick=&#123;<span class="hljs-variable language_">this</span>.<span class="hljs-property">handleClick</span>.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>)&#125;&gt;点我&lt;/div&gt;<br></code></pre></td></tr></table></figure><p>React并不是将click事件绑定到了div的真实DOM上，而是在document处监听了所有的事件，当事件发生并且冒泡到document处的时候，React将事件内容封装并交由真正的处理函数运行。这样的方式不仅仅减少了内存的消耗，还能在组件挂在销毁时统一订阅和移除事件。</p><p>除此之外，冒泡到document上的事件也不是原生的浏览器事件，而是由react自己实现的合成事件（SyntheticEvent）。因此如果不想要是事件冒泡的话应该调用event.preventDefault()方法，而不是调用event.stopProppagation()方法。<br><img src="2.png" alt="img"><br>JSX 上写的事件并没有绑定在对应的真实 DOM 上，而是通过事件代理的方式，将所有的事件都统一绑定在了 <code>document</code> 上。这样的方式不仅减少了内存消耗，还能在组件挂载销毁时统一订阅和移除事件。</p><p>另外冒泡到 <code>document</code> 上的事件也不是原生浏览器事件，而是 React 自己实现的合成事件（SyntheticEvent）。因此我们如果不想要事件冒泡的话，调用 <code>event.stopPropagation</code> 是无效的，而应该调用 <code>event.preventDefault</code>。</p><p>实现合成事件的目的如下：</p><ul><li>合成事件首先抹平了浏览器之间的兼容问题，另外这是一个跨浏览器原生事件包装器，赋予了跨浏览器开发的能力；</li><li>对于原生浏览器事件来说，浏览器会给监听器创建一个事件对象。如果你有很多的事件监听，那么就需要分配很多的事件对象，造成高额的内存分配问题。但是对于合成事件来说，有一个事件池专门来管理它们的创建和销毁，当事件需要被使用时，就会从池子中复用对象，事件回调结束后，就会销毁事件对象上的属性，从而便于下次复用事件对象。</li></ul><h3 id="2-React的事件和普通的HTML事件有什么不同？"><a href="#2-React的事件和普通的HTML事件有什么不同？" class="headerlink" title="2. React的事件和普通的HTML事件有什么不同？"></a>2. React的事件和普通的HTML事件有什么不同？</h3><p>区别：</p><ul><li>对于事件名称命名方式，原生事件为全小写，react 事件采用小驼峰；</li><li>对于事件函数处理语法，原生事件为字符串，react 事件为函数；</li><li>react 事件不能采用 return false 的方式来阻止浏览器的默认行为，而必须要地明确地调用<code>preventDefault()</code>来阻止默认行为。</li></ul><p>合成事件是 react 模拟原生 DOM 事件所有能力的一个事件对象，其优点如下：</p><ul><li>兼容所有浏览器，更好的跨平台；</li><li>将事件统一存放在一个数组，避免频繁的新增与删除（垃圾回收）。</li><li>方便 react 统一管理和事务机制。</li></ul><p>事件的执行顺序为原生事件先执行，合成事件后执行，合成事件会冒泡绑定到 document 上，所以尽量避免原生事件与合成事件混用，如果原生事件阻止冒泡，可能会导致合成事件不执行，因为需要冒泡到document 上合成事件才会执行。</p><h3 id="3-React-组件中怎么做事件代理？它的原理是什么？"><a href="#3-React-组件中怎么做事件代理？它的原理是什么？" class="headerlink" title="3. React 组件中怎么做事件代理？它的原理是什么？"></a>3. React 组件中怎么做事件代理？它的原理是什么？</h3><p>React基于Virtual DOM实现了一个SyntheticEvent层（合成事件层），定义的事件处理器会接收到一个合成事件对象的实例，它符合W3C标准，且与原生的浏览器事件拥有同样的接口，支持冒泡机制，所有的事件都自动绑定在最外层上。</p><p>在React底层，主要对合成事件做了两件事：</p><ul><li><strong>事件委派：</strong> React会把所有的事件绑定到结构的最外层，使用统一的事件监听器，这个事件监听器上维持了一个映射来保存所有组件内部事件监听和处理函数。</li><li><strong>自动绑定：</strong> React组件中，每个方法的上下文都会指向该组件的实例，即自动绑定this为当前组件。</li></ul><h3 id="4-React-高阶组件、Render-props、hooks-有什么区别，为什么要不断迭代"><a href="#4-React-高阶组件、Render-props、hooks-有什么区别，为什么要不断迭代" class="headerlink" title="4. React 高阶组件、Render props、hooks 有什么区别，为什么要不断迭代"></a>4. React 高阶组件、Render props、hooks 有什么区别，为什么要不断迭代</h3><p>这三者是目前react解决代码复用的主要方式：</p><ul><li>高阶组件（HOC）是 React 中用于复用组件逻辑的一种高级技巧。HOC 自身不是 React API 的一部分，它是一种基于 React 的组合特性而形成的设计模式。具体而言，高阶组件是参数为组件，返回值为新组件的函数。</li><li>render props是指一种在 React 组件之间使用一个值为函数的 prop 共享代码的简单技术，更具体的说，render prop 是一个用于告知组件需要渲染什么内容的函数 prop。</li><li>通常，render props 和高阶组件只渲染一个子节点。让 Hook 来服务这个使用场景更加简单。这两种模式仍有用武之地，（例如，一个虚拟滚动条组件或许会有一个 renderltem 属性，或是一个可见的容器组件或许会有它自己的 DOM 结构）。但在大部分场景下，Hook 足够了，并且能够帮助减少嵌套。</li></ul><p><strong>（1）HOC</strong><br>官方解释∶ </p><blockquote><p>高阶组件（HOC）是 React 中用于复用组件逻辑的一种高级技巧。HOC 自身不是 React API 的一部分，它是一种基于 React 的组合特性而形成的设计模式。</p></blockquote><p>简言之，HOC是一种组件的设计模式，HOC接受一个组件和额外的参数（如果需要），返回一个新的组件。HOC 是纯函数，没有副作用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// hoc的定义</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">withSubscription</span>(<span class="hljs-params">WrappedComponent, selectData</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">extends</span> <span class="hljs-title class_">React</span>.<span class="hljs-property">Component</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">props</span>) &#123;<br>      <span class="hljs-variable language_">super</span>(props);<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = &#123;<br>        <span class="hljs-attr">data</span>: <span class="hljs-title function_">selectData</span>(<span class="hljs-title class_">DataSource</span>, props)<br>      &#125;;<br>    &#125;<br>    <span class="hljs-comment">// 一些通用的逻辑处理</span><br>    <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-comment">// ... 并使用新数据渲染被包装的组件!</span><br>      <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">WrappedComponent</span> <span class="hljs-attr">data</span>=<span class="hljs-string">&#123;this.state.data&#125;</span> &#123;<span class="hljs-attr">...this.props</span>&#125; /&gt;</span></span>;<br>    &#125;<br>  &#125;;<br><br><span class="hljs-comment">// 使用</span><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">BlogPostWithSubscription</span> = <span class="hljs-title function_">withSubscription</span>(<span class="hljs-title class_">BlogPost</span>,<br>  <span class="hljs-function">(<span class="hljs-params">DataSource, props</span>) =&gt;</span> <span class="hljs-title class_">DataSource</span>.<span class="hljs-title function_">getBlogPost</span>(props.<span class="hljs-property">id</span>));<br></code></pre></td></tr></table></figure><p>HOC的优缺点∶</p><ul><li>优点∶ 逻辑服用、不影响被包裹组件的内部逻辑。 </li><li>缺点∶ hoc传递给被包裹组件的props容易和被包裹后的组件重名，进而被覆盖</li></ul><p><strong>（2）Render props</strong><br>官方解释∶</p><blockquote><p>“render prop”是指一种在 React 组件之间使用一个值为函数的 prop 共享代码的简单技术</p></blockquote><p>具有render prop 的组件接受一个返回React元素的函数，将render的渲染逻辑注入到组件内部。在这里，”render”的命名可以是任何其他有效的标识符。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// DataProvider组件内部的渲染逻辑如下</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">DataProvider</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Components</span> &#123;<br>     state = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Tom&#x27;</span><br>  &#125;<br><br>    <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> (<br>        <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">          <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>共享数据组件自己内部的渲染逻辑<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">          &#123; this.props.render(this.state) &#125;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>    );<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 调用方式</span><br>&lt;<span class="hljs-title class_">DataProvider</span> render=&#123;<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> (<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Hello &#123;data.name&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br>)&#125;/&gt;<br><br></code></pre></td></tr></table></figure><p>由此可以看到，render props的优缺点也很明显∶</p><ul><li>优点：数据共享、代码复用，将组件内的state作为props传递给调用者，将渲染逻辑交给调用者。</li><li>缺点：无法在 return 语句外访问数据、嵌套写法不够优雅</li></ul><p><strong>（3）Hooks</strong><br>官方解释∶</p><blockquote><p>Hook是 React 16.8 的新增特性。它可以让你在不编写 class 的情况下使用 state 以及其他的 React 特性。通过自定义hook，可以复用代码逻辑。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 自定义一个获取订阅数据的hook</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">useSubscription</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> data = <span class="hljs-title class_">DataSource</span>.<span class="hljs-title function_">getComments</span>();<br>  <span class="hljs-keyword">return</span> [data];<br>&#125;<br><span class="hljs-comment">// </span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">CommentList</span>(<span class="hljs-params">props</span>) &#123;<br>  <span class="hljs-keyword">const</span> &#123;data&#125; = props;<br>  <span class="hljs-keyword">const</span> [subData] = <span class="hljs-title function_">useSubscription</span>();<br>    ...<br>&#125;<br><span class="hljs-comment">// 使用</span><br>&lt;<span class="hljs-title class_">CommentList</span> data=<span class="hljs-string">&#x27;hello&#x27;</span> /&gt;<br></code></pre></td></tr></table></figure><p>以上可以看出，hook解决了hoc的prop覆盖的问题，同时使用的方式解决了render props的嵌套地狱的问题。hook的优点如下∶ </p><ul><li>使用直观；</li><li>解决hoc的prop 重名问题；</li><li>解决render props 因共享数据 而出现嵌套地狱的问题；</li><li>能在return之外使用数据的问题。</li></ul><p>需要注意的是：hook只能在组件顶层使用，不可在分支语句中使用。</p><p><strong>总结∶</strong><br>Hoc、render props和hook都是为了解决代码复用的问题，但是hoc和render props都有特定的使用场景和明显的缺点。hook是react16.8更新的新的API，让组件逻辑复用更简洁明了，同时也解决了hoc和render props的一些缺点。</p><h3 id="5-对React-Fiber的理解，它解决了什么问题？"><a href="#5-对React-Fiber的理解，它解决了什么问题？" class="headerlink" title="5. 对React-Fiber的理解，它解决了什么问题？"></a>5. 对React-Fiber的理解，它解决了什么问题？</h3><p>React V15 在渲染时，会递归比对 VirtualDOM 树，找出需要变动的节点，然后同步更新它们， 一气呵成。这个过程期间， React 会占据浏览器资源，这会导致用户触发的事件得不到响应，并且会导致掉帧，<strong>导致用户感觉到卡顿</strong>。</p><p>为了给用户制造一种应用很快的“假象”，不能让一个任务长期霸占着资源。 可以将浏览器的渲染、布局、绘制、资源加载(例如 HTML 解析)、事件响应、脚本执行视作操作系统的“进程”，需要通过某些调度策略合理地分配 CPU 资源，从而提高浏览器的用户响应速率, 同时兼顾任务执行效率。</p><p>所以 React 通过Fiber 架构，让这个执行过程变成可被中断。“适时”地让出 CPU 执行权，除了可以让浏览器及时地响应用户的交互，还有其他好处:</p><ul><li>分批延时对DOM进行操作，避免一次性操作大量 DOM 节点，可以得到更好的用户体验；</li><li>给浏览器一点喘息的机会，它会对代码进行编译优化（JIT）及进行热代码优化，或者对 reflow 进行修正。</li></ul><p><strong>核心思想:</strong> Fiber 也称协程或者纤程。它和线程并不一样，协程本身是没有并发或者并行能力的（需要配合线程），它只是一种控制流程的让出机制。让出 CPU 的执行权，让 CPU 能在这段时间执行其他的操作。渲染的过程可以被中断，可以将控制权交回浏览器，让位给高优先级的任务，浏览器空闲后再恢复渲染。</p><h3 id="6-React-Component-和-React-PureComponent-的区别"><a href="#6-React-Component-和-React-PureComponent-的区别" class="headerlink" title="6. React.Component 和 React.PureComponent 的区别"></a>6. React.Component 和 React.PureComponent 的区别</h3><p>PureComponent表示一个纯组件，可以用来优化React程序，减少render函数执行的次数，从而提高组件的性能。</p><p>在React中，当prop或者state发生变化时，可以通过在shouldComponentUpdate生命周期函数中执行return false来阻止页面的更新，从而减少不必要的render执行。React.PureComponent会自动执行 shouldComponentUpdate。</p><p>不过，pureComponent中的 shouldComponentUpdate() 进行的是<strong>浅比较</strong>，也就是说如果是引用数据类型的数据，只会比较不是同一个地址，而不会比较这个地址里面的数据是否一致。浅比较会忽略属性和或状态突变情况，其实也就是数据引用指针没有变化，而数据发生改变的时候render是不会执行的。如果需要重新渲染那么就需要重新开辟空间引用数据。PureComponent一般会用在一些纯展示组件上。</p><p>使用pureComponent的<strong>好处</strong>：当组件更新时，如果组件的props或者state都没有改变，render函数就不会触发。省去虚拟DOM的生成和对比过程，达到提升性能的目的。这是因为react自动做了一层浅比较。</p><h3 id="7-Component-Element-Instance-之间有什么区别和联系？"><a href="#7-Component-Element-Instance-之间有什么区别和联系？" class="headerlink" title="7. Component, Element, Instance 之间有什么区别和联系？"></a>7. Component, Element, Instance 之间有什么区别和联系？</h3><ul><li><strong>元素：</strong> 一个元素<code>element</code>是一个普通对象(plain object)，描述了对于一个DOM节点或者其他组件<code>component</code>，你想让它在屏幕上呈现成什么样子。元素<code>element</code>可以在它的属性<code>props</code>中包含其他元素(译注:用于形成元素树)。创建一个React元素<code>element</code>成本很低。元素<code>element</code>创建之后是不可变的。</li><li><strong>组件：</strong> 一个组件<code>component</code>可以通过多种方式声明。可以是带有一个<code>render()</code>方法的类，简单点也可以定义为一个函数。这两种情况下，它都把属性<code>props</code>作为输入，把返回的一棵元素树作为输出。</li><li><strong>实例：</strong> 一个实例<code>instance</code>是你在所写的组件类<code>component class</code>中使用关键字<code>this</code>所指向的东西(译注:组件实例)。它用来存储本地状态和响应生命周期事件很有用。</li></ul><p>函数式组件(<code>Functional component</code>)根本没有实例<code>instance</code>。类组件(<code>Class component</code>)有实例<code>instance</code>，但是永远也不需要直接创建一个组件的实例，因为React帮我们做了这些。</p><h3 id="8-React-createClass和extends-Component的区别有哪些？"><a href="#8-React-createClass和extends-Component的区别有哪些？" class="headerlink" title="8. React.createClass和extends Component的区别有哪些？"></a>8. React.createClass和extends Component的区别有哪些？</h3><p>React.createClass和extends Component的bai区别主要在于：</p><p><strong>（1）语法区别</strong></p><ul><li>createClass本质上是一个工厂函数，extends的方式更加接近最新的ES6规范的class写法。两种方式在语法上的差别主要体现在方法的定义和静态属性的声明上。</li><li>createClass方式的方法定义使用逗号，隔开，因为creatClass本质上是一个函数，传递给它的是一个Object；而class的方式定义方法时务必谨记不要使用逗号隔开，这是ES6 class的语法规范。</li></ul><p><strong>（2）propType 和 getDefaultProps</strong></p><ul><li>React.createClass：通过proTypes对象和getDefaultProps()方法来设置和获取props.</li><li>React.Component：通过设置两个属性propTypes和defaultProps</li></ul><p><strong>（3）状态的区别</strong></p><ul><li>React.createClass：通过getInitialState()方法返回一个包含初始值的对象</li><li>React.Component：通过constructor设置初始状态</li></ul><p><strong>（4）this区别</strong></p><ul><li>React.createClass：会正确绑定this</li><li>React.Component：由于使用了 ES6，这里会有些微不同，属性并不会自动绑定到 React 类的实例上。</li></ul><p><strong>（5）Mixins</strong></p><ul><li>React.createClass：使用 React.createClass 的话，可以在创建组件时添加一个叫做 mixins 的属性，并将可供混合的类的集合以数组的形式赋给 mixins。</li><li>如果使用 ES6 的方式来创建组件，那么 <code>React mixins</code> 的特性将不能被使用了。</li></ul><h3 id="9-React-高阶组件是什么，和普通组件有什么区别，适用什么场景"><a href="#9-React-高阶组件是什么，和普通组件有什么区别，适用什么场景" class="headerlink" title="9. React 高阶组件是什么，和普通组件有什么区别，适用什么场景"></a>9. React 高阶组件是什么，和普通组件有什么区别，适用什么场景</h3><p>官方解释∶ </p><blockquote><p>高阶组件（HOC）是 React 中用于复用组件逻辑的一种高级技巧。HOC 自身不是 React API 的一部分，它是一种基于 React 的组合特性而形成的设计模式。</p></blockquote><p>高阶组件（HOC）就是一个函数，且该函数接受一个组件作为参数，并返回一个新的组件，它只是一种组件的设计模式，这种设计模式是由react自身的组合性质必然产生的。我们将它们称为纯组件，因为它们可以接受任何动态提供的子组件，但它们不会修改或复制其输入组件中的任何行为。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// hoc的定义</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">withSubscription</span>(<span class="hljs-params">WrappedComponent, selectData</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">extends</span> <span class="hljs-title class_">React</span>.<span class="hljs-property">Component</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">props</span>) &#123;<br>      <span class="hljs-variable language_">super</span>(props);<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = &#123;<br>        <span class="hljs-attr">data</span>: <span class="hljs-title function_">selectData</span>(<span class="hljs-title class_">DataSource</span>, props)<br>      &#125;;<br>    &#125;<br>    <span class="hljs-comment">// 一些通用的逻辑处理</span><br>    <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-comment">// ... 并使用新数据渲染被包装的组件!</span><br>      <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">WrappedComponent</span> <span class="hljs-attr">data</span>=<span class="hljs-string">&#123;this.state.data&#125;</span> &#123;<span class="hljs-attr">...this.props</span>&#125; /&gt;</span></span>;<br>    &#125;<br>  &#125;;<br><br><span class="hljs-comment">// 使用</span><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">BlogPostWithSubscription</span> = <span class="hljs-title function_">withSubscription</span>(<span class="hljs-title class_">BlogPost</span>,<br>  <span class="hljs-function">(<span class="hljs-params">DataSource, props</span>) =&gt;</span> <span class="hljs-title class_">DataSource</span>.<span class="hljs-title function_">getBlogPost</span>(props.<span class="hljs-property">id</span>));<br></code></pre></td></tr></table></figure><p><strong>1）HOC的优缺点</strong></p><ul><li>优点∶ 逻辑服用、不影响被包裹组件的内部逻辑。</li><li>缺点∶hoc传递给被包裹组件的props容易和被包裹后的组件重名，进而被覆盖</li></ul><p><strong>2）适用场景</strong></p><ul><li>代码复用，逻辑抽象 </li><li>渲染劫持 </li><li>State 抽象和更改 </li><li>Props 更改</li></ul><p><strong>3）具体应用例子</strong></p><ul><li><strong>权限控制：</strong> 利用高阶组件的 <strong>条件渲染</strong> 特性可以对页面进行权限控制，权限控制一般分为两个维度：页面级别和 页面元素级别</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// HOC.js</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">withAdminAuth</span>(<span class="hljs-params">WrappedComponent</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">extends</span> <span class="hljs-title class_">React</span>.<span class="hljs-property">Component</span> &#123;<br>        state = &#123;<br>            <span class="hljs-attr">isAdmin</span>: <span class="hljs-literal">false</span>,<br>        &#125;<br>        <span class="hljs-keyword">async</span> <span class="hljs-title function_">UNSAFE_componentWillMount</span>(<span class="hljs-params"></span>) &#123;<br>            <span class="hljs-keyword">const</span> currentRole = <span class="hljs-keyword">await</span> <span class="hljs-title function_">getCurrentUserRole</span>();<br>            <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123;<br>                <span class="hljs-attr">isAdmin</span>: currentRole === <span class="hljs-string">&#x27;Admin&#x27;</span>,<br>            &#125;);<br>        &#125;<br>        <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">isAdmin</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">WrappedComponent</span> &#123;<span class="hljs-attr">...this.props</span>&#125; /&gt;</span></span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">return</span> (<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>您没有权限查看该页面，请联系管理员！<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>);<br>            &#125;<br>        &#125;<br>    &#125;;<br>&#125;<br><br><span class="hljs-comment">// pages/page-a.js</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">PageA</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">props</span>) &#123;<br>        <span class="hljs-variable language_">super</span>(props);<br>        <span class="hljs-comment">// something here...</span><br>    &#125;<br>    <span class="hljs-title function_">UNSAFE_componentWillMount</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-comment">// fetching data</span><br>    &#125;<br>    <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-comment">// render page with data</span><br>    &#125;<br>&#125;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">withAdminAuth</span>(<span class="hljs-title class_">PageA</span>);<br><br><br><span class="hljs-comment">// pages/page-b.js</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">PageB</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">props</span>) &#123;<br>        <span class="hljs-variable language_">super</span>(props);<br>    <span class="hljs-comment">// something here...</span><br>        &#125;<br>    <span class="hljs-title function_">UNSAFE_componentWillMount</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// fetching data</span><br>    &#125;<br>    <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// render page with data</span><br>    &#125;<br>&#125;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">withAdminAuth</span>(<span class="hljs-title class_">PageB</span>);<br></code></pre></td></tr></table></figure><ul><li><strong>组件渲染性能追踪：</strong> 借助父组件子组件生命周期规则捕获子组件的生命周期，可以方便的对某个组件的渲染时间进行记录∶</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Home</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;<br>        <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>            <span class="hljs-keyword">return</span> (<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Hello World.<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">withTiming</span>(<span class="hljs-params">WrappedComponent</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">extends</span> <span class="hljs-title class_">WrappedComponent</span> &#123;<br>            <span class="hljs-title function_">constructor</span>(<span class="hljs-params">props</span>) &#123;<br>                <span class="hljs-variable language_">super</span>(props);<br>                <span class="hljs-variable language_">this</span>.<span class="hljs-property">start</span> = <span class="hljs-number">0</span>;<br>                <span class="hljs-variable language_">this</span>.<span class="hljs-property">end</span> = <span class="hljs-number">0</span>;<br>            &#125;<br>            <span class="hljs-title function_">UNSAFE_componentWillMount</span>(<span class="hljs-params"></span>) &#123;<br>                <span class="hljs-variable language_">super</span>.<span class="hljs-property">componentWillMount</span> &amp;&amp; <span class="hljs-variable language_">super</span>.<span class="hljs-title function_">componentWillMount</span>();<br>                <span class="hljs-variable language_">this</span>.<span class="hljs-property">start</span> = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>();<br>            &#125;<br>            <span class="hljs-title function_">componentDidMount</span>(<span class="hljs-params"></span>) &#123;<br>                <span class="hljs-variable language_">super</span>.<span class="hljs-property">componentDidMount</span> &amp;&amp; <span class="hljs-variable language_">super</span>.<span class="hljs-title function_">componentDidMount</span>();<br>                <span class="hljs-variable language_">this</span>.<span class="hljs-property">end</span> = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>();<br>                <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;WrappedComponent.name&#125;</span> 组件渲染时间为 <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.end - <span class="hljs-variable language_">this</span>.start&#125;</span> ms`</span>);<br>            &#125;<br>            <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-variable language_">super</span>.<span class="hljs-title function_">render</span>();<br>            &#125;<br>        &#125;;<br>    &#125;<br><br>    <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">withTiming</span>(<span class="hljs-title class_">Home</span>);   <br><br><br></code></pre></td></tr></table></figure><p>注意：withTiming 是利用 反向继承 实现的一个高阶组件，功能是计算被包裹组件（这里是 Home 组件）的渲染时间。</p><ul><li><strong>页面复用</strong></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">withFetching</span> = fetching =&gt; <span class="hljs-function"><span class="hljs-params">WrappedComponent</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">extends</span> <span class="hljs-title class_">React</span>.<span class="hljs-property">Component</span> &#123;<br>        state = &#123;<br>            <span class="hljs-attr">data</span>: [],<br>        &#125;<br>        <span class="hljs-keyword">async</span> <span class="hljs-title function_">UNSAFE_componentWillMount</span>(<span class="hljs-params"></span>) &#123;<br>            <span class="hljs-keyword">const</span> data = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetching</span>();<br>            <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123;<br>                data,<br>            &#125;);<br>        &#125;<br>        <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">WrappedComponent</span> <span class="hljs-attr">data</span>=<span class="hljs-string">&#123;this.state.data&#125;</span> &#123;<span class="hljs-attr">...this.props</span>&#125; /&gt;</span></span>;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// pages/page-a.js</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">withFetching</span>(<span class="hljs-title function_">fetching</span>(<span class="hljs-string">&#x27;science-fiction&#x27;</span>))(<span class="hljs-title class_">MovieList</span>);<br><span class="hljs-comment">// pages/page-b.js</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">withFetching</span>(<span class="hljs-title function_">fetching</span>(<span class="hljs-string">&#x27;action&#x27;</span>))(<span class="hljs-title class_">MovieList</span>);<br><span class="hljs-comment">// pages/page-other.js</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">withFetching</span>(<span class="hljs-title function_">fetching</span>(<span class="hljs-string">&#x27;some-other-type&#x27;</span>))(<span class="hljs-title class_">MovieList</span>);<br></code></pre></td></tr></table></figure><h3 id="10-对componentWillReceiveProps-的理解"><a href="#10-对componentWillReceiveProps-的理解" class="headerlink" title="10. 对componentWillReceiveProps 的理解"></a>10. 对componentWillReceiveProps 的理解</h3><p>该方法当<code>props</code>发生变化时执行，初始化<code>render</code>时不执行，在这个回调函数里面，你可以根据属性的变化，通过调用<code>this.setState()</code>来更新你的组件状态，旧的属性还是可以通过<code>this.props</code>来获取,这里调用更新状态是安全的，并不会触发额外的<code>render</code>调用。</p><p><strong>使用好处：</strong> 在这个生命周期中，可以在子组件的render函数执行前获取新的props，从而更新子组件自己的state。 可以将数据请求放在这里进行执行，需要传的参数则从componentWillReceiveProps(nextProps)中获取。而不必将所有的请求都放在父组件中。于是该请求只会在该组件渲染时才会发出，从而减轻请求负担。</p><p>componentWillReceiveProps在初始化render的时候不会执行，它会在Component接受到新的状态(Props)时被触发，一般用于父组件状态更新时子组件的重新渲染。</p><h3 id="11-哪些方法会触发-React-重新渲染？重新渲染-render-会做些什么？"><a href="#11-哪些方法会触发-React-重新渲染？重新渲染-render-会做些什么？" class="headerlink" title="11. 哪些方法会触发 React 重新渲染？重新渲染 render 会做些什么？"></a>11. 哪些方法会触发 React 重新渲染？重新渲染 render 会做些什么？</h3><p><strong>（1）哪些方法会触发 react 重新渲染?</strong></p><ul><li><strong>setState（）方法被调用</strong></li></ul><p>setState 是 React 中最常用的命令，通常情况下，执行 setState 会触发 render。但是这里有个点值得关注，执行 setState 的时候不一定会重新渲染。当 setState 传入 null 时，并不会触发 render。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;<br>  state = &#123;<br>    <span class="hljs-attr">a</span>: <span class="hljs-number">1</span><br>  &#125;;<br><br>  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;render&quot;</span>);<br>    <span class="hljs-keyword">return</span> (<br>      <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">React.Fragement</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>&#123;this.state.a&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">button</span></span></span><br><span class="hljs-tag"><span class="language-xml">          <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> &#123;</span><br><span class="language-xml">            this.setState(&#123; a: 1 &#125;); // 这里并没有改变 a 的值</span><br><span class="language-xml">          &#125;&#125;</span><br><span class="language-xml">        &gt;</span><br><span class="language-xml">          Click me</span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> this.setState(null)&#125;&gt;setState null<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">Child</span> /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">React.Fragement</span>&gt;</span></span><br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>父组件重新渲染</strong></li></ul><p>只要父组件重新渲染了，即使传入子组件的 props 未发生变化，那么子组件也会重新渲染，进而触发 render</p><p><strong>（2）重新渲染 render 会做些什么?</strong></p><ul><li>会对新旧 VNode 进行对比，也就是我们所说的Diff算法。</li><li>对新旧两棵树进行一个深度优先遍历，这样每一个节点都会一个标记，在到深度遍历的时候，每遍历到一和个节点，就把该节点和新的节点树进行对比，如果有差异就放到一个对象里面</li><li>遍历差异对象，根据差异的类型，根据对应对规则更新VNode</li></ul><p>React 的处理 render 的基本思维模式是每次一有变动就会去重新渲染整个应用。在 Virtual DOM 没有出现之前，最简单的方法就是直接调用 innerHTML。Virtual DOM厉害的地方并不是说它比直接操作 DOM 快，而是说不管数据怎么变，都会尽量以最小的代价去更新 DOM。React 将 render 函数返回的虚拟 DOM 树与老的进行比较，从而确定 DOM 要不要更新、怎么更新。当 DOM 树很大时，遍历两棵树进行各种比对还是相当耗性能的，特别是在顶层 setState 一个微小的修改，默认会去遍历整棵树。尽管 React 使用高度优化的 Diff 算法，但是这个过程仍然会损耗性能.</p><h3 id="12-React如何判断什么时候重新渲染组件？"><a href="#12-React如何判断什么时候重新渲染组件？" class="headerlink" title="12. React如何判断什么时候重新渲染组件？"></a>12. React如何判断什么时候重新渲染组件？</h3><p>组件状态的改变可以因为<code>props</code>的改变，或者直接通过<code>setState</code>方法改变。组件获得新的状态，然后React决定是否应该重新渲染组件。只要组件的state发生变化，React就会对组件进行重新渲染。这是因为React中的<code>shouldComponentUpdate</code>方法默认返回<code>true</code>，这就是导致每次更新都重新渲染的原因。</p><p>当React将要渲染组件时会执行<code>shouldComponentUpdate</code>方法来看它是否返回<code>true</code>（组件应该更新，也就是重新渲染）。所以需要重写<code>shouldComponentUpdate</code>方法让它根据情况返回<code>true</code>或者<code>false</code>来告诉React什么时候重新渲染什么时候跳过重新渲染。</p><h3 id="13-React声明组件有哪几种方法，有什么不同？"><a href="#13-React声明组件有哪几种方法，有什么不同？" class="headerlink" title="13. React声明组件有哪几种方法，有什么不同？"></a>13. React声明组件有哪几种方法，有什么不同？</h3><p>React 声明组件的三种方式：</p><ul><li>函数式定义的<code>无状态组件</code></li><li>ES5原生方式<code>React.createClass</code>定义的组件</li><li>ES6形式的<code>extends React.Component</code>定义的组件</li></ul><p><strong>（1）无状态函数式组件</strong><br>它是为了创建纯展示组件，这种组件只负责根据传入的props来展示，不涉及到state状态的操作<br>组件不会被实例化，整体渲染性能得到提升，不能访问this对象，不能访问生命周期的方法</p><p><strong>（2）ES5 原生方式 React.createClass &#x2F;&#x2F; RFC</strong><br>React.createClass会自绑定函数方法，导致不必要的性能开销，增加代码过时的可能性。</p><p><strong>（3）E6继承形式 React.Component &#x2F;&#x2F; RCC</strong><br>目前极为推荐的创建有状态组件的方式，最终会取代React.createClass形式；相对于 React.createClass可以更好实现代码复用。</p><p><strong>无状态组件相对于于后者的区别：</strong><br>与无状态组件相比，React.createClass和React.Component都是创建有状态的组件，这些组件是要被实例化的，并且可以访问组件的生命周期方法。</p><p><strong>React.createClass与React.Component区别：</strong></p><p><strong>① 函数this自绑定</strong></p><ul><li>React.createClass创建的组件，其每一个成员函数的this都有React自动绑定，函数中的this会被正确设置。</li><li>React.Component创建的组件，其成员函数不会自动绑定this，需要开发者手动绑定，否则this不能获取当前组件实例对象。</li></ul><p><strong>② 组件属性类型propTypes及其默认props属性defaultProps配置不同</strong></p><ul><li>React.createClass在创建组件时，有关组件props的属性类型及组件默认的属性会作为组件实例的属性来配置，其中defaultProps是使用getDefaultProps的方法来获取默认组件属性的</li><li>React.Component在创建组件时配置这两个对应信息时，他们是作为组件类的属性，不是组件实例的属性，也就是所谓的类的静态属性来配置的。</li></ul><p><strong>③ 组件初始状态state的配置不同</strong></p><ul><li>React.createClass创建的组件，其状态state是通过getInitialState方法来配置组件相关的状态；</li><li>React.Component创建的组件，其状态state是在constructor中像初始化组件属性一样声明的。</li></ul><h3 id="14-对有状态组件和无状态组件的理解及使用场景"><a href="#14-对有状态组件和无状态组件的理解及使用场景" class="headerlink" title="14. 对有状态组件和无状态组件的理解及使用场景"></a>14. 对有状态组件和无状态组件的理解及使用场景</h3><p><strong>（1）有状态组件</strong></p><p><strong>特点：</strong></p><ul><li>是类组件 </li><li>有继承 </li><li>可以使用this</li><li>可以使用react的生命周期</li><li>使用较多，容易频繁触发生命周期钩子函数，影响性能</li><li>内部使用 state，维护自身状态的变化，有状态组件根据外部组件传入的 props 和自身的 state进行渲染。</li></ul><p><strong>使用场景：</strong></p><ul><li>需要使用到状态的。 </li><li>需要使用状态操作组件的（无状态组件的也可以实现新版本react hooks也可实现）</li></ul><p><strong>总结：</strong><br>类组件可以维护自身的状态变量，即组件的 state ，类组件还有不同的生命周期方法，可以让开发者能够在组件的不同阶段（挂载、更新、卸载），对组件做更多的控制。类组件则既可以充当无状态组件，也可以充当有状态组件。当一个类组件不需要管理自身状态时，也可称为无状态组件。</p><p><strong>（2）无状态组件</strong><br><strong>特点：</strong></p><ul><li>不依赖自身的状态state</li><li>可以是类组件或者函数组件。</li><li>可以完全避免使用 this 关键字。（由于使用的是箭头函数事件无需绑定）</li><li>有更高的性能。当不需要使用生命周期钩子时，应该首先使用无状态函数组件</li><li>组件内部不维护 state ，只根据外部组件传入的 props 进行渲染的组件，当 props 改变时，组件重新渲染。</li></ul><p><strong>使用场景：</strong></p><ul><li>组件不需要管理 state，纯展示</li></ul><p><strong>优点：</strong></p><ul><li>简化代码、专注于 render</li><li>组件不需要被实例化，无生命周期，提升性能。 输出（渲染）只取决于输入（属性），无副作用</li><li>视图和数据的解耦分离</li></ul><p><strong>缺点：</strong></p><ul><li>无法使用 ref </li><li>无生命周期方法</li><li>无法控制组件的重渲染，因为无法使用shouldComponentUpdate 方法，当组件接受到新的属性时则会重渲染</li></ul><p><strong>总结：</strong><br>组件内部状态且与外部无关的组件，可以考虑用状态组件，这样状态树就不会过于复杂，易于理解和管理。当一个组件不需要管理自身状态时，也就是无状态组件，应该优先设计为函数组件。比如自定义的 <code>&lt;Button/&gt;</code>、 <code>&lt;Input /&gt;</code> 等组件。</p><h3 id="15-对React中Fragment的理解，它的使用场景是什么？"><a href="#15-对React中Fragment的理解，它的使用场景是什么？" class="headerlink" title="15. 对React中Fragment的理解，它的使用场景是什么？"></a>15. 对React中Fragment的理解，它的使用场景是什么？</h3><p>在React中，组件返回的元素只能有一个根元素。为了不添加多余的DOM节点，我们可以使用Fragment标签来包裹所有的元素，Fragment标签不会渲染出任何元素。React官方对Fragment的解释：</p><blockquote><p>React 中的一个常见模式是一个组件返回多个元素。Fragments 允许你将子列表分组，而无需向 DOM 添加额外节点。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; <span class="hljs-title class_">Component</span>, <span class="hljs-title class_">Fragment</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><br><br><span class="hljs-comment">// 一般形式</span><br><span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">React.Fragment</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">ChildA</span> /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">ChildB</span> /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">ChildC</span> /&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">React.Fragment</span>&gt;</span></span><br>  );<br>&#125;<br><span class="hljs-comment">// 也可以写成以下形式</span><br><span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">ChildA</span> /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">ChildB</span> /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">ChildC</span> /&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="16-React如何获取组件对应的DOM元素？"><a href="#16-React如何获取组件对应的DOM元素？" class="headerlink" title="16. React如何获取组件对应的DOM元素？"></a>16. React如何获取组件对应的DOM元素？</h3><p>可以用ref来获取某个子节点的实例，然后通过当前class组件实例的一些特定属性来直接获取子节点实例。ref有三种实现方法:</p><ul><li><strong>字符串格式</strong>：字符串格式，这是React16版本之前用得最多的，例如：<code>&lt;p ref=&quot;info&quot;&gt;span&lt;/p&gt;</code></li><li><strong>函数格式</strong>：ref对应一个方法，该方法有一个参数，也就是对应的节点实例，例如：<code>&lt;p ref=&#123;ele =&gt; this.info = ele&#125;&gt;&lt;/p&gt;</code></li><li><strong>createRef方法</strong>：React 16提供的一个API，使用React.createRef()来实现</li></ul><p> 　　　　　　  </p><h3 id="17-React中可以在render访问refs吗？为什么？"><a href="#17-React中可以在render访问refs吗？为什么？" class="headerlink" title="17. React中可以在render访问refs吗？为什么？"></a>17. React中可以在render访问refs吗？为什么？</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&#123;this.spanRef&#125;</span>&gt;</span>&#123;this.state.title&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>&#123;</span><br><span class="language-xml">     this.spanRef.current ? &#x27;有值&#x27; : &#x27;无值&#x27;</span><br><span class="language-xml">  &#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br>&lt;/&gt;<br></code></pre></td></tr></table></figure><p>不可以，render 阶段 DOM 还没有生成，无法获取 DOM。DOM 的获取需要在 pre-commit 阶段和 commit 阶段：<br><img src="3.png" alt="img"></p><h3 id="18-对React的插槽-Portals-的理解，如何使用，有哪些使用场景"><a href="#18-对React的插槽-Portals-的理解，如何使用，有哪些使用场景" class="headerlink" title="18. 对React的插槽(Portals)的理解，如何使用，有哪些使用场景"></a>18. 对React的插槽(Portals)的理解，如何使用，有哪些使用场景</h3><p>React 官方对 Portals 的定义：</p><blockquote><p>Portal 提供了一种将子节点渲染到存在于父组件以外的 DOM 节点的优秀的方案</p></blockquote><p>Portals 是React 16提供的官方解决方案，使得组件可以脱离父组件层级挂载在DOM树的任何位置。通俗来讲，就是我们 render 一个组件，但这个组件的 DOM 结构并不在本组件内。</p><p>Portals语法如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">createPortal</span>(child, container);<br></code></pre></td></tr></table></figure><ul><li>第一个参数 child 是可渲染的 React 子项，比如元素，字符串或者片段等;</li><li>第二个参数 container 是一个 DOM 元素。</li></ul><p>一般情况下，组件的render函数返回的元素会被挂载在它的父级组件上：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">DemoComponent</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./DemoComponent&#x27;</span>;<br><span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">// DemoComponent元素会被挂载在id为parent的div的元素上</span><br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;parent&quot;</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">DemoComponent</span> /&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><p>然而，有些元素需要被挂载在更高层级的位置。最典型的应用场景：当父组件具有<code>overflow: hidden</code>或者<code>z-index</code>的样式设置时，组件有可能被其他元素遮挡，这时就可以考虑要不要使用Portal使组件的挂载脱离父组件。例如：对话框，模态窗。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">DemoComponent</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./DemoComponent&#x27;</span>;<br><span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">// DemoComponent元素会被挂载在id为parent的div的元素上</span><br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;parent&quot;</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">DemoComponent</span> /&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="19-在React中如何避免不必要的render？"><a href="#19-在React中如何避免不必要的render？" class="headerlink" title="19. 在React中如何避免不必要的render？"></a>19. 在React中如何避免不必要的render？</h3><p>React 基于虚拟 DOM 和高效 Diff 算法的完美配合，实现了对 DOM 最小粒度的更新。大多数情况下，React 对 DOM 的渲染效率足以业务日常。但在个别复杂业务场景下，性能问题依然会困扰我们。此时需要采取一些措施来提升运行性能，其很重要的一个方向，就是避免不必要的渲染（Render）。这里提下优化的点：</p><ul><li><strong>shouldComponentUpdate 和 PureComponent</strong></li></ul><p>在 React 类组件中，可以利用 shouldComponentUpdate或者 PureComponent 来减少因父组件更新而触发子组件的 render，从而达到目的。shouldComponentUpdate 来决定是否组件是否重新渲染，如果不希望组件重新渲染，返回 false 即可。</p><ul><li><strong>利用高阶组件</strong></li></ul><p>在函数组件中，并没有 shouldComponentUpdate 这个生命周期，可以利用高阶组件，封装一个类似 PureComponet 的功能</p><ul><li><strong>使用 React.memo</strong></li></ul><p>React.memo 是 React 16.6 新的一个 API，用来缓存组件的渲染，避免不必要的更新，其实也是一个高阶组件，与 PureComponent 十分类似，但不同的是， React.memo只能用于函数组件。</p><h3 id="20-对-React-Intl-的理解，它的工作原理？"><a href="#20-对-React-Intl-的理解，它的工作原理？" class="headerlink" title="20. 对 React-Intl 的理解，它的工作原理？"></a>20. 对 React-Intl 的理解，它的工作原理？</h3><p>React-intl是雅虎的语言国际化开源项目FormatJS的一部分，通过其提供的组件和API可以与ReactJS绑定。</p><p>React-intl提供了两种使用方法，一种是引用React组件，另一种是直接调取API，官方更加推荐在React项目中使用前者，只有在无法使用React组件的地方，才应该调用框架提供的API。它提供了一系列的React组件，包括数字格式化、字符串格式化、日期格式化等。</p><p>在React-intl中，可以配置不同的语言包，他的工作原理就是根据需要，在语言包之间进行切换。</p><h3 id="21-对-React-context-的理解"><a href="#21-对-React-context-的理解" class="headerlink" title="21. 对 React context 的理解"></a>21. 对 React context 的理解</h3><p>在React中，数据传递一般使用props传递数据，维持单向数据流，这样可以让组件之间的关系变得简单且可预测，但是单项数据流在某些场景中并不适用。单纯一对的父子组件传递并无问题，但要是组件之间层层依赖深入，props就需要层层传递显然，这样做太繁琐了。</p><p>Context 提供了一种在组件之间共享此类值的方式，而不必显式地通过组件树的逐层传递 props。</p><p>可以把context当做是特定一个组件树内共享的store，用来做数据传递。<strong>简单说就是，当你不想在组件树中通过逐层传递props或者state的方式来传递数据时，可以使用Context来实现跨层级的组件数据传递。</strong></p><p>JS的代码块在执行期间，会创建一个相应的作用域链，这个作用域链记录着运行时JS代码块执行期间所能访问的活动对象，包括变量和函数，JS程序通过作用域链访问到代码块内部或者外部的变量和函数。</p><p>假如以JS的作用域链作为类比，React组件提供的Context对象其实就好比一个提供给子组件访问的作用域，而 Context对象的属性可以看成作用域上的活动对象。由于组件 的 Context 由其父节点链上所有组件通 过 getChildContext（）返回的Context对象组合而成，所以，组件通过Context是可以访问到其父组件链上所有节点组件提供的Context的属性。</p><h3 id="22-为什么React并不推荐优先考虑使用Context？"><a href="#22-为什么React并不推荐优先考虑使用Context？" class="headerlink" title="22. 为什么React并不推荐优先考虑使用Context？"></a>22. 为什么React并不推荐优先考虑使用Context？</h3><ul><li>Context目前还处于实验阶段，可能会在后面的发行版本中有很大的变化，事实上这种情况已经发生了，所以为了避免给今后升级带来大的影响和麻烦，不建议在app中使用context。</li><li>尽管不建议在app中使用context，但是独有组件而言，由于影响范围小于app，如果可以做到高内聚，不破坏组件树之间的依赖关系，可以考虑使用context</li><li>对于组件之间的数据通信或者状态管理，有效使用props或者state解决，然后再考虑使用第三方的成熟库进行解决，以上的方法都不是最佳的方案的时候，在考虑context。</li><li>context的更新需要通过setState()触发，但是这并不是很可靠的，Context支持跨组件的访问，但是如果中间的子组件通过一些方法不影响更新，比如 shouldComponentUpdate() 返回false 那么不能保证Context的更新一定可以使用Context的子组件，因此，Context的可靠性需要关注</li></ul><h3 id="23-React中什么是受控组件和非控组件？"><a href="#23-React中什么是受控组件和非控组件？" class="headerlink" title="23. React中什么是受控组件和非控组件？"></a>23. React中什么是受控组件和非控组件？</h3><p><strong>（1）受控组件</strong><br>在使用表单来收集用户输入时，例如<code>&lt;input&gt;&lt;select&gt;&lt;textearea&gt;</code>等元素都要绑定一个change事件，当表单的状态发生变化，就会触发onChange事件，更新组件的state。这种组件在React中被称为<strong>受控组件</strong>，在受控组件中，组件渲染出的状态与它的value或checked属性相对应，react通过这种方式消除了组件的局部状态，使整个状态可控。react官方推荐使用受控表单组件。</p><p>受控组件更新state的流程：</p><ul><li>可以通过初始state中设置表单的默认值</li><li>每当表单的值发生变化时，调用onChange事件处理器</li><li>事件处理器通过事件对象e拿到改变后的状态，并更新组件的state</li><li>一旦通过setState方法更新state，就会触发视图的重新渲染，完成表单组件的更新</li></ul><p><strong>受控组件缺陷：</strong><br>表单元素的值都是由React组件进行管理，当有多个输入框，或者多个这种组件时，如果想同时获取到全部的值就必须每个都要编写事件处理函数，这会让代码看着很臃肿，所以为了解决这种情况，出现了非受控组件。</p><p><strong>（2）非受控组件</strong><br>如果一个表单组件没有value props（单选和复选按钮对应的是checked props）时，就可以称为非受控组件。在非受控组件中，可以使用一个ref来从DOM获得表单值。而不是为每个状态更新编写一个事件处理程序。</p><p>React官方的解释：</p><blockquote><p>要编写一个非受控组件，而不是为每个状态更新都编写数据处理函数，你可以使用 ref来从 DOM 节点中获取表单数据。<br>因为非受控组件将真实数据储存在 DOM 节点中，所以在使用非受控组件时，有时候反而更容易同时集成 React 和非 React 代码。如果你不介意代码美观性，并且希望快速编写代码，使用非受控组件往往可以减少你的代码量。否则，你应该使用受控组件。</p></blockquote><p>例如，下面的代码在非受控组件中接收单个属性：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">NameForm</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">props</span>) &#123;<br>    <span class="hljs-variable language_">super</span>(props);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">handleSubmit</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">handleSubmit</span>.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>);<br>  &#125;<br>  <span class="hljs-title function_">handleSubmit</span>(<span class="hljs-params">event</span>) &#123;<br>    <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;A name was submitted: &#x27;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">input</span>.<span class="hljs-property">value</span>);<br>    event.<span class="hljs-title function_">preventDefault</span>();<br>  &#125;<br>  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> (<br>      <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">onSubmit</span>=<span class="hljs-string">&#123;this.handleSubmit&#125;</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span></span><br><span class="language-xml">          Name:</span><br><span class="language-xml">          <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&#123;(input)</span> =&gt;</span> this.input = input&#125; /&gt;</span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Submit&quot;</span> /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span></span><br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>总结：</strong> 页面中所有输入类的DOM如果是现用现取的称为非受控组件，而通过setState将输入的值维护到了state中，需要时再从state中取出，这里的数据就受到了state的控制，称为受控组件。</p><h3 id="24-React中refs的作用是什么？有哪些应用场景？"><a href="#24-React中refs的作用是什么？有哪些应用场景？" class="headerlink" title="24. React中refs的作用是什么？有哪些应用场景？"></a>24. React中refs的作用是什么？有哪些应用场景？</h3><p>Refs 提供了一种方式，用于访问在 render 方法中创建的 React 元素或 DOM 节点。Refs 应该谨慎使用，如下场景使用 Refs 比较适合：</p><ul><li>处理焦点、文本选择或者媒体的控制</li><li>触发必要的动画</li><li>集成第三方 DOM 库</li></ul><p>Refs 是使用 <code>React.createRef()</code> 方法创建的，他通过 <code>ref</code> 属性附加到 React 元素上。要在整个组件中使用 Refs，需要将 <code>ref</code> 在构造函数中分配给其实例属性：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyComponent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">props</span>) &#123;<br>    <span class="hljs-variable language_">super</span>(props)<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">myRef</span> = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">createRef</span>()<br>  &#125;<br>  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&#123;this.myRef&#125;</span> /&gt;</span></span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>由于函数组件没有实例，因此不能在函数组件上直接使用 <code>ref</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">MyFunctionalComponent</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> /&gt;</span></span>;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Parent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">props</span>) &#123;<br>    <span class="hljs-variable language_">super</span>(props);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">textInput</span> = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">createRef</span>();<br>  &#125;<br>  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// 这将不会工作！</span><br>    <span class="hljs-keyword">return</span> (<br>      <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">MyFunctionalComponent</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&#123;this.textInput&#125;</span> /&gt;</span></span><br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>但可以通过闭合的帮助在函数组件内部进行使用 Refs：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">CustomTextInput</span>(<span class="hljs-params">props</span>) &#123;<br>  <span class="hljs-comment">// 这里必须声明 textInput，这样 ref 回调才可以引用它</span><br>  <span class="hljs-keyword">let</span> textInput = <span class="hljs-literal">null</span>;<br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">handleClick</span>(<span class="hljs-params"></span>) &#123;<br>    textInput.<span class="hljs-title function_">focus</span>();<br>  &#125;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">input</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">ref</span>=<span class="hljs-string">&#123;(input)</span> =&gt;</span> &#123; textInput = input; &#125;&#125; /&gt;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">input</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Focus the text input&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;handleClick&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">      /&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );  <br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注意：</strong></p><ul><li>不应该过度的使用 Refs</li><li><code>ref</code> 的返回值取决于节点的类型：    <ul><li>当 <code>ref</code> 属性被用于一个普通的 HTML 元素时，<code>React.createRef()</code> 将接收底层 DOM 元素作为他的 <code>current</code> 属性以创建 <code>ref</code>。</li><li>当 <code>ref</code> 属性被用于一个自定义的类组件时，<code>ref</code> 对象将接收该组件已挂载的实例作为他的 <code>current</code>。</li></ul></li><li>当在父组件中需要访问子组件中的 <code>ref</code> 时可使用传递 Refs 或回调 Refs。</li></ul><h3 id="26-React组件的构造函数有什么作用？它是必须的吗？"><a href="#26-React组件的构造函数有什么作用？它是必须的吗？" class="headerlink" title="26. React组件的构造函数有什么作用？它是必须的吗？"></a>26. React组件的构造函数有什么作用？它是必须的吗？</h3><p>构造函数主要用于两个目的：</p><ul><li>通过将对象分配给this.state来初始化本地状态 </li><li>将事件处理程序方法绑定到实例上</li></ul><p>所以，当在React class中需要设置state的初始值或者绑定事件时，需要加上构造函数，官方Demo：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">LikeButton</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">super</span>();<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = &#123;<br>      <span class="hljs-attr">liked</span>: <span class="hljs-literal">false</span><br>    &#125;;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">handleClick</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">handleClick</span>.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>);<br>  &#125;<br>  <span class="hljs-title function_">handleClick</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123;<span class="hljs-attr">liked</span>: !<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">liked</span>&#125;);<br>  &#125;<br>  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">const</span> text = <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">liked</span> ? <span class="hljs-string">&#x27;liked&#x27;</span> : <span class="hljs-string">&#x27;haven\&#x27;t liked&#x27;</span>;<br>    <span class="hljs-keyword">return</span> (<br>      <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;this.handleClick&#125;</span>&gt;</span></span><br><span class="language-xml">        You &#123;text&#125; this. Click to toggle.</span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>    );<br>  &#125;<br>&#125;<br><span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">render</span>(<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">LikeButton</span> /&gt;</span></span>,<br>  <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;example&#x27;</span>)<br>);<br></code></pre></td></tr></table></figure><p>构造函数用来新建父类的this对象；子类必须在constructor方法中调用super方法；否则新建实例时会报错；因为子类没有自己的this对象，而是继承父类的this对象，然后对其进行加工。如果不调用super方法；子类就得不到this对象。</p><p><strong>注意：</strong></p><ul><li>constructor () 必须配上 super(), 如果要在constructor 内部使用 this.props 就要 传入props , 否则不用</li><li>JavaScript中的 bind 每次都会返回一个新的函数, 为了性能等考虑, 尽量在constructor中绑定事件</li></ul><h3 id="27-React-forwardRef是什么？它有什么作用？"><a href="#27-React-forwardRef是什么？它有什么作用？" class="headerlink" title="27. React.forwardRef是什么？它有什么作用？"></a>27. React.forwardRef是什么？它有什么作用？</h3><p>React.forwardRef 会创建一个React组件，这个组件能够将其接受的 ref 属性转发到其组件树下的另一个组件中。这种技术并不常见，但在以下两种场景中特别有用：</p><ul><li>转发 refs 到 DOM 组件</li><li>在高阶组件中转发 refs</li></ul><h3 id="28-类组件与函数组件有什么异同？"><a href="#28-类组件与函数组件有什么异同？" class="headerlink" title="28. 类组件与函数组件有什么异同？"></a>28. 类组件与函数组件有什么异同？</h3><p><strong>相同点：</strong><br>组件是 React 可复用的最小代码片段，它们会返回要在页面中渲染的 React 元素。也正因为组件是 React 的最小编码单位，所以无论是函数组件还是类组件，在使用方式和最终呈现效果上都是完全一致的。</p><p>我们甚至可以将一个类组件改写成函数组件，或者把函数组件改写成一个类组件（虽然并不推荐这种重构行为）。从使用者的角度而言，很难从使用体验上区分两者，而且在现代浏览器中，闭包和类的性能只在极端场景下才会有明显的差别。所以，基本可认为两者作为组件是完全一致的。</p><p><strong>不同点：</strong></p><ul><li>它们在开发时的心智模型上却存在巨大的差异。类组件是基于面向对象编程的，它主打的是继承、生命周期等核心概念；而函数组件内核是函数式编程，主打的是 immutable、没有副作用、引用透明等特点。</li><li>之前，在使用场景上，如果存在需要使用生命周期的组件，那么主推类组件；设计模式上，如果需要使用继承，那么主推类组件。但现在由于 React Hooks 的推出，生命周期概念的淡出，函数组件可以完全取代类组件。其次继承并不是组件最佳的设计模式，官方更推崇“组合优于继承”的设计概念，所以类组件在这方面的优势也在淡出。</li><li>性能优化上，类组件主要依靠 shouldComponentUpdate 阻断渲染来提升性能，而函数组件依靠 React.memo 缓存渲染结果来提升性能。</li><li>从上手程度而言，类组件更容易上手，从未来趋势上看，由于React Hooks 的推出，函数组件成了社区未来主推的方案。</li><li>类组件在未来时间切片与并发模式中，由于生命周期带来的复杂度，并不易于优化。而函数组件本身轻量简单，且在 Hooks 的基础上提供了比原先更细粒度的逻辑组织与复用，更能适应 React 的未来发展。</li></ul><h2 id="二、数据管理"><a href="#二、数据管理" class="headerlink" title="二、数据管理"></a>二、数据管理</h2><h3 id="1-React-setState-调用的原理"><a href="#1-React-setState-调用的原理" class="headerlink" title="1. React setState 调用的原理"></a>1. React setState 调用的原理</h3><p><img src="4.png" alt="img"><br>具体的执行过程如下（源码级解析)：</p><ul><li>首先调用了<code>setState</code> 入口函数，入口函数在这里就是充当一个分发器的角色，根据入参的不同，将其分发到不同的功能函数中去；</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">ReactComponent</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">setState</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">partialState, callback</span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">updater</span>.<span class="hljs-title function_">enqueueSetState</span>(<span class="hljs-variable language_">this</span>, partialState);<br>  <span class="hljs-keyword">if</span> (callback) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">updater</span>.<span class="hljs-title function_">enqueueCallback</span>(<span class="hljs-variable language_">this</span>, callback, <span class="hljs-string">&#x27;setState&#x27;</span>);<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li><code>enqueueSetState</code> 方法将新的 <code>state</code> 放进组件的状态队列里，并调用 <code>enqueueUpdate</code> 来处理将要更新的实例对象；</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-attr">enqueueSetState</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">publicInstance, partialState</span>) &#123;<br>  <span class="hljs-comment">// 根据 this 拿到对应的组件实例</span><br>  <span class="hljs-keyword">var</span> internalInstance = <span class="hljs-title function_">getInternalInstanceReadyForUpdate</span>(publicInstance, <span class="hljs-string">&#x27;setState&#x27;</span>);<br>  <span class="hljs-comment">// 这个 queue 对应的就是一个组件实例的 state 数组</span><br>  <span class="hljs-keyword">var</span> queue = internalInstance.<span class="hljs-property">_pendingStateQueue</span> || (internalInstance.<span class="hljs-property">_pendingStateQueue</span> = []);<br>  queue.<span class="hljs-title function_">push</span>(partialState);<br>  <span class="hljs-comment">//  enqueueUpdate 用来处理当前的组件实例</span><br>  <span class="hljs-title function_">enqueueUpdate</span>(internalInstance);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>在 <code>enqueueUpdate</code> 方法中引出了一个关键的对象——<code>batchingStrategy</code>，该对象所具备的<code>isBatchingUpdates</code> 属性直接决定了当下是要走更新流程，还是应该排队等待；如果轮到执行，就调用 <code>batchedUpdates</code> 方法来直接发起更新流程。由此可以推测，<code>batchingStrategy</code> 或许正是 React 内部专门用于管控批量更新的对象。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">enqueueUpdate</span>(<span class="hljs-params">component</span>) &#123;<br>  <span class="hljs-title function_">ensureInjected</span>();<br>  <span class="hljs-comment">// 注意这一句是问题的关键，isBatchingUpdates标识着当前是否处于批量创建/更新组件的阶段</span><br>  <span class="hljs-keyword">if</span> (!batchingStrategy.<span class="hljs-property">isBatchingUpdates</span>) &#123;<br>    <span class="hljs-comment">// 若当前没有处于批量创建/更新组件的阶段，则立即更新组件</span><br>    batchingStrategy.<span class="hljs-title function_">batchedUpdates</span>(enqueueUpdate, component);<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>  <span class="hljs-comment">// 否则，先把组件塞入 dirtyComponents 队列里，让它“再等等”</span><br>  dirtyComponents.<span class="hljs-title function_">push</span>(component);<br>  <span class="hljs-keyword">if</span> (component.<span class="hljs-property">_updateBatchNumber</span> == <span class="hljs-literal">null</span>) &#123;<br>    component.<span class="hljs-property">_updateBatchNumber</span> = updateBatchNumber + <span class="hljs-number">1</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注意：</strong><code>batchingStrategy</code> 对象可以理解为“锁管理器”。这里的“锁”，是指 React 全局唯一的 <code>isBatchingUpdates</code> 变量，<code>isBatchingUpdates</code> 的初始值是 <code>false</code>，意味着“当前并未进行任何批量更新操作”。每当 React 调用 <code>batchedUpdate</code> 去执行更新动作时，会先把这个锁给“锁上”（置为 <code>true</code>），表明“现在正处于批量更新过程中”。当锁被“锁上”的时候，任何需要更新的组件都只能暂时进入 <code>dirtyComponents</code> 里排队等候下一次的批量更新，而不能随意“插队”。此处体现的“任务锁”的思想，是 React 面对大量状态仍然能够实现有序分批处理的基石。</p><h3 id="2-React-setState-调用之后发生了什么？是同步还是异步？"><a href="#2-React-setState-调用之后发生了什么？是同步还是异步？" class="headerlink" title="2. React setState 调用之后发生了什么？是同步还是异步？"></a>2. React setState 调用之后发生了什么？是同步还是异步？</h3><p><strong>（1）React中setState后发生了什么</strong></p><p>在代码中调用setState函数之后，React 会将传入的参数对象与组件当前的状态合并，然后触发调和过程(Reconciliation)。经过调和过程，React 会以相对高效的方式根据新的状态构建 React 元素树并且着手重新渲染整个UI界面。</p><p>在 React 得到元素树之后，React 会自动计算出新的树与老树的节点差异，然后根据差异对界面进行最小化重渲染。在差异计算算法中，React 能够相对精确地知道哪些位置发生了改变以及应该如何改变，这就保证了按需更新，而不是全部重新渲染。</p><p>如果在短时间内频繁setState。React会将state的改变压入栈中，在合适的时机，批量更新state和视图，达到提高性能的效果。</p><p><strong>（2）setState 是同步还是异步的</strong></p><p>假如所有setState是同步的，意味着每执行一次setState时（有可能一个同步代码中，多次setState），都重新vnode diff + dom修改，这对性能来说是极为不好的。如果是异步，则可以把一个同步代码中的多个setState合并成一次组件更新。所以默认是异步的，但是在一些情况下是同步的。</p><p>setState 并不是单纯同步&#x2F;异步的，它的表现会因调用场景的不同而不同。在源码中，通过 isBatchingUpdates 来判断setState 是先存进 state 队列还是直接更新，如果值为 true 则执行异步操作，为 false 则直接更新。</p><ul><li><strong>异步：</strong> 在 React 可以控制的地方，就为 true，比如在 React 生命周期事件和合成事件中，都会走合并操作，延迟更新的策略。</li><li><strong>同步：</strong> 在 React 无法控制的地方，比如原生事件，具体就是在 addEventListener 、setTimeout、setInterval 等事件中，就只能同步更新。</li></ul><p>一般认为，做异步设计是为了性能优化、减少渲染次数：</p><ul><li><code>setState</code>设计为异步，可以显著的提升性能。如果每次调用 <code>setState</code>都进行一次更新，那么意味着<code>render</code>函数会被频繁调用，界面重新渲染，这样效率是很低的；最好的办法应该是获取到多个更新，之后进行批量更新； </li><li>如果同步更新了<code>state</code>，但是还没有执行<code>render</code>函数，那么<code>state</code>和<code>props</code>不能保持同步。<code>state</code>和<code>props</code>不能保持一致性，会在开发中产生很多的问题；</li></ul><h3 id="3-React中的setState批量更新的过程是什么？"><a href="#3-React中的setState批量更新的过程是什么？" class="headerlink" title="3. React中的setState批量更新的过程是什么？"></a>3. React中的setState批量更新的过程是什么？</h3><p>调用 <code>setState</code> 时，组件的 <code>state</code> 并不会立即改变， <code>setState</code> 只是把要修改的 <code>state</code> 放入一个队列， <code>React</code> 会优化真正的执行时机，并出于性能原因，会将 <code>React</code> 事件处理程序中的多次<code>React</code> 事件处理程序中的多次 <code>setState</code> 的状态修改合并成一次状态修改。 最终更新只产生一次组件及其子组件的重新渲染，这对于大型应用程序中的性能提升至关重要。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123;<br>  <span class="hljs-attr">count</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">count</span> + <span class="hljs-number">1</span>    ===&gt;    入队，[count+<span class="hljs-number">1</span>的任务]<br>&#125;);<br><span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123;<br>  <span class="hljs-attr">count</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">count</span> + <span class="hljs-number">1</span>    ===&gt;    入队，[count+<span class="hljs-number">1</span>的任务，count+<span class="hljs-number">1</span>的任务]<br>&#125;);<br>                                          ↓<br>                                         合并 state，[count+<span class="hljs-number">1</span>的任务]<br>                                          ↓<br>                                         执行 count+<span class="hljs-number">1</span>的任务<br></code></pre></td></tr></table></figure><p>需要注意的是，只要同步代码还在执行，“攒起来”这个动作就不会停止。（注：这里之所以多次 +1 最终只有一次生效，是因为在同一个方法中多次 setState 的合并动作不是单纯地将更新累加。比如这里对于相同属性的设置，React 只会为其保留最后一次的更新）。</p><h3 id="4-React中有使用过getDefaultProps吗？它有什么作用？"><a href="#4-React中有使用过getDefaultProps吗？它有什么作用？" class="headerlink" title="4.  React中有使用过getDefaultProps吗？它有什么作用？"></a>4.  React中有使用过getDefaultProps吗？它有什么作用？</h3><p>通过实现组件的getDefaultProps，对属性设置默认值（ES5的写法）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> <span class="hljs-title class_">ShowTitle</span> = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">createClass</span>(&#123;<br>  <span class="hljs-attr">getDefaultProps</span>:<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">return</span>&#123;<br>      title : <span class="hljs-string">&quot;React&quot;</span><br>    &#125;<br>  &#125;,<br>  render : <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>&#123;this.props.title&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br>  &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><h3 id="5-React中setState的第二个参数作用是什么？"><a href="#5-React中setState的第二个参数作用是什么？" class="headerlink" title="5. React中setState的第二个参数作用是什么？"></a>5. React中setState的第二个参数作用是什么？</h3><p><code>setState</code> 的第二个参数是一个可选的回调函数。这个回调函数将在组件重新渲染后执行。等价于在 <code>componentDidUpdate</code> 生命周期内执行。通常建议使用 <code>componentDidUpdate</code> 来代替此方式。在这个回调函数中你可以拿到更新后 <code>state</code> 的值：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123;<br>    <span class="hljs-attr">key1</span>: newState1,<br>    <span class="hljs-attr">key2</span>: newState2,<br>    ...<br>&#125;, callback) <span class="hljs-comment">// 第二个参数是 state 更新完成后的回调函数</span><br></code></pre></td></tr></table></figure><h3 id="6-React中的setState和replaceState的区别是什么？"><a href="#6-React中的setState和replaceState的区别是什么？" class="headerlink" title="6. React中的setState和replaceState的区别是什么？"></a>6. React中的setState和replaceState的区别是什么？</h3><p><strong>（1）setState()</strong><br>setState()用于设置状态对象，其语法如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">setState</span>(object nextState[, <span class="hljs-keyword">function</span> callback])<br></code></pre></td></tr></table></figure><ul><li>nextState，将要设置的新状态，该状态会和当前的state合并</li><li>callback，可选参数，回调函数。该函数会在setState设置成功，且组件重新渲染后调用。</li></ul><p>合并nextState和当前state，并重新渲染组件。setState是React事件处理函数中和请求回调函数中触发UI更新的主要方法。</p><p><strong>（2）replaceState()</strong><br>replaceState()方法与setState()类似，但是方法只会保留nextState中状态，原state不在nextState中的状态都会被删除。其语法如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">replaceState</span>(object nextState[, <span class="hljs-keyword">function</span> callback])<br></code></pre></td></tr></table></figure><ul><li>nextState，将要设置的新状态，该状态会替换当前的state。</li><li>callback，可选参数，回调函数。该函数会在replaceState设置成功，且组件重新渲染后调用。</li></ul><p><strong>总结：</strong> setState 是修改其中的部分状态，相当于 Object.assign，只是覆盖，不会减少原来的状态。而replaceState 是完全替换原来的状态，相当于赋值，将原来的 state 替换为另一个对象，如果新状态属性减少，那么 state 中就没有这个状态了。</p><h3 id="7-在React中组件的this-state和setState有什么区别？"><a href="#7-在React中组件的this-state和setState有什么区别？" class="headerlink" title="7. 在React中组件的this.state和setState有什么区别？"></a>7. 在React中组件的this.state和setState有什么区别？</h3><p>this.state通常是用来初始化state的，this.setState是用来修改state值的。如果初始化了state之后再使用this.state，之前的state会被覆盖掉，如果使用this.setState，只会替换掉相应的state值。所以，如果想要修改state的值，就需要使用setState，而不能直接修改state，直接修改state之后页面是不会更新的。</p><h3 id="8-state-是怎么注入到组件的，从-reducer-到组件经历了什么样的过程"><a href="#8-state-是怎么注入到组件的，从-reducer-到组件经历了什么样的过程" class="headerlink" title="8. state 是怎么注入到组件的，从 reducer 到组件经历了什么样的过程"></a>8. state 是怎么注入到组件的，从 reducer 到组件经历了什么样的过程</h3><p>通过connect和mapStateToProps将state注入到组件中：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; connect &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-redux&#x27;</span><br><span class="hljs-keyword">import</span> &#123; setVisibilityFilter &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@/reducers/Todo/actions&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">Link</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@/containers/Todo/components/Link&#x27;</span><br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">mapStateToProps</span> = (<span class="hljs-params">state, ownProps</span>) =&gt; (&#123;<br>    <span class="hljs-attr">active</span>: ownProps.<span class="hljs-property">filter</span> === state.<span class="hljs-property">visibilityFilter</span><br>&#125;)<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">mapDispatchToProps</span> = (<span class="hljs-params">dispatch, ownProps</span>) =&gt; (&#123;<br>    <span class="hljs-attr">setFilter</span>: <span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-title function_">dispatch</span>(<span class="hljs-title function_">setVisibilityFilter</span>(ownProps.<span class="hljs-property">filter</span>))<br>    &#125;<br>&#125;)<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">connect</span>(<br>    mapStateToProps,<br>    mapDispatchToProps<br>)(<span class="hljs-title class_">Link</span>)<br></code></pre></td></tr></table></figure><p>上面代码中，active就是注入到Link组件中的状态。 mapStateToProps（state，ownProps）中带有两个参数，含义是∶</p><ul><li>state-store管理的全局状态对象，所有都组件状态数据都存储在该对象中。</li><li>ownProps 组件通过props传入的参数。</li></ul><p><strong>reducer 到组件经历的过程：</strong></p><ul><li>reducer对action对象处理，更新组件状态，并将新的状态值返回store。</li><li>通过connect（mapStateToProps，mapDispatchToProps）（Component）对组件 Component进行升级，此时将状态值从store取出并作为props参数传递到组件。</li></ul><p><strong>高阶组件实现源码∶</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">PropTypes</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;prop-types&#x27;</span><br><br><span class="hljs-comment">// 高阶组件 contect </span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">connect</span> = (<span class="hljs-params">mapStateToProps, mapDispatchToProps</span>) =&gt; <span class="hljs-function">(<span class="hljs-params">WrappedComponent</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Connect</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;<br>        <span class="hljs-comment">// 通过对context调用获取store</span><br>        <span class="hljs-keyword">static</span> contextTypes = &#123;<br>            <span class="hljs-attr">store</span>: <span class="hljs-title class_">PropTypes</span>.<span class="hljs-property">object</span><br>        &#125;<br><br>        <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>            <span class="hljs-variable language_">super</span>()<br>            <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = &#123;<br>                <span class="hljs-attr">allProps</span>: &#123;&#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 第一遍需初始化所有组件初始状态</span><br>        <span class="hljs-title function_">componentWillMount</span>(<span class="hljs-params"></span>) &#123;<br>            <span class="hljs-keyword">const</span> store = <span class="hljs-variable language_">this</span>.<span class="hljs-property">context</span>.<span class="hljs-property">store</span><br>            <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">_updateProps</span>()<br>            store.<span class="hljs-title function_">subscribe</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">_updateProps</span>()); <span class="hljs-comment">// 加入_updateProps()至store里的监听事件列表</span><br>        &#125;<br><br>        <span class="hljs-comment">// 执行action后更新props，使组件可以更新至最新状态（类似于setState）</span><br>        <span class="hljs-title function_">_updateProps</span>(<span class="hljs-params"></span>) &#123;<br>            <span class="hljs-keyword">const</span> store = <span class="hljs-variable language_">this</span>.<span class="hljs-property">context</span>.<span class="hljs-property">store</span>;<br>            <span class="hljs-keyword">let</span> stateProps = mapStateToProps ?<br>                <span class="hljs-title function_">mapStateToProps</span>(store.<span class="hljs-title function_">getState</span>(), <span class="hljs-variable language_">this</span>.<span class="hljs-property">props</span>) : &#123;&#125; <span class="hljs-comment">// 防止 mapStateToProps 没有传入</span><br>            <span class="hljs-keyword">let</span> dispatchProps = mapDispatchToProps ?<br>                <span class="hljs-title function_">mapDispatchToProps</span>(store.<span class="hljs-property">dispatch</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">props</span>) : &#123;<br>                                    <span class="hljs-attr">dispatch</span>: store.<span class="hljs-property">dispatch</span><br>                                &#125; <span class="hljs-comment">// 防止 mapDispatchToProps 没有传入</span><br>            <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123;<br>                <span class="hljs-attr">allProps</span>: &#123;<br>                    ...stateProps,<br>                    ...dispatchProps,<br>                    ...<span class="hljs-variable language_">this</span>.<span class="hljs-property">props</span><br>                &#125;<br>            &#125;)<br>        &#125;<br><br>        <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">WrappedComponent</span> &#123;<span class="hljs-attr">...this.state.allProps</span>&#125; /&gt;</span></span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Connect</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="9-React组件的state和props有什么区别？"><a href="#9-React组件的state和props有什么区别？" class="headerlink" title="9. React组件的state和props有什么区别？"></a>9. React组件的state和props有什么区别？</h3><p><strong>（1）props</strong></p><p>props是一个从外部传进组件的参数，主要作为就是从父组件向子组件传递数据，它具有可读性和不变性，只能通过外部组件主动传入新的props来重新渲染子组件，否则子组件的props以及展现形式不会改变。</p><p><strong>（2）state</strong></p><p>state的主要作用是用于组件保存、控制以及修改自己的状态，它只能在constructor中初始化，它算是组件的私有属性，不可通过外部访问和修改，只能通过组件内部的this.setState来修改，修改state属性会导致组件的重新渲染。</p><p><strong>（3）区别</strong></p><ul><li>props 是传递给组件的（类似于函数的形参），而state 是在组件内被组件自己管理的（类似于在一个函数内声明的变量）。</li><li>props 是不可修改的，所有 React 组件都必须像纯函数一样保护它们的 props 不被更改。</li><li>state 是在组件中创建的，一般在 constructor中初始化 state。state 是多变的、可以修改，每次setState都异步更新的。</li></ul><h3 id="10-React中的props为什么是只读的？"><a href="#10-React中的props为什么是只读的？" class="headerlink" title="10. React中的props为什么是只读的？"></a>10. React中的props为什么是只读的？</h3><p><code>this.props</code>是组件之间沟通的一个接口，原则上来讲，它只能从父组件流向子组件。React具有浓重的函数式编程的思想。</p><p>提到函数式编程就要提一个概念：纯函数。它有几个特点：</p><ul><li>给定相同的输入，总是返回相同的输出。</li><li>过程没有副作用。</li><li>不依赖外部状态。</li></ul><p><code>this.props</code>就是汲取了纯函数的思想。props的不可以变性就保证的相同的输入，页面显示的内容是一样的，并且不会产生副作用</p><h3 id="11-在React中组件的props改变时更新组件的有哪些方法？"><a href="#11-在React中组件的props改变时更新组件的有哪些方法？" class="headerlink" title="11. 在React中组件的props改变时更新组件的有哪些方法？"></a>11. 在React中组件的props改变时更新组件的有哪些方法？</h3><p>在一个组件传入的props更新时重新渲染该组件常用的方法是在<code>componentWillReceiveProps</code>中将新的props更新到组件的state中（这种state被成为派生状态（Derived State）），从而实现重新渲染。React 16.3中还引入了一个新的钩子函数<code>getDerivedStateFromProps</code>来专门实现这一需求。</p><p><strong>（1）componentWillReceiveProps（已废弃）</strong></p><p>在react的componentWillReceiveProps(nextProps)生命周期中，可以在子组件的render函数执行前，通过this.props获取旧的属性，通过nextProps获取新的props，对比两次props是否相同，从而更新子组件自己的state。</p><p>这样的好处是，可以将数据请求放在这里进行执行，需要传的参数则从componentWillReceiveProps(nextProps)中获取。而不必将所有的请求都放在父组件中。于是该请求只会在该组件渲染时才会发出，从而减轻请求负担。</p><p><strong>（2）getDerivedStateFromProps（16.3引入）</strong></p><p>这个生命周期函数是为了替代<code>componentWillReceiveProps</code>存在的，所以在需要使用<code>componentWillReceiveProps</code>时，就可以考虑使用<code>getDerivedStateFromProps</code>来进行替代。</p><p>两者的参数是不相同的，而<code>getDerivedStateFromProps</code>是一个静态函数，也就是这个函数不能通过this访问到class的属性，也并不推荐直接访问属性。而是应该通过参数提供的nextProps以及prevState来进行判断，根据新传入的props来映射到state。</p><p>需要注意的是，<strong>如果props传入的内容不需要影响到你的state，那么就需要返回一个null</strong>，这个返回值是必须的，所以尽量将其写到函数的末尾：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">static</span> <span class="hljs-title function_">getDerivedStateFromProps</span>(<span class="hljs-params">nextProps, prevState</span>) &#123;<br>    <span class="hljs-keyword">const</span> &#123;type&#125; = nextProps;<br>    <span class="hljs-comment">// 当传入的type发生变化的时候，更新state</span><br>    <span class="hljs-keyword">if</span> (type !== prevState.<span class="hljs-property">type</span>) &#123;<br>        <span class="hljs-keyword">return</span> &#123;<br>            type,<br>        &#125;;<br>    &#125;<br>    <span class="hljs-comment">// 否则，对于state不进行任何操作</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="12-React中怎么检验props？验证props的目的是什么？"><a href="#12-React中怎么检验props？验证props的目的是什么？" class="headerlink" title="12. React中怎么检验props？验证props的目的是什么？"></a>12. React中怎么检验props？验证props的目的是什么？</h3><p><strong>React</strong>为我们提供了<strong>PropTypes</strong>以供验证使用。当我们向<strong>Props</strong>传入的数据无效（向Props传入的数据类型和验证的数据类型不符）就会在控制台发出警告信息。它可以避免随着应用越来越复杂从而出现的问题。并且，它还可以让程序变得更易读。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">PropTypes</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;prop-types&#x27;</span>;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Greeting</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;<br>  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> (<br>      <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Hello, &#123;this.props.name&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br>    );<br>  &#125;<br>&#125;<br><br><span class="hljs-title class_">Greeting</span>.<span class="hljs-property">propTypes</span> = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-title class_">PropTypes</span>.<span class="hljs-property">string</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>当然，如果项目汇中使用了TypeScript，那么就可以不用PropTypes来校验，而使用TypeScript定义接口来校验props。</p><h2 id="三、生命周期"><a href="#三、生命周期" class="headerlink" title="三、生命周期"></a>三、生命周期</h2><h3 id="1-React的生命周期有哪些？"><a href="#1-React的生命周期有哪些？" class="headerlink" title="1. React的生命周期有哪些？"></a>1. React的生命周期有哪些？</h3><p> React 通常将组件生命周期分为三个阶段：</p><ul><li>装载阶段（Mount），组件第一次在DOM树中被渲染的过程；</li><li>更新过程（Update），组件状态发生变化，重新更新渲染的过程；</li><li>卸载过程（Unmount），组件从DOM树中被移除的过程；</li></ul><p><img src="5.png" alt="img"></p><h4 id="1）组件挂载阶段"><a href="#1）组件挂载阶段" class="headerlink" title="1）组件挂载阶段"></a>1）组件挂载阶段</h4><p>挂载阶段组件被创建，然后组件实例插入到 DOM 中，完成组件的第一次渲染，该过程只会发生一次，在此阶段会依次调用以下这些方法：</p><ul><li>constructor</li><li>getDerivedStateFromProps</li><li>render</li><li>componentDidMount</li></ul><h5 id="（1）constructor"><a href="#（1）constructor" class="headerlink" title="（1）constructor"></a>（1）constructor</h5><p>组件的构造函数，第一个被执行，若没有显式定义它，会有一个默认的构造函数，但是若显式定义了构造函数，我们必须在构造函数中执行 <code>super(props)</code>，否则无法在构造函数中拿到this。</p><p>如果不初始化 state 或不进行方法绑定，则不需要为 React 组件实现构造函数<strong>Constructor</strong>。</p><p>constructor中通常只做两件事： </p><ul><li>初始化组件的 state</li><li>给事件处理方法绑定 this</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">constructor</span>(<span class="hljs-params">props</span>) &#123;<br>  <span class="hljs-variable language_">super</span>(props);<br>  <span class="hljs-comment">// 不要在构造函数中调用 setState，可以直接给 state 设置初始值</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = &#123; <span class="hljs-attr">counter</span>: <span class="hljs-number">0</span> &#125;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">handleClick</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">handleClick</span>.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="（2）getDerivedStateFromProps"><a href="#（2）getDerivedStateFromProps" class="headerlink" title="（2）getDerivedStateFromProps"></a>（2）getDerivedStateFromProps</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">static</span> <span class="hljs-title function_">getDerivedStateFromProps</span>(props, state)<br></code></pre></td></tr></table></figure><p>这是个静态方法，所以不能在这个函数里使用 <code>this</code>，有两个参数 <code>props</code> 和 <code>state</code>，分别指接收到的新参数和当前组件的 <code>state</code> 对象，这个函数会返回一个对象用来更新当前的 <code>state</code> 对象，如果不需要更新可以返回 <code>null</code>。</p><p>该函数会在装载时，接收到新的 <code>props</code> 或者调用了 <code>setState</code> 和 <code>forceUpdate</code> 时被调用。如当接收到新的属性想修改 <code>state</code> ，就可以使用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 当 props.counter 变化时，赋值给 state </span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">props</span>) &#123;<br>    <span class="hljs-variable language_">super</span>(props)<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = &#123;<br>      <span class="hljs-attr">counter</span>: <span class="hljs-number">0</span><br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">static</span> <span class="hljs-title function_">getDerivedStateFromProps</span>(<span class="hljs-params">props, state</span>) &#123;<br>    <span class="hljs-keyword">if</span> (props.<span class="hljs-property">counter</span> !== state.<span class="hljs-property">counter</span>) &#123;<br>      <span class="hljs-keyword">return</span> &#123;<br>        <span class="hljs-attr">counter</span>: props.<span class="hljs-property">counter</span><br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span><br>  &#125;<br>  <br>  handleClick = <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123;<br>      <span class="hljs-attr">counter</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">counter</span> + <span class="hljs-number">1</span><br>    &#125;)<br>  &#125;<br>  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> (<br>      <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;this.handleClick&#125;</span>&gt;</span>Hello, world!&#123;this.state.counter&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>    )<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>现在可以显式传入 <code>counter</code> ，但是这里有个问题，如果想要通过点击实现 <code>state.counter</code> 的增加，但这时会发现值不会发生任何变化，一直保持 <code>props</code> 传进来的值。这是由于在 React 16.4^ 的版本中 <code>setState</code> 和 <code>forceUpdate</code> 也会触发这个生命周期，所以当组件内部 <code>state</code> 变化后，就会重新走这个方法，同时会把 <code>state</code> 值赋值为 <code>props</code> 的值。因此需要多加一个字段来记录之前的 <code>props</code> 值，这样就会解决上述问题。具体如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 这里只列出需要变化的地方</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">props</span>) &#123;<br>    <span class="hljs-variable language_">super</span>(props)<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = &#123;<br>      <span class="hljs-comment">// 增加一个 preCounter 来记录之前的 props 传来的值</span><br>      <span class="hljs-attr">preCounter</span>: <span class="hljs-number">0</span>,<br>      <span class="hljs-attr">counter</span>: <span class="hljs-number">0</span><br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">static</span> <span class="hljs-title function_">getDerivedStateFromProps</span>(<span class="hljs-params">props, state</span>) &#123;<br>    <span class="hljs-comment">// 跟 state.preCounter 进行比较</span><br>    <span class="hljs-keyword">if</span> (props.<span class="hljs-property">counter</span> !== state.<span class="hljs-property">preCounter</span>) &#123;<br>      <span class="hljs-keyword">return</span> &#123;<br>        <span class="hljs-attr">counter</span>: props.<span class="hljs-property">counter</span>,<br>        <span class="hljs-attr">preCounter</span>: props.<span class="hljs-property">counter</span><br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span><br>  &#125;<br>  handleClick = <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123;<br>      <span class="hljs-attr">counter</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">counter</span> + <span class="hljs-number">1</span><br>    &#125;)<br>  &#125;<br>  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> (<br>      <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;this.handleClick&#125;</span>&gt;</span>Hello, world!&#123;this.state.counter&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>    )<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="（3）render"><a href="#（3）render" class="headerlink" title="（3）render"></a>（3）render</h5><p>render是React 中最核心的方法，一个组件中必须要有这个方法，它会根据状态 <code>state</code> 和属性 <code>props</code> 渲染组件。这个函数只做一件事，就是返回需要渲染的内容，所以不要在这个函数内做其他业务逻辑，通常调用该方法会返回以下类型中一个：</p><ul><li><strong>React 元素</strong>：这里包括原生的 DOM 以及 React 组件；</li><li><strong>数组和 Fragment（片段）</strong>：可以返回多个元素；</li><li><strong>Portals（插槽）</strong>：可以将子元素渲染到不同的 DOM 子树种；</li><li><strong>字符串和数字</strong>：被渲染成 DOM 中的 text 节点；</li><li><strong>布尔值或 null</strong>：不渲染任何内容。</li></ul><h5 id="（4）componentDidMount"><a href="#（4）componentDidMount" class="headerlink" title="（4）componentDidMount()"></a>（4）componentDidMount()</h5><p>componentDidMount()会在组件挂载后（插入 DOM 树中）立即调。该阶段通常进行以下操作：</p><ul><li>执行依赖于DOM的操作；</li><li>发送网络请求；（官方建议）</li><li>添加订阅消息（会在componentWillUnmount取消订阅）；</li></ul><p>如果在 <code>componentDidMount</code> 中调用 <code>setState</code> ，就会触发一次额外的渲染，多调用了一次 <code>render</code> 函数，由于它是在浏览器刷新屏幕前执行的，所以用户对此是没有感知的，但是我应当避免这样使用，这样会带来一定的性能问题，尽量是在 <code>constructor</code> 中初始化 <code>state</code> 对象。</p><p>在组件装载之后，将计数数字变为1：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span>  &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">props</span>) &#123;<br>    <span class="hljs-variable language_">super</span>(props)<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = &#123;<br>      <span class="hljs-attr">counter</span>: <span class="hljs-number">0</span><br>    &#125;<br>  &#125;<br>  componentDidMount () &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123;<br>      <span class="hljs-attr">counter</span>: <span class="hljs-number">1</span><br>    &#125;)<br>  &#125;<br>  render ()  &#123;<br>    <span class="hljs-keyword">return</span> (<br>      <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;counter&quot;</span>&gt;</span></span><br><span class="language-xml">        counter值: &#123; this.state.counter &#125;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>    )<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2）组件更新阶段"><a href="#2）组件更新阶段" class="headerlink" title="2）组件更新阶段"></a>2）组件更新阶段</h4><p>当组件的 <code>props</code> 改变了，或组件内部调用了 <code>setState/forceUpdate</code>，会触发更新重新渲染，这个过程可能会发生多次。这个阶段会依次调用下面这些方法：</p><ul><li>getDerivedStateFromProps</li><li>shouldComponentUpdate</li><li>render</li><li>getSnapshotBeforeUpdate</li><li>componentDidUpdate</li></ul><h5 id="（1）shouldComponentUpdate"><a href="#（1）shouldComponentUpdate" class="headerlink" title="（1）shouldComponentUpdate"></a>（1）shouldComponentUpdate</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">shouldComponentUpdate</span>(nextProps, nextState)<br></code></pre></td></tr></table></figure><p>在说这个生命周期函数之前，来看两个问题：</p><ul><li><strong>setState 函数在任何情况下都会导致组件重新渲染吗？例如下面这种情况：</strong></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123;<span class="hljs-attr">number</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">number</span>&#125;)<br></code></pre></td></tr></table></figure><ul><li><strong>如果没有调用 setState，props 值也没有变化，是不是组件就不会重新渲染？</strong></li></ul><p>第一个问题答案是 <strong>会</strong> ，第二个问题如果是父组件重新渲染时，不管传入的 props 有没有变化，都会引起子组件的重新渲染。</p><p>那么有没有什么方法解决在这两个场景下不让组件重新渲染进而提升性能呢？这个时候 <code>shouldComponentUpdate</code> 登场了，这个生命周期函数是用来提升速度的，它是在重新渲染组件开始前触发的，默认返回 <code>true</code>，可以比较 <code>this.props</code> 和 <code>nextProps</code> ，<code>this.state</code> 和 <code>nextState</code> 值是否变化，来确认返回 true 或者 <code>false</code>。当返回 <code>false</code> 时，组件的更新过程停止，后续的 <code>render</code>、<code>componentDidUpdate</code> 也不会被调用。</p><p><strong>注意：</strong> 添加 <code>shouldComponentUpdate</code> 方法时，不建议使用深度相等检查（如使用 <code>JSON.stringify()</code>），因为深比较效率很低，可能会比重新渲染组件效率还低。而且该方法维护比较困难，建议使用该方法会产生明显的性能提升时使用。</p><h5 id="（2）getSnapshotBeforeUpdate"><a href="#（2）getSnapshotBeforeUpdate" class="headerlink" title="（2）getSnapshotBeforeUpdate"></a>（2）getSnapshotBeforeUpdate</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">getSnapshotBeforeUpdate</span>(prevProps, prevState)<br></code></pre></td></tr></table></figure><p>这个方法在 <code>render</code> 之后，<code>componentDidUpdate</code> 之前调用，有两个参数 <code>prevProps</code> 和 <code>prevState</code>，表示更新之前的 <code>props</code> 和 <code>state</code>，这个函数必须要和 <code>componentDidUpdate</code> 一起使用，并且要有一个返回值，默认是 <code>null</code>，这个返回值作为第三个参数传给 <code>componentDidUpdate</code>。</p><h5 id="（3）componentDidUpdate"><a href="#（3）componentDidUpdate" class="headerlink" title="（3）componentDidUpdate"></a>（3）componentDidUpdate</h5><p>componentDidUpdate() 会在更新后会被立即调用，首次渲染不会执行此方法。 该阶段通常进行以下操作：</p><ul><li>当组件更新后，对 DOM 进行操作； </li><li>如果你对更新前后的 props 进行了比较，也可以选择在此处进行网络请求；（例如，当 props 未发生变化时，则不会执行网络请求）。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">componentDidUpdate</span>(<span class="hljs-params">prevProps, prevState, snapshot</span>)&#123;&#125;<br></code></pre></td></tr></table></figure><p>该方法有三个参数：</p><ul><li>prevProps: 更新前的props</li><li>prevState: 更新前的state</li><li>snapshot: getSnapshotBeforeUpdate()生命周期的返回值</li></ul><h4 id="3）组件卸载阶段"><a href="#3）组件卸载阶段" class="headerlink" title="3）组件卸载阶段"></a>3）组件卸载阶段</h4><p>卸载阶段只有一个生命周期函数，componentWillUnmount() 会在组件卸载及销毁之前直接调用。在此方法中执行必要的清理操作：</p><ul><li>清除 timer，取消网络请求或清除</li><li>取消在 componentDidMount() 中创建的订阅等；</li></ul><p>这个生命周期在一个组件被卸载和销毁之前被调用，因此你不应该再这个方法中使用 <code>setState</code>，因为组件一旦被卸载，就不会再装载，也就不会重新渲染。</p><h4 id="4）错误处理阶段"><a href="#4）错误处理阶段" class="headerlink" title="4）错误处理阶段"></a>4）错误处理阶段</h4><p>componentDidCatch(error, info)，此生命周期在后代组件抛出错误后被调用。 它接收两个参数∶</p><ul><li>error：抛出的错误。</li><li>info：带有 componentStack key 的对象，其中包含有关组件引发错误的栈信息</li></ul><p>React常见的生命周期如下：<br><img src="6.png" alt="img"><br><strong>React常见生命周期的过程大致如下：</strong></p><ul><li>挂载阶段，首先执行constructor构造方法，来创建组件</li><li>创建完成之后，就会执行render方法，该方法会返回需要渲染的内容</li><li>随后，React会将需要渲染的内容挂载到DOM树上</li><li><strong>挂载完成之后就会执行componentDidMount生命周期函数</strong></li><li>如果我们给组件创建一个props（用于组件通信）、调用setState（更改state中的数据）、调用forceUpdate（强制更新组件）时，都会重新调用render函数</li><li>render函数重新执行之后，就会重新进行DOM树的挂载</li><li><strong>挂载完成之后就会执行componentDidUpdate生命周期函数</strong></li><li><strong>当移除组件时，就会执行componentWillUnmount生命周期函数</strong></li></ul><p><strong>React主要生命周期总结：</strong></p><ol><li><strong>getDefaultProps</strong>：这个函数会在组件创建之前被调用一次（有且仅有一次），它被用来初始化组件的 Props；</li><li><strong>getInitialState</strong>：用于初始化组件的 state 值；</li><li><strong>componentWillMount</strong>：在组件创建后、render 之前，会走到 componentWillMount 阶段。这个阶段我个人一直没用过、非常鸡肋。后来React 官方已经不推荐大家在 componentWillMount 里做任何事情、到现在 <strong>React16 直接废弃了这个生命周期</strong>，足见其鸡肋程度了；</li><li><strong>render</strong>：这是所有生命周期中唯一一个你必须要实现的方法。一般来说需要返回一个 jsx 元素，这时 React 会根据 props 和 state 来把组件渲染到界面上；不过有时，你可能不想渲染任何东西，这种情况下让它返回 null 或者 false 即可；</li><li><strong>componentDidMount</strong>：会在组件挂载后（插入 DOM 树中后）立即调用，标志着组件挂载完成。一些操作如果依赖获取到 DOM 节点信息，我们就会放在这个阶段来做。此外，这还是 React 官方推荐的发起 ajax 请求的时机。该方法和 componentWillMount 一样，有且仅有一次调用。</li></ol><h3 id="2-React-废弃了哪些生命周期？为什么？"><a href="#2-React-废弃了哪些生命周期？为什么？" class="headerlink" title="2. React 废弃了哪些生命周期？为什么？"></a>2. React 废弃了哪些生命周期？为什么？</h3><p>被废弃的三个函数都是在render之前，因为fber的出现，很可能因为高优先级任务的出现而打断现有任务导致它们会被执行多次。另外的一个原因则是，React想约束使用者，好的框架能够让人不得已写出容易维护和扩展的代码，这一点又是从何谈起，可以从新增加以及即将废弃的生命周期分析入手</p><p><strong>1) componentWillMount</strong></p><p>首先这个函数的功能完全可以使用componentDidMount和 constructor来代替，异步获取的数据的情况上面已经说明了，而如果抛去异步获取数据，其余的即是初始化而已，这些功能都可以在constructor中执行，除此之外，如果在 willMount 中订阅事件，但在服务端这并不会执行 willUnMount事件，也就是说服务端会导致内存泄漏所以componentWilIMount完全可以不使用，但使用者有时候难免因为各 种各样的情况在 componentWilMount中做一些操作，那么React为了约束开发者，干脆就抛掉了这个API </p><p><strong>2) componentWillReceiveProps</strong></p><p>在老版本的 React 中，如果组件自身的某个 state 跟其 props 密切相关的话，一直都没有一种很优雅的处理方式去更新 state，而是需要在 componentWilReceiveProps 中判断前后两个 props 是否相同，如果不同再将新的 props更新到相应的 state 上去。这样做一来会破坏 state 数据的单一数据源，导致组件状态变得不可预测，另一方面也会增加组件的重绘次数。类似的业务需求也有很多，如一个可以横向滑动的列表，当前高亮的 Tab 显然隶属于列表自身的时，根据传入的某个值，直接定位到某个 Tab。为了解决这些问题，React引入了第一个新的生命周期：getDerivedStateFromProps。它有以下的优点∶</p><ul><li>getDSFP是静态方法，在这里不能使用this，也就是一个纯函数，开发者不能写出副作用的代码</li><li>开发者只能通过prevState而不是prevProps来做对比，保证了state和props之间的简单关系以及不需要处理第一次渲染时prevProps为空的情况</li><li>基于第一点，将状态变化（setState）和昂贵操作（tabChange）区分开，更加便于 render 和 commit 阶段操作或者说优化。</li></ul><p><strong>3) componentWillUpdate</strong></p><p>与 componentWillReceiveProps 类似，许多开发者也会在 componentWillUpdate 中根据 props 的变化去触发一些回调 。 但不论是 componentWilReceiveProps 还 是 componentWilUpdate，都有可能在一次更新中被调用多次，也就是说写在这里的回调函数也有可能会被调用多次，这显然是不可取的。与 componentDidMount 类 似， componentDidUpdate 也不存在这样的问题，一次更新中 componentDidUpdate 只会被调用一次，所以将原先写在 componentWillUpdate 中 的 回 调 迁 移 至 componentDidUpdate 就可以解决这个问题。</p><p>另外一种情况则是需要获取DOM元素状态，但是由于在fber中，render可打断，可能在wilMount中获取到的元素状态很可能与实际需要的不同，这个通常可以使用第二个新增的生命函数的解决 getSnapshotBeforeUpdate(prevProps, prevState)</p><p><strong>4) getSnapshotBeforeUpdate(prevProps, prevState)</strong></p><p>返回的值作为componentDidUpdate的第三个参数。与willMount不同的是，getSnapshotBeforeUpdate会在最终确定的render执行之前执行，也就是能保证其获取到的元素状态与didUpdate中获取到的元素状态相同。官方参考代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ScrollingList</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">props</span>) &#123;<br>    <span class="hljs-variable language_">super</span>(props);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">listRef</span> = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">createRef</span>();<br>  &#125;<br><br>  <span class="hljs-title function_">getSnapshotBeforeUpdate</span>(<span class="hljs-params">prevProps, prevState</span>) &#123;<br>    <span class="hljs-comment">// 我们是否在 list 中添加新的 items ？</span><br>    <span class="hljs-comment">// 捕获滚动​​位置以便我们稍后调整滚动位置。</span><br>    <span class="hljs-keyword">if</span> (prevProps.<span class="hljs-property">list</span>.<span class="hljs-property">length</span> &lt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">props</span>.<span class="hljs-property">list</span>.<span class="hljs-property">length</span>) &#123;<br>      <span class="hljs-keyword">const</span> list = <span class="hljs-variable language_">this</span>.<span class="hljs-property">listRef</span>.<span class="hljs-property">current</span>;<br>      <span class="hljs-keyword">return</span> list.<span class="hljs-property">scrollHeight</span> - list.<span class="hljs-property">scrollTop</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>  &#125;<br><br>  <span class="hljs-title function_">componentDidUpdate</span>(<span class="hljs-params">prevProps, prevState, snapshot</span>) &#123;<br>    <span class="hljs-comment">// 如果我们 snapshot 有值，说明我们刚刚添加了新的 items，</span><br>    <span class="hljs-comment">// 调整滚动位置使得这些新 items 不会将旧的 items 推出视图。</span><br>    <span class="hljs-comment">//（这里的 snapshot 是 getSnapshotBeforeUpdate 的返回值）</span><br>    <span class="hljs-keyword">if</span> (snapshot !== <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-keyword">const</span> list = <span class="hljs-variable language_">this</span>.<span class="hljs-property">listRef</span>.<span class="hljs-property">current</span>;<br>      list.<span class="hljs-property">scrollTop</span> = list.<span class="hljs-property">scrollHeight</span> - snapshot;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> (<br>      <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&#123;this.listRef&#125;</span>&gt;</span>&#123;/* ...contents... */&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-React-16-X-中-props-改变后在哪个生命周期中处理"><a href="#3-React-16-X-中-props-改变后在哪个生命周期中处理" class="headerlink" title="3. React 16.X 中 props 改变后在哪个生命周期中处理"></a>3. React 16.X 中 props 改变后在哪个生命周期中处理</h3><p><strong>在getDerivedStateFromProps中进行处理。</strong></p><p>这个生命周期函数是为了替代<code>componentWillReceiveProps</code>存在的，所以在需要使用<code>componentWillReceiveProps</code>时，就可以考虑使用<code>getDerivedStateFromProps</code>来进行替代。</p><p>两者的参数是不相同的，而<code>getDerivedStateFromProps</code>是一个静态函数，也就是这个函数不能通过this访问到class的属性，也并不推荐直接访问属性。而是应该通过参数提供的nextProps以及prevState来进行判断，根据新传入的props来映射到state。</p><p>需要注意的是，<strong>如果props传入的内容不需要影响到你的state，那么就需要返回一个null</strong>，这个返回值是必须的，所以尽量将其写到函数的末尾：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">static</span> <span class="hljs-title function_">getDerivedStateFromProps</span>(<span class="hljs-params">nextProps, prevState</span>) &#123;<br>    <span class="hljs-keyword">const</span> &#123;type&#125; = nextProps;<br>    <span class="hljs-comment">// 当传入的type发生变化的时候，更新state</span><br>    <span class="hljs-keyword">if</span> (type !== prevState.<span class="hljs-property">type</span>) &#123;<br>        <span class="hljs-keyword">return</span> &#123;<br>            type,<br>        &#125;;<br>    &#125;<br>    <span class="hljs-comment">// 否则，对于state不进行任何操作</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-React-性能优化在哪个生命周期？它优化的原理是什么？"><a href="#4-React-性能优化在哪个生命周期？它优化的原理是什么？" class="headerlink" title="4. React 性能优化在哪个生命周期？它优化的原理是什么？"></a>4. React 性能优化在哪个生命周期？它优化的原理是什么？</h3><p>react的父级组件的render函数重新渲染会引起子组件的render方法的重新渲染。但是，有的时候子组件的接受父组件的数据没有变动。子组件render的执行会影响性能，这时就可以使用shouldComponentUpdate来解决这个问题。</p><p>使用方法如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">shouldComponentUpdate</span>(<span class="hljs-params">nexrProps</span>) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">props</span>.<span class="hljs-property">num</span> === nexrProps.<span class="hljs-property">num</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>shouldComponentUpdate提供了两个参数nextProps和nextState，表示下一次props和一次state的值，当函数返回false时候，render()方法不执行，组件也就不会渲染，返回true时，组件照常重渲染。此方法就是拿当前props中值和下一次props中的值进行对比，数据相等时，返回false，反之返回true。</p><p>需要注意，在进行新旧对比的时候，是<strong>浅对比，</strong>也就是说如果比较的数据时引用数据类型，只要数据的引用的地址没变，即使内容变了，也会被判定为true。</p><p>面对这个问题，可以使用如下方法进行解决：<br>（1）使用setState改变数据之前，先采用ES6中assgin进行拷贝，但是assgin只深拷贝的数据的第一层，所以说不是最完美的解决办法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> o2 = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(&#123;&#125;,<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">obj</span>)<br>    o2.<span class="hljs-property">student</span>.<span class="hljs-property">count</span> = <span class="hljs-string">&#x27;00000&#x27;</span>;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123;<br>        <span class="hljs-attr">obj</span>: o2,<br>    &#125;)<br></code></pre></td></tr></table></figure><p>（2）使用JSON.parse(JSON.stringfy())进行深拷贝，但是遇到数据为undefined和函数时就会错。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> o2 = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">obj</span>))<br>    o2.<span class="hljs-property">student</span>.<span class="hljs-property">count</span> = <span class="hljs-string">&#x27;00000&#x27;</span>;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123;<br>        <span class="hljs-attr">obj</span>: o2,<br>    &#125;)<br></code></pre></td></tr></table></figure><h3 id="5-state-和-props-触发更新的生命周期分别有什么区别？"><a href="#5-state-和-props-触发更新的生命周期分别有什么区别？" class="headerlink" title="5. state 和 props 触发更新的生命周期分别有什么区别？"></a>5. state 和 props 触发更新的生命周期分别有什么区别？</h3><p><strong>state 更新流程：</strong><br><img src="7.png" alt="img"><br>这个过程当中涉及的函数：</p><ol><li>shouldComponentUpdate: 当组件的 state 或 props 发生改变时，都会首先触发这个生命周期函数。它会接收两个参数：nextProps, nextState——它们分别代表传入的新 props 和新的 state 值。拿到这两个值之后，我们就可以通过一些对比逻辑来决定是否有 re-render（重渲染）的必要了。如果该函数的返回值为 false，则生命周期终止，反之继续；</li></ol><blockquote><p>注意：此方法仅作为<strong>性能优化的方式</strong>而存在。不要企图依靠此方法来“阻止”渲染，因为这可能会产生 bug。应该<strong>考虑使用内置的 PureComponent 组件</strong>，而不是手动编写 <code>shouldComponentUpdate()</code></p></blockquote><ol start="2"><li>componentWillUpdate：当组件的 state 或 props 发生改变时，会在渲染之前调用 componentWillUpdate。componentWillUpdate <strong>是 React16 废弃的三个生命周期之一</strong>。过去，我们可能希望能在这个阶段去收集一些必要的信息（比如更新前的 DOM 信息等等），现在我们完全可以在 React16 的 getSnapshotBeforeUpdate 中去做这些事；</li><li>componentDidUpdate：componentDidUpdate() 会在UI更新后会被立即调用。它接收 prevProps（上一次的 props 值）作为入参，也就是说在此处我们仍然可以进行 props 值对比（再次说明 componentWillUpdate 确实鸡肋哈）。</li></ol><p><strong>​</strong></p><p><strong>props 更新流程：</strong><br><img src="8.png" alt="img"><br>相对于 state 更新，props 更新后唯一的区别是增加了对 componentWillReceiveProps 的调用。关于 componentWillReceiveProps，需要知道这些事情：</p><ul><li>componentWillReceiveProps：它在Component接受到新的 props 时被触发。componentWillReceiveProps 会接收一个名为 nextProps 的参数（对应新的 props 值）。<strong>该生命周期是 React16 废弃掉的三个生命周期之一</strong>。在它被废弃前，可以用它来比较 this.props 和 nextProps 来重新setState。在 React16 中，用一个类似的新生命周期 getDerivedStateFromProps 来代替它。</li></ul><h3 id="6-React中发起网络请求应该在哪个生命周期中进行？为什么？"><a href="#6-React中发起网络请求应该在哪个生命周期中进行？为什么？" class="headerlink" title="6. React中发起网络请求应该在哪个生命周期中进行？为什么？"></a>6. React中发起网络请求应该在哪个生命周期中进行？为什么？</h3><p>对于异步请求，最好放在componentDidMount中去操作，对于同步的状态改变，可以放在componentWillMount中，一般用的比较少。</p><p>如果认为在componentWillMount里发起请求能提早获得结果，这种想法其实是错误的，通常componentWillMount比componentDidMount早不了多少微秒，网络上任何一点延迟，这一点差异都可忽略不计。</p><p><strong>react的生命周期：</strong> constructor() -&gt; componentWillMount() -&gt; render() -&gt; componentDidMount()</p><p>上面这些方法的调用是有次序的，由上而下依次调用。</p><ul><li>constructor被调用是在组件准备要挂载的最开始，此时组件尚未挂载到网页上。</li><li>componentWillMount方法的调用在constructor之后，在render之前，在这方法里的代码调用setState方法不会触发重新render，所以它一般不会用来作加载数据之用。</li><li>componentDidMount方法中的代码，是在组件已经完全挂载到网页上才会调用被执行，所以可以保证数据的加载。此外，在这方法中调用setState方法，会触发重新渲染。所以，官方设计这个方法就是用来加载外部数据用的，或处理其他的副作用代码。与组件上的数据无关的加载，也可以在constructor里做，但constructor是做组件state初绐化工作，并不是做加载数据这工作的，constructor里也不能setState，还有加载的时间太长或者出错，页面就无法加载出来。所以有副作用的代码都会集中在componentDidMount方法里。</li></ul><p>总结：</p><ul><li>跟服务器端渲染（同构）有关系，如果在componentWillMount里面获取数据，fetch data会执行两次，一次在服务器端一次在客户端。在componentDidMount中可以解决这个问题，componentWillMount同样也会render两次。</li><li>在componentWillMount中fetch data，数据一定在render后才能到达，如果忘记了设置初始状态，用户体验不好。</li><li>react16.0以后，componentWillMount可能会被执行多次。</li></ul><h3 id="7-React-16中新生命周期有哪些"><a href="#7-React-16中新生命周期有哪些" class="headerlink" title="7. React 16中新生命周期有哪些"></a>7. React 16中新生命周期有哪些</h3><p>关于 React16 开始应用的新生命周期：<br><img src="9.png" alt="img"><br>可以看出，React16 自上而下地对生命周期做了另一种维度的解读：</p><ul><li><strong>Render 阶段</strong>：用于计算一些必要的状态信息。这个阶段可能会被 React 暂停，这一点和 React16 引入的 Fiber 架构（我们后面会重点讲解）是有关的；</li><li><strong>Pre-commit阶段</strong>：所谓“commit”，这里指的是“更新真正的 DOM 节点”这个动作。所谓 Pre-commit，就是说我在这个阶段其实还并没有去更新真实的 DOM，不过 DOM 信息已经是可以读取的了；</li><li><strong>Commit 阶段</strong>：在这一步，React 会完成真实 DOM 的更新工作。Commit 阶段，我们可以拿到真实 DOM（包括 refs）。</li></ul><p>与此同时，新的生命周期在流程方面，仍然遵循“挂载”、“更新”、“卸载”这三个广义的划分方式。它们分别对应到：</p><ul><li>挂载过程：<ul><li><strong>constructor</strong></li><li><strong>getDerivedStateFromProps</strong></li><li><strong>render</strong></li><li><strong>componentDidMount</strong></li></ul></li><li>更新过程：<ul><li><strong>getDerivedStateFromProps</strong></li><li><strong>shouldComponentUpdate</strong></li><li><strong>render</strong></li><li><strong>getSnapshotBeforeUpdate</strong></li><li><strong>componentDidUpdate</strong></li></ul></li><li>卸载过程：<ul><li><strong>componentWillUnmount</strong></li></ul></li></ul><h2 id="四、组件通信"><a href="#四、组件通信" class="headerlink" title="四、组件通信"></a>四、组件通信</h2><p>React组件间通信常见的几种情况:</p><ul><li>父组件向子组件通信</li><li>子组件向父组件通信</li><li>跨级组件通信</li><li>非嵌套关系的组件通信</li></ul><h3 id="1-父子组件的通信方式？"><a href="#1-父子组件的通信方式？" class="headerlink" title="1. 父子组件的通信方式？"></a>1. 父子组件的通信方式？</h3><p><strong>父组件向子组件通信</strong>：父组件通过 props 向子组件传递需要的信息。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 子组件: Child</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">Child</span> = props =&gt;&#123;<br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>&#123;props.name&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br>&#125;<br><span class="hljs-comment">// 父组件 Parent</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">Parent</span> = (<span class="hljs-params"></span>)=&gt;&#123;<br>    <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Child</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;react&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Child</span>&gt;</span></span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>子组件向父组件通信</strong>：: props+回调的方式。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 子组件: Child</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">Child</span> = props =&gt;&#123;<br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">cb</span> = msg =&gt;&#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-function">()=&gt;</span>&#123;<br>          props.<span class="hljs-title function_">callback</span>(msg)<br>      &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> (<br>      <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;cb(</span>&quot;<span class="hljs-attr">你好</span>!&quot;)&#125;&gt;</span>你好<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br>  )<br>&#125;<br><span class="hljs-comment">// 父组件 Parent</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Parent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Component</span> &#123;<br>    <span class="hljs-title function_">callback</span>(<span class="hljs-params">msg</span>)&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(msg)<br>    &#125;<br>    <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Child</span> <span class="hljs-attr">callback</span>=<span class="hljs-string">&#123;this.callback.bind(this)&#125;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Child</span>&gt;</span></span>    <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-跨级组件的通信方式？"><a href="#2-跨级组件的通信方式？" class="headerlink" title="2. 跨级组件的通信方式？"></a>2. 跨级组件的通信方式？</h3><p>父组件向子组件的子组件通信，向更深层子组件通信：</p><ul><li>使用props，利用中间组件层层传递,但是如果父组件结构较深，那么中间每一层组件都要去传递props，增加了复杂度，并且这些props并不是中间组件自己需要的。</li><li>使用context，context相当于一个大容器，可以把要通信的内容放在这个容器中，这样不管嵌套多深，都可以随意取用，对于跨越多层的全局数据可以使用context实现。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// context方式实现跨级组件通信 </span><br><span class="hljs-comment">// Context 设计目的是为了共享那些对于一个组件树而言是“全局”的数据</span><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">BatteryContext</span> = <span class="hljs-title function_">createContext</span>();<br><span class="hljs-comment">//  子组件的子组件 </span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">GrandChild</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Component</span> &#123;<br>    <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-keyword">return</span> (<br>            <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">BatteryContext.Consumer</span>&gt;</span></span><br><span class="language-xml">                &#123;</span><br><span class="language-xml">                    color =&gt; <span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&#123;&#123;</span>&quot;<span class="hljs-attr">color</span>&quot;<span class="hljs-attr">:color</span>&#125;&#125;&gt;</span>我是红色的:&#123;color&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br><span class="language-xml">                &#125;</span><br><span class="language-xml">            <span class="hljs-tag">&lt;/<span class="hljs-name">BatteryContext.Consumer</span>&gt;</span></span><br>        )<br>    &#125;<br>&#125;<br><span class="hljs-comment">//  子组件</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">Child</span> = (<span class="hljs-params"></span>) =&gt;&#123;<br>    <span class="hljs-keyword">return</span> (<br>        <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">GrandChild</span>/&gt;</span></span><br>    )<br>&#125;<br><span class="hljs-comment">// 父组件</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Parent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Component</span> &#123;<br>      state = &#123;<br>          <span class="hljs-attr">color</span>:<span class="hljs-string">&quot;red&quot;</span><br>      &#125;<br>      <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>)&#123;<br>          <span class="hljs-keyword">const</span> &#123;color&#125; = <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span><br>          <span class="hljs-keyword">return</span> (<br>          <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">BatteryContext.Provider</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;color&#125;</span>&gt;</span></span><br><span class="language-xml">              <span class="hljs-tag">&lt;<span class="hljs-name">Child</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Child</span>&gt;</span></span><br><span class="language-xml">          <span class="hljs-tag">&lt;/<span class="hljs-name">BatteryContext.Provider</span>&gt;</span></span><br>          )<br>      &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h3 id="3-非嵌套关系组件的通信方式？"><a href="#3-非嵌套关系组件的通信方式？" class="headerlink" title="3. 非嵌套关系组件的通信方式？"></a>3. 非嵌套关系组件的通信方式？</h3><p>即没有任何包含关系的组件，包括兄弟组件以及不在同一个父级中的非兄弟组件。</p><ul><li>可以使用自定义事件通信（发布订阅模式）</li><li>可以通过redux等进行全局状态管理</li><li>如果是兄弟组件通信，可以找到这两个兄弟节点共同的父节点, 结合父子间通信方式进行通信。</li></ul><h3 id="4-如何解决-props-层级过深的问题"><a href="#4-如何解决-props-层级过深的问题" class="headerlink" title="4. 如何解决 props 层级过深的问题"></a>4. 如何解决 props 层级过深的问题</h3><ul><li>使用Context API：提供一种组件之间的状态共享，而不必通过显式组件树逐层传递props；</li><li>使用Redux等状态库。</li></ul><h3 id="5-组件通信的方式有哪些"><a href="#5-组件通信的方式有哪些" class="headerlink" title="5. 组件通信的方式有哪些"></a>5. 组件通信的方式有哪些</h3><ul><li><strong>⽗组件向⼦组件通讯</strong>: ⽗组件可以向⼦组件通过传 props 的⽅式，向⼦组件进⾏通讯 </li><li><strong>⼦组件向⽗组件通讯</strong>: props+回调的⽅式，⽗组件向⼦组件传递props进⾏通讯，此props为作⽤域为⽗组件⾃身的函 数，⼦组件调⽤该函数，将⼦组件想要传递的信息，作为参数，传递到⽗组件的作⽤域中 </li><li><strong>兄弟组件通信</strong>: 找到这两个兄弟节点共同的⽗节点,结合上⾯两种⽅式由⽗节点转发信息进⾏通信 </li><li><strong>跨层级通信</strong>: Context 设计⽬的是为了共享那些对于⼀个组件树⽽⾔是“全局”的数据，例如当前认证的⽤户、主题或⾸选语⾔，对于跨越多层的全局数据通过 Context 通信再适合不过 </li><li><strong>发布订阅模式</strong>: 发布者发布事件，订阅者监听事件并做出反应,我们可以通过引⼊event模块进⾏通信 </li><li><strong>全局状态管理⼯具</strong>: 借助Redux或者Mobx等全局状态管理⼯具进⾏通信,这种⼯具会维护⼀个全局状态中⼼Store,并根据不同的事件产⽣新的状态</li></ul><h2 id="五、路由"><a href="#五、路由" class="headerlink" title="五、路由"></a>五、路由</h2><h3 id="1-React-Router的实现原理是什么？"><a href="#1-React-Router的实现原理是什么？" class="headerlink" title="1. React-Router的实现原理是什么？"></a>1. React-Router的实现原理是什么？</h3><p>客户端路由实现的思想：</p><ul><li>基于 hash 的路由：通过监听<code>hashchange</code>事件，感知 hash 的变化<ul><li>改变 hash 可以直接通过 location.hash&#x3D;xxx</li></ul></li><li>基于 H5 history 路由：<ul><li>改变 url 可以通过 history.pushState 和 resplaceState 等，会将URL压入堆栈，同时能够应用 <code>history.go()</code> 等 API</li><li>监听 url 的变化可以通过自定义事件触发实现</li></ul></li></ul><p><strong>react-router 实现的思想：</strong></p><ul><li>基于 <code>history</code> 库来实现上述不同的客户端路由实现思想，并且能够保存历史记录等，磨平浏览器差异，上层无感知</li><li>通过维护的列表，在每次 URL 发生变化的回收，通过配置的 路由路径，匹配到对应的 Component，并且 render</li></ul><h3 id="2-如何配置-React-Router-实现路由切换"><a href="#2-如何配置-React-Router-实现路由切换" class="headerlink" title="2. 如何配置 React-Router 实现路由切换"></a>2. 如何配置 React-Router 实现路由切换</h3><p><strong>（1）使用<code>&lt;Route&gt;</code> 组件</strong></p><p>路由匹配是通过比较 <code>&lt;Route&gt;</code> 的 path 属性和当前地址的 pathname 来实现的。当一个 <code>&lt;Route&gt;</code> 匹配成功时，它将渲染其内容，当它不匹配时就会渲染 null。没有路径的 <code>&lt;Route&gt;</code> 将始终被匹配。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// when location = &#123; pathname: &#x27;/about&#x27; &#125;</span><br>&lt;<span class="hljs-title class_">Route</span> path=<span class="hljs-string">&#x27;/about&#x27;</span> component=&#123;<span class="hljs-title class_">About</span>&#125;/&gt; <span class="hljs-comment">// renders &lt;About/&gt;</span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Route</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&#x27;/contact&#x27;</span> <span class="hljs-attr">component</span>=<span class="hljs-string">&#123;Contact&#125;/</span>&gt;</span></span> <span class="hljs-comment">// renders null</span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Route</span> <span class="hljs-attr">component</span>=<span class="hljs-string">&#123;Always&#125;/</span>&gt;</span></span> <span class="hljs-comment">// renders &lt;Always/&gt;</span><br></code></pre></td></tr></table></figure><p><strong>（2）结合使用 <code>&lt;Switch&gt;</code> 组件和 <code>&lt;Route&gt;</code> 组件</strong></p><p><code>&lt;Switch&gt;</code> 用于将 <code>&lt;Route&gt;</code> 分组。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;<span class="hljs-title class_">Switch</span>&gt;<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Route</span> <span class="hljs-attr">exact</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;/&quot;</span> <span class="hljs-attr">component</span>=<span class="hljs-string">&#123;Home&#125;</span> /&gt;</span></span><br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Route</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;/about&quot;</span> <span class="hljs-attr">component</span>=<span class="hljs-string">&#123;About&#125;</span> /&gt;</span></span><br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Route</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;/contact&quot;</span> <span class="hljs-attr">component</span>=<span class="hljs-string">&#123;Contact&#125;</span> /&gt;</span></span><br>&lt;/<span class="hljs-title class_">Switch</span>&gt;<br></code></pre></td></tr></table></figure><p><code>&lt;Switch&gt;</code> 不是分组 <code>&lt;Route&gt;</code> 所必须的，但他通常很有用。 一个 <code>&lt;Switch&gt;</code> 会遍历其所有的子 <code>&lt;Route&gt;</code>元素，并仅渲染与当前地址匹配的第一个元素。</p><p><strong>（3）使用 <code>&lt;Link&gt;、 &lt;NavLink&gt;、&lt;Redirect&gt;</code> 组件</strong></p><p><code>&lt;Link&gt;</code> 组件来在你的应用程序中创建链接。无论你在何处渲染一个<code>&lt;Link&gt;</code> ，都会在应用程序的 HTML 中渲染锚（<code>&lt;a&gt;</code>）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;<span class="hljs-title class_">Link</span> to=<span class="hljs-string">&quot;/&quot;</span>&gt;<span class="hljs-title class_">Home</span>&lt;/<span class="hljs-title class_">Link</span>&gt;   <br><span class="hljs-comment">// &lt;a href=&#x27;/&#x27;&gt;Home&lt;/a&gt;</span><br></code></pre></td></tr></table></figure><p><NavLink> 是一种特殊类型的 <Link> 当它的 to属性与当前地址匹配时，可以将其定义为”活跃的”。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// location = &#123; pathname: &#x27;/react&#x27; &#125;</span><br>&lt;<span class="hljs-title class_">NavLink</span> to=<span class="hljs-string">&quot;/react&quot;</span> activeClassName=<span class="hljs-string">&quot;hurray&quot;</span>&gt;<br>    <span class="hljs-title class_">React</span><br>&lt;/<span class="hljs-title class_">NavLink</span>&gt;<br><span class="hljs-comment">// &lt;a href=&#x27;/react&#x27; className=&#x27;hurray&#x27;&gt;React&lt;/a&gt;</span><br></code></pre></td></tr></table></figure><p>当我们想强制导航时，可以渲染一个<code>&lt;Redirect&gt;</code>，当一个<code>&lt;Redirect&gt;</code>渲染时，它将使用它的to属性进行定向。</p><h3 id="3-React-Router怎么设置重定向？"><a href="#3-React-Router怎么设置重定向？" class="headerlink" title="3. React-Router怎么设置重定向？"></a>3. React-Router怎么设置重定向？</h3><p>使用<code>&lt;Redirect&gt;</code>组件实现路由的重定向：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;<span class="hljs-title class_">Switch</span>&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Redirect</span> <span class="hljs-attr">from</span>=<span class="hljs-string">&#x27;/users/:id&#x27;</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&#x27;/users/profile/:id&#x27;</span>/&gt;</span></span><br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Route</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&#x27;/users/profile/:id&#x27;</span> <span class="hljs-attr">component</span>=<span class="hljs-string">&#123;Profile&#125;/</span>&gt;</span></span><br>&lt;/<span class="hljs-title class_">Switch</span>&gt;<br></code></pre></td></tr></table></figure><p>当请求 <code>/users/:id</code> 被重定向去 <code>&#39;/users/profile/:id&#39;</code>：</p><ul><li>属性 <code>from: string</code>：需要匹配的将要被重定向路径。</li><li>属性 <code>to: string</code>：重定向的 URL 字符串</li><li>属性 <code>to: object</code>：重定向的 location 对象</li><li>属性 <code>push: bool</code>：若为真，重定向操作将会把新地址加入到访问历史记录里面，并且无法回退到前面的页面。</li></ul><h3 id="4-react-router-里的-Link-标签和-a-标签的区别"><a href="#4-react-router-里的-Link-标签和-a-标签的区别" class="headerlink" title="4. react-router 里的 Link 标签和 a 标签的区别"></a>4. react-router 里的 Link 标签和 a 标签的区别</h3><p>从最终渲染的 DOM 来看，这两者都是链接，都是 标签，区别是∶<br><code>&lt;Link&gt;</code>是react-router 里实现路由跳转的链接，一般配合<code>&lt;Route&gt;</code> 使用，react-router接管了其默认的链接跳转行为，区别于传统的页面跳转，<code>&lt;Link&gt;</code> 的“跳转”行为只会触发相匹配的<code>&lt;Route&gt;</code>对应的页面内容更新，而不会刷新整个页面。</p><p><code>&lt;Link&gt;</code>做了3件事情:</p><ul><li>有onclick那就执行onclick</li><li>click的时候阻止a标签默认事件</li><li>根据跳转href(即是to)，用history (web前端路由两种方式之一，history &amp; hash)跳转，此时只是链接变了，并没有刷新页面而<code>&lt;a&gt;</code>标签就是普通的超链接了，用于从当前页面跳转到href指向的另一 个页面(非锚点情况)。</li></ul><p>a标签默认事件禁掉之后做了什么才实现了跳转?</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> domArr = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementsByTagName</span>(<span class="hljs-string">&#x27;a&#x27;</span>)<br>[...domArr].<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">item</span>=&gt;</span>&#123;<br>    item.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>,<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        location.<span class="hljs-property">href</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">href</span><br>    &#125;)<br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="5-React-Router如何获取URL的参数和历史对象？"><a href="#5-React-Router如何获取URL的参数和历史对象？" class="headerlink" title="5. React-Router如何获取URL的参数和历史对象？"></a>5. React-Router如何获取URL的参数和历史对象？</h3><p><strong>（1）获取URL的参数</strong></p><ul><li><strong>get传值</strong></li></ul><p>路由配置还是普通的配置，如：<code>&#39;admin&#39;</code>，传参方式如：<code>&#39;admin?id=&#39;1111&#39;&#39;</code>。通过<code>this.props.location.search</code>获取url获取到一个字符串<code>&#39;?id=&#39;1111&#39;</code><br>可以用url，qs，querystring，浏览器提供的api URLSearchParams对象或者自己封装的方法去解析出id的值。</p><ul><li><strong>动态路由传值</strong></li></ul><p>路由需要配置成动态路由：如<code>path=&#39;/admin/:id&#39;</code>，传参方式，如<code>&#39;admin/111&#39;</code>。通过<code>this.props.match.params.id</code> 取得url中的动态路由id部分的值，除此之外还可以通过<code>useParams（Hooks）</code>来获取</p><ul><li><strong>通过query或state传值</strong></li></ul><p>传参方式如：在Link组件的to属性中可以传递对象<code>&#123;pathname:&#39;/admin&#39;,query:&#39;111&#39;,state:&#39;111&#39;&#125;;</code>。通过<code>this.props.location.state</code>或<code>this.props.location.query</code>来获取即可，传递的参数可以是对象、数组等，但是存在缺点就是只要刷新页面，参数就会丢失。</p><p><strong>（2）获取历史对象</strong></p><ul><li>如果React &gt;&#x3D; 16.8 时可以使用 React Router中提供的Hooks</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; useHistory &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react-router-dom&quot;</span>;<br><span class="hljs-keyword">let</span> history = <span class="hljs-title function_">useHistory</span>();<br></code></pre></td></tr></table></figure><p>2.使用this.props.history获取历史对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> history = <span class="hljs-variable language_">this</span>.<span class="hljs-property">props</span>.<span class="hljs-property">history</span>;<br></code></pre></td></tr></table></figure><h3 id="6-React-Router-4怎样在路由变化时重新渲染同一个组件？"><a href="#6-React-Router-4怎样在路由变化时重新渲染同一个组件？" class="headerlink" title="6. React-Router 4怎样在路由变化时重新渲染同一个组件？"></a>6. React-Router 4怎样在路由变化时重新渲染同一个组件？</h3><p>当路由变化时，即组件的props发生了变化，会调用componentWillReceiveProps等生命周期钩子。那需要做的只是： 当路由改变时，根据路由，也去请求数据：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">NewsList</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Component</span> &#123;<br>  componentDidMount () &#123;<br>     <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">fetchData</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">props</span>.<span class="hljs-property">location</span>);<br>  &#125;<br>  <br>  <span class="hljs-title function_">fetchData</span>(<span class="hljs-params">location</span>) &#123;<br>    <span class="hljs-keyword">const</span> type = location.<span class="hljs-property">pathname</span>.<span class="hljs-title function_">replace</span>(<span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>) || <span class="hljs-string">&#x27;top&#x27;</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">props</span>.<span class="hljs-title function_">dispatch</span>(<span class="hljs-title function_">fetchListData</span>(type))<br>  &#125;<br>  <span class="hljs-title function_">componentWillReceiveProps</span>(<span class="hljs-params">nextProps</span>) &#123;<br>     <span class="hljs-keyword">if</span> (nextProps.<span class="hljs-property">location</span>.<span class="hljs-property">pathname</span> != <span class="hljs-variable language_">this</span>.<span class="hljs-property">props</span>.<span class="hljs-property">location</span>.<span class="hljs-property">pathname</span>) &#123;<br>         <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">fetchData</span>(nextProps.<span class="hljs-property">location</span>);<br>     &#125; <br>  &#125;<br>  render () &#123;<br>    ...<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>利用生命周期componentWillReceiveProps，进行重新render的预处理操作。</p><h3 id="7-React-Router的路由有几种模式？"><a href="#7-React-Router的路由有几种模式？" class="headerlink" title="7. React-Router的路由有几种模式？"></a>7. React-Router的路由有几种模式？</h3><p>React-Router 支持使用 hash（对应 HashRouter）和 browser（对应 BrowserRouter） 两种路由规则， react-router-dom 提供了 BrowserRouter 和 HashRouter 两个组件来实现应用的 UI 和 URL 同步：</p><ul><li>BrowserRouter 创建的 URL 格式：<a href="http://xxx.com/path">http://xxx.com/path</a></li><li>HashRouter 创建的 URL 格式：<a href="http://xxx.com/#/path">http://xxx.com/#/path</a></li></ul><p><strong>（1）BrowserRouter</strong></p><p>它使用 HTML5 提供的 history API（pushState、replaceState 和 popstate 事件）来保持 UI 和 URL 的同步。由此可以看出，<strong>BrowserRouter 是使用 HTML 5 的 history API 来控制路由跳转的：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;<span class="hljs-title class_">BrowserRouter</span><br>    basename=&#123;string&#125;<br>    forceRefresh=&#123;bool&#125;<br>    getUserConfirmation=&#123;func&#125;<br>    keyLength=&#123;number&#125;<br>/&gt;<br></code></pre></td></tr></table></figure><p><strong>其中的属性如下：</strong></p><ul><li>basename 所有路由的基准 URL。basename 的正确格式是前面有一个前导斜杠，但不能有尾部斜杠；</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;<span class="hljs-title class_">BrowserRouter</span> basename=<span class="hljs-string">&quot;/calendar&quot;</span>&gt;<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Link</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&quot;/today&quot;</span> /&gt;</span></span><br>&lt;/<span class="hljs-title class_">BrowserRouter</span>&gt;<br></code></pre></td></tr></table></figure><p>等同于</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;a href=<span class="hljs-string">&quot;/calendar/today&quot;</span> /&gt;<br></code></pre></td></tr></table></figure><ul><li>forceRefresh 如果为 true，在导航的过程中整个页面将会刷新。一般情况下，只有在不支持 HTML5 history API 的浏览器中使用此功能；</li><li>getUserConfirmation 用于确认导航的函数，默认使用 window.confirm。例如，当从 &#x2F;a 导航至 &#x2F;b 时，会使用默认的 confirm 函数弹出一个提示，用户点击确定后才进行导航，否则不做任何处理；</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 这是默认的确认函数</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">getConfirmation</span> = (<span class="hljs-params">message, callback</span>) =&gt; &#123;<br>  <span class="hljs-keyword">const</span> allowTransition = <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">confirm</span>(message);<br>  <span class="hljs-title function_">callback</span>(allowTransition);<br>&#125;<br>&lt;<span class="hljs-title class_">BrowserRouter</span> getUserConfirmation=&#123;getConfirmation&#125; /&gt;<br></code></pre></td></tr></table></figure><blockquote><p>需要配合<code>&lt;Prompt&gt;</code> 一起使用。</p></blockquote><ul><li>KeyLength 用来设置 Location.Key 的长度。</li></ul><p><strong>（2）HashRouter</strong></p><p>使用 URL 的 hash 部分（即 window.location.hash）来保持 UI 和 URL 的同步。由此可以看出，<strong>HashRouter 是通过 URL 的 hash 属性来控制路由跳转的：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;<span class="hljs-title class_">HashRouter</span><br>    basename=&#123;string&#125;<br>    getUserConfirmation=&#123;func&#125;<br>    hashType=&#123;string&#125;  <br>/&gt;<br></code></pre></td></tr></table></figure><p><strong>其参数如下</strong>：</p><ul><li>basename, getUserConfirmation 和 <code>BrowserRouter</code> 功能一样；</li><li>hashType window.location.hash 使用的 hash 类型，有如下几种：<ul><li>slash - 后面跟一个斜杠，例如 #&#x2F; 和 #&#x2F;sunshine&#x2F;lollipops；</li><li>noslash - 后面没有斜杠，例如 # 和 #sunshine&#x2F;lollipops；</li><li>hashbang - Google 风格的 ajax crawlable，例如 #!&#x2F; 和 #!&#x2F;sunshine&#x2F;lollipops。</li></ul></li></ul><h3 id="8-React-Router-4的Switch有什么用？"><a href="#8-React-Router-4的Switch有什么用？" class="headerlink" title="8. React-Router 4的Switch有什么用？"></a>8. React-Router 4的Switch有什么用？</h3><p>Switch 通常被用来包裹 Route，用于渲染与路径匹配的第一个子 <code>&lt;Route&gt;</code> 或 <code>&lt;Redirect&gt;</code>，它里面不能放其他元素。</p><p>假如不加 <code>&lt;Switch&gt;</code> ：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">Route</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-router-dom&#x27;</span><br><br>&lt;<span class="hljs-title class_">Route</span> path=<span class="hljs-string">&quot;/&quot;</span> component=&#123;<span class="hljs-title class_">Home</span>&#125;&gt;&lt;/<span class="hljs-title class_">Route</span>&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Route</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;/login&quot;</span> <span class="hljs-attr">component</span>=<span class="hljs-string">&#123;Login&#125;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Route</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>Route 组件的 path 属性用于匹配路径，因为需要匹配 <code>/</code> 到 <code>Home</code>，匹配 <code>/login</code> 到 <code>Login</code>，所以需要两个 Route，但是不能这么写。这样写的话，当 URL 的 path 为 “&#x2F;login” 时，<code>&lt;Route path=&quot;/&quot; /&gt;</code>和<code>&lt;Route path=&quot;/login&quot; /&gt;</code> 都会被匹配，因此页面会展示 Home 和 Login 两个组件。这时就需要借助 <code>&lt;Switch&gt;</code> 来做到只显示一个匹配组件：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">Switch</span>, <span class="hljs-title class_">Route</span>&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-router-dom&#x27;</span><br>    <br>&lt;<span class="hljs-title class_">Switch</span>&gt;<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Route</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;/&quot;</span> <span class="hljs-attr">component</span>=<span class="hljs-string">&#123;Home&#125;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Route</span>&gt;</span></span><br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Route</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;/login&quot;</span> <span class="hljs-attr">component</span>=<span class="hljs-string">&#123;Login&#125;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Route</span>&gt;</span></span><br>&lt;/<span class="hljs-title class_">Switch</span>&gt;<br></code></pre></td></tr></table></figure><p>此时，再访问 “&#x2F;login” 路径时，却只显示了 Home 组件。这是就用到了exact属性，它的作用就是精确匹配路径，经常与<code>&lt;Switch&gt;</code> 联合使用。只有当 URL 和该 <code>&lt;Route&gt;</code> 的 path 属性完全一致的情况下才能匹配上：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">Switch</span>, <span class="hljs-title class_">Route</span>&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-router-dom&#x27;</span><br>   <br>&lt;<span class="hljs-title class_">Switch</span>&gt;<br>   <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Route</span> <span class="hljs-attr">exact</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;/&quot;</span> <span class="hljs-attr">component</span>=<span class="hljs-string">&#123;Home&#125;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Route</span>&gt;</span></span><br>   <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Route</span> <span class="hljs-attr">exact</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;/login&quot;</span> <span class="hljs-attr">component</span>=<span class="hljs-string">&#123;Login&#125;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Route</span>&gt;</span></span><br>&lt;/<span class="hljs-title class_">Switch</span>&gt;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>BGW</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>BGW-Vue2</title>
    <link href="/2023/04/18/BGW-Vue2/"/>
    <url>/2023/04/18/BGW-Vue2/</url>
    
    <content type="html"><![CDATA[<p>BGW-Vue2</p><p><img src="1.png" alt="img"></p><h2 id="四、路由"><a href="#四、路由" class="headerlink" title="四、路由"></a>四、路由</h2><h3 id="1-Vue-Router-的懒加载如何实现"><a href="#1-Vue-Router-的懒加载如何实现" class="headerlink" title="1. Vue-Router 的懒加载如何实现"></a>1. Vue-Router 的懒加载如何实现</h3><p>非懒加载：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">List</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@/components/list.vue&#x27;</span><br><span class="hljs-keyword">const</span> router = <span class="hljs-keyword">new</span> <span class="hljs-title class_">VueRouter</span>(&#123;<br>  <span class="hljs-attr">routes</span>: [<br>    &#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/list&#x27;</span>, <span class="hljs-attr">component</span>: <span class="hljs-title class_">List</span> &#125;<br>  ]<br>&#125;)<br></code></pre></td></tr></table></figure><p>（1）方案一(常用)：使用箭头函数+import动态加载</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">List</span> = (<span class="hljs-params"></span>) =&gt; <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;@/components/list.vue&#x27;</span>)<br><span class="hljs-keyword">const</span> router = <span class="hljs-keyword">new</span> <span class="hljs-title class_">VueRouter</span>(&#123;<br>  <span class="hljs-attr">routes</span>: [<br>    &#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/list&#x27;</span>, <span class="hljs-attr">component</span>: <span class="hljs-title class_">List</span> &#125;<br>  ]<br>&#125;)<br></code></pre></td></tr></table></figure><p>（2）方案二：使用箭头函数+require动态加载</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> router = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Router</span>(&#123;<br>  <span class="hljs-attr">routes</span>: [<br>   &#123;<br>     <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/list&#x27;</span>,<br>     <span class="hljs-attr">component</span>: <span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> <span class="hljs-built_in">require</span>([<span class="hljs-string">&#x27;@/components/list&#x27;</span>], resolve)<br>   &#125;<br>  ]<br>&#125;)<br></code></pre></td></tr></table></figure><p>（3）方案三：使用webpack的require.ensure技术，也可以实现按需加载。 这种情况下，多个路由指定相同的chunkName，会合并打包成一个js文件。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// r就是resolve</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">List</span> = r =&gt; <span class="hljs-built_in">require</span>.<span class="hljs-title function_">ensure</span>([], <span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">r</span>(<span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;@/components/list&#x27;</span>)), <span class="hljs-string">&#x27;list&#x27;</span>);<br><span class="hljs-comment">// 路由也是正常的写法  这种是官方推荐的写的 按模块划分懒加载 </span><br><span class="hljs-keyword">const</span> router = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Router</span>(&#123;<br>  <span class="hljs-attr">routes</span>: [<br>  &#123;<br>    <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/list&#x27;</span>,<br>    <span class="hljs-attr">component</span>: <span class="hljs-title class_">List</span>,<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;list&#x27;</span><br>  &#125;<br> ]<br>&#125;))<br></code></pre></td></tr></table></figure><h3 id="2-路由的hash和history模式的区别"><a href="#2-路由的hash和history模式的区别" class="headerlink" title="2. 路由的hash和history模式的区别"></a>2. 路由的hash和history模式的区别</h3><p>Vue-Router有两种模式：<strong>hash模式</strong>和<strong>history模式</strong>。默认的路由模式是hash模式。</p><h4 id="1-hash模式"><a href="#1-hash模式" class="headerlink" title="1. hash模式"></a>1. hash模式</h4><p><strong>简介：</strong> hash模式是开发中默认的模式，它的URL带着一个#，例如：<a href="http://www.abc.com/#/vue">http://www.abc.com/#/vue</a>，它的hash值就是<code>#/vue</code>。</p><p><strong>特点</strong>：hash值会出现在URL里面，但是不会出现在HTTP请求中，对后端完全没有影响。所以改变hash值，不会重新加载页面。这种模式的浏览器支持度很好，低版本的IE浏览器也支持这种模式。hash路由被称为是前端路由，已经成为SPA（单页面应用）的标配。</p><p><strong>原理：</strong> hash模式的主要原理就是<strong>onhashchange()事件</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">window</span>.<span class="hljs-property">onhashchange</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>)&#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(event.<span class="hljs-property">oldURL</span>, event.<span class="hljs-property">newURL</span>);<br><span class="hljs-keyword">let</span> hash = location.<span class="hljs-property">hash</span>.<span class="hljs-title function_">slice</span>(<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>使用onhashchange()事件的好处就是，在页面的hash值发生变化时，无需向后端发起请求，window就可以监听事件的改变，并按规则加载相应的代码。除此之外，hash值变化对应的URL都会被浏览器记录下来，这样浏览器就能实现页面的前进和后退。虽然是没有请求后端服务器，但是页面的hash值和对应的URL关联起来了。</p><h4 id="2-history模式"><a href="#2-history模式" class="headerlink" title="2. history模式"></a>2. history模式</h4><p><strong>简介：</strong> history模式的URL中没有#，它使用的是传统的路由分发模式，即用户在输入一个URL时，服务器会接收这个请求，并解析这个URL，然后做出相应的逻辑处理。<br><strong>特点：</strong> 当使用history模式时，URL就像这样：<a href="http://abc.com/user/id">http://abc.com/user/id</a>。相比hash模式更加好看。但是，history模式需要后台配置支持。如果后台没有正确配置，访问时会返回404。<br><strong>API：</strong> history api可以分为两大部分，切换历史状态和修改历史状态：</p><ul><li><strong>修改历史状态</strong>：包括了 HTML5 History Interface 中新增的 <code>pushState()</code> 和 <code>replaceState()</code> 方法，这两个方法应用于浏览器的历史记录栈，提供了对历史记录进行修改的功能。只是当他们进行修改时，虽然修改了url，但浏览器不会立即向后端发送请求。如果要做到改变url但又不刷新页面的效果，就需要前端用上这两个API。</li><li><strong>切换历史状态：</strong> 包括<code>forward()</code>、<code>back()</code>、<code>go()</code>三个方法，对应浏览器的前进，后退，跳转操作。</li></ul><p>虽然history模式丢弃了丑陋的#。但是，它也有自己的缺点，就是在刷新页面的时候，如果没有相应的路由或资源，就会刷出404来。</p><p>如果想要切换到history模式，就要进行以下配置（后端也要进行配置）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> router = <span class="hljs-keyword">new</span> <span class="hljs-title class_">VueRouter</span>(&#123;<br>  <span class="hljs-attr">mode</span>: <span class="hljs-string">&#x27;history&#x27;</span>,<br>  <span class="hljs-attr">routes</span>: [...]<br>&#125;)<br></code></pre></td></tr></table></figure><h4 id="3-两种模式对比"><a href="#3-两种模式对比" class="headerlink" title="3. 两种模式对比"></a>3. 两种模式对比</h4><p>调用 history.pushState() 相比于直接修改 hash，存在以下优势:</p><ul><li>pushState() 设置的新 URL 可以是与当前 URL 同源的任意 URL；而 hash 只可修改 # 后面的部分，因此只能设置与当前 URL 同文档的 URL；</li><li>pushState() 设置的新 URL 可以与当前 URL 一模一样，这样也会把记录添加到栈中；而 hash 设置的新值必须与原来不一样才会触发动作将记录添加到栈中；</li><li>pushState() 通过 stateObject 参数可以添加任意类型的数据到记录中；而 hash 只可添加短字符串；</li><li>pushState() 可额外设置 title 属性供后续使用。</li><li>hash模式下，仅hash符号之前的url会被包含在请求中，后端如果没有做到对路由的全覆盖，也不会返回404错误；history模式下，前端的url必须和实际向后端发起请求的url一致，如果没有对用的路由处理，将返回404错误。</li></ul><p>hash模式和history模式都有各自的优势和缺陷，还是要根据实际情况选择性的使用。</p><h3 id="3-如何获取页面的hash变化"><a href="#3-如何获取页面的hash变化" class="headerlink" title="3. 如何获取页面的hash变化"></a>3. 如何获取页面的hash变化</h3><p><strong>（1）监听$route的变化</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 监听,当路由发生变化的时候执行</span><br><span class="hljs-attr">watch</span>: &#123;<br>  <span class="hljs-attr">$route</span>: &#123;<br>    <span class="hljs-attr">handler</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">val, oldVal</span>)&#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(val);<br>    &#125;,<br>    <span class="hljs-comment">// 深度观察监听</span><br>    <span class="hljs-attr">deep</span>: <span class="hljs-literal">true</span><br>  &#125;<br>&#125;,<br></code></pre></td></tr></table></figure><p><strong>（2）window.location.hash读取#值</strong><br>window.location.hash 的值可读可写，读取来判断状态是否改变，写入时可以在不重载网页的前提下，添加一条历史访问记录。</p><h3 id="4-route-和-router-的区别"><a href="#4-route-和-router-的区别" class="headerlink" title="4. $route 和$router 的区别"></a>4. <code>$route 和$router</code> 的区别</h3><ul><li>$route 是“路由信息对象”，包括 path，params，hash，query，fullPath，matched，name 等路由信息参数</li><li>$router 是“路由实例”对象包括了路由的跳转方法，钩子函数等。</li></ul><h3 id="5-如何定义动态路由？如何获取传过来的动态参数？"><a href="#5-如何定义动态路由？如何获取传过来的动态参数？" class="headerlink" title="5. 如何定义动态路由？如何获取传过来的动态参数？"></a>5. 如何定义动态路由？如何获取传过来的动态参数？</h3><p><strong>（1）param方式</strong></p><ul><li>配置路由格式：<code>/router/:id</code></li><li>传递的方式：在path后面跟上对应的值</li><li>传递后形成的路径：<code>/router/123</code></li></ul><p>1）路由定义</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//在APP.vue中</span><br>&lt;router-link :to=<span class="hljs-string">&quot;&#x27;/user/&#x27;+userId&quot;</span> replace&gt;用户&lt;/router-link&gt;    <br><br><span class="hljs-comment">//在index.js</span><br>&#123;<br>   <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/user/:userid&#x27;</span>,<br>   <span class="hljs-attr">component</span>: <span class="hljs-title class_">User</span>,<br>&#125;,<br></code></pre></td></tr></table></figure><p>2）路由跳转</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 方法1：</span><br>&lt;router-link :to=<span class="hljs-string">&quot;&#123; name: &#x27;users&#x27;, params: &#123; uname: wade &#125;&#125;&quot;</span>&gt;按钮&lt;/router-link<br><br><span class="hljs-comment">// 方法2：</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">$router</span>.<span class="hljs-title function_">push</span>(&#123;<span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;users&#x27;</span>,<span class="hljs-attr">params</span>:&#123;<span class="hljs-attr">uname</span>:wade&#125;&#125;)<br><br><span class="hljs-comment">// 方法3：</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">$router</span>.<span class="hljs-title function_">push</span>(<span class="hljs-string">&#x27;/user/&#x27;</span> + wade)<br></code></pre></td></tr></table></figure><p>3）参数获取<br>通过 <code>$route.params.userid</code> 获取传递的值</p><p><strong>（2）query方式</strong></p><ul><li>配置路由格式：<code>/router</code>，也就是普通配置</li><li>传递的方式：对象中使用query的key作为传递方式</li><li>传递后形成的路径：<code>/route?id=123</code></li></ul><p>1）路由定义</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//方式1：直接在router-link 标签上以对象的形式</span><br>&lt;router-link :to=<span class="hljs-string">&quot;&#123;path:&#x27;/profile&#x27;,query:&#123;name:&#x27;why&#x27;,age:28,height:188&#125;&#125;&quot;</span>&gt;档案&lt;/router-link&gt;<br><br><span class="hljs-comment">// 方式2：写成按钮以点击事件形式</span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&#x27;profileClick&#x27;</span>&gt;</span>我的<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span>    <br><br><span class="hljs-title function_">profileClick</span>(<span class="hljs-params"></span>)&#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">$router</span>.<span class="hljs-title function_">push</span>(&#123;<br>    <span class="hljs-attr">path</span>: <span class="hljs-string">&quot;/profile&quot;</span>,<br>    <span class="hljs-attr">query</span>: &#123;<br>        <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;kobi&quot;</span>,<br>        <span class="hljs-attr">age</span>: <span class="hljs-string">&quot;28&quot;</span>,<br>        <span class="hljs-attr">height</span>: <span class="hljs-number">198</span><br>    &#125;<br>  &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p>2）跳转方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 方法1：</span><br>&lt;router-link :to=<span class="hljs-string">&quot;&#123; name: &#x27;users&#x27;, query: &#123; uname: james &#125;&#125;&quot;</span>&gt;按钮&lt;/router-link&gt;<br><br><span class="hljs-comment">// 方法2：</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">$router</span>.<span class="hljs-title function_">push</span>(&#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;users&#x27;</span>, <span class="hljs-attr">query</span>:&#123; <span class="hljs-attr">uname</span>:james &#125;&#125;)<br><br><span class="hljs-comment">// 方法3：</span><br>&lt;router-link :to=<span class="hljs-string">&quot;&#123; path: &#x27;/user&#x27;, query: &#123; uname:james &#125;&#125;&quot;</span>&gt;按钮&lt;/router-link&gt;<br><br><span class="hljs-comment">// 方法4：</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">$router</span>.<span class="hljs-title function_">push</span>(&#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/user&#x27;</span>, <span class="hljs-attr">query</span>:&#123; <span class="hljs-attr">uname</span>:james &#125;&#125;)<br><br><span class="hljs-comment">// 方法5：</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">$router</span>.<span class="hljs-title function_">push</span>(<span class="hljs-string">&#x27;/user?uname=&#x27;</span> + jsmes)<br></code></pre></td></tr></table></figure><p>3）获取参数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">通过$route.<span class="hljs-property">query</span> 获取传递的值<br></code></pre></td></tr></table></figure><h3 id="6-Vue-router-路由钩子在生命周期的体现"><a href="#6-Vue-router-路由钩子在生命周期的体现" class="headerlink" title="6. Vue-router 路由钩子在生命周期的体现"></a>6. Vue-router 路由钩子在生命周期的体现</h3><p>一、Vue-Router导航守卫</p><p>有的时候，需要通过路由来进行一些操作，比如最常见的登录权限验证，当用户满足条件时，才让其进入导航，否则就取消跳转，并跳到登录页面让其登录。<br>为此有很多种方法可以植入路由的导航过程：全局的，单个路由独享的，或者组件级的</p><ol><li>全局路由钩子</li></ol><p>vue-router全局有三个路由钩子;</p><ul><li>router.beforeEach 全局前置守卫 进入路由之前</li><li>router.beforeResolve 全局解析守卫（2.5.0+）在 beforeRouteEnter 调用之后调用</li><li>router.afterEach 全局后置钩子 进入路由之后</li></ul><p>具体使用∶</p><ul><li>beforeEach（判断是否登录了，没登录就跳转到登录页）</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript">router.<span class="hljs-title function_">beforeEach</span>(<span class="hljs-function">(<span class="hljs-params">to, <span class="hljs-keyword">from</span>, next</span>) =&gt;</span> &#123;  <br>    <span class="hljs-keyword">let</span> ifInfo = <span class="hljs-title class_">Vue</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">$common</span>.<span class="hljs-title function_">getSession</span>(<span class="hljs-string">&#x27;userData&#x27;</span>);  <span class="hljs-comment">// 判断是否登录的存储信息</span><br>    <span class="hljs-keyword">if</span> (!ifInfo) &#123; <br>        <span class="hljs-comment">// sessionStorage里没有储存user信息    </span><br>        <span class="hljs-keyword">if</span> (to.<span class="hljs-property">path</span> == <span class="hljs-string">&#x27;/&#x27;</span>) &#123; <br>            <span class="hljs-comment">//如果是登录页面路径，就直接next()      </span><br>            <span class="hljs-title function_">next</span>();    <br>        &#125; <span class="hljs-keyword">else</span> &#123; <br>            <span class="hljs-comment">//不然就跳转到登录      </span><br>            <span class="hljs-title class_">Message</span>.<span class="hljs-title function_">warning</span>(<span class="hljs-string">&quot;请重新登录！&quot;</span>);     <br>            <span class="hljs-variable language_">window</span>.<span class="hljs-property">location</span>.<span class="hljs-property">href</span> = <span class="hljs-title class_">Vue</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">$loginUrl</span>;    <br>        &#125;  <br>    &#125; <span class="hljs-keyword">else</span> &#123;    <br>        <span class="hljs-keyword">return</span> <span class="hljs-title function_">next</span>();  <br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><ul><li>afterEach （跳转之后滚动条回到顶部）</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript">router.<span class="hljs-title function_">afterEach</span>(<span class="hljs-function">(<span class="hljs-params">to, <span class="hljs-keyword">from</span></span>) =&gt;</span> &#123;  <br>    <span class="hljs-comment">// 跳转之后滚动条回到顶部  </span><br>    <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">scrollTo</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><ol start="2"><li>单个路由独享钩子</li></ol><p><strong>beforeEnter</strong><br>如果不想全局配置守卫的话，可以为某些路由单独配置守卫，有三个参数∶ to、from、next</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> [    <br>    &#123;        <br>        <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/&#x27;</span>,        <br>        <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;login&#x27;</span>,        <br>        <span class="hljs-attr">component</span>: login,        <br>        <span class="hljs-attr">beforeEnter</span>: <span class="hljs-function">(<span class="hljs-params">to, <span class="hljs-keyword">from</span>, next</span>) =&gt;</span> &#123;          <br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;即将进入登录页面&#x27;</span>)          <br>            <span class="hljs-title function_">next</span>()        <br>        &#125;    <br>    &#125;<br>]<br></code></pre></td></tr></table></figure><ol start="3"><li>组件内钩子</li></ol><p>beforeRouteUpdate、beforeRouteEnter、beforeRouteLeave</p><p>这三个钩子都有三个参数∶to、from、next</p><ul><li>beforeRouteEnter∶ 进入组件前触发</li><li>beforeRouteUpdate∶ 当前地址改变并且改组件被复用时触发，举例来说，带有动态参数的路径foo&#x2F;∶id，在 &#x2F;foo&#x2F;1 和 &#x2F;foo&#x2F;2 之间跳转的时候，由于会渲染同样的foa组件，这个钩子在这种情况下就会被调用</li><li>beforeRouteLeave∶ 离开组件被调用</li></ul><p>注意点，beforeRouteEnter组件内还访问不到this，因为该守卫执行前组件实例还没有被创建，需要传一个回调给 next来访问，例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">beforeRouteEnter</span>(<span class="hljs-params">to, <span class="hljs-keyword">from</span>, next</span>) &#123;      <br>    <span class="hljs-title function_">next</span>(<span class="hljs-function"><span class="hljs-params">target</span> =&gt;</span> &#123;        <br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">from</span>.<span class="hljs-property">path</span> == <span class="hljs-string">&#x27;/classProcess&#x27;</span>) &#123;          <br>            target.<span class="hljs-property">isFromProcess</span> = <span class="hljs-literal">true</span>        <br>        &#125;      <br>    &#125;)    <br>&#125;<br></code></pre></td></tr></table></figure><p>二、Vue路由钩子在生命周期函数的体现</p><ol><li>完整的路由导航解析流程（不包括其他生命周期）</li></ol><ul><li>触发进入其他路由。</li><li>调用要离开路由的组件守卫beforeRouteLeave</li><li>调用局前置守卫∶ beforeEach</li><li>在重用的组件里调用 beforeRouteUpdate</li><li>调用路由独享守卫 beforeEnter。</li><li>解析异步路由组件。</li><li>在将要进入的路由组件中调用 beforeRouteEnter</li><li>调用全局解析守卫 beforeResolve</li><li>导航被确认。</li><li>调用全局后置钩子的 afterEach 钩子。</li><li>触发DOM更新（mounted）。</li><li>执行beforeRouteEnter 守卫中传给 next 的回调函数</li></ul><ol start="2"><li>触发钩子的完整顺序</li></ol><p>路由导航、keep-alive、和组件生命周期钩子结合起来的，触发顺序，假设是从a组件离开，第一次进入b组件∶</p><ul><li>beforeRouteLeave：路由组件的组件离开路由前钩子，可取消路由离开。</li><li>beforeEach：路由全局前置守卫，可用于登录验证、全局路由loading等。</li><li>beforeEnter：路由独享守卫</li><li>beforeRouteEnter：路由组件的组件进入路由前钩子。</li><li>beforeResolve：路由全局解析守卫</li><li>afterEach：路由全局后置钩子</li><li>beforeCreate：组件生命周期，不能访问tAis。</li><li>created;组件生命周期，可以访问tAis，不能访问dom。</li><li>beforeMount：组件生命周期</li><li>deactivated：离开缓存组件a，或者触发a的beforeDestroy和destroyed组件销毁钩子。</li><li>mounted：访问&#x2F;操作dom。</li><li>activated：进入缓存组件，进入a的嵌套子组件（如果有的话）。</li><li>执行beforeRouteEnter回调函数next。</li></ul><ol start="3"><li>导航行为被触发到导航完成的整个过程</li></ol><ul><li>导航行为被触发，此时导航未被确认。</li><li>在失活的组件里调用离开守卫 beforeRouteLeave。</li><li>调用全局的 beforeEach守卫。</li><li>在重用的组件里调用 beforeRouteUpdate 守卫(2.2+)。</li><li>在路由配置里调用 beforeEnteY。 </li><li>解析异步路由组件（如果有）。</li><li>在被激活的组件里调用 beforeRouteEnter。</li><li>调用全局的 beforeResolve 守卫（2.5+），标示解析阶段完成。</li><li>导航被确认。</li><li>调用全局的 afterEach 钩子。</li><li>非重用组件，开始组件实例的生命周期：beforeCreate&amp;created、beforeMount&amp;mounted</li><li>触发 DOM 更新。</li><li>用创建好的实例调用 beforeRouteEnter守卫中传给 next 的回调函数。</li><li>导航完成</li></ul><h3 id="7-Vue-router跳转和location-href有什么区别"><a href="#7-Vue-router跳转和location-href有什么区别" class="headerlink" title="7. Vue-router跳转和location.href有什么区别"></a>7. Vue-router跳转和location.href有什么区别</h3><ul><li>使用 <code>location.href= /url </code>来跳转，简单方便，但是刷新了页面；</li><li>使用 <code>history.pushState( /url )</code> ，无刷新页面，静态跳转；</li><li>引进 router ，然后使用 <code>router.push( /url )</code> 来跳转，使用了 <code>diff</code> 算法，实现了按需加载，减少了 dom 的消耗。其实使用 router 跳转和使用 <code>history.pushState()</code> 没什么差别的，因为vue-router就是用了 <code>history.pushState()</code> ，尤其是在history模式下。</li></ul><h3 id="8-params和query的区别"><a href="#8-params和query的区别" class="headerlink" title="8. params和query的区别"></a>8. params和query的区别</h3><p><strong>用法</strong>：query要用path来引入，params要用name来引入，接收参数都是类似的，分别是 <code>this.$route.query.name</code> 和 <code>this.$route.params.name</code> 。</p><p><strong>url地址显示</strong>：query更加类似于ajax中get传参，params则类似于post，说的再简单一点，前者在浏览器地址栏中显示参数，后者则不显示</p><p><strong>注意</strong>：query刷新不会丢失query里面的数据 params刷新会丢失 params里面的数据。</p><h3 id="9-Vue-router-导航守卫有哪些"><a href="#9-Vue-router-导航守卫有哪些" class="headerlink" title="9. Vue-router 导航守卫有哪些"></a>9. Vue-router 导航守卫有哪些</h3><ul><li>全局前置&#x2F;钩子：beforeEach、beforeResolve、afterEach</li><li>路由独享的守卫：beforeEnter</li><li>组件内的守卫：beforeRouteEnter、beforeRouteUpdate、beforeRouteLeave</li></ul><h3 id="10-对前端路由的理解"><a href="#10-对前端路由的理解" class="headerlink" title="10. 对前端路由的理解"></a>10. 对前端路由的理解</h3><p>在前端技术早期，一个 url 对应一个页面，如果要从 A 页面切换到 B 页面，那么必然伴随着页面的刷新。这个体验并不好，不过在最初也是无奈之举——用户只有在刷新页面的情况下，才可以重新去请求数据。</p><p>后来，改变发生了——Ajax 出现了，它允许人们在不刷新页面的情况下发起请求；与之共生的，还有“不刷新页面即可更新页面内容”这种需求。在这样的背景下，出现了 <strong>SPA（单页面应用</strong>）。</p><p>SPA极大地提升了用户体验，它允许页面在不刷新的情况下更新页面内容，使内容的切换更加流畅。但是在 SPA 诞生之初，人们并没有考虑到“定位”这个问题——在内容切换前后，页面的 URL 都是一样的，这就带来了两个问题：</p><ul><li>SPA 其实并不知道当前的页面“进展到了哪一步”。可能在一个站点下经过了反复的“前进”才终于唤出了某一块内容，但是此时只要刷新一下页面，一切就会被清零，必须重复之前的操作、才可以重新对内容进行定位——SPA 并不会“记住”你的操作。</li><li>由于有且仅有一个 URL 给页面做映射，这对 SEO 也不够友好，搜索引擎无法收集全面的信息</li></ul><p>为了解决这个问题，前端路由出现了。</p><p>前端路由可以帮助我们在仅有一个页面的情况下，“记住”用户当前走到了哪一步——为 SPA 中的各个视图匹配一个唯一标识。这意味着用户前进、后退触发的新内容，都会映射到不同的 URL 上去。此时即便他刷新页面，因为当前的 URL 可以标识出他所处的位置，因此内容也不会丢失。</p><p>那么如何实现这个目的呢？首先要解决两个问题：</p><ul><li>当用户刷新页面时，浏览器会默认根据当前 URL 对资源进行重新定位（发送请求）。这个动作对 SPA 是不必要的，因为我们的 SPA 作为单页面，无论如何也只会有一个资源与之对应。此时若走正常的请求-刷新流程，反而会使用户的前进后退操作无法被记录。</li><li>单页面应用对服务端来说，就是一个URL、一套资源，那么如何做到用“不同的URL”来映射不同的视图内容呢？</li></ul><p>从这两个问题来看，服务端已经完全救不了这个场景了。所以要靠咱们前端自力更生，不然怎么叫“前端路由”呢？作为前端，可以提供这样的解决思路：</p><ul><li>拦截用户的刷新操作，避免服务端盲目响应、返回不符合预期的资源内容。把刷新这个动作完全放到前端逻辑里消化掉。</li><li>感知 URL 的变化。这里不是说要改造 URL、凭空制造出 N 个 URL 来。而是说 URL 还是那个 URL，只不过我们可以给它做一些微小的处理——这些处理并不会影响 URL 本身的性质，不会影响服务器对它的识别，只有我们前端感知的到。一旦我们感知到了，我们就根据这些变化、用 JS 去给它生成不同的内容。</li></ul><h2 id="五、Vuex"><a href="#五、Vuex" class="headerlink" title="五、Vuex"></a>五、Vuex</h2><h3 id="1-Vuex-的原理"><a href="#1-Vuex-的原理" class="headerlink" title="1. Vuex 的原理"></a>1. Vuex 的原理</h3><p>Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。每一个 Vuex 应用的核心就是 store（仓库）。“store” 基本上就是一个容器，它包含着你的应用中大部分的状态 ( state )。</p><ul><li>Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。</li><li>改变 store 中的状态的唯一途径就是显式地提交 (commit) mutation。这样可以方便地跟踪每一个状态的变化。</li></ul><p><img src="BGW-Vue2/2.png" alt="b025e120ca3d0bd2ded3d038d58cacf4.jpg"><br>Vuex为Vue Components建立起了一个完整的生态圈，包括开发中的API调用一环。<br><strong>（1）核心流程中的主要功能：</strong></p><ul><li>Vue Components 是 vue 组件，组件会触发（dispatch）一些事件或动作，也就是图中的 Actions;</li><li>在组件中发出的动作，肯定是想获取或者改变数据的，但是在 vuex 中，数据是集中管理的，不能直接去更改数据，所以会把这个动作提交（Commit）到 Mutations 中;</li><li>然后 Mutations 就去改变（Mutate）State 中的数据;</li><li>当 State 中的数据被改变之后，就会重新渲染（Render）到 Vue Components 中去，组件展示更新后的数据，完成一个流程。</li></ul><p><strong>（2）各模块在核心流程中的主要功能：</strong></p><ul><li><code>Vue Components</code>∶ Vue组件。HTML页面上，负责接收用户操作等交互行为，执行dispatch方法触发对应action进行回应。</li><li><code>dispatch</code>∶操作行为触发方法，是唯一能执行action的方法。</li><li><code>actions</code>∶ 操作行为处理模块。负责处理Vue Components接收到的所有交互行为。包含同步&#x2F;异步操作，支持多个同名方法，按照注册的顺序依次触发。向后台API请求的操作就在这个模块中进行，包括触发其他action以及提交mutation的操作。该模块提供了Promise的封装，以支持action的链式触发。</li><li><code>commit</code>∶状态改变提交操作方法。对mutation进行提交，是唯一能执行mutation的方法。</li><li><code>mutations</code>∶状态改变操作方法。是Vuex修改state的唯一推荐方法，其他修改方式在严格模式下将会报错。该方法只能进行同步操作，且方法名只能全局唯一。操作之中会有一些hook暴露出来，以进行state的监控等。</li><li><code>state</code>∶ 页面状态管理容器对象。集中存储Vuecomponents中data对象的零散数据，全局唯一，以进行统一的状态管理。页面显示所需的数据从该对象中进行读取，利用Vue的细粒度数据响应机制来进行高效的状态更新。</li><li><code>getters</code>∶ state对象读取方法。图中没有单独列出该模块，应该被包含在了render中，Vue Components通过该方法读取全局state对象。</li></ul><h3 id="2-Vuex中action和mutation的区别"><a href="#2-Vuex中action和mutation的区别" class="headerlink" title="2. Vuex中action和mutation的区别"></a>2. Vuex中action和mutation的区别</h3><p>mutation中的操作是一系列的同步函数，用于修改state中的变量的的状态。当使用vuex时需要通过commit来提交需要操作的内容。mutation 非常类似于事件：每个 mutation 都有一个字符串的 事件类型 (type) 和 一个 回调函数 (handler)。这个回调函数就是实际进行状态更改的地方，并且它会接受 state 作为第一个参数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> store = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vuex</span>.<span class="hljs-title class_">Store</span>(&#123;<br>  <span class="hljs-attr">state</span>: &#123;<br>    <span class="hljs-attr">count</span>: <span class="hljs-number">1</span><br>  &#125;,<br>  <span class="hljs-attr">mutations</span>: &#123;<br>    increment (state) &#123;<br>      state.<span class="hljs-property">count</span>++      <span class="hljs-comment">// 变更状态</span><br>    &#125;<br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p>当触发一个类型为 increment 的 mutation 时，需要调用此函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">store.<span class="hljs-title function_">commit</span>(<span class="hljs-string">&#x27;increment&#x27;</span>)<br></code></pre></td></tr></table></figure><p>而Action类似于mutation，不同点在于：</p><ul><li>Action 可以包含任意异步操作。</li><li>Action 提交的是 mutation，而不是直接变更状态。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> store = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vuex</span>.<span class="hljs-title class_">Store</span>(&#123;<br>  <span class="hljs-attr">state</span>: &#123;<br>    <span class="hljs-attr">count</span>: <span class="hljs-number">0</span><br>  &#125;,<br>  <span class="hljs-attr">mutations</span>: &#123;<br>    increment (state) &#123;<br>      state.<span class="hljs-property">count</span>++<br>    &#125;<br>  &#125;,<br>  <span class="hljs-attr">actions</span>: &#123;<br>    increment (context) &#123;<br>      context.<span class="hljs-title function_">commit</span>(<span class="hljs-string">&#x27;increment&#x27;</span>)<br>    &#125;<br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p>Action 函数接受一个与 store 实例具有相同方法和属性的 context 对象，因此你可以调用 context.commit 提交一个 mutation，或者通过 context.state 和 context.getters 来获取 state 和 getters。<br>所以，两者的不同点如下：</p><ul><li>Mutation专注于修改State，理论上是修改State的唯一途径；Action业务代码、异步请求。</li><li>Mutation：必须同步执行；Action：可以异步，但不能直接操作State。</li><li>在视图更新时，先触发actions，actions再触发mutation</li><li>mutation的参数是state，它包含store中的数据；store的参数是context，它是 state 的父级，包含 state、getters</li></ul><h3 id="3-Vuex-和-localStorage-的区别"><a href="#3-Vuex-和-localStorage-的区别" class="headerlink" title="3. Vuex 和 localStorage 的区别"></a>3. Vuex 和 localStorage 的区别</h3><p><strong>（1）最重要的区别</strong></p><ul><li>vuex存储在内存中</li><li>localstorage 则以文件的方式存储在本地，只能存储字符串类型的数据，存储对象需要 JSON的stringify和parse方法进行处理。 读取内存比读取硬盘速度要快</li></ul><p><strong>（2）应用场景</strong></p><ul><li>Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。vuex用于组件之间的传值。</li><li>localstorage是本地存储，是将数据存储到浏览器的方法，一般是在跨页面传递数据时使用 。</li><li>Vuex能做到数据的响应式，localstorage不能</li></ul><p><strong>（3）永久性</strong></p><p>刷新页面时vuex存储的值会丢失，localstorage不会。</p><p><strong>注意：</strong> 对于不变的数据确实可以用localstorage可以代替vuex，但是当两个组件共用一个数据源（对象或数组）时，如果其中一个组件改变了该数据源，希望另一个组件响应该变化时，localstorage无法做到，原因就是区别1。</p><h3 id="4-Redux-和-Vuex-有什么区别，它们的共同思想"><a href="#4-Redux-和-Vuex-有什么区别，它们的共同思想" class="headerlink" title="4. Redux 和 Vuex 有什么区别，它们的共同思想"></a>4. Redux 和 Vuex 有什么区别，它们的共同思想</h3><p><strong>（1）Redux 和 Vuex区别</strong></p><ul><li>Vuex改进了Redux中的Action和Reducer函数，以mutations变化函数取代Reducer，无需switch，只需在对应的mutation函数里改变state值即可</li><li>Vuex由于Vue自动重新渲染的特性，无需订阅重新渲染函数，只要生成新的State即可</li><li>Vuex数据流的顺序是∶View调用store.commit提交对应的请求到Store中对应的mutation函数-&gt;store改变（vue检测到数据变化自动渲染）</li></ul><p>通俗点理解就是，vuex 弱化 dispatch，通过commit进行 store状态的一次更变;取消了action概念，不必传入特定的 action形式进行指定变更;弱化reducer，基于commit参数直接对数据进行转变，使得框架更加简易; </p><p><strong>（2）共同思想</strong></p><ul><li>单—的数据源 </li><li>变化可以预测</li></ul><p>本质上：redux与vuex都是对mvvm思想的服务，将数据从视图中抽离的一种方案;<br>形式上：vuex借鉴了redux，将store作为全局的数据中心，进行mode管理;</p><h3 id="5-为什么要用-Vuex-或者-Redux"><a href="#5-为什么要用-Vuex-或者-Redux" class="headerlink" title="5. 为什么要用 Vuex 或者 Redux"></a>5. 为什么要用 Vuex 或者 Redux</h3><p>由于传参的方法对于多层嵌套的组件将会非常繁琐，并且对于兄弟组件间的状态传递无能为力。我们经常会采用父子组件直接引用或者通过事件来变更和同步状态的多份拷贝。以上的这些模式非常脆弱，通常会导致代码无法维护。</p><p>所以需要把组件的共享状态抽取出来，以一个全局单例模式管理。在这种模式下，组件树构成了一个巨大的”视图”，不管在树的哪个位置，任何组件都能获取状态或者触发行为。</p><p>另外，通过定义和隔离状态管理中的各种概念并强制遵守一定的规则，代码将会变得更结构化且易维护。</p><h3 id="6-Vuex有哪几种属性？"><a href="#6-Vuex有哪几种属性？" class="headerlink" title="6. Vuex有哪几种属性？"></a>6. Vuex有哪几种属性？</h3><p>有五种，分别是 State、 Getter、Mutation 、Action、 Module</p><ul><li>state &#x3D;&gt; 基本数据(数据源存放地)</li><li>getters &#x3D;&gt; 从基本数据派生出来的数据</li><li>mutations &#x3D;&gt; 提交更改数据的方法，同步</li><li>actions &#x3D;&gt; 像一个装饰器，包裹mutations，使之可以异步。</li><li>modules &#x3D;&gt; 模块化Vuex</li></ul><h3 id="7-Vuex和单纯的全局对象有什么区别？"><a href="#7-Vuex和单纯的全局对象有什么区别？" class="headerlink" title="7. Vuex和单纯的全局对象有什么区别？"></a>7. Vuex和单纯的全局对象有什么区别？</h3><ul><li>Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。</li><li>不能直接改变 store 中的状态。改变 store 中的状态的唯一途径就是显式地提交 (commit) mutation。这样可以方便地跟踪每一个状态的变化，从而能够实现一些工具帮助更好地了解我们的应用。</li></ul><h3 id="8-为什么-Vuex-的-mutation-中不能做异步操作？"><a href="#8-为什么-Vuex-的-mutation-中不能做异步操作？" class="headerlink" title="8. 为什么 Vuex 的 mutation 中不能做异步操作？"></a>8. 为什么 Vuex 的 mutation 中不能做异步操作？</h3><ul><li>Vuex中所有的状态更新的唯一途径都是mutation，异步操作通过 Action 来提交 mutation实现，这样可以方便地跟踪每一个状态的变化，从而能够实现一些工具帮助更好地了解我们的应用。</li><li>每个mutation执行完成后都会对应到一个新的状态变更，这样devtools就可以打个快照存下来，然后就可以实现 time-travel 了。如果mutation支持异步操作，就没有办法知道状态是何时更新的，无法很好的进行状态的追踪，给调试带来困难。</li></ul><h3 id="9-Vuex的严格模式是什么-有什么作用，如何开启？"><a href="#9-Vuex的严格模式是什么-有什么作用，如何开启？" class="headerlink" title="9. Vuex的严格模式是什么,有什么作用，如何开启？"></a>9. Vuex的严格模式是什么,有什么作用，如何开启？</h3><p>在严格模式下，无论何时发生了状态变更且不是由mutation函数引起的，将会抛出错误。这能保证所有的状态变更都能被调试工具跟踪到。</p><p>在Vuex.Store 构造器选项中开启,如下</p><figure class="highlight monkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs monkey"><span class="hljs-keyword">const</span> store = <span class="hljs-keyword">new</span> Vuex.Store(&#123;<br>    <span class="hljs-meta">strict</span>:<span class="hljs-literal">true</span>,<br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="10-如何在组件中批量使用Vuex的getter属性"><a href="#10-如何在组件中批量使用Vuex的getter属性" class="headerlink" title="10. 如何在组件中批量使用Vuex的getter属性"></a>10. 如何在组件中批量使用Vuex的getter属性</h3><p>使用mapGetters辅助函数, 利用对象展开运算符将getter混入computed 对象中</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123;mapGetters&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vuex&#x27;</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span>&#123;<br>    <span class="hljs-attr">computed</span>:&#123;<br>        ...<span class="hljs-title function_">mapGetters</span>([<span class="hljs-string">&#x27;total&#x27;</span>,<span class="hljs-string">&#x27;discountTotal&#x27;</span>])<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="11-如何在组件中重复使用Vuex的mutation"><a href="#11-如何在组件中重复使用Vuex的mutation" class="headerlink" title="11. 如何在组件中重复使用Vuex的mutation"></a>11. 如何在组件中重复使用Vuex的mutation</h3><p>使用mapMutations辅助函数,在组件中这么使用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; mapMutations &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vuex&#x27;</span><br><span class="hljs-attr">methods</span>:&#123;<br>    ...<span class="hljs-title function_">mapMutations</span>(&#123;<br>        <span class="hljs-attr">setNumber</span>:<span class="hljs-string">&#x27;SET_NUMBER&#x27;</span>,<br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p>然后调用<code>this.setNumber(10)</code>相当调用<code>this.$store.commit(&#39;SET_NUMBER&#39;,10)</code></p><h2 id="六、Vue-3-0"><a href="#六、Vue-3-0" class="headerlink" title="六、Vue 3.0"></a>六、Vue 3.0</h2><h3 id="1-Vue3-0有什么更新"><a href="#1-Vue3-0有什么更新" class="headerlink" title="1. Vue3.0有什么更新"></a>1. Vue3.0有什么更新</h3><p><strong>（1）监测机制的改变</strong></p><ul><li>3.0 将带来基于代理 Proxy的 observer 实现，提供全语言覆盖的反应性跟踪。</li><li>消除了 Vue 2 当中基于 Object.defineProperty 的实现所存在的很多限制：</li></ul><p><strong>（2）只能监测属性，不能监测对象</strong></p><ul><li>检测属性的添加和删除；</li><li>检测数组索引和长度的变更；</li><li>支持 Map、Set、WeakMap 和 WeakSet。</li></ul><p><strong>（3）模板</strong></p><ul><li>作用域插槽，2.x 的机制导致作用域插槽变了，父组件会重新渲染，而 3.0 把作用域插槽改成了函数的方式，这样只会影响子组件的重新渲染，提升了渲染的性能。</li><li>同时，对于 render 函数的方面，vue3.0 也会进行一系列更改来方便习惯直接使用 api 来生成 vdom 。</li></ul><p><strong>（4）对象式的组件声明方式</strong></p><ul><li>vue2.x 中的组件是通过声明的方式传入一系列 option，和 TypeScript 的结合需要通过一些装饰器的方式来做，虽然能实现功能，但是比较麻烦。</li><li>3.0 修改了组件的声明方式，改成了类式的写法，这样使得和 TypeScript 的结合变得很容易</li></ul><p><strong>（5）其它方面的更改</strong></p><ul><li>支持自定义渲染器，从而使得 weex 可以通过自定义渲染器的方式来扩展，而不是直接 fork 源码来改的方式。</li><li>支持 Fragment（多个根节点）和 Protal（在 dom 其他部分渲染组建内容）组件，针对一些特殊的场景做了处理。</li><li>基于 tree shaking 优化，提供了更多的内置功能。</li></ul><h3 id="2-defineProperty和proxy的区别"><a href="#2-defineProperty和proxy的区别" class="headerlink" title="2. defineProperty和proxy的区别"></a>2. defineProperty和proxy的区别</h3><p>Vue 在实例初始化时遍历 data 中的所有属性，并使用 Object.defineProperty 把这些属性全部转为 getter&#x2F;setter。这样当追踪数据发生变化时，setter 会被自动调用。</p><p>Object.defineProperty 是 ES5 中一个无法 shim 的特性，这也就是 Vue 不支持 IE8 以及更低版本浏览器的原因。</p><p>但是这样做有以下问题：</p><ol><li>添加或删除对象的属性时，Vue 检测不到。因为添加或删除的对象没有在初始化进行响应式处理，只能通过<code>$set</code> 来调用<code>Object.defineProperty()</code>处理。</li><li>无法监控到数组下标和长度的变化。</li></ol><p>Vue3 使用 Proxy 来监控数据的变化。Proxy 是 ES6 中提供的功能，其作用为：用于定义基本操作的自定义行为（如属性查找，赋值，枚举，函数调用等）。相对于<code>Object.defineProperty()</code>，其有以下特点：</p><ol><li>Proxy 直接代理整个对象而非对象属性，这样只需做一层代理就可以监听同级结构下的所有属性变化，包括新增属性和删除属性。</li><li>Proxy 可以监听数组的变化。</li></ol><h3 id="3-Vue3-0-为什么要用-proxy？"><a href="#3-Vue3-0-为什么要用-proxy？" class="headerlink" title="3. Vue3.0 为什么要用 proxy？"></a>3. Vue3.0 为什么要用 proxy？</h3><p>在 Vue2 中， 0bject.defineProperty 会改变原始数据，而 Proxy 是创建对象的虚拟表示，并提供 set 、get 和 deleteProperty 等处理器，这些处理器可在访问或修改原始对象上的属性时进行拦截，有以下特点∶</p><ul><li>不需用使用 <code>Vue.$set</code> 或 <code>Vue.$delete</code> 触发响应式。</li><li>全方位的数组变化检测，消除了Vue2 无效的边界情况。</li><li>支持 Map，Set，WeakMap 和 WeakSet。</li></ul><p> Proxy 实现的响应式原理与 Vue2的实现原理相同，实现方式大同小异∶ </p><ul><li>get 收集依赖</li><li>Set、delete 等触发依赖</li><li>对于集合类型，就是对集合对象的方法做一层包装：原方法执行后执行依赖相关的收集或触发逻辑。</li></ul><h3 id="4-Vue-3-0-中的-Vue-Composition-API？"><a href="#4-Vue-3-0-中的-Vue-Composition-API？" class="headerlink" title="4.  Vue 3.0 中的 Vue Composition API？"></a>4.  Vue 3.0 中的 Vue Composition API？</h3><p>在 Vue2 中，代码是 Options API 风格的，也就是通过填充 (option) data、methods、computed 等属性来完成一个 Vue 组件。这种风格使得 Vue 相对于 React极为容易上手，同时也造成了几个问题：</p><ol><li>由于 Options API 不够灵活的开发方式，使得Vue开发缺乏优雅的方法来在组件间共用代码。</li><li>Vue 组件过于依赖<code>this</code>上下文，Vue 背后的一些小技巧使得 Vue 组件的开发看起来与 JavaScript 的开发原则相悖，比如在<code>methods</code> 中的<code>this</code>竟然指向组件实例来不指向<code>methods</code>所在的对象。这也使得 TypeScript 在Vue2 中很不好用。</li></ol><p>于是在 Vue3 中，舍弃了 Options API，转而投向 Composition API。Composition API本质上是将 Options API 背后的机制暴露给用户直接使用，这样用户就拥有了更多的灵活性，也使得 Vue3 更适合于 TypeScript 结合。</p><p>如下，是一个使用了 Vue Composition API 的 Vue3 组件：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;template&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;increment&quot;</span>&gt;</span></span><br><span class="language-xml">    Count: &#123;&#123; count &#125;&#125;</span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br>&lt;/template&gt;<br> <br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-comment">// Composition API 将组件属性暴露为函数，因此第一步是导入所需的函数</span></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">import</span> &#123; ref, computed, onMounted &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span></span></span><br><span class="language-javascript"><span class="language-xml"> </span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-comment">// 使用 ref 函数声明了称为 count 的响应属性，对应于Vue2中的data函数</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">const</span> count = <span class="hljs-title function_">ref</span>(<span class="hljs-number">0</span>)</span></span><br><span class="language-javascript"><span class="language-xml"> </span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-comment">// Vue2中需要在methods option中声明的函数，现在直接声明</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">function</span> <span class="hljs-title function_">increment</span>(<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      count.<span class="hljs-property">value</span>++</span></span><br><span class="language-javascript"><span class="language-xml">    &#125;</span></span><br><span class="language-javascript"><span class="language-xml"> <span class="hljs-comment">// 对应于Vue2中的mounted声明周期</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-title function_">onMounted</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;component mounted!&#x27;</span>))</span></span><br><span class="language-javascript"><span class="language-xml"> </span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">return</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      count,</span></span><br><span class="language-javascript"><span class="language-xml">      increment</span></span><br><span class="language-javascript"><span class="language-xml">    &#125;</span></span><br><span class="language-javascript"><span class="language-xml">  &#125;</span></span><br><span class="language-javascript"><span class="language-xml">&#125;</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>显而易见，Vue Composition API 使得 Vue3 的开发风格更接近于原生 JavaScript，带给开发者更多地灵活性</p><h3 id="5-Composition-API与React-Hook很像，区别是什么"><a href="#5-Composition-API与React-Hook很像，区别是什么" class="headerlink" title="5. Composition API与React Hook很像，区别是什么"></a>5. Composition API与React Hook很像，区别是什么</h3><p>从React Hook的实现角度看，React Hook是根据useState调用的顺序来确定下一次重渲染时的state是来源于哪个useState，所以出现了以下限制</p><ul><li>不能在循环、条件、嵌套函数中调用Hook</li><li>必须确保总是在你的React函数的顶层调用Hook</li><li>useEffect、useMemo等函数必须手动确定依赖关系</li></ul><p>而Composition API是基于Vue的响应式系统实现的，与React Hook的相比</p><ul><li>声明在setup函数内，一次组件实例化只调用一次setup，而React Hook每次重渲染都需要调用Hook，使得React的GC比Vue更有压力，性能也相对于Vue来说也较慢</li><li>Compositon API的调用不需要顾虑调用顺序，也可以在循环、条件、嵌套函数中使用</li><li>响应式系统自动实现了依赖收集，进而组件的部分的性能优化由Vue内部自己完成，而React Hook需要手动传入依赖，而且必须必须保证依赖的顺序，让useEffect、useMemo等函数正确的捕获依赖变量，否则会由于依赖不正确使得组件性能下降。</li></ul><p>虽然Compositon API看起来比React Hook好用，但是其设计思想也是借鉴React Hook的。</p><h2 id="七、虚拟DOM"><a href="#七、虚拟DOM" class="headerlink" title="七、虚拟DOM"></a>七、虚拟DOM</h2><h3 id="1-对虚拟DOM的理解？"><a href="#1-对虚拟DOM的理解？" class="headerlink" title="1. 对虚拟DOM的理解？"></a>1. 对虚拟DOM的理解？</h3><p>从本质上来说，Virtual Dom是一个JavaScript对象，通过对象的方式来表示DOM结构。将页面的状态抽象为JS对象的形式，配合不同的渲染工具，使跨平台渲染成为可能。通过事务处理机制，将多次DOM修改的结果一次性的更新到页面上，从而有效的减少页面渲染的次数，减少修改DOM的重绘重排次数，提高渲染性能。</p><p>虚拟DOM是对DOM的抽象，这个对象是更加轻量级的对 DOM的描述。它设计的最初目的，就是更好的跨平台，比如Node.js就没有DOM，如果想实现SSR，那么一个方式就是借助虚拟DOM，因为虚拟DOM本身是js对象。 在代码渲染到页面之前，vue会把代码转换成一个对象（虚拟 DOM）。以对象的形式来描述真实DOM结构，最终渲染到页面。在每次数据发生变化前，虚拟DOM都会缓存一份，变化之时，现在的虚拟DOM会与缓存的虚拟DOM进行比较。在vue内部封装了diff算法，通过这个算法来进行比较，渲染时修改改变的变化，原先没有发生改变的通过原先的数据进行渲染。</p><p>另外现代前端框架的一个基本要求就是无须手动操作DOM，一方面是因为手动操作DOM无法保证程序性能，多人协作的项目中如果review不严格，可能会有开发者写出性能较低的代码，另一方面更重要的是省略手动DOM操作可以大大提高开发效率。</p><h3 id="2-虚拟DOM的解析过程"><a href="#2-虚拟DOM的解析过程" class="headerlink" title="2. 虚拟DOM的解析过程"></a>2. 虚拟DOM的解析过程</h3><p>虚拟DOM的解析过程：</p><ul><li>首先对将要插入到文档中的 DOM 树结构进行分析，使用 js 对象将其表示出来，比如一个元素对象，包含 TagName、props 和 Children 这些属性。然后将这个 js 对象树给保存下来，最后再将 DOM 片段插入到文档中。</li><li>当页面的状态发生改变，需要对页面的 DOM 的结构进行调整的时候，首先根据变更的状态，重新构建起一棵对象树，然后将这棵新的对象树和旧的对象树进行比较，记录下两棵树的的差异。</li><li>最后将记录的有差异的地方应用到真正的 DOM 树中去，这样视图就更新了。</li></ul><h3 id="3-为什么要用虚拟DOM"><a href="#3-为什么要用虚拟DOM" class="headerlink" title="3. 为什么要用虚拟DOM"></a>3. 为什么要用虚拟DOM</h3><p><strong>（1）保证性能下限，在不进行手动优化的情况下，提供过得去的性能</strong><br>看一下页面渲染的流程：<strong>解析HTML -&gt; 生成DOM -&gt; 生成 CSSOM -&gt; Layout -&gt; Paint -&gt; Compiler</strong><br>下面对比一下修改DOM时真实DOM操作和Virtual DOM的过程，来看一下它们重排重绘的性能消耗∶</p><ul><li>真实DOM∶ 生成HTML字符串＋重建所有的DOM元素</li><li>虚拟DOM∶ 生成vNode+ DOMDiff＋必要的dom更新</li></ul><p>Virtual DOM的更新DOM的准备工作耗费更多的时间，也就是JS层面，相比于更多的DOM操作它的消费是极其便宜的。尤雨溪在社区论坛中说道∶ 框架给你的保证是，你不需要手动优化的情况下，依然可以给你提供过得去的性能。<br><strong>（2）跨平台</strong><br>Virtual DOM本质上是JavaScript的对象，它可以很方便的跨平台操作，比如服务端渲染、uniapp等。</p><h3 id="4-虚拟DOM真的比真实DOM性能好吗"><a href="#4-虚拟DOM真的比真实DOM性能好吗" class="headerlink" title="4. 虚拟DOM真的比真实DOM性能好吗"></a>4. 虚拟DOM真的比真实DOM性能好吗</h3><ul><li>首次渲染大量DOM时，由于多了一层虚拟DOM的计算，会比innerHTML插入慢。</li><li>正如它能保证性能下限，在真实DOM操作的时候进行针对性的优化时，还是更快的。</li></ul><h3 id="5-DIFF算法的原理"><a href="#5-DIFF算法的原理" class="headerlink" title="5. DIFF算法的原理"></a>5. DIFF算法的原理</h3><p>在新老虚拟DOM对比时：</p><ul><li>首先，对比节点本身，判断是否为同一节点，如果不为相同节点，则删除该节点重新创建节点进行替换</li><li>如果为相同节点，进行patchVnode，判断如何对该节点的子节点进行处理，先判断一方有子节点一方没有子节点的情况(如果新的children没有子节点，将旧的子节点移除)</li><li>比较如果都有子节点，则进行updateChildren，判断如何对这些新老节点的子节点进行操作（diff核心）。</li><li>匹配时，找到相同的子节点，递归比较子节点</li></ul><p>在diff中，只对同层的子节点进行比较，放弃跨级的节点比较，使得时间复杂从O(n3)降低值O(n)，也就是说，只有当新旧children都为多个子节点时才需要用核心的Diff算法进行同层级比较。</p><h3 id="6-Vue中key的作用"><a href="#6-Vue中key的作用" class="headerlink" title="6. Vue中key的作用"></a>6. Vue中key的作用</h3><p>vue 中 key 值的作用可以分为两种情况来考虑：</p><ul><li>第一种情况是 v-if 中使用 key。由于 Vue 会尽可能高效地渲染元素，通常会复用已有元素而不是从头开始渲染。因此当使用 v-if 来实现元素切换的时候，如果切换前后含有相同类型的元素，那么这个元素就会被复用。如果是相同的 input 元素，那么切换前后用户的输入不会被清除掉，这样是不符合需求的。因此可以通过使用 key 来唯一的标识一个元素，这个情况下，使用 key 的元素不会被复用。这个时候 key 的作用是用来标识一个独立的元素。</li><li>第二种情况是 v-for 中使用 key。用 v-for 更新已渲染过的元素列表时，它默认使用“就地复用”的策略。如果数据项的顺序发生了改变，Vue 不会移动 DOM 元素来匹配数据项的顺序，而是简单复用此处的每个元素。因此通过为每个列表项提供一个 key 值，来以便 Vue 跟踪元素的身份，从而高效的实现复用。这个时候 key 的作用是为了高效的更新渲染虚拟 DOM。</li></ul><p>key 是为 Vue 中 vnode 的唯一标记，通过这个 key，diff 操作可以更准确、更快速</p><ul><li>更准确：因为带 key 就不是就地复用了，在 sameNode 函数a.key &#x3D;&#x3D;&#x3D; b.key对比中可以避免就地复用的情况。所以会更加准确。</li><li>更快速：利用 key 的唯一性生成 map 对象来获取对应节点，比遍历方式更快</li></ul><h3 id="7-为什么不建议用index作为key"><a href="#7-为什么不建议用index作为key" class="headerlink" title="7. 为什么不建议用index作为key?"></a>7. 为什么不建议用index作为key?</h3><p>使用index 作为 key和没写基本上没区别，因为不管数组的顺序怎么颠倒，index 都是 0, 1, 2…这样排列，导致 Vue 会复用错误的旧子节点，做很多额外的工作。</p>]]></content>
    
    
    <categories>
      
      <category>BGW</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>BGW-Vue1</title>
    <link href="/2023/04/18/BGW-Vue1/"/>
    <url>/2023/04/18/BGW-Vue1/</url>
    
    <content type="html"><![CDATA[<p>BGW-Vue1</p><p><img src="1.png" alt="img"></p><h2 id="一、Vue-基础"><a href="#一、Vue-基础" class="headerlink" title="一、Vue 基础"></a>一、Vue 基础</h2><h3 id="1-Vue的基本原理"><a href="#1-Vue的基本原理" class="headerlink" title="1. Vue的基本原理"></a>1. Vue的基本原理</h3><p>当一个Vue实例创建时，Vue会遍历data中的属性，用 Object.defineProperty（vue3.0使用proxy ）将它们转为 getter&#x2F;setter，并且在内部追踪相关依赖，在属性被访问和修改时通知变化。 每个组件实例都有相应的 watcher 程序实例，它会在组件渲染的过程中把属性记录为依赖，之后当依赖项的setter被调用时，会通知watcher重新计算，从而致使它关联的组件得以更新。<br><img src="2.png" alt="img"></p><h3 id="2-双向数据绑定的原理"><a href="#2-双向数据绑定的原理" class="headerlink" title="2. 双向数据绑定的原理"></a>2. 双向数据绑定的原理</h3><p>Vue.js 是采用<strong>数据劫持</strong>结合<strong>发布者-订阅者模式</strong>的方式，通过Object.defineProperty()来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。主要分为以下几个步骤：</p><ol><li>需要observe的数据对象进行递归遍历，包括子属性对象的属性，都加上setter和getter这样的话，给这个对象的某个值赋值，就会触发setter，那么就能监听到了数据变化</li><li>compile解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图</li><li>Watcher订阅者是Observer和Compile之间通信的桥梁，主要做的事情是: ①在自身实例化时往属性订阅器(dep)里面添加自己 ②自身必须有一个update()方法 ③待属性变动dep.notice()通知时，能调用自身的update()方法，并触发Compile中绑定的回调，则功成身退。</li><li>MVVM作为数据绑定的入口，整合Observer、Compile和Watcher三者，通过Observer来监听自己的model数据变化，通过Compile来解析编译模板指令，最终利用Watcher搭起Observer和Compile之间的通信桥梁，达到数据变化 -&gt; 视图更新；视图交互变化(input) -&gt; 数据model变更的双向绑定效果。</li></ol><p><img src="3.png" alt="img"></p><h3 id="3-使用-Object-defineProperty-来进行数据劫持有什么缺点？"><a href="#3-使用-Object-defineProperty-来进行数据劫持有什么缺点？" class="headerlink" title="3. 使用 Object.defineProperty() 来进行数据劫持有什么缺点？"></a>3. 使用 Object.defineProperty() 来进行数据劫持有什么缺点？</h3><p>在对一些属性进行操作时，使用这种方法无法拦截，比如通过下标方式修改数组数据或者给对象新增属性，这都不能触发组件的重新渲染，因为 Object.defineProperty 不能拦截到这些操作。更精确的来说，对于数组而言，大部分操作都是拦截不到的，只是 Vue 内部通过重写函数的方式解决了这个问题。</p><p>在 Vue3.0 中已经不使用这种方式了，而是通过使用 Proxy 对对象进行代理，从而实现数据劫持。使用Proxy 的好处是它可以完美的监听到任何方式的数据改变，唯一的缺点是兼容性的问题，因为 Proxy 是 ES6 的语法。</p><h3 id="4-MVVM、MVC、MVP的区别"><a href="#4-MVVM、MVC、MVP的区别" class="headerlink" title="4. MVVM、MVC、MVP的区别"></a>4. MVVM、MVC、MVP的区别</h3><p>MVC、MVP 和 MVVM 是三种常见的软件架构设计模式，主要通过分离关注点的方式来组织代码结构，优化开发效率。</p><p>在开发单页面应用时，往往一个路由页面对应了一个脚本文件，所有的页面逻辑都在一个脚本文件里。页面的渲染、数据的获取，对用户事件的响应所有的应用逻辑都混合在一起，这样在开发简单项目时，可能看不出什么问题，如果项目变得复杂，那么整个文件就会变得冗长、混乱，这样对项目开发和后期的项目维护是非常不利的。</p><p><strong>（1）MVC</strong></p><p>MVC 通过分离 Model、View 和 Controller 的方式来组织代码结构。其中 View 负责页面的显示逻辑，Model 负责存储页面的业务数据，以及对相应数据的操作。并且 View 和 Model 应用了观察者模式，当 Model 层发生改变的时候它会通知有关 View 层更新页面。Controller 层是 View 层和 Model 层的纽带，它主要负责用户与应用的响应操作，当用户与页面产生交互的时候，Controller 中的事件触发器就开始工作了，通过调用 Model 层，来完成对 Model 的修改，然后 Model 层再去通知 View 层更新。<br><img src="4.png" alt="img"></p><p>（2）MVVM</p><p>MVVM 分为 Model、View、ViewModel：</p><ul><li>Model代表数据模型，数据和业务逻辑都在Model层中定义；</li><li>View代表UI视图，负责数据的展示；</li><li>ViewModel负责监听Model中数据的改变并且控制视图的更新，处理用户交互操作；</li></ul><p>Model和View并无直接关联，而是通过ViewModel来进行联系的，Model和ViewModel之间有着双向数据绑定的联系。因此当Model中的数据改变时会触发View层的刷新，View中由于用户交互操作而改变的数据也会在Model中同步。</p><p>这种模式实现了 Model和View的数据自动同步，因此开发者只需要专注于数据的维护操作即可，而不需要自己操作DOM。<br><img src="5.png" alt="img"></p><p><strong>（3）MVP</strong></p><p>MVP 模式与 MVC 唯一不同的在于 Presenter 和 Controller。在 MVC 模式中使用观察者模式，来实现当 Model 层数据发生变化的时候，通知 View 层的更新。这样 View 层和 Model 层耦合在一起，当项目逻辑变得复杂的时候，可能会造成代码的混乱，并且可能会对代码的复用性造成一些问题。MVP 的模式通过使用 Presenter 来实现对 View 层和 Model 层的解耦。MVC 中的Controller 只知道 Model 的接口，因此它没有办法控制 View 层的更新，MVP 模式中，View 层的接口暴露给了 Presenter 因此可以在 Presenter 中将 Model 的变化和 View 的变化绑定在一起，以此来实现 View 和 Model 的同步更新。这样就实现了对 View 和 Model 的解耦，Presenter 还包含了其他的响应逻辑。</p><h3 id="5-Computed-和-Watch-的区别"><a href="#5-Computed-和-Watch-的区别" class="headerlink" title="5. Computed 和 Watch 的区别"></a>5. Computed 和 Watch 的区别</h3><p><strong>对于Computed：</strong></p><ul><li>它支持缓存，只有依赖的数据发生了变化，才会重新计算</li><li>不支持异步，当Computed中有异步操作时，无法监听数据的变化</li><li>computed的值会默认走缓存，计算属性是基于它们的响应式依赖进行缓存的，也就是基于data声明过，或者父组件传递过来的props中的数据进行计算的。</li><li>如果一个属性是由其他属性计算而来的，这个属性依赖其他的属性，一般会使用computed</li><li>如果computed属性的属性值是函数，那么默认使用get方法，函数的返回值就是属性的属性值；在computed中，属性有一个get方法和一个set方法，当数据发生变化时，会调用set方法。</li></ul><p><strong>对于Watch：</strong></p><ul><li>它不支持缓存，数据变化时，它就会触发相应的操作</li><li>支持异步监听</li><li>监听的函数接收两个参数，第一个参数是最新的值，第二个是变化之前的值</li><li>当一个属性发生变化时，就需要执行相应的操作</li><li>监听数据必须是data中声明的或者父组件传递过来的props中的数据，当发生变化时，会触发其他操作，函数有两个的参数：<ul><li>immediate：组件加载立即触发回调函数</li><li>deep：深度监听，发现数据内部的变化，在复杂数据类型中使用，例如数组中的对象发生变化。需要注意的是，deep无法监听到数组和对象内部的变化。</li></ul></li></ul><p>当想要执行异步或者昂贵的操作以响应不断的变化时，就需要使用watch。</p><p><strong>总结：</strong></p><ul><li>computed 计算属性 : 依赖其它属性值，并且 computed 的值有缓存，只有它依赖的属性值发生改变，下一次获取 computed 的值时才会重新计算 computed 的值。 </li><li>watch 侦听器 : 更多的是<strong>观察</strong>的作用，<strong>无缓存性</strong>，类似于某些数据的监听回调，每当监听的数据变化时都会执行回调进行后续操作。</li></ul><p><strong>运用场景：</strong></p><ul><li>当需要进行数值计算,并且依赖于其它数据时，应该使用 computed，因为可以利用 computed 的缓存特性，避免每次获取值时都要重新计算。 </li><li>当需要在数据变化时执行异步或开销较大的操作时，应该使用 watch，使用 watch 选项允许执行异步操作 ( 访问一个 API )，限制执行该操作的频率，并在得到最终结果前，设置中间状态。这些都是计算属性无法做到的。</li></ul><h3 id="6-Computed-和-Methods-的区别"><a href="#6-Computed-和-Methods-的区别" class="headerlink" title="6. Computed 和 Methods 的区别"></a>6. Computed 和 Methods 的区别</h3><p>可以将同一函数定义为一个 method 或者一个计算属性。对于最终的结果，两种方式是相同的 </p><p><strong>不同点：</strong></p><ul><li>computed: 计算属性是基于它们的依赖进行缓存的，只有在它的相关依赖发生改变时才会重新求值；</li><li>method 调用总会执行该函数。</li></ul><h3 id="7-slot是什么？有什么作用？原理是什么？"><a href="#7-slot是什么？有什么作用？原理是什么？" class="headerlink" title="7. slot是什么？有什么作用？原理是什么？"></a>7. slot是什么？有什么作用？原理是什么？</h3><p>slot又名插槽，是Vue的内容分发机制，组件内部的模板引擎使用slot元素作为承载分发内容的出口。插槽slot是子组件的一个模板标签元素，而这一个标签元素是否显示，以及怎么显示是由父组件决定的。slot又分三类，默认插槽，具名插槽和作用域插槽。</p><ul><li>默认插槽：又名匿名查抄，当slot没有指定name属性值的时候一个默认显示插槽，一个组件内只有有一个匿名插槽。</li><li>具名插槽：带有具体名字的插槽，也就是带有name属性的slot，一个组件可以出现多个具名插槽。</li><li>作用域插槽：默认插槽、具名插槽的一个变体，可以是匿名插槽，也可以是具名插槽，该插槽的不同点是在子组件渲染作用域插槽时，可以将子组件内部的数据传递给父组件，让父组件根据子组件的传递过来的数据决定如何渲染该插槽。</li></ul><p>实现原理：当子组件vm实例化时，获取到父组件传入的slot标签的内容，存放在<code>vm.$slot</code>中，默认插槽为<code>vm.$slot.default</code>，具名插槽为<code>vm.$slot.xxx</code>，xxx 为插槽名，当组件执行渲染函数时候，遇到slot标签，使用<code>$slot</code>中的内容进行替换，此时可以为插槽传递数据，若存在数据，则可称该插槽为作用域插槽。</p><h3 id="8-过滤器的作用，如何实现一个过滤器"><a href="#8-过滤器的作用，如何实现一个过滤器" class="headerlink" title="8. 过滤器的作用，如何实现一个过滤器"></a>8. 过滤器的作用，如何实现一个过滤器</h3><p>根据过滤器的名称，过滤器是用来过滤数据的，在Vue中使用<code>filters</code>来过滤数据，<code>filters</code>不会修改数据，而是过滤数据，改变用户看到的输出（计算属性 <code>computed</code> ，方法 <code>methods</code> 都是通过修改数据来处理数据格式的输出显示）。</p><p><strong>使用场景：</strong></p><ul><li>需要格式化数据的情况，比如需要处理时间、价格等数据格式的输出 &#x2F; 显示。</li><li>比如后端返回一个 <strong>年月日的日期字符串</strong>，前端需要展示为 <strong>多少天前</strong> 的数据格式，此时就可以用<code>fliters</code>过滤器来处理数据。</li></ul><p>过滤器是一个函数，它会把表达式中的值始终当作函数的第一个参数。过滤器用在<strong>插值表达式 <strong><code>&#123;&#123; &#125;&#125;</code> 和 <code>v-bind</code></strong> 表达式</strong> 中，然后放在操作符“ <code>|</code> ”后面进行指示。</p><p>例如，在显示金额，给商品价格添加单位：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;li&gt;商品价格：&#123;&#123;item.<span class="hljs-property">price</span> | filterPrice&#125;&#125;&lt;/li&gt;<br><br> <span class="hljs-attr">filters</span>: &#123;<br>    filterPrice (price) &#123;<br>      <span class="hljs-keyword">return</span> price ? (<span class="hljs-string">&#x27;￥&#x27;</span> + price) : <span class="hljs-string">&#x27;--&#x27;</span><br>    &#125;<br>  &#125;<br></code></pre></td></tr></table></figure><h3 id="9-如何保存页面的当前的状态"><a href="#9-如何保存页面的当前的状态" class="headerlink" title="9. 如何保存页面的当前的状态"></a>9. 如何保存页面的当前的状态</h3><p>既然是要保持页面的状态（其实也就是组件的状态），那么会出现以下两种情况：</p><ul><li>前组件会被卸载</li><li>前组件不会被卸载</li></ul><p>那么可以按照这两种情况分别得到以下方法：</p><p><strong>组件会被卸载：</strong></p><p><strong>（1）将状态存储在LocalStorage &#x2F; SessionStorage</strong></p><p>只需要在组件即将被销毁的生命周期 <code>componentWillUnmount</code> （react）中在 LocalStorage &#x2F; SessionStorage 中把当前组件的 state 通过 JSON.stringify() 储存下来就可以了。在这里面需要注意的是组件更新状态的时机。</p><p>比如从 B 组件跳转到 A 组件的时候，A 组件需要更新自身的状态。但是如果从别的组件跳转到 B 组件的时候，实际上是希望 B 组件重新渲染的，也就是不要从 Storage 中读取信息。所以需要在 Storage 中的状态加入一个 flag 属性，用来控制 A 组件是否读取 Storage 中的状态。</p><p><strong>优点：</strong></p><ul><li>兼容性好，不需要额外库或工具。</li><li>简单快捷，基本可以满足大部分需求。</li></ul><p><strong>缺点：</strong></p><ul><li>状态通过 JSON 方法储存（相当于深拷贝），如果状态中有特殊情况（比如 Date 对象、Regexp 对象等）的时候会得到字符串而不是原来的值。（具体参考用 JSON 深拷贝的缺点）</li><li>如果 B 组件后退或者下一页跳转并不是前组件，那么 flag 判断会失效，导致从其他页面进入 A 组件页面时 A 组件会重新读取 Storage，会造成很奇怪的现象</li></ul><p><strong>（2）路由传值</strong></p><p>通过 react-router 的 Link 组件的 prop —— to 可以实现路由间传递参数的效果。</p><p>在这里需要用到 state 参数，在 B 组件中通过 history.location.state 就可以拿到 state 值，保存它。返回 A 组件时再次携带 state 达到路由状态保持的效果。</p><p><strong>优点：</strong></p><ul><li>简单快捷，不会污染 LocalStorage &#x2F; SessionStorage。</li><li>可以传递 Date、RegExp 等特殊对象（不用担心 JSON.stringify &#x2F; parse 的不足）</li></ul><p><strong>缺点：</strong></p><ul><li>如果 A 组件可以跳转至多个组件，那么在每一个跳转组件内都要写相同的逻辑。</li></ul><p><strong>组件不会被卸载：</strong></p><p><strong>（1）单页面渲染</strong></p><p>要切换的组件作为子组件全屏渲染，父组件中正常储存页面状态。</p><p><strong>优点：</strong></p><ul><li>代码量少</li><li>不需要考虑状态传递过程中的错误</li></ul><p><strong>缺点：</strong></p><ul><li>增加 A 组件维护成本</li><li>需要传入额外的 prop 到 B 组件</li><li>无法利用路由定位页面</li></ul><p>除此之外，在Vue中，还可以是用keep-alive来缓存页面，当组件在keep-alive内被切换时组件的<strong>activated、deactivated</strong>这两个生命周期钩子函数会被执行<br>被包裹在keep-alive中的组件的状态将会被保留：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;keep-alive&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">router-view</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;$route.meta.keepAlive&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">router-view</span>&gt;</span></span><br>&lt;/kepp-alive&gt;<br></code></pre></td></tr></table></figure><p><strong>router.js</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&#123;<br>  <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/&#x27;</span>,<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;xxx&#x27;</span>,<br>  <span class="hljs-attr">component</span>: <span class="hljs-function">()=&gt;</span><span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;../src/views/xxx.vue&#x27;</span>),<br>  <span class="hljs-attr">meta</span>:&#123;<br>    <span class="hljs-attr">keepAlive</span>: <span class="hljs-literal">true</span> <span class="hljs-comment">// 需要被缓存</span><br>  &#125;<br>&#125;,<br></code></pre></td></tr></table></figure><h3 id="10-常见的事件修饰符及其作用"><a href="#10-常见的事件修饰符及其作用" class="headerlink" title="10. 常见的事件修饰符及其作用"></a>10. 常见的事件修饰符及其作用</h3><ul><li><code>.stop</code>：等同于 JavaScript 中的 <code>event.stopPropagation()</code> ，防止事件冒泡；</li><li><code>.prevent</code> ：等同于 JavaScript 中的 <code>event.preventDefault()</code> ，防止执行预设的行为（如果事件可取消，则取消该事件，而不停止事件的进一步传播）；</li><li><code>.capture</code> ：与事件冒泡的方向相反，事件捕获由外到内；</li><li><code>.self</code> ：只会触发自己范围内的事件，不包含子元素；</li><li><code>.once</code> ：只会触发一次。</li></ul><h3 id="11-v-if、v-show、v-html-的原理"><a href="#11-v-if、v-show、v-html-的原理" class="headerlink" title="11. v-if、v-show、v-html 的原理"></a>11. v-if、v-show、v-html 的原理</h3><ul><li>v-if会调用addIfCondition方法，生成vnode的时候会忽略对应节点，render的时候就不会渲染；</li><li>v-show会生成vnode，render的时候也会渲染成真实节点，只是在render过程中会在节点的属性中修改show属性值，也就是常说的display； </li><li>v-html会先移除节点下的所有节点，调用html方法，通过addProp添加innerHTML属性，归根结底还是设置innerHTML为v-html的值。</li></ul><h3 id="13-v-if和v-show的区别"><a href="#13-v-if和v-show的区别" class="headerlink" title="13. v-if和v-show的区别"></a>13. v-if和v-show的区别</h3><ul><li><strong>手段</strong>：v-if是动态的向DOM树内添加或者删除DOM元素；v-show是通过设置DOM元素的display样式属性控制显隐；</li><li><strong>编译过程</strong>：v-if切换有一个局部编译&#x2F;卸载的过程，切换过程中合适地销毁和重建内部的事件监听和子组件；v-show只是简单的基于css切换；</li><li><strong>编译条件</strong>：v-if是惰性的，如果初始条件为假，则什么也不做；只有在条件第一次变为真时才开始局部编译; v-show是在任何条件下，无论首次条件是否为真，都被编译，然后被缓存，而且DOM元素保留；</li><li><strong>性能消耗</strong>：v-if有更高的切换消耗；v-show有更高的初始渲染消耗；</li><li><strong>使用场景</strong>：v-if适合运营条件不大可能改变；v-show适合频繁切换。</li></ul><h3 id="14-v-model-是如何实现的，语法糖实际是什么？"><a href="#14-v-model-是如何实现的，语法糖实际是什么？" class="headerlink" title="14. v-model 是如何实现的，语法糖实际是什么？"></a>14. v-model 是如何实现的，语法糖实际是什么？</h3><p><strong>（1）作用在表单元素上</strong><br>动态绑定了 input 的 value 指向了 messgae 变量，并且在触发 input 事件的时候去动态把 message设置为目标值：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;input v-model=<span class="hljs-string">&quot;sth&quot;</span> /&gt;<br><span class="hljs-comment">//  等同于</span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> </span></span><br><span class="hljs-tag"><span class="language-xml">    <span class="hljs-attr">v-bind:value</span>=<span class="hljs-string">&quot;message&quot;</span> </span></span><br><span class="hljs-tag"><span class="language-xml">    <span class="hljs-attr">v-on:input</span>=<span class="hljs-string">&quot;message=$event.target.value&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">&gt;</span></span><br><span class="language-xml">//$event 指代当前触发的事件对象;</span><br><span class="language-xml">//$event.target 指代当前触发的事件对象的dom;</span><br><span class="language-xml">//$event.target.value 就是当前dom的value值;</span><br><span class="language-xml">//在@input方法中，value =&gt; sth;</span><br><span class="language-xml">//在:value中,sth =&gt; value;</span><br></code></pre></td></tr></table></figure><p><strong>（2）作用在组件上</strong><br>在自定义组件中，v-model 默认会利用名为 value 的 prop和名为 input 的事件</p><p><strong>本质是一个父子组件通信的语法糖，通过prop和$.emit实现。</strong> 因此父组件 v-model 语法糖本质上可以修改为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;child :value=<span class="hljs-string">&quot;message&quot;</span>  @input=<span class="hljs-string">&quot;function(e)&#123;message = e&#125;&quot;</span>&gt;&lt;/child&gt;<br></code></pre></td></tr></table></figure><p>在组件的实现中，可以通过 v-model属性来配置子组件接收的prop名称，以及派发的事件名称。<br>例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 父组件</span><br>&lt;aa-input v-model=<span class="hljs-string">&quot;aa&quot;</span>&gt;&lt;/aa-input&gt;<br><span class="hljs-comment">// 等价于</span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">aa-input</span> <span class="hljs-attr">v-bind:value</span>=<span class="hljs-string">&quot;aa&quot;</span> <span class="hljs-attr">v-on:input</span>=<span class="hljs-string">&quot;aa=$event.target.value&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">aa-input</span>&gt;</span></span><br><br><span class="hljs-comment">// 子组件：</span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">v-bind:value</span>=<span class="hljs-string">&quot;aa&quot;</span> <span class="hljs-attr">v-on:input</span>=<span class="hljs-string">&quot;onmessage&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">aa-input</span>&gt;</span></span><br><br><span class="hljs-attr">props</span>:&#123;<span class="hljs-attr">value</span>:aa,&#125;<br><span class="hljs-attr">methods</span>:&#123;<br>    <span class="hljs-title function_">onmessage</span>(<span class="hljs-params">e</span>)&#123;<br>        $emit(<span class="hljs-string">&#x27;input&#x27;</span>,e.<span class="hljs-property">target</span>.<span class="hljs-property">value</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>默认情况下，一个组件上的v-model 会把 value 用作 prop且把 input 用作 event。但是一些输入类型比如单选框和复选框按钮可能想使用 value prop 来达到不同的目的。使用 model 选项可以回避这些情况产生的冲突。js 监听input 输入框输入数据改变，用oninput，数据改变以后就会立刻出发这个事件。通过input事件把数据$emit 出去，在父组件接受。父组件设置v-model的值为input <code>$emit</code>过来的值。</p><h3 id="15-v-model-可以被用在自定义组件上吗？如果可以，如何使用？"><a href="#15-v-model-可以被用在自定义组件上吗？如果可以，如何使用？" class="headerlink" title="15. v-model 可以被用在自定义组件上吗？如果可以，如何使用？"></a>15. v-model 可以被用在自定义组件上吗？如果可以，如何使用？</h3><p>可以。v-model 实际上是一个语法糖，如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;input v-model=<span class="hljs-string">&quot;searchText&quot;</span>&gt;<br></code></pre></td></tr></table></figure><p>实际上相当于：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;input<br>  v-<span class="hljs-attr">bind</span>:value=<span class="hljs-string">&quot;searchText&quot;</span><br>  v-<span class="hljs-attr">on</span>:input=<span class="hljs-string">&quot;searchText = $event.target.value&quot;</span><br>&gt;<br></code></pre></td></tr></table></figure><p>用在自定义组件上也是同理：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;custom-input v-model=<span class="hljs-string">&quot;searchText&quot;</span>&gt;<br></code></pre></td></tr></table></figure><p>相当于：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;custom-input<br>  v-<span class="hljs-attr">bind</span>:value=<span class="hljs-string">&quot;searchText&quot;</span><br>  v-<span class="hljs-attr">on</span>:input=<span class="hljs-string">&quot;searchText = $event&quot;</span><br>&gt;&lt;/custom-input&gt;<br></code></pre></td></tr></table></figure><p>显然，custom-input 与父组件的交互如下：</p><ol><li>父组件将<code>searchText</code>变量传入custom-input 组件，使用的 prop 名为<code>value</code>；</li><li>custom-input 组件向父组件传出名为<code>input</code>的事件，父组件将接收到的值赋值给<code>searchText</code>；</li></ol><p>所以，custom-input 组件的实现应该类似于这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">component</span>(<span class="hljs-string">&#x27;custom-input&#x27;</span>, &#123;<br>  <span class="hljs-attr">props</span>: [<span class="hljs-string">&#x27;value&#x27;</span>],<br>  <span class="hljs-attr">template</span>: <span class="hljs-string">`</span><br><span class="hljs-string">    &lt;input</span><br><span class="hljs-string">      v-bind:value=&quot;value&quot;</span><br><span class="hljs-string">      v-on:input=&quot;$emit(&#x27;input&#x27;, $event.target.value)&quot;</span><br><span class="hljs-string">    &gt;</span><br><span class="hljs-string">  `</span><br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="16-data为什么是一个函数而不是对象"><a href="#16-data为什么是一个函数而不是对象" class="headerlink" title="16. data为什么是一个函数而不是对象"></a>16. data为什么是一个函数而不是对象</h3><p>JavaScript中的对象是引用类型的数据，当多个实例引用同一个对象时，只要一个实例对这个对象进行操作，其他实例中的数据也会发生变化。</p><p>而在Vue中，更多的是想要复用组件，那就需要每个组件都有自己的数据，这样组件之间才不会相互干扰。</p><p>所以组件的数据不能写成对象的形式，而是要写成函数的形式。数据以函数返回值的形式定义，这样当每次复用组件的时候，就会返回一个新的data，也就是说每个组件都有自己的私有数据空间，它们各自维护自己的数据，不会干扰其他组件的正常运行。</p><h3 id="17-对keep-alive的理解，它是如何实现的，具体缓存的是什么？"><a href="#17-对keep-alive的理解，它是如何实现的，具体缓存的是什么？" class="headerlink" title="17. 对keep-alive的理解，它是如何实现的，具体缓存的是什么？"></a>17. 对keep-alive的理解，它是如何实现的，具体缓存的是什么？</h3><p>如果需要在组件切换的时候，保存一些组件的状态防止多次渲染，就可以使用 keep-alive 组件包裹需要保存的组件。</p><p><strong>（1）keep-alive</strong></p><p>keep-alive有以下三个属性：</p><ul><li>include 字符串或正则表达式，只有名称匹配的组件会被匹配；</li><li>exclude 字符串或正则表达式，任何名称匹配的组件都不会被缓存；</li><li>max 数字，最多可以缓存多少组件实例。</li></ul><p>注意：keep-alive 包裹动态组件时，会缓存不活动的组件实例。</p><p><strong>主要流程</strong></p><ol><li>判断组件 name ，不在 include 或者在 exclude 中，直接返回 vnode，说明该组件不被缓存。</li><li>获取组件实例 key ，如果有获取实例的 key，否则重新生成。</li><li>key生成规则，cid +”∶∶”+ tag ，仅靠cid是不够的，因为相同的构造函数可以注册为不同的本地组件。</li><li>如果缓存对象内存在，则直接从缓存对象中获取组件实例给 vnode ，不存在则添加到缓存对象中。 5.最大缓存数量，当缓存组件数量超过 max 值时，清除 keys 数组内第一个组件。</li></ol><p><strong>（2）keep-alive 的实现</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-attr">patternTypes</span>: <span class="hljs-title class_">Array</span>&lt;<span class="hljs-title class_">Function</span>&gt; = [<span class="hljs-title class_">String</span>, <span class="hljs-title class_">RegExp</span>, <span class="hljs-title class_">Array</span>] <span class="hljs-comment">// 接收：字符串，正则，数组</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;keep-alive&#x27;</span>,<br>  <span class="hljs-attr">abstract</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 抽象组件，是一个抽象组件：它自身不会渲染一个 DOM 元素，也不会出现在父组件链中。</span><br><br>  <span class="hljs-attr">props</span>: &#123;<br>    <span class="hljs-attr">include</span>: patternTypes, <span class="hljs-comment">// 匹配的组件，缓存</span><br>    <span class="hljs-attr">exclude</span>: patternTypes, <span class="hljs-comment">// 不去匹配的组件，不缓存</span><br>    <span class="hljs-attr">max</span>: [<span class="hljs-title class_">String</span>, <span class="hljs-title class_">Number</span>], <span class="hljs-comment">// 缓存组件的最大实例数量, 由于缓存的是组件实例（vnode），数量过多的时候，会占用过多的内存，可以用max指定上限</span><br>  &#125;,<br><br>  <span class="hljs-title function_">created</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// 用于初始化缓存虚拟DOM数组和vnode的key</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">cache</span> = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(<span class="hljs-literal">null</span>)<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">keys</span> = []<br>  &#125;,<br><br>  <span class="hljs-title function_">destroyed</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// 销毁缓存cache的组件实例</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> key <span class="hljs-keyword">in</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">cache</span>) &#123;<br>      <span class="hljs-title function_">pruneCacheEntry</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">cache</span>, key, <span class="hljs-variable language_">this</span>.<span class="hljs-property">keys</span>)<br>    &#125;<br>  &#125;,<br><br>  <span class="hljs-title function_">mounted</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// prune 削减精简[v.]</span><br>    <span class="hljs-comment">// 去监控include和exclude的改变，根据最新的include和exclude的内容，来实时削减缓存的组件的内容</span><br>    <span class="hljs-variable language_">this</span>.$watch(<span class="hljs-string">&#x27;include&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">val</span>) =&gt;</span> &#123;<br>      <span class="hljs-title function_">pruneCache</span>(<span class="hljs-variable language_">this</span>, <span class="hljs-function">(<span class="hljs-params">name</span>) =&gt;</span> <span class="hljs-title function_">matches</span>(val, name))<br>    &#125;)<br>    <span class="hljs-variable language_">this</span>.$watch(<span class="hljs-string">&#x27;exclude&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">val</span>) =&gt;</span> &#123;<br>      <span class="hljs-title function_">pruneCache</span>(<span class="hljs-variable language_">this</span>, <span class="hljs-function">(<span class="hljs-params">name</span>) =&gt;</span> !<span class="hljs-title function_">matches</span>(val, name))<br>    &#125;)<br>  &#125;,<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>render函数：</strong></p><ol><li>会在 keep-alive 组件内部去写自己的内容，所以可以去获取默认 slot 的内容，然后根据这个去获取组件</li><li>keep-alive 只对第一个组件有效，所以获取第一个子组件。</li><li>和 keep-alive 搭配使用的一般有：动态组件 和router-view</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs javascript">render () &#123;<br>  <span class="hljs-comment">//</span><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">getFirstComponentChild</span> (<span class="hljs-attr">children</span>: ?<span class="hljs-title class_">Array</span>&lt;<span class="hljs-title class_">VNode</span>&gt;): ?<span class="hljs-title class_">VNode</span> &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(children)) &#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; children.<span class="hljs-property">length</span>; i++) &#123;<br>    <span class="hljs-keyword">const</span> c = children[i]<br>    <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isDef</span>(c) &amp;&amp; (<span class="hljs-title function_">isDef</span>(c.<span class="hljs-property">componentOptions</span>) || <span class="hljs-title function_">isAsyncPlaceholder</span>(c))) &#123;<br>      <span class="hljs-keyword">return</span> c<br>    &#125;<br>  &#125;<br>  &#125;<br>  &#125;<br>  <span class="hljs-keyword">const</span> slot = <span class="hljs-variable language_">this</span>.<span class="hljs-property">$slots</span>.<span class="hljs-property">default</span> <span class="hljs-comment">// 获取默认插槽</span><br>  <span class="hljs-keyword">const</span> <span class="hljs-attr">vnode</span>: <span class="hljs-title class_">VNode</span> = <span class="hljs-title function_">getFirstComponentChild</span>(slot)<span class="hljs-comment">// 获取第一个子组件</span><br>  <span class="hljs-keyword">const</span> <span class="hljs-attr">componentOptions</span>: ?<span class="hljs-title class_">VNodeComponentOptions</span> = vnode &amp;&amp; vnode.<span class="hljs-property">componentOptions</span> <span class="hljs-comment">// 组件参数</span><br>  <span class="hljs-keyword">if</span> (componentOptions) &#123; <span class="hljs-comment">// 是否有组件参数</span><br>    <span class="hljs-comment">// check pattern</span><br>    <span class="hljs-keyword">const</span> <span class="hljs-attr">name</span>: ?string = <span class="hljs-title function_">getComponentName</span>(componentOptions) <span class="hljs-comment">// 获取组件名</span><br>    <span class="hljs-keyword">const</span> &#123; include, exclude &#125; = <span class="hljs-variable language_">this</span><br>    <span class="hljs-keyword">if</span> (<br>      <span class="hljs-comment">// not included</span><br>      (include &amp;&amp; (!name || !<span class="hljs-title function_">matches</span>(include, name))) ||<br>      <span class="hljs-comment">// excluded</span><br>      (exclude &amp;&amp; name &amp;&amp; <span class="hljs-title function_">matches</span>(exclude, name))<br>    ) &#123;<br>      <span class="hljs-comment">// 如果不匹配当前组件的名字和include以及exclude</span><br>      <span class="hljs-comment">// 那么直接返回组件的实例</span><br>      <span class="hljs-keyword">return</span> vnode<br>    &#125;<br><br>    <span class="hljs-keyword">const</span> &#123; cache, keys &#125; = <span class="hljs-variable language_">this</span><br><br>    <span class="hljs-comment">// 获取这个组件的key</span><br>    <span class="hljs-keyword">const</span> <span class="hljs-attr">key</span>: ?string = vnode.<span class="hljs-property">key</span> == <span class="hljs-literal">null</span><br>      <span class="hljs-comment">// same constructor may get registered as different local components</span><br>      <span class="hljs-comment">// so cid alone is not enough (#3269)</span><br>      ? componentOptions.<span class="hljs-property">Ctor</span>.<span class="hljs-property">cid</span> + (componentOptions.<span class="hljs-property">tag</span> ? <span class="hljs-string">`::<span class="hljs-subst">$&#123;componentOptions.tag&#125;</span>`</span> : <span class="hljs-string">&#x27;&#x27;</span>)<br>      : vnode.<span class="hljs-property">key</span><br><br>    <span class="hljs-keyword">if</span> (cache[key]) &#123;<br>      <span class="hljs-comment">// LRU缓存策略执行</span><br>      vnode.<span class="hljs-property">componentInstance</span> = cache[key].<span class="hljs-property">componentInstance</span> <span class="hljs-comment">// 组件初次渲染的时候componentInstance为undefined</span><br><br>      <span class="hljs-comment">// make current key freshest</span><br>      <span class="hljs-title function_">remove</span>(keys, key)<br>      keys.<span class="hljs-title function_">push</span>(key)<br>      <span class="hljs-comment">// 根据LRU缓存策略执行，将key从原来的位置移除，然后将这个key值放到最后面</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// 在缓存列表里面没有的话，则加入，同时判断当前加入之后，是否超过了max所设定的范围，如果是，则去除</span><br>      <span class="hljs-comment">// 使用时间间隔最长的一个</span><br>      cache[key] = vnode<br>      keys.<span class="hljs-title function_">push</span>(key)<br>      <span class="hljs-comment">// prune oldest entry</span><br>      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">max</span> &amp;&amp; keys.<span class="hljs-property">length</span> &gt; <span class="hljs-built_in">parseInt</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">max</span>)) &#123;<br>        <span class="hljs-title function_">pruneCacheEntry</span>(cache, keys[<span class="hljs-number">0</span>], keys, <span class="hljs-variable language_">this</span>.<span class="hljs-property">_vnode</span>)<br>      &#125;<br>    &#125;<br>    <span class="hljs-comment">// 将组件的keepAlive属性设置为true</span><br>    vnode.<span class="hljs-property">data</span>.<span class="hljs-property">keepAlive</span> = <span class="hljs-literal">true</span> <span class="hljs-comment">// 作用：判断是否要执行组件的created、mounted生命周期函数</span><br>  &#125;<br>  <span class="hljs-keyword">return</span> vnode || (slot &amp;&amp; slot[<span class="hljs-number">0</span>])<br>&#125;<br></code></pre></td></tr></table></figure><p>keep-alive 具体是通过 cache 数组缓存所有组件的 vnode 实例。当 cache 内原有组件被使用时会将该组件 key 从 keys 数组中删除，然后 push 到 keys数组最后，以便清除最不常用组件。</p><p><strong>实现步骤：</strong></p><ol><li>获取 keep-alive 下第一个子组件的实例对象，通过他去获取这个组件的组件名</li><li>通过当前组件名去匹配原来 include 和 exclude，判断当前组件是否需要缓存，不需要缓存，直接返回当前组件的实例vNode</li><li>需要缓存，判断他当前是否在缓存数组里面：</li></ol><ul><li>存在，则将他原来位置上的 key 给移除，同时将这个组件的 key 放到数组最后面（LRU）</li><li>不存在，将组件 key 放入数组，然后判断当前 key数组是否超过 max 所设置的范围，超过，那么削减未使用时间最长的一个组件的 key</li></ul><ol start="4"><li>最后将这个组件的 keepAlive 设置为 true</li></ol><p><strong>（3）keep-alive 本身的创建过程和 patch 过程</strong></p><p>缓存渲染的时候，会根据 vnode.componentInstance（首次渲染 vnode.componentInstance 为 undefined） 和 keepAlive 属性判断不会执行组件的 created、mounted 等钩子函数，而是对缓存的组件执行 patch 过程∶ 直接把缓存的 DOM 对象直接插入到目标元素中，完成了数据更新的情况下的渲染过程。</p><p><strong>首次渲染</strong></p><ul><li>组件的首次渲染∶判断组件的 abstract 属性，才往父组件里面挂载 DOM</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// core/instance/lifecycle</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">initLifecycle</span> (<span class="hljs-attr">vm</span>: <span class="hljs-title class_">Component</span>) &#123;<br>  <span class="hljs-keyword">const</span> options = vm.<span class="hljs-property">$options</span><br><br>  <span class="hljs-comment">// locate first non-abstract parent</span><br>  <span class="hljs-keyword">let</span> parent = options.<span class="hljs-property">parent</span><br>  <span class="hljs-keyword">if</span> (parent &amp;&amp; !options.<span class="hljs-property">abstract</span>) &#123; <span class="hljs-comment">// 判断组件的abstract属性，才往父组件里面挂载DOM</span><br>    <span class="hljs-keyword">while</span> (parent.<span class="hljs-property">$options</span>.<span class="hljs-property">abstract</span> &amp;&amp; parent.<span class="hljs-property">$parent</span>) &#123;<br>      parent = parent.<span class="hljs-property">$parent</span><br>    &#125;<br>    parent.<span class="hljs-property">$children</span>.<span class="hljs-title function_">push</span>(vm)<br>  &#125;<br><br>  vm.<span class="hljs-property">$parent</span> = parent<br>  vm.<span class="hljs-property">$root</span> = parent ? parent.<span class="hljs-property">$root</span> : vm<br><br>  vm.<span class="hljs-property">$children</span> = []<br>  vm.<span class="hljs-property">$refs</span> = &#123;&#125;<br><br>  vm.<span class="hljs-property">_watcher</span> = <span class="hljs-literal">null</span><br>  vm.<span class="hljs-property">_inactive</span> = <span class="hljs-literal">null</span><br>  vm.<span class="hljs-property">_directInactive</span> = <span class="hljs-literal">false</span><br>  vm.<span class="hljs-property">_isMounted</span> = <span class="hljs-literal">false</span><br>  vm.<span class="hljs-property">_isDestroyed</span> = <span class="hljs-literal">false</span><br>  vm.<span class="hljs-property">_isBeingDestroyed</span> = <span class="hljs-literal">false</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>判断当前 keepAlive 和 componentInstance 是否存在来判断是否要执行组件 prepatch 还是执行创建 componentlnstance</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// core/vdom/create-component</span><br>init (<span class="hljs-attr">vnode</span>: <span class="hljs-title class_">VNodeWithData</span>, <span class="hljs-attr">hydrating</span>: boolean): ?boolean &#123;<br>    <span class="hljs-keyword">if</span> (<br>      vnode.<span class="hljs-property">componentInstance</span> &amp;&amp;<br>      !vnode.<span class="hljs-property">componentInstance</span>.<span class="hljs-property">_isDestroyed</span> &amp;&amp;<br>      vnode.<span class="hljs-property">data</span>.<span class="hljs-property">keepAlive</span><br>    ) &#123; <span class="hljs-comment">// componentInstance在初次是undefined!!!</span><br>      <span class="hljs-comment">// kept-alive components, treat as a patch</span><br>      <span class="hljs-keyword">const</span> <span class="hljs-attr">mountedNode</span>: any = vnode <span class="hljs-comment">// work around flow</span><br>      componentVNodeHooks.<span class="hljs-title function_">prepatch</span>(mountedNode, mountedNode) <span class="hljs-comment">// prepatch函数执行的是组件更新的过程</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">const</span> child = vnode.<span class="hljs-property">componentInstance</span> = <span class="hljs-title function_">createComponentInstanceForVnode</span>(<br>        vnode,<br>        activeInstance<br>      )<br>      child.$mount(hydrating ? vnode.<span class="hljs-property">elm</span> : <span class="hljs-literal">undefined</span>, hydrating)<br>    &#125;<br>  &#125;,<br></code></pre></td></tr></table></figure><p>prepatch 操作就不会在执行组件的 mounted 和 created 生命周期函数，而是直接将 DOM 插入</p><p><strong>（4）LRU （least recently used）缓存策略</strong></p><p>LRU 缓存策略∶ 从内存中找出最久未使用的数据并置换新的数据。<br>LRU（Least rencently used）算法根据数据的历史访问记录来进行淘汰数据，其核心思想是 **”如果数据最近被访问过，那么将来被访问的几率也更高”**。 最常见的实现是使用一个链表保存缓存数据，详细算法实现如下∶ </p><ul><li>新数据插入到链表头部</li><li>每当缓存命中（即缓存数据被访问），则将数据移到链表头部</li><li>链表满的时候，将链表尾部的数据丢弃。</li></ul><h3 id="18-nextTick-原理及作用"><a href="#18-nextTick-原理及作用" class="headerlink" title="18. $nextTick 原理及作用"></a>18. $nextTick 原理及作用</h3><p>Vue 的 nextTick 其本质是对 JavaScript 执行原理 EventLoop 的一种应用。</p><p>nextTick 的核心是利用了如 Promise 、MutationObserver、setImmediate、setTimeout的原生 JavaScript 方法来模拟对应的微&#x2F;宏任务的实现，本质是为了利用 JavaScript 的这些异步回调任务队列来实现 Vue 框架中自己的异步回调队列。</p><p>nextTick 不仅是 Vue 内部的异步队列的调用方法，同时也允许开发者在实际项目中使用这个方法来满足实际应用中对 DOM 更新数据时机的后续逻辑处理</p><p>nextTick 是典型的将底层 JavaScript 执行原理应用到具体案例中的示例，引入异步更新队列机制的原因∶</p><ul><li>如果是同步更新，则多次对一个或多个属性赋值，会频繁触发 UI&#x2F;DOM 的渲染，可以减少一些无用渲染</li><li>同时由于 VirtualDOM 的引入，每一次状态发生变化后，状态变化的信号会发送给组件，组件内部使用 VirtualDOM 进行计算得出需要更新的具体的 DOM 节点，然后对 DOM 进行更新操作，每次更新状态后的渲染过程需要更多的计算，而这种无用功也将浪费更多的性能，所以异步渲染变得更加至关重要</li></ul><p>Vue采用了数据驱动视图的思想，但是在一些情况下，仍然需要操作DOM。有时候，可能遇到这样的情况，DOM1的数据发生了变化，而DOM2需要从DOM1中获取数据，那这时就会发现DOM2的视图并没有更新，这时就需要用到了<code>nextTick</code>了。</p><p>由于Vue的DOM操作是异步的，所以，在上面的情况中，就要将DOM2获取数据的操作写在<code>$nextTick</code>中。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">this</span>.$nextTick(<span class="hljs-function">() =&gt;</span> &#123;    <span class="hljs-comment">// 获取数据的操作...&#125;)</span><br></code></pre></td></tr></table></figure><p>所以，在以下情况下，会用到nextTick：</p><ul><li>在数据变化后执行的某个操作，而这个操作需要使用随数据变化而变化的DOM结构的时候，这个操作就需要方法在<code>nextTick()</code>的回调函数中。</li><li>在vue生命周期中，如果在created()钩子进行DOM操作，也一定要放在<code>nextTick()</code>的回调函数中。</li></ul><p>因为在created()钩子函数中，页面的DOM还未渲染，这时候也没办法操作DOM，所以，此时如果想要操作DOM，必须将操作的代码放在<code>nextTick()</code>的回调函数中。</p><h3 id="19-Vue-中给-data-中的对象属性添加一个新的属性时会发生什么？如何解决？"><a href="#19-Vue-中给-data-中的对象属性添加一个新的属性时会发生什么？如何解决？" class="headerlink" title="19. Vue 中给 data 中的对象属性添加一个新的属性时会发生什么？如何解决？"></a><strong>19. Vue 中给 data 中的对象属性添加一个新的属性时会发生什么？如何解决？</strong></h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;template&gt; <br>   <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span></span><br><span class="language-xml">         <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;value in obj&quot;</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">&quot;value&quot;</span>&gt;</span> &#123;&#123;value&#125;&#125; <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span> </span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span> </span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;addObjB&quot;</span>&gt;</span>添加 obj.b<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span> </span><br><span class="language-xml">   <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>&lt;/template&gt;<br><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123; </span></span><br><span class="language-javascript"><span class="language-xml">       data () &#123; </span></span><br><span class="language-javascript"><span class="language-xml">          <span class="hljs-keyword">return</span> &#123; </span></span><br><span class="language-javascript"><span class="language-xml">              <span class="hljs-attr">obj</span>: &#123; </span></span><br><span class="language-javascript"><span class="language-xml">                  <span class="hljs-attr">a</span>: <span class="hljs-string">&#x27;obj.a&#x27;</span> </span></span><br><span class="language-javascript"><span class="language-xml">              &#125; </span></span><br><span class="language-javascript"><span class="language-xml">          &#125; </span></span><br><span class="language-javascript"><span class="language-xml">       &#125;,</span></span><br><span class="language-javascript"><span class="language-xml">       <span class="hljs-attr">methods</span>: &#123; </span></span><br><span class="language-javascript"><span class="language-xml">          addObjB () &#123; </span></span><br><span class="language-javascript"><span class="language-xml">              <span class="hljs-variable language_">this</span>.<span class="hljs-property">obj</span>.<span class="hljs-property">b</span> = <span class="hljs-string">&#x27;obj.b&#x27;</span> </span></span><br><span class="language-javascript"><span class="language-xml">              <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">obj</span>) </span></span><br><span class="language-javascript"><span class="language-xml">          &#125; </span></span><br><span class="language-javascript"><span class="language-xml">      &#125;</span></span><br><span class="language-javascript"><span class="language-xml">   &#125;</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>点击 button 会发现，obj.b 已经成功添加，但是视图并未刷新。这是因为在Vue实例创建时，obj.b并未声明，因此就没有被Vue转换为响应式的属性，自然就不会触发视图的更新，这时就需要使用Vue的全局 api <strong>$set()：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript">addObjB () (<br>   <span class="hljs-variable language_">this</span>.$set(<span class="hljs-variable language_">this</span>.<span class="hljs-property">obj</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;obj.b&#x27;</span>)<br>   <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">obj</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>$set()方法相当于手动的去把obj.b处理成一个响应式的属性，此时视图也会跟着改变了。</p><h3 id="20-Vue中封装的数组方法有哪些，其如何实现页面更新"><a href="#20-Vue中封装的数组方法有哪些，其如何实现页面更新" class="headerlink" title="20. Vue中封装的数组方法有哪些，其如何实现页面更新"></a>20. Vue中封装的数组方法有哪些，其如何实现页面更新</h3><p>在Vue中，对响应式处理利用的是Object.defineProperty对数据进行拦截，而这个方法并不能监听到数组内部变化，数组长度变化，数组的截取变化等，所以需要对这些操作进行hack，让Vue能监听到其中的变化。<br><img src="BGW-Vue1/6.png" alt="image.png"><br>那Vue是如何实现让这些数组方法实现元素的实时更新的呢，下面是Vue中对这些方法的封装：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 缓存数组原型</span><br><span class="hljs-keyword">const</span> arrayProto = <span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>;<br><span class="hljs-comment">// 实现 arrayMethods.__proto__ === Array.prototype</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> arrayMethods = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(arrayProto);<br><span class="hljs-comment">// 需要进行功能拓展的方法</span><br><span class="hljs-keyword">const</span> methodsToPatch = [<br>  <span class="hljs-string">&quot;push&quot;</span>,<br>  <span class="hljs-string">&quot;pop&quot;</span>,<br>  <span class="hljs-string">&quot;shift&quot;</span>,<br>  <span class="hljs-string">&quot;unshift&quot;</span>,<br>  <span class="hljs-string">&quot;splice&quot;</span>,<br>  <span class="hljs-string">&quot;sort&quot;</span>,<br>  <span class="hljs-string">&quot;reverse&quot;</span><br>];<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Intercept mutating methods and emit events</span><br><span class="hljs-comment"> */</span><br>methodsToPatch.<span class="hljs-title function_">forEach</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">method</span>) &#123;<br>  <span class="hljs-comment">// 缓存原生数组方法</span><br>  <span class="hljs-keyword">const</span> original = arrayProto[method];<br>  <span class="hljs-title function_">def</span>(arrayMethods, method, <span class="hljs-keyword">function</span> <span class="hljs-title function_">mutator</span>(<span class="hljs-params">...args</span>) &#123;<br>    <span class="hljs-comment">// 执行并缓存原生数组功能</span><br>    <span class="hljs-keyword">const</span> result = original.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, args);<br>    <span class="hljs-comment">// 响应式处理</span><br>    <span class="hljs-keyword">const</span> ob = <span class="hljs-variable language_">this</span>.<span class="hljs-property">__ob__</span>;<br>    <span class="hljs-keyword">let</span> inserted;<br>    <span class="hljs-keyword">switch</span> (method) &#123;<br>    <span class="hljs-comment">// push、unshift会新增索引，所以要手动observer</span><br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;push&quot;</span>:<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;unshift&quot;</span>:<br>        inserted = args;<br>        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-comment">// splice方法，如果传入了第三个参数，也会有索引加入，也要手动observer。</span><br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;splice&quot;</span>:<br>        inserted = args.<span class="hljs-title function_">slice</span>(<span class="hljs-number">2</span>);<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-comment">// </span><br>    <span class="hljs-keyword">if</span> (inserted) ob.<span class="hljs-title function_">observeArray</span>(inserted);<span class="hljs-comment">// 获取插入的值，并设置响应式监听</span><br>    <span class="hljs-comment">// notify change</span><br>    ob.<span class="hljs-property">dep</span>.<span class="hljs-title function_">notify</span>();<span class="hljs-comment">// 通知依赖更新</span><br>    <span class="hljs-comment">// 返回原生数组方法的执行结果</span><br>    <span class="hljs-keyword">return</span> result;<br>  &#125;);<br>&#125;);<br></code></pre></td></tr></table></figure><p>简单来说就是，重写了数组中的那些原生方法，首先获取到这个数组的__ob__，也就是它的Observer对象，如果有新的值，就调用observeArray继续对新的值观察变化（也就是通过<code>target__proto__ == arrayMethods</code>来改变了数组实例的型），然后手动调用notify，通知渲染watcher，执行update。</p><h3 id="21-Vue-单页应用与多页应用的区别"><a href="#21-Vue-单页应用与多页应用的区别" class="headerlink" title="21. Vue 单页应用与多页应用的区别"></a>21. Vue 单页应用与多页应用的区别</h3><p><strong>概念：</strong></p><ul><li>SPA单页面应用（SinglePage Web Application），指只有一个主页面的应用，一开始只需要加载一次js、css等相关资源。所有内容都包含在主页面，对每一个功能模块组件化。单页应用跳转，就是切换相关组件，仅仅刷新局部资源。</li><li>MPA多页面应用 （MultiPage Application），指有多个独立页面的应用，每个页面必须重复加载js、css等相关资源。多页应用跳转，需要整页资源刷新。</li></ul><p><strong>区别：</strong><br><img src="7.jpg" alt="img"></p><h3 id="22-Vue-template-到-render-的过程"><a href="#22-Vue-template-到-render-的过程" class="headerlink" title="22. Vue template 到 render 的过程"></a>22. Vue template 到 render 的过程</h3><p>vue的模版编译过程主要如下：<strong>template -&gt; ast -&gt; render函数</strong></p><p>vue 在模版编译版本的码中会执行 compileToFunctions 将template转化为render函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 将模板编译为render函数const &#123; render, staticRenderFns &#125; = compileToFunctions(template,options//省略&#125;, this)</span><br></code></pre></td></tr></table></figure><p>CompileToFunctions中的主要逻辑如下∶<br><strong>（1）调用parse方法将template转化为ast（抽象语法树）</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">constast = <span class="hljs-title function_">parse</span>(template.<span class="hljs-title function_">trim</span>(), options)<br></code></pre></td></tr></table></figure><ul><li><strong>parse的目标</strong>：把tamplate转换为AST树，它是一种用 JavaScript对象的形式来描述整个模板。</li><li><strong>解析过程</strong>：利用正则表达式顺序解析模板，当解析到开始标签、闭合标签、文本的时候都会分别执行对应的 回调函数，来达到构造AST树的目的。</li></ul><p>AST元素节点总共三种类型：type为1表示普通元素、2为表达式、3为纯文本</p><p><strong>（2）对静态节点做优化</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">optimize</span>(ast,options)<br></code></pre></td></tr></table></figure><p>这个过程主要分析出哪些是静态节点，给其打一个标记，为后续更新渲染可以直接跳过静态节点做优化</p><p>深度遍历AST，查看每个子树的节点元素是否为静态节点或者静态节点根。如果为静态节点，他们生成的DOM永远不会改变，这对运行时模板更新起到了极大的优化作用。</p><p><strong>（3）生成代码</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> code = <span class="hljs-title function_">generate</span>(ast, options)<br></code></pre></td></tr></table></figure><p>generate将ast抽象语法树编译成 render字符串并将静态部分放到 staticRenderFns 中，最后通过 <code>new Function(`` render``)</code> 生成render函数。</p><h3 id="23-Vue-data-中某一个属性的值发生改变后，视图会立即同步执行重新渲染吗？"><a href="#23-Vue-data-中某一个属性的值发生改变后，视图会立即同步执行重新渲染吗？" class="headerlink" title="23. Vue data 中某一个属性的值发生改变后，视图会立即同步执行重新渲染吗？"></a>23. Vue data 中某一个属性的值发生改变后，视图会立即同步执行重新渲染吗？</h3><p>不会立即同步执行重新渲染。Vue 实现响应式并不是数据发生变化之后 DOM 立即变化，而是按一定的策略进行 DOM 的更新。Vue 在更新 DOM 时是异步执行的。只要侦听到数据变化， Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据变更。</p><p>如果同一个watcher被多次触发，只会被推入到队列中一次。这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作是非常重要的。然后，在下一个的事件循环tick中，Vue 刷新队列并执行实际（已去重的）工作。</p><h3 id="24-简述-mixin、extends-的覆盖逻辑"><a href="#24-简述-mixin、extends-的覆盖逻辑" class="headerlink" title="24. 简述 mixin、extends 的覆盖逻辑"></a>24. 简述 mixin、extends 的覆盖逻辑</h3><p><strong>（1）mixin 和 extends</strong><br>mixin 和 extends均是用于合并、拓展组件的，两者均通过 mergeOptions 方法实现合并。</p><ul><li>mixins 接收一个混入对象的数组，其中混入对象可以像正常的实例对象一样包含实例选项，这些选项会被合并到最终的选项中。Mixin 钩子按照传入顺序依次调用，并在调用组件自身的钩子之前被调用。</li><li>extends 主要是为了便于扩展单文件组件，接收一个对象或构造函数。</li></ul><p><img src="8.jpg" alt="img"><br><strong>（2)mergeOptions 的执行过程</strong></p><ul><li>规范化选项（normalizeProps、normalizelnject、normalizeDirectives)</li><li>对未合并的选项，进行判断</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">if</span>(!child.<span class="hljs-property">_base</span>) &#123;    <span class="hljs-keyword">if</span>(child.<span class="hljs-property">extends</span>) &#123;        parent = <span class="hljs-title function_">mergeOptions</span>(parent, child.<span class="hljs-property">extends</span>, vm)    &#125;    <span class="hljs-keyword">if</span>(child.<span class="hljs-property">mixins</span>) &#123;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>, l = child.<span class="hljs-property">mixins</span>.<span class="hljs-property">length</span>; i &lt; l; i++)&#123;            parent = <span class="hljs-title function_">mergeOptions</span>(parent, child.<span class="hljs-property">mixins</span>[i], vm)        &#125;    &#125;&#125;<br></code></pre></td></tr></table></figure><ul><li>合并处理。根据一个通用 Vue 实例所包含的选项进行分类逐一判断合并，如 props、data、 methods、watch、computed、生命周期等，将合并结果存储在新定义的 options 对象里。</li><li>返回合并结果 options。</li></ul><h3 id="25-描述下Vue自定义指令"><a href="#25-描述下Vue自定义指令" class="headerlink" title="25. 描述下Vue自定义指令"></a>25. 描述下Vue自定义指令</h3><p>在 Vue2.0 中，代码复用和抽象的主要形式是组件。然而，有的情况下，你仍然需要对普通 DOM 元素进行底层操作，这时候就会用到自定义指令。<br>一般需要对DOM元素进行底层操作时使用，尽量只用来操作 DOM展示，不修改内部的值。当使用自定义指令直接修改 value 值时绑定v-model的值也不会同步更新；如必须修改可以在自定义指令中使用keydown事件，在vue组件中使用 change事件，回调中修改vue数据; </p><p><strong>（1）自定义指令基本内容</strong></p><ul><li><p>全局定义：<code>Vue.directive(&quot;focus&quot;,&#123;&#125;)</code></p></li><li><p>局部定义：<code>directives:&#123;focus:&#123;&#125;&#125;</code></p></li><li><p>钩子函数：指令定义对象提供钩子函数</p><p>o bind：只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置。</p><p>o inSerted：被绑定元素插入父节点时调用（仅保证父节点存在，但不一定已被插入文档中）。</p><p>o update：所在组件的VNode更新时调用，但是可能发生在其子VNode更新之前调用。指令的值可能发生了改变，也可能没有。但是可以通过比较更新前后的值来忽略不必要的模板更新。</p><p>o ComponentUpdate：指令所在组件的 VNode及其子VNode全部更新后调用。</p><p>o unbind：只调用一次，指令与元素解绑时调用。</p></li><li><p>钩子函数参数<br>o el：绑定元素</p><p>o bing： 指令核心对象，描述指令全部信息属性</p><p>o name</p><p>o value</p><p>o oldValue</p><p>o expression</p><p>o arg</p><p>o modifers</p><p>o vnode  虚拟节点</p><p>o oldVnode：上一个虚拟节点（更新钩子函数中才有用）</p></li></ul><p><strong>（2）使用场景</strong></p><ul><li><p>普通DOM元素进行底层操作的时候，可以使用自定义指令</p></li><li><p>自定义指令是用来操作DOM的。尽管Vue推崇数据驱动视图的理念，但并非所有情况都适合数据驱动。自定义指令就是一种有效的补充和扩展，不仅可用于定义任何的DOM操作，并且是可复用的。</p></li></ul><p><strong>（3）使用案例</strong></p><p>初级应用：</p><ul><li>鼠标聚焦</li><li>下拉菜单</li><li>相对时间转换</li><li>滚动动画</li></ul><p>高级应用：</p><ul><li>自定义指令实现图片懒加载</li><li>自定义指令集成第三方插件</li></ul><h3 id="26-子组件可以直接改变父组件的数据吗？"><a href="#26-子组件可以直接改变父组件的数据吗？" class="headerlink" title="26. 子组件可以直接改变父组件的数据吗？"></a>26. 子组件可以直接改变父组件的数据吗？</h3><p>子组件不可以直接改变父组件的数据。这样做主要是为了维护父子组件的单向数据流。每次父级组件发生更新时，子组件中所有的 prop 都将会刷新为最新的值。如果这样做了，Vue 会在浏览器的控制台中发出警告。</p><p>Vue提倡单向数据流，即父级 props 的更新会流向子组件，但是反过来则不行。这是为了防止意外的改变父组件状态，使得应用的数据流变得难以理解，导致数据流混乱。如果破坏了单向数据流，当应用复杂时，debug 的成本会非常高。</p><p><strong>只能通过 <strong><code>$emit</code></strong> 派发一个自定义事件，父组件接收到后，由父组件修改。</strong></p><h3 id="27-Vue是如何收集依赖的？"><a href="#27-Vue是如何收集依赖的？" class="headerlink" title="27. Vue是如何收集依赖的？"></a>27. Vue是如何收集依赖的？</h3><p>在初始化 Vue 的每个组件时，会对组件的 data 进行初始化，就会将由普通对象变成响应式对象，在这个过程中便会进行依赖收集的相关逻辑，如下所示∶</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">defieneReactive</span> (obj, key, val)&#123;<br>  <span class="hljs-keyword">const</span> dep = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dep</span>();<br>  ...<br>  <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(obj, key, &#123;<br>    ...<br>    <span class="hljs-attr">get</span>: <span class="hljs-keyword">function</span> <span class="hljs-title function_">reactiveGetter</span> () &#123;<br>      <span class="hljs-keyword">if</span>(<span class="hljs-title class_">Dep</span>.<span class="hljs-property">target</span>)&#123;<br>        dep.<span class="hljs-title function_">depend</span>();<br>        ...<br>      &#125;<br>      <span class="hljs-keyword">return</span> val<br>    &#125;<br>    ...<br>  &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p>以上只保留了关键代码，主要就是 <code>const dep = new Dep()</code>实例化一个 Dep 的实例，然后在 get 函数中通过 <code>dep.depend()</code> 进行依赖收集。<br><strong>（1）Dep</strong><br>Dep是整个依赖收集的核心，其关键代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dep</span> &#123;<br>  <span class="hljs-keyword">static</span> target;<br>  subs;<br><br>  <span class="hljs-title function_">constructor</span> () &#123;<br>    ...<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">subs</span> = [];<br>  &#125;<br>  addSub (sub) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">subs</span>.<span class="hljs-title function_">push</span>(sub)<br>  &#125;<br>  removeSub (sub) &#123;<br>    <span class="hljs-title function_">remove</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">sub</span>, sub)<br>  &#125;<br>  depend () &#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-title class_">Dep</span>.<span class="hljs-property">target</span>)&#123;<br>      <span class="hljs-title class_">Dep</span>.<span class="hljs-property">target</span>.<span class="hljs-title function_">addDep</span>(<span class="hljs-variable language_">this</span>)<br>    &#125;<br>  &#125;<br>  notify () &#123;<br>    <span class="hljs-keyword">const</span> subs = <span class="hljs-variable language_">this</span>.<span class="hljs-property">subds</span>.<span class="hljs-title function_">slice</span>();<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>;i &lt; subs.<span class="hljs-property">length</span>; i++)&#123;<br>      subs[i].<span class="hljs-title function_">update</span>()<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Dep 是一个 class ，其中有一个关 键的静态属性 static，它指向了一个全局唯一 Watcher，保证了同一时间全局只有一个 watcher 被计算，另一个属性 subs 则是一个 Watcher 的数组，所以 Dep 实际上就是对 Watcher 的管理，再看看 Watcher 的相关代码∶</p><p><strong>（2）Watcher</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Watcher</span> &#123;<br>  getter;<br>  ...<br>  <span class="hljs-title function_">constructor</span> (vm, expression)&#123;<br>    ...<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">getter</span> = expression;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">get</span>();<br>  &#125;<br>  get () &#123;<br>    <span class="hljs-title function_">pushTarget</span>(<span class="hljs-variable language_">this</span>);<br>    value = <span class="hljs-variable language_">this</span>.<span class="hljs-property">getter</span>.<span class="hljs-title function_">call</span>(vm, vm)<br>    ...<br>    <span class="hljs-keyword">return</span> value<br>  &#125;<br>  addDep (dep)&#123;<br>        ...<br>    dep.<span class="hljs-title function_">addSub</span>(<span class="hljs-variable language_">this</span>)<br>  &#125;<br>  ...<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">pushTarget</span> (_target) &#123;<br>  <span class="hljs-title class_">Dep</span>.<span class="hljs-property">target</span> = _target<br>&#125;<br></code></pre></td></tr></table></figure><p>Watcher 是一个 class，它定义了一些方法，其中和依赖收集相关的主要有 get、addDep 等。</p><p><strong>（3）过程</strong></p><p>在实例化 Vue 时，依赖收集的相关过程如下∶<br>初 始 化 状 态 initState ， 这 中 间 便 会 通 过 defineReactive 将数据变成响应式对象，其中的 getter 部分便是用来依赖收集的。<br>初始化最终会走 mount 过程，其中会实例化 Watcher ，进入 Watcher 中，便会执行 this.get() 方法，</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript">updateComponent = <span class="hljs-function">() =&gt;</span> &#123;<br>  vm.<span class="hljs-title function_">_update</span>(vm.<span class="hljs-title function_">_render</span>())<br>&#125;<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Watcher</span>(vm, updateComponent)<br></code></pre></td></tr></table></figure><p>get 方法中的 pushTarget 实际上就是把 Dep.target 赋值为当前的 watcher。</p><p>this.getter.call（vm，vm），这里的 getter 会执行 vm._render() 方法，在这个过程中便会触发数据对象的 getter。那么每个对象值的 getter 都持有一个 dep，在触发 getter 的时候会调用 dep.depend() 方法，也就会执行 Dep.target.addDep(this)。刚才 Dep.target 已经被赋值为 watcher，于是便会执行 addDep 方法，然后走到 dep.addSub() 方法，便将当前的 watcher 订阅到这个数据持有的 dep 的 subs 中，这个目的是为后续数据变化时候能通知到哪些 subs 做准备。所以在 vm._render() 过程中，会触发所有数据的 getter，这样便已经完成了一个依赖收集的过程。</p><h3 id="28-对-React-和-Vue-的理解，它们的异同"><a href="#28-对-React-和-Vue-的理解，它们的异同" class="headerlink" title="28. 对 React 和 Vue 的理解，它们的异同"></a>28. 对 React 和 Vue 的理解，它们的异同</h3><p><strong>相似之处：</strong></p><ul><li>都将注意力集中保持在核心库，而将其他功能如路由和全局状态管理交给相关的库；</li><li>都有自己的构建工具，能让你得到一个根据最佳实践设置的项目模板；</li><li>都使用了Virtual DOM（虚拟DOM）提高重绘性能；</li><li>都有props的概念，允许组件间的数据传递；</li><li>都鼓励组件化应用，将应用分拆成一个个功能明确的模块，提高复用性。</li></ul><p><strong>不同之处 ：</strong></p><p><strong>1）数据流</strong></p><p>Vue默认支持数据双向绑定，而React一直提倡单向数据流 </p><p><strong>2）虚拟DOM</strong></p><p>Vue2.x开始引入”Virtual DOM”，消除了和React在这方面的差异，但是在具体的细节还是有各自的特点。 </p><ul><li>Vue宣称可以更快地计算出Virtual DOM的差异，这是由于它在渲染过程中，会跟踪每一个组件的依赖关系，不需要重新渲染整个组件树。</li><li>对于React而言，每当应用的状态被改变时，全部子组件都会重新渲染。当然，这可以通过 PureComponent&#x2F;shouldComponentUpdate这个生命周期方法来进行控制，但Vue将此视为默认的优化。</li></ul><p><strong>3）组件化</strong></p><p>React与Vue最大的不同是模板的编写。</p><ul><li>Vue鼓励写近似常规HTML的模板。写起来很接近标准 HTML元素，只是多了一些属性。</li><li>React推荐你所有的模板通用JavaScript的语法扩展——JSX书写。</li></ul><p>具体来讲：React中render函数是支持闭包特性的，所以import的组件在render中可以直接调用。但是在Vue中，由于模板中使用的数据都必须挂在 this 上进行一次中转，所以 import 一个组件完了之后，还需要在 components 中再声明下。<br><strong>4）监听数据变化的实现原理不同</strong></p><ul><li>Vue 通过 getter&#x2F;setter 以及一些函数的劫持，能精确知道数据变化，不需要特别的优化就能达到很好的性能</li><li>React 默认是通过比较引用的方式进行的，如果不优化（PureComponent&#x2F;shouldComponentUpdate）可能导致大量不必要的vDOM的重新渲染。这是因为 Vue 使用的是可变数据，而React更强调数据的不可变。</li></ul><p><strong>5）高阶组件</strong></p><p>react可以通过高阶组件（HOC）来扩展，而Vue需要通过mixins来扩展。</p><p>高阶组件就是高阶函数，而React的组件本身就是纯粹的函数，所以高阶函数对React来说易如反掌。相反Vue.js使用HTML模板创建视图组件，这时模板无法有效的编译，因此Vue不能采用HOC来实现。</p><p><strong>6）构建工具</strong></p><p>两者都有自己的构建工具：</p><ul><li>React &#x3D;&#x3D;&gt; Create React APP</li><li>Vue &#x3D;&#x3D;&gt; vue-cli</li></ul><p><strong>7）跨平台</strong></p><ul><li>React &#x3D;&#x3D;&gt; React Native</li><li>Vue &#x3D;&#x3D;&gt; Weex</li></ul><h3 id="29-Vue的优点"><a href="#29-Vue的优点" class="headerlink" title="29. Vue的优点"></a>29. Vue的优点</h3><ul><li>轻量级框架：只关注视图层，是一个构建数据的视图集合，大小只有几十 <code>kb</code> ；</li><li>简单易学：国人开发，中文文档，不存在语言障碍 ，易于理解和学习；</li><li>双向数据绑定：保留了 <code>angular</code> 的特点，在数据操作方面更为简单；</li><li>组件化：保留了 <code>react</code> 的优点，实现了 <code>html</code> 的封装和重用，在构建单页面应用方面有着独特的优势；</li><li>视图，数据，结构分离：使数据的更改更为简单，不需要进行逻辑代码的修改，只需要操作数据就能完成相关操作；</li><li>虚拟DOM：<code>dom</code> 操作是非常耗费性能的，不再使用原生的 <code>dom</code> 操作节点，极大解放 <code>dom</code> 操作，但具体操作的还是 <code>dom</code> 不过是换了另一种方式；</li><li>运行速度更快：相比较于 <code>react</code> 而言，同样是操作虚拟 <code>dom</code>，就性能而言， <code>vue</code> 存在很大的优势。</li></ul><h3 id="30-assets和static的区别"><a href="#30-assets和static的区别" class="headerlink" title="30. assets和static的区别"></a>30. assets和static的区别</h3><p><strong>相同点：</strong> <code>assets</code> 和 <code>static</code> 两个都是存放静态资源文件。项目中所需要的资源文件图片，字体图标，样式文件等都可以放在这两个文件下，这是相同点</p><p><strong>不相同点：</strong><code>assets</code> 中存放的静态资源文件在项目打包时，也就是运行 <code>npm run build</code> 时会将 <code>assets</code> 中放置的静态资源文件进行打包上传，所谓打包简单点可以理解为压缩体积，代码格式化。而压缩后的静态资源文件最终也都会放置在 <code>static</code> 文件中跟着 <code>index.html</code> 一同上传至服务器。<code>static</code> 中放置的静态资源文件就不会要走打包压缩格式化等流程，而是直接进入打包好的目录，直接上传至服务器。因为避免了压缩直接进行上传，在打包时会提高一定的效率，但是 <code>static</code> 中的资源文件由于没有进行压缩等操作，所以文件的体积也就相对于 <code>assets</code> 中打包后的文件提交较大点。在服务器中就会占据更大的空间。</p><p><strong>建议：</strong> 将项目中 <code>template</code>需要的样式文件js文件等都可以放置在 <code>assets</code> 中，走打包这一流程。减少体积。而项目中引入的第三方的资源文件如<code>iconfoont.css</code> 等文件可以放置在 <code>static</code> 中，因为这些引入的第三方文件已经经过处理，不再需要处理，直接上传。</p><h3 id="31-delete和Vue-delete删除数组的区别"><a href="#31-delete和Vue-delete删除数组的区别" class="headerlink" title="31. delete和Vue.delete删除数组的区别"></a>31. delete和Vue.delete删除数组的区别</h3><ul><li><code>delete</code> 只是被删除的元素变成了 <code>empty/undefined</code> 其他的元素的键值还是不变。</li><li><code>Vue.delete</code> 直接删除了数组 改变了数组的键值。</li></ul><h3 id="32-vue如何监听对象或者数组某个属性的变化"><a href="#32-vue如何监听对象或者数组某个属性的变化" class="headerlink" title="32. vue如何监听对象或者数组某个属性的变化"></a>32. vue如何监听对象或者数组某个属性的变化</h3><p>当在项目中直接设置数组的某一项的值，或者直接设置对象的某个属性值，这个时候，你会发现页面并没有更新。这是因为Object.defineProperty()限制，监听不到变化。</p><p>解决方式：</p><ul><li>this.$set(你要改变的数组&#x2F;对象，你要改变的位置&#x2F;key，你要改成什么value)</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">this</span>.$set(<span class="hljs-variable language_">this</span>.<span class="hljs-property">arr</span>, <span class="hljs-number">0</span>, <span class="hljs-string">&quot;OBKoro1&quot;</span>); <span class="hljs-comment">// 改变数组this.$set(this.obj, &quot;c&quot;, &quot;OBKoro1&quot;); // 改变对象</span><br></code></pre></td></tr></table></figure><ul><li>调用以下几个数组的方法</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">splice</span>()、 <span class="hljs-title function_">push</span>()、<span class="hljs-title function_">pop</span>()、<span class="hljs-title function_">shift</span>()、<span class="hljs-title function_">unshift</span>()、<span class="hljs-title function_">sort</span>()、<span class="hljs-title function_">reverse</span>()<br></code></pre></td></tr></table></figure><p>vue源码里缓存了array的原型链，然后重写了这几个方法，触发这几个方法的时候会observer数据，意思是使用这些方法不用再进行额外的操作，视图自动进行更新。 推荐使用splice方法会比较好自定义,因为splice可以在数组的任何位置进行删除&#x2F;添加操作</p><p>vm.<code>$set</code> 的实现原理是：</p><ul><li>如果目标是数组，直接使用数组的 splice 方法触发相应式；</li><li>如果目标是对象，会先判读属性是否存在、对象是否是响应式，最终如果要对属性进行响应式处理，则是通过调用 defineReactive 方法进行响应式处理（ defineReactive 方法就是 Vue 在初始化对象时，给对象属性采用 Object.defineProperty 动态添加 getter 和 setter 的功能所调用的方法）</li></ul><h3 id="33-什么是-mixin-？"><a href="#33-什么是-mixin-？" class="headerlink" title="33. 什么是 mixin ？"></a>33. 什么是 mixin ？</h3><ul><li>Mixin 使我们能够为 Vue 组件编写可插拔和可重用的功能。</li><li>如果希望在多个组件之间重用一组组件选项，例如生命周期 hook、 方法等，则可以将其编写为 mixin，并在组件中简单的引用它。</li><li>然后将 mixin 的内容合并到组件中。如果你要在 mixin 中定义生命周期 hook，那么它在执行时将优化于组件自已的 hook。</li></ul><h3 id="34-Vue模版编译原理"><a href="#34-Vue模版编译原理" class="headerlink" title="34. Vue模版编译原理"></a>34. Vue模版编译原理</h3><p>vue中的模板template无法被浏览器解析并渲染，因为这不属于浏览器的标准，不是正确的HTML语法，所有需要将template转化成一个JavaScript函数，这样浏览器就可以执行这一个函数并渲染出对应的HTML元素，就可以让视图跑起来了，这一个转化的过程，就成为模板编译。模板编译又分三个阶段，解析parse，优化optimize，生成generate，最终生成可执行函数render。</p><ul><li><strong>解析阶段</strong>：使用大量的正则表达式对template字符串进行解析，将标签、指令、属性等转化为抽象语法树AST。</li><li><strong>优化阶段</strong>：遍历AST，找到其中的一些静态节点并进行标记，方便在页面重渲染的时候进行diff比较时，直接跳过这一些静态节点，优化runtime的性能。</li><li><strong>生成阶段</strong>：将最终的AST转化为render函数字符串。</li></ul><h3 id="35-对SSR的理解"><a href="#35-对SSR的理解" class="headerlink" title="35. 对SSR的理解"></a>35. 对SSR的理解</h3><p>SSR也就是服务端渲染，也就是将Vue在客户端把标签渲染成HTML的工作放在服务端完成，然后再把html直接返回给客户端</p><p>SSR的优势：</p><ul><li>更好的SEO</li><li>首屏加载速度更快</li></ul><p>SSR的缺点：</p><ul><li>开发条件会受到限制，服务器端渲染只支持beforeCreate和created两个钩子；</li><li>当需要一些外部扩展库时需要特殊处理，服务端渲染应用程序也需要处于Node.js的运行环境；</li><li>更多的服务端负载。</li></ul><h3 id="36-Vue的性能优化有哪些"><a href="#36-Vue的性能优化有哪些" class="headerlink" title="36. Vue的性能优化有哪些"></a>36. Vue的性能优化有哪些</h3><p><strong>（1）编码阶段</strong></p><ul><li>尽量减少data中的数据，data中的数据都会增加getter和setter，会收集对应的watcher</li><li>v-if和v-for不能连用</li><li>如果需要使用v-for给每项元素绑定事件时使用事件代理</li><li>SPA 页面采用keep-alive缓存组件</li><li>在更多的情况下，使用v-if替代v-show</li><li>key保证唯一</li><li>使用路由懒加载、异步组件</li><li>防抖、节流</li><li>第三方模块按需导入</li><li>长列表滚动到可视区域动态加载</li><li>图片懒加载</li></ul><p><strong>（2）SEO优化</strong></p><ul><li>预渲染</li><li>服务端渲染SSR</li></ul><p><strong>（3）打包优化</strong></p><ul><li>压缩代码</li><li>Tree Shaking&#x2F;Scope Hoisting</li><li>使用cdn加载第三方模块</li><li>多线程打包happypack</li><li>splitChunks抽离公共文件</li><li>sourceMap优化</li></ul><p><strong>（4）用户体验</strong></p><ul><li>骨架屏</li><li>PWA</li><li>还可以使用缓存(客户端缓存、服务端缓存)优化、服务端开启gzip压缩等。</li></ul><h3 id="37-对-SPA-单页面的理解，它的优缺点分别是什么？"><a href="#37-对-SPA-单页面的理解，它的优缺点分别是什么？" class="headerlink" title="37. 对 SPA 单页面的理解，它的优缺点分别是什么？"></a>37. 对 SPA 单页面的理解，它的优缺点分别是什么？</h3><p>SPA（ single-page application ）仅在 Web 页面初始化时加载相应的 HTML、JavaScript 和 CSS。一旦页面加载完成，SPA 不会因为用户的操作而进行页面的重新加载或跳转；取而代之的是利用路由机制实现 HTML 内容的变换，UI 与用户的交互，避免页面的重新加载。</p><p><strong>优点：</strong></p><ul><li>用户体验好、快，内容的改变不需要重新加载整个页面，避免了不必要的跳转和重复渲染；</li><li>基于上面一点，SPA 相对对服务器压力小；</li><li>前后端职责分离，架构清晰，前端进行交互逻辑，后端负责数据处理；</li></ul><p><strong>缺点：</strong></p><ul><li>初次加载耗时多：为实现单页 Web 应用功能及显示效果，需要在加载页面的时候将 JavaScript、CSS 统一加载，部分页面按需加载；</li><li>前进后退路由管理：由于单页应用在一个页面中显示所有的内容，所以不能使用浏览器的前进后退功能，所有的页面切换需要自己建立堆栈管理；</li><li>SEO 难度较大：由于所有的内容都在一个页面中动态替换显示，所以在 SEO 上其有着天然的弱势。</li></ul><h3 id="38-template和jsx的有什么分别？"><a href="#38-template和jsx的有什么分别？" class="headerlink" title="38. template和jsx的有什么分别？"></a>38. template和jsx的有什么分别？</h3><p>对于 runtime 来说，只需要保证组件存在 render 函数即可，而有了预编译之后，只需要保证构建过程中生成 render 函数就可以。在 webpack 中，使用<code>vue-loader</code>编译.vue文件，内部依赖的<code>vue-template-compiler</code>模块，在 webpack 构建过程中，将template预编译成 render 函数。与 react 类似，在添加了jsx的语法糖解析器<code>babel-plugin-transform-vue-jsx</code>之后，就可以直接手写render函数。</p><p>所以，template和jsx的都是render的一种表现形式，不同的是：JSX相对于template而言，具有更高的灵活性，在复杂的组件中，更具有优势，而 template 虽然显得有些呆滞。但是 template 在代码结构上更符合视图与逻辑分离的习惯，更简单、更直观、更好维护。</p><h3 id="39-vue初始化页面闪动问题"><a href="#39-vue初始化页面闪动问题" class="headerlink" title="39. vue初始化页面闪动问题"></a>39. vue初始化页面闪动问题</h3><p>使用vue开发时，在vue初始化之前，由于div是不归vue管的，所以我们写的代码在还没有解析的情况下会容易出现花屏现象，看到类似于的字样，虽然一般情况下这个时间很短暂，但是还是有必要让解决这个问题的。</p><p>首先：在css里加上以下代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">[v-cloak] &#123;    <span class="hljs-attr">display</span>: none;&#125;<br></code></pre></td></tr></table></figure><p>如果没有彻底解决问题，则在根元素加上<code>style=&quot;display: none;&quot; :style=&quot;&#123;display: &#39;block&#39;&#125;&quot;</code></p><h3 id="40-extend-有什么作用"><a href="#40-extend-有什么作用" class="headerlink" title="40. extend 有什么作用"></a>40. extend 有什么作用</h3><p>这个 API 很少用到，作用是扩展组件生成一个构造器，通常会与 <code>$mount</code> 一起使用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 创建组件构造器let Component = Vue.extend(&#123;  template: &#x27;&lt;div&gt;test&lt;/div&gt;&#x27;&#125;)// 挂载到 #app 上new Component().$mount(&#x27;#app&#x27;)// 除了上面的方式，还可以用来扩展已有的组件let SuperComponent = Vue.extend(Component)new SuperComponent(&#123;    created() &#123;        console.log(1)    &#125;&#125;)new SuperComponent().$mount(&#x27;#app&#x27;)</span><br></code></pre></td></tr></table></figure><h3 id="41-mixin-和-mixins-区别"><a href="#41-mixin-和-mixins-区别" class="headerlink" title="41. mixin 和 mixins 区别"></a>41. mixin 和 mixins 区别</h3><p><code>mixin</code> 用于全局混入，会影响到每个组件实例，通常插件都是这样做初始化的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">mixin</span>(&#123;    <span class="hljs-title function_">beforeCreate</span>(<span class="hljs-params"></span>) &#123;        <span class="hljs-comment">// ...逻辑        // 这种方式会影响到每个组件的 beforeCreate 钩子函数    &#125;&#125;)</span><br></code></pre></td></tr></table></figure><p>虽然文档不建议在应用中直接使用 <code>mixin</code>，但是如果不滥用的话也是很有帮助的，比如可以全局混入封装好的 <code>ajax</code> 或者一些工具函数等等。</p><p><code>mixins</code> 应该是最常使用的扩展组件的方式了。如果多个组件中有相同的业务逻辑，就可以将这些逻辑剥离出来，通过 <code>mixins</code> 混入代码，比如上拉下拉加载数据这种逻辑等等。<br>另外需要注意的是 <code>mixins</code> 混入的钩子函数会先于组件内的钩子函数执行，并且在遇到同名选项的时候也会有选择性的进行合并。</p><h3 id="42-MVVM的优缺点"><a href="#42-MVVM的优缺点" class="headerlink" title="42. MVVM的优缺点?"></a>42. <strong>MVVM</strong>的优缺点?</h3><p>优点: </p><ul><li>分离视图（View）和模型（Model），降低代码耦合，提⾼视图或者逻辑的重⽤性: ⽐如视图（View）可以独⽴于Model变化和修改，⼀个ViewModel可以绑定不同的”View”上，当View变化的时候Model不可以不变，当Model变化的时候View也可以不变。你可以把⼀些视图逻辑放在⼀个ViewModel⾥⾯，让很多view重⽤这段视图逻辑 </li><li>提⾼可测试性: ViewModel的存在可以帮助开发者更好地编写测试代码 </li><li>⾃动更新dom: 利⽤双向绑定,数据更新后视图⾃动更新,让开发者从繁琐的⼿动dom中解放</li></ul><p>缺点: </p><ul><li>Bug很难被调试: 因为使⽤双向绑定的模式，当你看到界⾯异常了，有可能是你View的代码有Bug，也可能是Model的代码有问题。数据绑定使得⼀个位置的Bug被快速传递到别的位置，要定位原始出问题的地⽅就变得不那么容易了。另外，数据绑定的声明是指令式地写在View的模版当中的，这些内容是没办法去打断点debug的 </li><li>⼀个⼤的模块中model也会很⼤，虽然使⽤⽅便了也很容易保证了数据的⼀致性，当时⻓期持有，不释放内存就造成了花费更多的内存 </li><li>对于⼤型的图形应⽤程序，视图状态较多，ViewModel的构建和维护的成本都会⽐较⾼。</li></ul><h2 id="二、生命周期"><a href="#二、生命周期" class="headerlink" title="二、生命周期"></a>二、生命周期</h2><h3 id="1-说一下Vue的生命周期"><a href="#1-说一下Vue的生命周期" class="headerlink" title="1. 说一下Vue的生命周期"></a>1. 说一下Vue的生命周期</h3><p>Vue 实例有⼀个完整的⽣命周期，也就是从开始创建、初始化数据、编译模版、挂载Dom -&gt; 渲染、更新 -&gt; 渲染、卸载 等⼀系列过程，称这是Vue的⽣命周期。 </p><ol><li><strong>beforeCreate（创建前）</strong>：数据观测和初始化事件还未开始，此时 data 的响应式追踪、event&#x2F;watcher 都还没有被设置，也就是说不能访问到data、computed、watch、methods上的方法和数据。</li><li><strong>created（创建后）</strong> ：实例创建完成，实例上配置的 options 包括 data、computed、watch、methods 等都配置完成，但是此时渲染得节点还未挂载到 DOM，所以不能访问到 <code>$el</code> 属性。</li><li><strong>beforeMount（挂载前）</strong>：在挂载开始之前被调用，相关的render函数首次被调用。实例已完成以下的配置：编译模板，把data里面的数据和模板生成html。此时还没有挂载html到页面上。</li><li><strong>mounted（挂载后）</strong>：在el被新创建的 vm.$el 替换，并挂载到实例上去之后调用。实例已完成以下的配置：用上面编译好的html内容替换el属性指向的DOM对象。完成模板中的html渲染到html 页面中。此过程中进行ajax交互。</li><li><strong>beforeUpdate（更新前）</strong>：响应式数据更新时调用，此时虽然响应式数据更新了，但是对应的真实 DOM 还没有被渲染。</li><li><strong>updated（更新后）</strong> ：在由于数据更改导致的虚拟DOM重新渲染和打补丁之后调用。此时 DOM 已经根据响应式数据的变化更新了。调用时，组件 DOM已经更新，所以可以执行依赖于DOM的操作。然而在大多数情况下，应该避免在此期间更改状态，因为这可能会导致更新无限循环。该钩子在服务器端渲染期间不被调用。</li><li><strong>beforeDestroy（销毁前）</strong>：实例销毁之前调用。这一步，实例仍然完全可用，<code>this</code> 仍能获取到实例。</li><li><strong>destroyed（销毁后）</strong>：实例销毁后调用，调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。该钩子在服务端渲染期间不被调用。</li></ol><p>另外还有 <code>keep-alive</code> 独有的生命周期，分别为 <code>activated</code> 和 <code>deactivated</code> 。用 <code>keep-alive</code> 包裹的组件在切换时不会进行销毁，而是缓存到内存中并执行 <code>deactivated</code> 钩子函数，命中缓存渲染后会执行 <code>activated</code> 钩子函数。</p><h3 id="2-Vue-子组件和父组件执行顺序"><a href="#2-Vue-子组件和父组件执行顺序" class="headerlink" title="2. Vue 子组件和父组件执行顺序"></a>2. Vue 子组件和父组件执行顺序</h3><p><strong>加载渲染过程：</strong></p><ol><li>父组件 beforeCreate</li><li>父组件 created</li><li>父组件 beforeMount</li><li>子组件 beforeCreate</li><li>子组件 created</li><li>子组件 beforeMount</li><li>子组件 mounted</li><li>父组件 mounted</li></ol><p><strong>更新过程：</strong></p><pre><code class="hljs">  1. 父组件 beforeUpdate  2. 子组件 beforeUpdate  3. 子组件 updated  4. 父组件 updated</code></pre><p><strong>销毁过程：</strong></p><pre><code class="hljs">  1. 父组件 beforeDestroy  2. 子组件 beforeDestroy  3. 子组件 destroyed  4. 父组件 destoryed</code></pre><h3 id="3-created和mounted的区别"><a href="#3-created和mounted的区别" class="headerlink" title="3. created和mounted的区别"></a>3. created和mounted的区别</h3><ul><li>created:在模板渲染成html前调用，即通常初始化某些属性值，然后再渲染成视图。</li><li>mounted:在模板渲染成html后调用，通常是初始化页面完成后，再对html的dom节点进行一些需要的操作。</li></ul><h3 id="4-一般在哪个生命周期请求异步数据"><a href="#4-一般在哪个生命周期请求异步数据" class="headerlink" title="4. 一般在哪个生命周期请求异步数据"></a>4. 一般在哪个生命周期请求异步数据</h3><p>我们可以在钩子函数 created、beforeMount、mounted 中进行调用，因为在这三个钩子函数中，data 已经创建，可以将服务端端返回的数据进行赋值。<br>​</p><p>推荐在 created 钩子函数中调用异步请求，因为在 created 钩子函数中调用异步请求有以下优点：</p><ul><li>能更快获取到服务端数据，减少页面加载时间，用户体验更好；</li><li>SSR不支持 beforeMount 、mounted 钩子函数，放在 created 中有助于一致性。</li></ul><h3 id="5-keep-alive-中的生命周期哪些"><a href="#5-keep-alive-中的生命周期哪些" class="headerlink" title="5. keep-alive 中的生命周期哪些"></a>5. keep-alive 中的生命周期哪些</h3><p>keep-alive是 Vue 提供的一个内置组件，用来对组件进行缓存——在组件切换过程中将状态保留在内存中，防止重复渲染DOM。</p><p>如果为一个组件包裹了 keep-alive，那么它会多出两个生命周期：deactivated、activated。同时，beforeDestroy 和 destroyed 就不会再被触发了，因为组件不会被真正销毁。</p><p>当组件被换掉时，会被缓存到内存中、触发 deactivated 生命周期；当组件被切回来时，再去缓存里找这个组件、触发 activated钩子函数。</p><h2 id="三、组件通信"><a href="#三、组件通信" class="headerlink" title="三、组件通信"></a>三、组件通信</h2><p>组件通信的方式如下：</p><h3 id="（1）-props-x2F-emit"><a href="#（1）-props-x2F-emit" class="headerlink" title="（1） props  &#x2F;   $emit"></a>（1） props  &#x2F;   $emit</h3><p>父组件通过<code>props</code>向子组件传递数据，子组件通过<code>$emit</code>和父组件通信</p><h5 id="1-父组件向子组件传值"><a href="#1-父组件向子组件传值" class="headerlink" title="1. 父组件向子组件传值"></a>1. 父组件向子组件传值</h5><ul><li><code>props</code>只能是父组件向子组件进行传值，<code>props</code>使得父子组件之间形成了一个单向下行绑定。子组件的数据会随着父组件不断更新。</li><li><code>props</code> 可以显示定义一个或一个以上的数据，对于接收的数据，可以是各种数据类型，同样也可以传递一个函数。</li><li><code>props</code>属性名规则：若在<code>props</code>中使用驼峰形式，模板中需要使用短横线的形式</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 父组件</span><br>&lt;template&gt;<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;father&quot;</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">son</span> <span class="hljs-attr">:msg</span>=<span class="hljs-string">&quot;msgData&quot;</span> <span class="hljs-attr">:fn</span>=<span class="hljs-string">&quot;myFunction&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">son</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>&lt;/template&gt;<br><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">import</span> son <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./son.vue&quot;</span>;</span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-attr">name</span>: father,</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-attr">msgData</span>: <span class="hljs-string">&quot;父组件数据&quot;</span>;</span></span><br><span class="language-javascript"><span class="language-xml">    &#125;,</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-attr">methods</span>: &#123;</span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-title function_">myFunction</span>(<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;vue&quot;</span>);</span></span><br><span class="language-javascript"><span class="language-xml">        &#125;</span></span><br><span class="language-javascript"><span class="language-xml">    &#125;,</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-attr">components</span>: &#123;</span></span><br><span class="language-javascript"><span class="language-xml">        son</span></span><br><span class="language-javascript"><span class="language-xml">    &#125;</span></span><br><span class="language-javascript"><span class="language-xml">&#125;;</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 子组件</span><br>&lt;template&gt;<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;son&quot;</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>&#123;&#123;msg&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;fn&quot;</span>&gt;</span>按钮<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>&lt;/template&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;son&quot;</span>,</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-attr">props</span>: [<span class="hljs-string">&quot;msg&quot;</span>, <span class="hljs-string">&quot;fn&quot;</span>]</span></span><br><span class="language-javascript"><span class="language-xml">&#125;;</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h5 id="2-子组件向父组件传值"><a href="#2-子组件向父组件传值" class="headerlink" title="2. 子组件向父组件传值"></a>2. 子组件向父组件传值</h5><ul><li><code>$emit</code>绑定一个自定义事件，当这个事件被执行的时就会将参数传递给父组件，而父组件通过<code>v-on</code>监听并接收参数。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 父组件</span><br>&lt;template&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;section&quot;</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">com-article</span> <span class="hljs-attr">:articles</span>=<span class="hljs-string">&quot;articleList&quot;</span> @<span class="hljs-attr">onEmitIndex</span>=<span class="hljs-string">&quot;onEmitIndex&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">com-article</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>&#123;&#123;currentIndex&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>&lt;/template&gt;<br><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">import</span> comArticle <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./test/article.vue&#x27;</span></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;comArticle&#x27;</span>,</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-attr">components</span>: &#123; comArticle &#125;,</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">return</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-attr">currentIndex</span>: -<span class="hljs-number">1</span>,</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-attr">articleList</span>: [<span class="hljs-string">&#x27;红楼梦&#x27;</span>, <span class="hljs-string">&#x27;西游记&#x27;</span>, <span class="hljs-string">&#x27;三国演义&#x27;</span>]</span></span><br><span class="language-javascript"><span class="language-xml">    &#125;</span></span><br><span class="language-javascript"><span class="language-xml">  &#125;,</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-attr">methods</span>: &#123;</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-title function_">onEmitIndex</span>(<span class="hljs-params">idx</span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-variable language_">this</span>.<span class="hljs-property">currentIndex</span> = idx</span></span><br><span class="language-javascript"><span class="language-xml">    &#125;</span></span><br><span class="language-javascript"><span class="language-xml">  &#125;</span></span><br><span class="language-javascript"><span class="language-xml">&#125;</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//子组件</span><br>&lt;template&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;(item, index) in articles&quot;</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">&quot;index&quot;</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;emitIndex(index)&quot;</span>&gt;</span>&#123;&#123;item&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>&lt;/template&gt;<br><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-attr">props</span>: [<span class="hljs-string">&#x27;articles&#x27;</span>],</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-attr">methods</span>: &#123;</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-title function_">emitIndex</span>(<span class="hljs-params">index</span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-variable language_">this</span>.$emit(<span class="hljs-string">&#x27;onEmitIndex&#x27;</span>, index) <span class="hljs-comment">// 触发父组件的方法，并传递参数index</span></span></span><br><span class="language-javascript"><span class="language-xml">    &#125;</span></span><br><span class="language-javascript"><span class="language-xml">  &#125;</span></span><br><span class="language-javascript"><span class="language-xml">&#125;</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h3 id="（2）eventBus事件总线（-emit-on）"><a href="#（2）eventBus事件总线（-emit-on）" class="headerlink" title="（2）eventBus事件总线（$emit / $on）"></a>（2）eventBus事件总线（<code>$emit / $on</code>）</h3><p><code>eventBus</code>事件总线适用于<strong>父子组件</strong>、<strong>非父子组件</strong>等之间的通信，使用步骤如下：<br><strong>（1）创建事件中心管理组件之间的通信</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// event-bus.js</span><br><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">Vue</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">EventBus</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>()<br></code></pre></td></tr></table></figure><p><strong>（2）发送事件</strong><br>假设有两个兄弟组件<code>firstCom</code>和<code>secondCom</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;template&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">first-com</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">first-com</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">second-com</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">second-com</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>&lt;/template&gt;<br><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">import</span> firstCom <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./firstCom.vue&#x27;</span></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">import</span> secondCom <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./secondCom.vue&#x27;</span></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-attr">components</span>: &#123; firstCom, secondCom &#125;</span></span><br><span class="language-javascript"><span class="language-xml">&#125;</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>在<code>firstCom</code>组件中发送事件：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;template&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;add&quot;</span>&gt;</span>加法<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>    </span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>&lt;/template&gt;<br><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">import</span> &#123;<span class="hljs-title class_">EventBus</span>&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./event-bus.js&#x27;</span> <span class="hljs-comment">// 引入事件中心</span></span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>)&#123;</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">return</span>&#123;</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-attr">num</span>:<span class="hljs-number">0</span></span></span><br><span class="language-javascript"><span class="language-xml">    &#125;</span></span><br><span class="language-javascript"><span class="language-xml">  &#125;,</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-attr">methods</span>:&#123;</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-title function_">add</span>(<span class="hljs-params"></span>)&#123;</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-title class_">EventBus</span>.$emit(<span class="hljs-string">&#x27;addition&#x27;</span>, &#123;</span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-attr">num</span>:<span class="hljs-variable language_">this</span>.<span class="hljs-property">num</span>++</span></span><br><span class="language-javascript"><span class="language-xml">      &#125;)</span></span><br><span class="language-javascript"><span class="language-xml">    &#125;</span></span><br><span class="language-javascript"><span class="language-xml">  &#125;</span></span><br><span class="language-javascript"><span class="language-xml">&#125;</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p><strong>（3）接收事件</strong><br>在<code>secondCom</code>组件中发送事件：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;template&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>求和: &#123;&#123;count&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>&lt;/template&gt;<br><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">EventBus</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./event-bus.js&#x27;</span></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">return</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-attr">count</span>: <span class="hljs-number">0</span></span></span><br><span class="language-javascript"><span class="language-xml">    &#125;</span></span><br><span class="language-javascript"><span class="language-xml">  &#125;,</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-title function_">mounted</span>(<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-title class_">EventBus</span>.$on(<span class="hljs-string">&#x27;addition&#x27;</span>, <span class="hljs-function"><span class="hljs-params">param</span> =&gt;</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span> + param.<span class="hljs-property">num</span>;</span></span><br><span class="language-javascript"><span class="language-xml">    &#125;)</span></span><br><span class="language-javascript"><span class="language-xml">  &#125;</span></span><br><span class="language-javascript"><span class="language-xml">&#125;</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>在上述代码中，这就相当于将<code>num</code>值存贮在了事件总线中，在其他组件中可以直接访问。事件总线就相当于一个桥梁，不用组件通过它来通信。</p><p>虽然看起来比较简单，但是这种方法也有不变之处，如果项目过大，使用这种方式进行通信，后期维护起来会很困难。</p><h3 id="（3）依赖注入（provide-x2F-inject）"><a href="#（3）依赖注入（provide-x2F-inject）" class="headerlink" title="（3）依赖注入（provide &#x2F; inject）"></a>（3）依赖注入（provide &#x2F; inject）</h3><p>这种方式就是Vue中的<strong>依赖注入</strong>，该方法用于<strong>父子组件之间的通信</strong>。当然这里所说的父子不一定是真正的父子，也可以是祖孙组件，在层数很深的情况下，可以使用这种方法来进行传值。就不用一层一层的传递了。</p><p><code>provide / inject</code>是Vue提供的两个钩子，和<code>data</code>、<code>methods</code>是同级的。并且<code>provide</code>的书写形式和<code>data</code>一样。</p><ul><li><code>provide</code> 钩子用来发送数据或方法</li><li><code>inject</code>钩子用来接收数据或方法</li></ul><p>在父组件中：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">provide</span>(<span class="hljs-params"></span>) &#123; <br>    <span class="hljs-keyword">return</span> &#123;     <br>        <span class="hljs-attr">num</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">num</span>  <br>    &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>在子组件中：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-attr">inject</span>: [<span class="hljs-string">&#x27;num&#x27;</span>]<br></code></pre></td></tr></table></figure><p>还可以这样写，这样写就可以访问父组件中的所有属性：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">provide</span>(<span class="hljs-params"></span>) &#123;<br> <span class="hljs-keyword">return</span> &#123;<br>    <span class="hljs-attr">app</span>: <span class="hljs-variable language_">this</span><br>  &#125;;<br>&#125;<br><span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;<br> <span class="hljs-keyword">return</span> &#123;<br>    <span class="hljs-attr">num</span>: <span class="hljs-number">1</span><br>  &#125;;<br>&#125;<br><br><span class="hljs-attr">inject</span>: [<span class="hljs-string">&#x27;app&#x27;</span>]<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">app</span>.<span class="hljs-property">num</span>)<br></code></pre></td></tr></table></figure><p><strong>注意：</strong> 依赖注入所提供的属性是<strong>非响应式</strong>的。</p><h3 id="（3）ref-x2F-refs"><a href="#（3）ref-x2F-refs" class="headerlink" title="（3）ref &#x2F; $refs"></a>（3）ref &#x2F; $refs</h3><p>这种方式也是实现<strong>父子组件</strong>之间的通信。</p><p><code>ref</code>： 这个属性用在子组件上，它的引用就指向了子组件的实例。可以通过实例来访问组件的数据和方法。</p><p>在子组件中：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  data () &#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>      <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;JavaScript&#x27;</span><br>    &#125;<br>  &#125;,<br>  <span class="hljs-attr">methods</span>: &#123;<br>    sayHello () &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;hello&#x27;</span>)<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在父组件中：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;template&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">child</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;child&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">component-a</span>&gt;</span></span><br>&lt;/template&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-keyword">import</span> child <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./child.vue&#x27;</span></span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-attr">components</span>: &#123; child &#125;,</span></span><br><span class="language-javascript"><span class="language-xml">    mounted () &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">$refs</span>.<span class="hljs-property">child</span>.<span class="hljs-property">name</span>);  <span class="hljs-comment">// JavaScript</span></span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-variable language_">this</span>.<span class="hljs-property">$refs</span>.<span class="hljs-property">child</span>.<span class="hljs-title function_">sayHello</span>();  <span class="hljs-comment">// hello</span></span></span><br><span class="language-javascript"><span class="language-xml">    &#125;</span></span><br><span class="language-javascript"><span class="language-xml">  &#125;</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h3 id="（4）-parent-children"><a href="#（4）-parent-children" class="headerlink" title="（4）$parent / $children"></a>（4）<code>$parent / $children</code></h3><ul><li>使用<code>$parent</code>可以让组件访问父组件的实例（访问的是上一级父组件的属性和方法）</li><li>使用<code>$children</code>可以让组件访问子组件的实例，但是，<code>$children</code>并不能保证顺序，并且访问的数据也不是响应式的。</li></ul><p>在子组件中：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;template&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>&#123;&#123;message&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>获取父组件的值为:  &#123;&#123;parentVal&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>&lt;/template&gt;<br><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">return</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;Vue&#x27;</span></span></span><br><span class="language-javascript"><span class="language-xml">    &#125;</span></span><br><span class="language-javascript"><span class="language-xml">  &#125;,</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-attr">computed</span>:&#123;</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-title function_">parentVal</span>(<span class="hljs-params"></span>)&#123;</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">$parent</span>.<span class="hljs-property">msg</span>;</span></span><br><span class="language-javascript"><span class="language-xml">    &#125;</span></span><br><span class="language-javascript"><span class="language-xml">  &#125;</span></span><br><span class="language-javascript"><span class="language-xml">&#125;</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>在父组件中：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 父组件中</span><br>&lt;template&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;hello_world&quot;</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>&#123;&#123;msg&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">child</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">child</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;change&quot;</span>&gt;</span>点击改变子组件值<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>&lt;/template&gt;<br><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">import</span> child <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./child.vue&#x27;</span></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-attr">components</span>: &#123; child &#125;,</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">return</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-attr">msg</span>: <span class="hljs-string">&#x27;Welcome&#x27;</span></span></span><br><span class="language-javascript"><span class="language-xml">    &#125;</span></span><br><span class="language-javascript"><span class="language-xml">  &#125;,</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-attr">methods</span>: &#123;</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-title function_">change</span>(<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-comment">// 获取到子组件</span></span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-variable language_">this</span>.<span class="hljs-property">$children</span>[<span class="hljs-number">0</span>].<span class="hljs-property">message</span> = <span class="hljs-string">&#x27;JavaScript&#x27;</span></span></span><br><span class="language-javascript"><span class="language-xml">    &#125;</span></span><br><span class="language-javascript"><span class="language-xml">  &#125;</span></span><br><span class="language-javascript"><span class="language-xml">&#125;</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>在上面的代码中，子组件获取到了父组件的<code>parentVal</code>值，父组件改变了子组件中<code>message</code>的值。<br><strong>需要注意：</strong></p><ul><li>通过<code>$parent</code>访问到的是上一级父组件的实例，可以使用<code>$root</code>来访问根组件的实例</li><li>在组件中使用<code>$children</code>拿到的是所有的子组件的实例，它是一个数组，并且是无序的</li><li>在根组件<code>#app</code>上拿<code>$parent</code>得到的是<code>new Vue()</code>的实例，在这实例上再拿<code>$parent</code>得到的是<code>undefined</code>，而在最底层的子组件拿<code>$children</code>是个空数组</li><li><code>$children</code> 的值是<strong>数组</strong>，而<code>$parent</code>是个<strong>对象</strong></li></ul><h3 id="（5）-attrs-listeners"><a href="#（5）-attrs-listeners" class="headerlink" title="（5）$attrs / $listeners"></a>（5）<code>$attrs / $listeners</code></h3><p>考虑一种场景，如果A是B组件的父组件，B是C组件的父组件。如果想要组件A给组件C传递数据，这种隔代的数据，该使用哪种方式呢？</p><p>如果是用<code>props/$emit</code>来一级一级的传递，确实可以完成，但是比较复杂；如果使用事件总线，在多人开发或者项目较大的时候，维护起来很麻烦；如果使用Vuex，的确也可以，但是如果仅仅是传递数据，那可能就有点浪费了。</p><p>针对上述情况，Vue引入了<code>$attrs / $listeners</code>，实现组件之间的跨代通信。</p><p>先来看一下<code>inheritAttrs</code>，它的默认值true，继承所有的父组件属性除<code>props</code>之外的所有属性；<code>inheritAttrs：false</code> 只继承class属性 。</p><ul><li><code>$attrs</code>：继承所有的父组件属性（除了prop传递的属性、class 和 style ），一般用在子组件的子元素上</li><li><code>$listeners</code>：该属性是一个对象，里面包含了作用在这个组件上的所有监听器，可以配合 <code>v-on=&quot;$listeners&quot;</code> 将所有的事件监听器指向这个组件的某个特定的子元素。（相当于子组件继承父组件的事件）</li></ul><p>A组件（<code>APP.vue</code>）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;template&gt;<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span></span><br><span class="language-xml">        //此处监听了两个事件，可以在B组件或者C组件中直接触发 </span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">child1</span> <span class="hljs-attr">:p-child1</span>=<span class="hljs-string">&quot;child1&quot;</span> <span class="hljs-attr">:p-child2</span>=<span class="hljs-string">&quot;child2&quot;</span> @<span class="hljs-attr">test1</span>=<span class="hljs-string">&quot;onTest1&quot;</span> @<span class="hljs-attr">test2</span>=<span class="hljs-string">&quot;onTest2&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">child1</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>&lt;/template&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Child1</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./Child1.vue&#x27;</span>;</span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-attr">components</span>: &#123; <span class="hljs-title class_">Child1</span> &#125;,</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-attr">methods</span>: &#123;</span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-title function_">onTest1</span>(<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;test1 running&#x27;</span>);</span></span><br><span class="language-javascript"><span class="language-xml">        &#125;,</span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-title function_">onTest2</span>(<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;test2 running&#x27;</span>);</span></span><br><span class="language-javascript"><span class="language-xml">        &#125;</span></span><br><span class="language-javascript"><span class="language-xml">    &#125;</span></span><br><span class="language-javascript"><span class="language-xml">&#125;;</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>B组件（<code>Child1.vue</code>）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;template&gt;<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;child-1&quot;</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>props: &#123;&#123;pChild1&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>$attrs: &#123;&#123;$attrs&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">child2</span> <span class="hljs-attr">v-bind</span>=<span class="hljs-string">&quot;$attrs&quot;</span> <span class="hljs-attr">v-on</span>=<span class="hljs-string">&quot;$listeners&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">child2</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>&lt;/template&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Child2</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./Child2.vue&#x27;</span>;</span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-attr">props</span>: [<span class="hljs-string">&#x27;pChild1&#x27;</span>],</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-attr">components</span>: &#123; <span class="hljs-title class_">Child2</span> &#125;,</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-attr">inheritAttrs</span>: <span class="hljs-literal">false</span>,</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-title function_">mounted</span>(<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-variable language_">this</span>.$emit(<span class="hljs-string">&#x27;test1&#x27;</span>); <span class="hljs-comment">// 触发APP.vue中的test1方法</span></span></span><br><span class="language-javascript"><span class="language-xml">    &#125;</span></span><br><span class="language-javascript"><span class="language-xml">&#125;;</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>C 组件 (<code>Child2.vue</code>)：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;template&gt;<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;child-2&quot;</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>props: &#123;&#123;pChild2&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>$attrs: &#123;&#123;$attrs&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>&lt;/template&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-attr">props</span>: [<span class="hljs-string">&#x27;pChild2&#x27;</span>],</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-attr">inheritAttrs</span>: <span class="hljs-literal">false</span>,</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-title function_">mounted</span>(<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-variable language_">this</span>.$emit(<span class="hljs-string">&#x27;test2&#x27;</span>);<span class="hljs-comment">// 触发APP.vue中的test2方法</span></span></span><br><span class="language-javascript"><span class="language-xml">    &#125;</span></span><br><span class="language-javascript"><span class="language-xml">&#125;;</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>在上述代码中：</p><ul><li>C组件中能直接触发test的原因在于 B组件调用C组件时 使用 v-on 绑定了<code>$listeners</code> 属性</li><li>在B组件中通过v-bind 绑定<code>$attrs</code>属性，C组件可以直接获取到A组件中传递下来的props（除了B组件中props声明的）</li></ul><h3 id="（6）总结"><a href="#（6）总结" class="headerlink" title="（6）总结"></a>（6）总结</h3><p><strong>（1）父子组件间通信</strong></p><ul><li>子组件通过 props 属性来接受父组件的数据，然后父组件在子组件上注册监听事件，子组件通过 emit 触发事件来向父组件发送数据。</li><li>通过 ref 属性给子组件设置一个名字。父组件通过 <code>$refs</code> 组件名来获得子组件，子组件通过 <code>$parent</code> 获得父组件，这样也可以实现通信。</li><li>使用 provide&#x2F;inject，在父组件中通过 provide提供变量，在子组件中通过 inject 来将变量注入到组件中。不论子组件有多深，只要调用了 inject 那么就可以注入 provide中的数据。</li></ul><p><strong>（2）兄弟组件间通信</strong></p><ul><li>使用 eventBus 的方法，它的本质是通过创建一个空的 Vue 实例来作为消息传递的对象，通信的组件引入这个实例，通信的组件通过在这个实例上监听和触发事件，来实现消息的传递。</li><li>通过 <code>$parent/$refs</code> 来获取到兄弟组件，也可以进行通信。</li></ul><p><strong>（3）任意组件之间</strong></p><ul><li>使用 eventBus ，其实就是创建一个事件中心，相当于中转站，可以用它来传递事件和接收事件。</li></ul><p>如果业务逻辑复杂，很多组件之间需要同时处理一些公共的数据，这个时候采用上面这一些方法可能不利于项目的维护。这个时候可以使用 vuex ，vuex 的思想就是将这一些公共的数据抽离出来，将它作为一个全局的变量来管理，然后其他组件就可以对这个公共数据进行读写操作，这样达到了解耦的目的。</p>]]></content>
    
    
    <categories>
      
      <category>BGW</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>BGW-JavaScript1</title>
    <link href="/2023/04/18/BGW-JavaScript1/"/>
    <url>/2023/04/18/BGW-JavaScript1/</url>
    
    <content type="html"><![CDATA[<p>BGW-JavaScript1</p><p><img src="1.png" alt="img"></p><h2 id="一、数据类型"><a href="#一、数据类型" class="headerlink" title="一、数据类型"></a>一、数据类型</h2><h3 id="1-JavaScript有哪些数据类型，它们的区别？"><a href="#1-JavaScript有哪些数据类型，它们的区别？" class="headerlink" title="1. JavaScript有哪些数据类型，它们的区别？"></a>1. JavaScript有哪些数据类型，它们的区别？</h3><p>JavaScript共有八种数据类型，分别是 Undefined、Null、Boolean、Number、String、Object、Symbol、BigInt。</p><p>其中 Symbol 和 BigInt 是ES6 中新增的数据类型：</p><ul><li>Symbol 代表创建后独一无二且不可变的数据类型，它主要是为了解决可能出现的全局变量冲突的问题。</li><li>BigInt 是一种数字类型的数据，它可以表示任意精度格式的整数，使用 BigInt 可以安全地存储和操作大整数，即使这个数已经超出了 Number 能够表示的安全整数范围。</li></ul><p>这些数据可以分为原始数据类型和引用数据类型：</p><ul><li>栈：原始数据类型（Undefined、Null、Boolean、Number、String）</li><li>堆：引用数据类型（对象、数组和函数）</li></ul><p>两种类型的区别在于<strong>存储位置的不同：</strong></p><ul><li>原始数据类型直接存储在栈（stack）中的简单数据段，占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储；</li><li>引用数据类型存储在堆（heap）中的对象，占据空间大、大小不固定。如果存储在栈中，将会影响程序运行的性能；引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体。</li></ul><p>堆和栈的概念存在于数据结构和操作系统内存中，在数据结构中：</p><ul><li>在数据结构中，栈中数据的存取方式为先进后出。</li><li>堆是一个优先队列，是按优先级来进行排序的，优先级可以按照大小来规定。</li></ul><p>在操作系统中，内存被分为栈区和堆区：</p><ul><li>栈区内存由编译器自动分配释放，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。 </li><li>堆区内存一般由开发着分配释放，若开发者不释放，程序结束时可能由垃圾回收机制回收。</li></ul><h3 id="2-数据类型检测的方式有哪些"><a href="#2-数据类型检测的方式有哪些" class="headerlink" title="2. 数据类型检测的方式有哪些"></a>2. 数据类型检测的方式有哪些</h3><p><strong>（1）typeof</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> <span class="hljs-number">2</span>);               <span class="hljs-comment">// number</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> <span class="hljs-literal">true</span>);            <span class="hljs-comment">// boolean</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> <span class="hljs-string">&#x27;str&#x27;</span>);           <span class="hljs-comment">// string</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> []);              <span class="hljs-comment">// object    </span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;&#125;);    <span class="hljs-comment">// function</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> &#123;&#125;);              <span class="hljs-comment">// object</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> <span class="hljs-literal">undefined</span>);       <span class="hljs-comment">// undefined</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> <span class="hljs-literal">null</span>);            <span class="hljs-comment">// object</span><br></code></pre></td></tr></table></figure><p>其中数组、对象、null都会被判断为object，其他判断都正确。</p><p><strong>（2）instanceof</strong></p><p><code>instanceof</code>可以正确判断对象的类型，<strong>其内部运行机制是判断在其原型链中能否找到该类型的原型</strong>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">2</span> <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Number</span>);                    <span class="hljs-comment">// false</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-literal">true</span> <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Boolean</span>);                <span class="hljs-comment">// false </span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;str&#x27;</span> <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">String</span>);                <span class="hljs-comment">// false </span><br> <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>([] <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Array</span>);                    <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;&#125; <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Function</span>);       <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(&#123;&#125; <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Object</span>);                   <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>可以看到，<code>instanceof</code><strong>只能正确判断引用数据类型</strong>，而不能判断基本数据类型。<code>instanceof</code> 运算符可以用来测试一个对象在其原型链中是否存在一个构造函数的 <code>prototype</code> 属性。</p><p><strong>（3） constructor</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>((<span class="hljs-number">2</span>).<span class="hljs-property">constructor</span> === <span class="hljs-title class_">Number</span>); <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>((<span class="hljs-literal">true</span>).<span class="hljs-property">constructor</span> === <span class="hljs-title class_">Boolean</span>); <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>((<span class="hljs-string">&#x27;str&#x27;</span>).<span class="hljs-property">constructor</span> === <span class="hljs-title class_">String</span>); <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(([]).<span class="hljs-property">constructor</span> === <span class="hljs-title class_">Array</span>); <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>((<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;&#125;).<span class="hljs-property">constructor</span> === <span class="hljs-title class_">Function</span>); <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>((&#123;&#125;).<span class="hljs-property">constructor</span> === <span class="hljs-title class_">Object</span>); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p><code>constructor</code>有两个作用，一是判断数据的类型，二是对象实例通过 <code>constrcutor</code> 对象访问它的构造函数。需要注意，如果创建一个对象来改变它的原型，<code>constructor</code>就不能用来判断数据类型了：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Fn</span>(<span class="hljs-params"></span>)&#123;&#125;;<br> <br><span class="hljs-title class_">Fn</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>();<br> <br><span class="hljs-keyword">var</span> f = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Fn</span>();<br> <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(f.<span class="hljs-property">constructor</span>===<span class="hljs-title class_">Fn</span>);    <span class="hljs-comment">// false</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(f.<span class="hljs-property">constructor</span>===<span class="hljs-title class_">Array</span>); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p><strong>（4）Object.prototype.toString.call()</strong></p><p><code>Object.prototype.toString.call()</code> 使用 Object 对象的原型方法 toString 来判断数据类型：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = <span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>;<br> <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a.<span class="hljs-title function_">call</span>(<span class="hljs-number">2</span>));<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a.<span class="hljs-title function_">call</span>(<span class="hljs-literal">true</span>));<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a.<span class="hljs-title function_">call</span>(<span class="hljs-string">&#x27;str&#x27;</span>));<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a.<span class="hljs-title function_">call</span>([]));<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a.<span class="hljs-title function_">call</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;&#125;));<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a.<span class="hljs-title function_">call</span>(&#123;&#125;));<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a.<span class="hljs-title function_">call</span>(<span class="hljs-literal">undefined</span>));<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a.<span class="hljs-title function_">call</span>(<span class="hljs-literal">null</span>));<br></code></pre></td></tr></table></figure><p>同样是检测对象obj调用toString方法，obj.toString()的结果和Object.prototype.toString.call(obj)的结果不一样，这是为什么？</p><p>这是因为toString是Object的原型方法，而Array、function等<strong>类型作为Object的实例，都重写了toString方法</strong>。不同的对象类型调用toString方法时，根据原型链的知识，调用的是对应的重写之后的toString方法（function类型返回内容为函数体的字符串，Array类型返回元素组成的字符串…），而不会去调用Object上原型toString方法（返回对象的具体类型），所以采用obj.toString()不能得到其对象类型，只能将obj转换为字符串类型；因此，在想要得到对象的具体类型时，应该调用Object原型上的toString方法。</p><h3 id="3-判断数组的方式有哪些"><a href="#3-判断数组的方式有哪些" class="headerlink" title="3. 判断数组的方式有哪些"></a>3. 判断数组的方式有哪些</h3><ul><li>通过Object.prototype.toString.call()做判断</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>(obj).<span class="hljs-title function_">slice</span>(<span class="hljs-number">8</span>,-<span class="hljs-number">1</span>) === <span class="hljs-string">&#x27;Array&#x27;</span>;<br></code></pre></td></tr></table></figure><ul><li>通过原型链做判断</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">obj.<span class="hljs-property">__proto__</span> === <span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>;<br></code></pre></td></tr></table></figure><ul><li>通过ES6的Array.isArray()做判断</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArrray</span>(obj);<br></code></pre></td></tr></table></figure><ul><li>通过instanceof做判断</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">obj <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Array</span><br></code></pre></td></tr></table></figure><ul><li>通过Array.prototype.isPrototypeOf</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-title function_">isPrototypeOf</span>(obj)<br></code></pre></td></tr></table></figure><h3 id="4-null和undefined区别"><a href="#4-null和undefined区别" class="headerlink" title="4. null和undefined区别"></a>4. null和undefined区别</h3><p>首先 Undefined 和 Null 都是基本数据类型，这两个基本数据类型分别都只有一个值，就是 undefined 和 null。</p><p>undefined 代表的含义是<strong>未定义</strong>，null 代表的含义是<strong>空对象</strong>。一般变量声明了但还没有定义的时候会返回 undefined，null主要用于赋值给一些可能会返回对象的变量，作为初始化。</p><p>undefined 在 JavaScript 中不是一个保留字，这意味着可以使用 undefined 来作为一个变量名，但是这样的做法是非常危险的，它会影响对 undefined 值的判断。我们可以通过一些方法获得安全的 undefined 值，比如说 void 0。</p><p>当对这两种类型使用 typeof 进行判断时，Null 类型化会返回 “object”，这是一个历史遗留的问题。当使用双等号对两种类型的值进行比较时会返回 true，使用三个等号时会返回 false。</p><h3 id="5-typeof-null-的结果是什么，为什么？"><a href="#5-typeof-null-的结果是什么，为什么？" class="headerlink" title="5. typeof null 的结果是什么，为什么？"></a>5. typeof null 的结果是什么，为什么？</h3><p>typeof null 的结果是Object。</p><p>在 JavaScript 第一个版本中，所有值都存储在 32 位的单元中，每个单元包含一个小的 <strong>类型标签(1-3 bits)</strong> 以及当前要存储值的真实数据。类型标签存储在每个单元的低位中，共有五种数据类型：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-number">000</span>: object   - 当前存储的数据指向一个对象。<br>  <span class="hljs-number">1</span>: int      - 当前存储的数据是一个 <span class="hljs-number">31</span> 位的有符号整数。<br><span class="hljs-number">010</span>: double   - 当前存储的数据指向一个双精度的浮点数。<br><span class="hljs-number">100</span>: string   - 当前存储的数据指向一个字符串。<br><span class="hljs-number">110</span>: boolean  - 当前存储的数据是布尔值。<br></code></pre></td></tr></table></figure><p>如果最低位是 1，则类型标签标志位的长度只有一位；如果最低位是 0，则类型标签标志位的长度占三位，为存储其他四种数据类型提供了额外两个 bit 的长度。</p><p>有两种特殊数据类型：</p><ul><li>undefined的值是 (-2)30(一个超出整数范围的数字)；</li><li>null 的值是机器码 NULL 指针(null 指针的值全是 0)</li></ul><p>那也就是说null的类型标签也是000，和Object的类型标签一样，所以会被判定为Object。</p><h3 id="6-intanceof-操作符的实现原理及实现"><a href="#6-intanceof-操作符的实现原理及实现" class="headerlink" title="6. intanceof 操作符的实现原理及实现"></a>6. intanceof 操作符的实现原理及实现</h3><p> instanceof 运算符用于判断构造函数的 prototype 属性是否出现在对象的原型链中的任何位置。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">myInstanceof</span>(<span class="hljs-params">left, right</span>) &#123;<br>  <span class="hljs-comment">// 获取对象的原型</span><br>  <span class="hljs-keyword">let</span> proto = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getPrototypeOf</span>(left)<br>  <span class="hljs-comment">// 获取构造函数的 prototype 对象</span><br>  <span class="hljs-keyword">let</span> prototype = right.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>; <br> <br>  <span class="hljs-comment">// 判断构造函数的 prototype 对象是否在对象的原型链上</span><br>  <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>    <span class="hljs-keyword">if</span> (!proto) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">if</span> (proto === prototype) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-comment">// 如果没有找到，就继续从其原型上找，Object.getPrototypeOf方法用来获取指定对象的原型</span><br>    proto = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getPrototypeOf</span>(proto);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="7-为什么0-1-0-2-x3D-x3D-0-3，如何让其相等"><a href="#7-为什么0-1-0-2-x3D-x3D-0-3，如何让其相等" class="headerlink" title="7. 为什么0.1+0.2 ! &#x3D;&#x3D; 0.3，如何让其相等"></a>7. 为什么0.1+0.2 ! &#x3D;&#x3D; 0.3，如何让其相等</h3><p>在开发过程中遇到类似这样的问题：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> n1 = <span class="hljs-number">0.1</span>, n2 = <span class="hljs-number">0.2</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(n1 + n2)  <span class="hljs-comment">// 0.30000000000000004</span><br></code></pre></td></tr></table></figure><p>这里得到的不是想要的结果，要想等于0.3，就要把它进行转化：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">(n1 + n2).<span class="hljs-title function_">toFixed</span>(<span class="hljs-number">2</span>) <span class="hljs-comment">// 注意，toFixed为四舍五入</span><br></code></pre></td></tr></table></figure><p><code>toFixed(num)</code> 方法可把 Number 四舍五入为指定小数位数的数字。那为什么会出现这样的结果呢？</p><p>计算机是通过二进制的方式存储数据的，所以计算机计算0.1+0.2的时候，实际上是计算的两个数的二进制的和。0.1的二进制是<code>0.0001100110011001100...</code>（1100循环），0.2的二进制是：<code>0.00110011001100...</code>（1100循环），这两个数的二进制都是无限循环的数。那JavaScript是如何处理无限循环的二进制小数呢？</p><p>一般我们认为数字包括整数和小数，但是在 JavaScript 中只有一种数字类型：Number，它的实现遵循IEEE 754标准，使用64位固定长度来表示，也就是标准的double双精度浮点数。在二进制科学表示法中，双精度浮点数的小数部分最多只能保留52位，再加上前面的1，其实就是保留53位有效数字，剩余的需要舍去，遵从“0舍1入”的原则。</p><p>根据这个原则，0.1和0.2的二进制数相加，再转化为十进制数就是：<code>0.30000000000000004</code>。</p><p>下面看一下<strong>双精度数是如何保存</strong>的：<br><img src="2.png" alt="img"></p><ul><li>第一部分（蓝色）：用来存储符号位（sign），用来区分正负数，0表示正数，占用1位</li><li>第二部分（绿色）：用来存储指数（exponent），占用11位</li><li>第三部分（红色）：用来存储小数（fraction），占用52位</li></ul><p>对于0.1，它的二进制为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-number">0.00011001100110011001100110011001100110011001100110011001</span> <span class="hljs-number">10011.</span>..<br></code></pre></td></tr></table></figure><p>转为科学计数法（科学计数法的结果就是浮点数）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-number">1.1001100110011001100110011001100110011001100110011001</span>*<span class="hljs-number">2</span>^-<span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p>可以看出0.1的符号位为0，指数位为-4，小数位为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-number">1001100110011001100110011001100110011001100110011001</span><br></code></pre></td></tr></table></figure><p>那么问题又来了，<strong>指数位是负数，该如何保存</strong>呢？</p><p>IEEE标准规定了一个偏移量，对于指数部分，每次都加这个偏移量进行保存，这样即使指数是负数，那么加上这个偏移量也就是正数了。由于JavaScript的数字是双精度数，这里就以双精度数为例，它的指数部分为11位，能表示的范围就是0~2047，IEEE固定<strong>双精度数的偏移量为1023</strong>。</p><ul><li>当指数位不全是0也不全是1时(规格化的数值)，IEEE规定，阶码计算公式为 e-Bias。 此时e最小值是1，则1-1023&#x3D; -1022，e最大值是2046，则2046-1023&#x3D;1023，可以看到，这种情况下取值范围是<code>-1022~1013</code>。</li><li>当指数位全部是0的时候(非规格化的数值)，IEEE规定，阶码的计算公式为1-Bias，即1-1023&#x3D; -1022。</li><li>当指数位全部是1的时候(特殊值)，IEEE规定这个浮点数可用来表示3个特殊值，分别是正无穷，负无穷，NaN。 具体的，小数位不为0的时候表示NaN；小数位为0时，当符号位s&#x3D;0时表示正无穷，s&#x3D;1时候表示负无穷。</li></ul><p>对于上面的0.1的指数位为-4，-4+1023 &#x3D; 1019 转化为二进制就是：<code>1111111011</code>.</p><p>所以，0.1表示为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-number">0</span> <span class="hljs-number">1111111011</span> <span class="hljs-number">1001100110011001100110011001100110011001100110011001</span><br></code></pre></td></tr></table></figure><p>说了这么多，是时候该最开始的问题了，如何实现0.1+0.2&#x3D;0.3呢？</p><p>对于这个问题，一个直接的解决方法就是设置一个误差范围，通常称为“机器精度”。对JavaScript来说，这个值通常为2-52，在ES6中，提供了<code>Number.EPSILON</code>属性，而它的值就是2-52，只要判断<code>0.1+0.2-0.3</code>是否小于<code>Number.EPSILON</code>，如果小于，就可以判断为0.1+0.2 &#x3D;&#x3D;&#x3D;0.3</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">numberepsilon</span>(<span class="hljs-params">arg1,arg2</span>)&#123;                   <br>  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">abs</span>(arg1 - arg2) &lt; <span class="hljs-title class_">Number</span>.<span class="hljs-property">EPSILON</span>;        <br>&#125;        <br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">numberepsilon</span>(<span class="hljs-number">0.1</span> + <span class="hljs-number">0.2</span>, <span class="hljs-number">0.3</span>)); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><h3 id="8-如何获取安全的-undefined-值？"><a href="#8-如何获取安全的-undefined-值？" class="headerlink" title="8. 如何获取安全的 undefined 值？"></a>8. 如何获取安全的 undefined 值？</h3><p>因为 undefined 是一个标识符，所以可以被当作变量来使用和赋值，但是这样会影响 undefined 的正常判断。表达式 void ___ 没有返回值，因此返回结果是 undefined。void 并不改变表达式的结果，只是让表达式不返回值。因此可以用 void 0 来获得 undefined。</p><h3 id="9-typeof-NaN-的结果是什么？"><a href="#9-typeof-NaN-的结果是什么？" class="headerlink" title="9. typeof NaN 的结果是什么？"></a>9. typeof NaN 的结果是什么？</h3><p>NaN 指“不是一个数字”（not a number），NaN 是一个“警戒值”（sentinel value，有特殊用途的常规值），用于指出数字类型中的错误情况，即“执行数学运算没有成功，这是失败后返回的结果”。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">typeof</span> <span class="hljs-title class_">NaN</span>; <span class="hljs-comment">// &quot;number&quot;</span><br></code></pre></td></tr></table></figure><p>NaN 是一个特殊值，它和自身不相等，是唯一一个非自反（自反，reflexive，即 x &#x3D;&#x3D;&#x3D; x 不成立）的值。而 NaN !&#x3D;&#x3D; NaN 为 true。</p><h3 id="10-isNaN-和-Number-isNaN-函数的区别？"><a href="#10-isNaN-和-Number-isNaN-函数的区别？" class="headerlink" title="10. isNaN 和 Number.isNaN 函数的区别？"></a>10. isNaN 和 Number.isNaN 函数的区别？</h3><ul><li>函数 isNaN 接收参数后，会尝试将这个参数转换为数值，任何不能被转换为数值的的值都会返回 true，因此非数字值传入也会返回 true ，会影响 NaN 的判断。</li><li>函数 Number.isNaN 会首先判断传入参数是否为数字，如果是数字再继续判断是否为 NaN ，不会进行数据类型的转换，这种方法对于 NaN 的判断更为准确。</li></ul><h3 id="11-x3D-x3D-操作符的强制类型转换规则？"><a href="#11-x3D-x3D-操作符的强制类型转换规则？" class="headerlink" title="11. &#x3D;&#x3D; 操作符的强制类型转换规则？"></a>11. &#x3D;&#x3D; 操作符的强制类型转换规则？</h3><p>对于 <code>==</code> 来说，如果对比双方的类型<strong>不一样</strong>，就会进行<strong>类型转换</strong>。假如对比 <code>x</code> 和 <code>y</code> 是否相同，就会进行如下判断流程：</p><ol><li>首先会判断两者类型是否<strong>相同，</strong>相同的话就比较两者的大小；</li><li>类型不相同的话，就会进行类型转换；</li><li>会先判断是否在对比 <code>null</code> 和 <code>undefined</code>，是的话就会返回 <code>true</code></li><li>判断两者类型是否为 <code>string</code> 和 <code>number</code>，是的话就会将字符串转换为 <code>number</code></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-number">1</span> == <span class="hljs-string">&#x27;1&#x27;</span><br>      ↓<br><span class="hljs-number">1</span> ==  <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><ol start="5"><li>判断其中一方是否为 <code>boolean</code>，是的话就会把 <code>boolean</code> 转为 <code>number</code> 再进行判断</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;1&#x27;</span> == <span class="hljs-literal">true</span><br>        ↓<br><span class="hljs-string">&#x27;1&#x27;</span> ==  <span class="hljs-number">1</span><br>        ↓<br> <span class="hljs-number">1</span>  ==  <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><ol start="6"><li>判断其中一方是否为 <code>object</code> 且另一方为 <code>string</code>、<code>number</code> 或者 <code>symbol</code>，是的话就会把 <code>object</code> 转为原始类型再进行判断</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;1&#x27;</span> == &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;js&#x27;</span> &#125;        ↓<span class="hljs-string">&#x27;1&#x27;</span> == <span class="hljs-string">&#x27;[object Object]&#x27;</span><br></code></pre></td></tr></table></figure><p>其流程图如下：<br><img src="3.png" alt="img"></p><h3 id="12-其他值到字符串的转换规则？"><a href="#12-其他值到字符串的转换规则？" class="headerlink" title="12. 其他值到字符串的转换规则？"></a>12. 其他值到字符串的转换规则？</h3><ul><li>Null 和 Undefined 类型 ，null 转换为 “null”，undefined 转换为 “undefined”，</li><li>Boolean 类型，true 转换为 “true”，false 转换为 “false”。</li><li>Number 类型的值直接转换，不过那些极小和极大的数字会使用指数形式。</li><li>Symbol 类型的值直接转换，但是只允许显式强制类型转换，使用隐式强制类型转换会产生错误。</li><li>对普通对象来说，除非自行定义 toString() 方法，否则会调用 toString()（Object.prototype.toString()）来返回内部属性 [[Class]] 的值，如”[object Object]”。如果对象有自己的 toString() 方法，字符串化时就会调用该方法并使用其返回值。</li></ul><h3 id="13-其他值到数字值的转换规则？"><a href="#13-其他值到数字值的转换规则？" class="headerlink" title="13. 其他值到数字值的转换规则？"></a>13. 其他值到数字值的转换规则？</h3><ul><li>Undefined 类型的值转换为 NaN。</li><li>Null 类型的值转换为 0。</li><li>Boolean 类型的值，true 转换为 1，false 转换为 0。</li><li>String 类型的值转换如同使用 Number() 函数进行转换，如果包含非数字值则转换为 NaN，空字符串为 0。</li><li>Symbol 类型的值不能转换为数字，会报错。</li><li>对象（包括数组）会首先被转换为相应的基本类型值，如果返回的是非数字的基本类型值，则再遵循以上规则将其强制转换为数字。</li></ul><p>为了将值转换为相应的基本类型值，抽象操作 ToPrimitive 会首先（通过内部操作 DefaultValue）检查该值是否有valueOf()方法。如果有并且返回基本类型值，就使用该值进行强制类型转换。如果没有就使用 toString() 的返回值（如果存在）来进行强制类型转换。</p><p>如果 valueOf() 和 toString() 均不返回基本类型值，会产生 TypeError 错误。</p><h3 id="14-其他值到布尔类型的值的转换规则？"><a href="#14-其他值到布尔类型的值的转换规则？" class="headerlink" title="14. 其他值到布尔类型的值的转换规则？"></a>14. 其他值到布尔类型的值的转换规则？</h3><p>以下这些是假值：<br>• undefined<br>• null<br>• false<br>• +0、-0 和 NaN<br>• “”</p><p>假值的布尔强制类型转换结果为 false。从逻辑上说，假值列表以外的都应该是真值。</p><h3 id="15-和-amp-amp-操作符的返回值？"><a href="#15-和-amp-amp-操作符的返回值？" class="headerlink" title="15. || 和 &amp;&amp; 操作符的返回值？"></a>15. || 和 &amp;&amp; 操作符的返回值？</h3><p>|| 和 &amp;&amp; 首先会对第一个操作数执行条件判断，如果其不是布尔值就先强制转换为布尔类型，然后再执行条件判断。</p><ul><li>对于 || 来说，如果条件判断结果为 true 就返回第一个操作数的值，如果为 false 就返回第二个操作数的值。</li><li>&amp;&amp; 则相反，如果条件判断结果为 true 就返回第二个操作数的值，如果为 false 就返回第一个操作数的值。</li></ul><p>|| 和 &amp;&amp; 返回它们其中一个操作数的值，而非条件判断的结果</p><h3 id="16-Object-is-与比较操作符-“-x3D-x3D-x3D-”、“-x3D-x3D-”-的区别？"><a href="#16-Object-is-与比较操作符-“-x3D-x3D-x3D-”、“-x3D-x3D-”-的区别？" class="headerlink" title="16. Object.is() 与比较操作符 “&#x3D;&#x3D;&#x3D;”、“&#x3D;&#x3D;” 的区别？"></a>16. Object.is() 与比较操作符 “&#x3D;&#x3D;&#x3D;”、“&#x3D;&#x3D;” 的区别？</h3><ul><li>使用双等号（&#x3D;&#x3D;）进行相等判断时，如果两边的类型不一致，则会进行强制类型转化后再进行比较。</li><li>使用三等号（&#x3D;&#x3D;&#x3D;）进行相等判断时，如果两边的类型不一致时，不会做强制类型准换，直接返回 false。</li><li>使用 Object.is 来进行相等判断时，一般情况下和三等号的判断相同，它处理了一些特殊的情况，比如 -0 和 +0 不再相等，两个 NaN 是相等的。</li></ul><h3 id="17-什么是-JavaScript-中的包装类型？"><a href="#17-什么是-JavaScript-中的包装类型？" class="headerlink" title="17. 什么是 JavaScript 中的包装类型？"></a>17. 什么是 JavaScript 中的包装类型？</h3><p>在 JavaScript 中，基本类型是没有属性和方法的，但是为了便于操作基本类型的值，在调用基本类型的属性或方法时 JavaScript 会在后台隐式地将基本类型的值转换为对象，如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> a = <span class="hljs-string">&quot;abc&quot;</span>;<br>a.<span class="hljs-property">length</span>; <span class="hljs-comment">// 3</span><br>a.<span class="hljs-title function_">toUpperCase</span>(); <span class="hljs-comment">// &quot;ABC&quot;</span><br></code></pre></td></tr></table></figure><p>在访问<code>&#39;abc&#39;.length</code>时，JavaScript 将<code>&#39;abc&#39;</code>在后台转换成<code>String(&#39;abc&#39;)</code>，然后再访问其<code>length</code>属性。</p><p>JavaScript也可以使用<code>Object</code>函数显式地将基本类型转换为包装类型：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = <span class="hljs-string">&#x27;abc&#x27;</span><br><span class="hljs-title class_">Object</span>(a) <span class="hljs-comment">// String &#123;&quot;abc&quot;&#125;</span><br></code></pre></td></tr></table></figure><p>也可以使用<code>valueOf</code>方法将包装类型倒转成基本类型：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = <span class="hljs-string">&#x27;abc&#x27;</span><br><span class="hljs-keyword">var</span> b = <span class="hljs-title class_">Object</span>(a)<br><span class="hljs-keyword">var</span> c = b.<span class="hljs-title function_">valueOf</span>() <span class="hljs-comment">// &#x27;abc&#x27;</span><br></code></pre></td></tr></table></figure><p>看看如下代码会打印出什么：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Boolean</span>( <span class="hljs-literal">false</span> );<br><span class="hljs-keyword">if</span> (!a) &#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-string">&quot;Oops&quot;</span> ); <span class="hljs-comment">// never runs</span><br>&#125;<br></code></pre></td></tr></table></figure><p>答案是什么都不会打印，因为虽然包裹的基本类型是<code>false</code>，但是<code>false</code>被包裹成包装类型后就成了对象，所以其非值为<code>false</code>，所以循环体中的内容不会运行。</p><h3 id="18-JavaScript-中如何进行隐式类型转换？"><a href="#18-JavaScript-中如何进行隐式类型转换？" class="headerlink" title="18. JavaScript 中如何进行隐式类型转换？"></a>18. JavaScript 中如何进行隐式类型转换？</h3><p>首先要介绍<code>ToPrimitive</code>方法，这是 JavaScript 中每个值隐含的自带的方法，用来将值 （无论是基本类型值还是对象）转换为基本类型值。如果值为基本类型，则直接返回值本身；如果值为对象，其看起来大概是这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* <span class="hljs-doctag">@obj</span> 需要转换的对象</span><br><span class="hljs-comment">* <span class="hljs-doctag">@type</span> 期望的结果类型</span><br><span class="hljs-comment">*/</span><br><span class="hljs-title class_">ToPrimitive</span>(obj,type)<br></code></pre></td></tr></table></figure><p><code>type</code>的值为<code>number</code>或者<code>string</code>。</p><p><strong>（1）当</strong><code>type</code><strong>为</strong><code>number</code><strong>时规则如下：</strong></p><ul><li>调用<code>obj</code>的<code>valueOf</code>方法，如果为原始值，则返回，否则下一步；</li><li>调用<code>obj</code>的<code>toString</code>方法，后续同上；</li><li>抛出<code>TypeError</code> 异常。</li></ul><p><strong>（2）当</strong><code>type</code><strong>为</strong><code>string</code><strong>时规则如下：</strong></p><ul><li>调用<code>obj</code>的<code>toString</code>方法，如果为原始值，则返回，否则下一步；</li><li>调用<code>obj</code>的<code>valueOf</code>方法，后续同上；</li><li>抛出<code>TypeError</code> 异常。</li></ul><p>可以看出两者的主要区别在于调用<code>toString</code>和<code>valueOf</code>的先后顺序。默认情况下：</p><ul><li>如果对象为 Date 对象，则<code>type</code>默认为<code>string</code>；</li><li>其他情况下，<code>type</code>默认为<code>number</code>。</li></ul><p>总结上面的规则，对于 Date 以外的对象，转换为基本类型的大概规则可以概括为一个函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> <span class="hljs-title function_">objToNumber</span> = value =&gt; <span class="hljs-title class_">Number</span>(value.<span class="hljs-title function_">valueOf</span>().<span class="hljs-title function_">toString</span>())<br><span class="hljs-title function_">objToNumber</span>([]) === <span class="hljs-number">0</span><br><span class="hljs-title function_">objToNumber</span>(&#123;&#125;) === <span class="hljs-title class_">NaN</span><br></code></pre></td></tr></table></figure><p>而 JavaScript 中的隐式类型转换主要发生在<code>+、-、*、/</code>以及<code>==、&gt;、&lt;</code>这些运算符之间。而这些运算符只能操作基本类型值，所以在进行这些运算前的第一步就是将两边的值用<code>ToPrimitive</code>转换成基本类型，再进行操作。</p><p>以下是基本类型的值在不同操作符的情况下隐式转换的规则 （对于对象，其会被<code>ToPrimitive</code>转换成基本类型，所以最终还是要应用基本类型转换规则）：</p><ol><li><code>+</code><strong>操作符</strong><br><code>+</code>操作符的两边有至少一个<code>string</code>类型变量时，两边的变量都会被隐式转换为字符串；其他情况下两边的变量都会被转换为数字。</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-number">1</span> + <span class="hljs-string">&#x27;23&#x27;</span> <span class="hljs-comment">// &#x27;123&#x27;</span><br> <span class="hljs-number">1</span> + <span class="hljs-literal">false</span> <span class="hljs-comment">// 1 </span><br> <span class="hljs-number">1</span> + <span class="hljs-title class_">Symbol</span>() <span class="hljs-comment">// Uncaught TypeError: Cannot convert a Symbol value to a number</span><br> <span class="hljs-string">&#x27;1&#x27;</span> + <span class="hljs-literal">false</span> <span class="hljs-comment">// &#x27;1false&#x27;</span><br> <span class="hljs-literal">false</span> + <span class="hljs-literal">true</span> <span class="hljs-comment">// 1</span><br></code></pre></td></tr></table></figure><ol start="2"><li><code>-</code>、<code>*</code>、<code>\</code><strong>操作符</strong></li></ol><p><code>NaN</code>也是一个数字</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-number">1</span> * <span class="hljs-string">&#x27;23&#x27;</span> <span class="hljs-comment">// 23</span><br> <span class="hljs-number">1</span> * <span class="hljs-literal">false</span> <span class="hljs-comment">// 0</span><br> <span class="hljs-number">1</span> / <span class="hljs-string">&#x27;aa&#x27;</span> <span class="hljs-comment">// NaN</span><br></code></pre></td></tr></table></figure><ol start="3"><li><strong>对于</strong><code>==</code><strong>操作符</strong></li></ol><p>操作符两边的值都尽量转成<code>number</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-number">3</span> == <span class="hljs-literal">true</span> <span class="hljs-comment">// false, 3 转为number为3，true转为number为1</span><br><span class="hljs-string">&#x27;0&#x27;</span> == <span class="hljs-literal">false</span> <span class="hljs-comment">//true, &#x27;0&#x27;转为number为0，false转为number为0</span><br><span class="hljs-string">&#x27;0&#x27;</span> == <span class="hljs-number">0</span> <span class="hljs-comment">// &#x27;0&#x27;转为number为0</span><br></code></pre></td></tr></table></figure><ol start="4"><li><strong>对于</strong><code>&lt;</code><strong>和</strong><code>&gt;</code><strong>比较符</strong></li></ol><p>如果两边都是字符串，则比较字母表顺序：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;ca&#x27;</span> &lt; <span class="hljs-string">&#x27;bd&#x27;</span> <span class="hljs-comment">// false</span><br><span class="hljs-string">&#x27;a&#x27;</span> &lt; <span class="hljs-string">&#x27;b&#x27;</span> <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>其他情况下，转换为数字再比较：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;12&#x27;</span> &lt; <span class="hljs-number">13</span> <span class="hljs-comment">// true</span><br><span class="hljs-literal">false</span> &gt; -<span class="hljs-number">1</span> <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>以上说的是基本类型的隐式转换，而对象会被<code>ToPrimitive</code>转换为基本类型再进行转换：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = &#123;&#125;<br>a &gt; <span class="hljs-number">2</span> <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><p>其对比过程如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript">a.<span class="hljs-title function_">valueOf</span>() <span class="hljs-comment">// &#123;&#125;, 上面提到过，ToPrimitive默认type为number，所以先valueOf，结果还是个对象，下一步</span><br>a.<span class="hljs-title function_">toString</span>() <span class="hljs-comment">// &quot;[object Object]&quot;，现在是一个字符串了</span><br><span class="hljs-title class_">Number</span>(a.<span class="hljs-title function_">toString</span>()) <span class="hljs-comment">// NaN，根据上面 &lt; 和 &gt; 操作符的规则，要转换成数字</span><br><span class="hljs-title class_">NaN</span> &gt; <span class="hljs-number">2</span> <span class="hljs-comment">//false，得出比较结果</span><br></code></pre></td></tr></table></figure><p>又比如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = &#123;<span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;Jack&#x27;</span>&#125;<br><span class="hljs-keyword">var</span> b = &#123;<span class="hljs-attr">age</span>: <span class="hljs-number">18</span>&#125;<br>a + b <span class="hljs-comment">// &quot;[object Object][object Object]&quot;</span><br></code></pre></td></tr></table></figure><p>运算过程如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript">a.<span class="hljs-title function_">valueOf</span>() <span class="hljs-comment">// &#123;&#125;，上面提到过，ToPrimitive默认type为number，所以先valueOf，结果还是个对象，下一步</span><br>a.<span class="hljs-title function_">toString</span>() <span class="hljs-comment">// &quot;[object Object]&quot;</span><br>b.<span class="hljs-title function_">valueOf</span>() <span class="hljs-comment">// 同理</span><br>b.<span class="hljs-title function_">toString</span>() <span class="hljs-comment">// &quot;[object Object]&quot;</span><br>a + b <span class="hljs-comment">// &quot;[object Object][object Object]&quot;</span><br></code></pre></td></tr></table></figure><h3 id="19-操作符什么时候用于字符串的拼接？"><a href="#19-操作符什么时候用于字符串的拼接？" class="headerlink" title="19. + 操作符什么时候用于字符串的拼接？"></a>19. <code>+</code> 操作符什么时候用于字符串的拼接？</h3><p>根据 ES5 规范，如果某个操作数是字符串或者能够通过以下步骤转换为字符串的话，+ 将进行拼接操作。如果其中一个操作数是对象（包括数组），则首先对其调用 ToPrimitive 抽象操作，该抽象操作再调用 [[DefaultValue]]，以数字作为上下文。如果不能转换为字符串，则会将其转换为数字类型来进行计算。</p><p>简单来说就是，如果 + 的其中一个操作数是字符串（或者通过以上步骤最终得到字符串），则执行字符串拼接，否则执行数字加法。</p><p>那么对于除了加法的运算符来说，只要其中一方是数字，那么另一方就会被转为数字。</p><h3 id="20-为什么会有BigInt的提案？"><a href="#20-为什么会有BigInt的提案？" class="headerlink" title="20. 为什么会有BigInt的提案？"></a>20. 为什么会有<strong>BigInt</strong>的提案？</h3><p>JavaScript中Number.MAX_SAFE_INTEGER表示最⼤安全数字，计算结果是9007199254740991，即在这个数范围内不会出现精度丢失（⼩数除外）。但是⼀旦超过这个范围，js就会出现计算不准确的情况，这在⼤数计算的时候不得不依靠⼀些第三⽅库进⾏解决，因此官⽅提出了BigInt来解决此问题。 </p><h3 id="21-object-assign和扩展运算法是深拷贝还是浅拷贝，两者区别"><a href="#21-object-assign和扩展运算法是深拷贝还是浅拷贝，两者区别" class="headerlink" title="21. object.assign和扩展运算法是深拷贝还是浅拷贝，两者区别"></a>21. object.assign和扩展运算法是深拷贝还是浅拷贝，两者区别</h3><p>扩展运算符：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> outObj = &#123;<br>  <span class="hljs-attr">inObj</span>: &#123;<span class="hljs-attr">a</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">b</span>: <span class="hljs-number">2</span>&#125;<br>&#125;<br><span class="hljs-keyword">let</span> newObj = &#123;...outObj&#125;<br>newObj.<span class="hljs-property">inObj</span>.<span class="hljs-property">a</span> = <span class="hljs-number">2</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(outObj) <span class="hljs-comment">// &#123;inObj: &#123;a: 2, b: 2&#125;&#125;</span><br></code></pre></td></tr></table></figure><p>Object.assign():</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> outObj = &#123;<br>  <span class="hljs-attr">inObj</span>: &#123;<span class="hljs-attr">a</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">b</span>: <span class="hljs-number">2</span>&#125;<br>&#125;<br><span class="hljs-keyword">let</span> newObj = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(&#123;&#125;, outObj)<br>newObj.<span class="hljs-property">inObj</span>.<span class="hljs-property">a</span> = <span class="hljs-number">2</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(outObj) <span class="hljs-comment">// &#123;inObj: &#123;a: 2, b: 2&#125;&#125;</span><br></code></pre></td></tr></table></figure><p>可以看到，两者都是浅拷贝。</p><ul><li>Object.assign()方法接收的第一个参数作为目标对象，后面的所有参数作为源对象。然后把所有的源对象合并到目标对象中。它会修改了一个对象，因此会触发 ES6 setter。</li><li>扩展操作符（…）使用它时，数组或对象中的每一个值都会被拷贝到一个新的数组或对象中。它不复制继承的属性或类的属性，但是它会复制ES6的 symbols 属性。</li></ul><h2 id="二、ES6"><a href="#二、ES6" class="headerlink" title="二、ES6"></a>二、ES6</h2><h3 id="1-let、const、var的区别"><a href="#1-let、const、var的区别" class="headerlink" title="1. let、const、var的区别"></a>1. let、const、var的区别</h3><p><strong>（1）块级作用域：</strong> 块作用域由 <code>&#123; &#125;</code>包括，let和const具有块级作用域，var不存在块级作用域。块级作用域解决了ES5中的两个问题：</p><ul><li>内层变量可能覆盖外层变量</li><li>用来计数的循环变量泄露为全局变量</li></ul><p><strong>（2）变量提升：</strong> var存在变量提升，let和const不存在变量提升，即在变量只能在声明之后使用，否在会报错。</p><p><strong>（3）给全局添加属性：</strong> 浏览器的全局对象是window，Node的全局对象是global。var声明的变量为全局变量，并且会将该变量添加为全局对象的属性，但是let和const不会。</p><p><strong>（4）重复声明：</strong> var声明变量时，可以重复声明变量，后声明的同名变量会覆盖之前声明的遍历。const和let不允许重复声明变量。</p><p><strong>（5）暂时性死区：</strong> 在使用let、const命令声明变量之前，该变量都是不可用的。这在语法上，称为<strong>暂时性死区</strong>。使用var声明的变量不存在暂时性死区。</p><p><strong>（6）初始值设置：</strong> 在变量声明时，var 和 let 可以不用设置初始值。而const声明变量必须设置初始值。</p><p><strong>（7）指针指向：</strong> let和const都是ES6新增的用于创建变量的语法。 let创建的变量是可以更改指针指向（可以重新赋值）。但const声明的变量是不允许改变指针的指向。</p><table><thead><tr><th><strong>区别</strong></th><th><strong>var</strong></th><th><strong>let</strong></th><th><strong>const</strong></th></tr></thead><tbody><tr><td>是否有块级作用域</td><td>×</td><td>✔️</td><td>✔️</td></tr><tr><td>是否存在变量提升</td><td>✔️</td><td>×</td><td>×</td></tr><tr><td>是否添加全局属性</td><td>✔️</td><td>×</td><td>×</td></tr><tr><td>能否重复声明变量</td><td>✔️</td><td>×</td><td>×</td></tr><tr><td>是否存在暂时性死区</td><td>×</td><td>✔️</td><td>✔️</td></tr><tr><td>是否必须设置初始值</td><td>×</td><td>×</td><td>✔️</td></tr><tr><td>能否改变指针指向</td><td>✔️</td><td>✔️</td><td>×</td></tr></tbody></table><h3 id="2-const对象的属性可以修改吗"><a href="#2-const对象的属性可以修改吗" class="headerlink" title="2. const对象的属性可以修改吗"></a>2. const对象的属性可以修改吗</h3><p>const保证的并不是变量的值不能改动，而是变量指向的那个内存地址不能改动。对于基本类型的数据（数值、字符串、布尔值），其值就保存在变量指向的那个内存地址，因此等同于常量。</p><p>但对于引用类型的数据（主要是对象和数组）来说，变量指向数据的内存地址，保存的只是一个指针，const只能保证这个指针是固定不变的，至于它指向的数据结构是不是可变的，就完全不能控制了。</p><h3 id="3-如果new一个箭头函数的会怎么样"><a href="#3-如果new一个箭头函数的会怎么样" class="headerlink" title="3. 如果new一个箭头函数的会怎么样"></a>3. 如果new一个箭头函数的会怎么样</h3><p>箭头函数是ES6中的提出来的，它没有prototype，也没有自己的this指向，更不可以使用arguments参数，所以不能New一个箭头函数。</p><p>new操作符的实现步骤如下：</p><ol><li>创建一个对象</li><li>将构造函数的作用域赋给新对象（也就是将对象的__proto__属性指向构造函数的prototype属性）</li><li>指向构造函数中的代码，构造函数中的this指向该对象（也就是为这个对象添加属性和方法）</li><li>返回新的对象</li></ol><p>所以，上面的第二、三步，箭头函数都是没有办法执行的。</p><h3 id="4-箭头函数与普通函数的区别"><a href="#4-箭头函数与普通函数的区别" class="headerlink" title="4. 箭头函数与普通函数的区别"></a>4. 箭头函数与普通函数的区别</h3><p><strong>（1）箭头函数比普通函数更加简洁</strong></p><ul><li>如果没有参数，就直接写一个空括号即可</li><li>如果只有一个参数，可以省去参数的括号</li><li>如果有多个参数，用逗号分割</li><li>如果函数体的返回值只有一句，可以省略大括号</li><li>如果函数体不需要返回值，且只有一句话，可以给这个语句前面加一个void关键字。最常见的就是调用一个函数：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> <span class="hljs-title function_">fn</span> = (<span class="hljs-params"></span>) =&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">doesNotReturn</span>();<br></code></pre></td></tr></table></figure><p><strong>（2）箭头函数没有自己的this</strong></p><p>箭头函数不会创建自己的this， 所以它没有自己的this，它只会在自己作用域的上一层继承this。所以箭头函数中this的指向在它在定义时已经确定了，之后不会改变。</p><p><strong>（3）箭头函数继承来的this指向永远不会改变</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> id = <span class="hljs-string">&#x27;GLOBAL&#x27;</span>;<br><span class="hljs-keyword">var</span> obj = &#123;<br>  <span class="hljs-attr">id</span>: <span class="hljs-string">&#x27;OBJ&#x27;</span>,<br>  <span class="hljs-attr">a</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">id</span>);<br>  &#125;,<br>  <span class="hljs-attr">b</span>: <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">id</span>);<br>  &#125;<br>&#125;;<br>obj.<span class="hljs-title function_">a</span>();    <span class="hljs-comment">// &#x27;OBJ&#x27;</span><br>obj.<span class="hljs-title function_">b</span>();    <span class="hljs-comment">// &#x27;GLOBAL&#x27;</span><br><span class="hljs-keyword">new</span> obj.<span class="hljs-title function_">a</span>()  <span class="hljs-comment">// undefined</span><br><span class="hljs-keyword">new</span> obj.<span class="hljs-title function_">b</span>()  <span class="hljs-comment">// Uncaught TypeError: obj.b is not a constructor</span><br></code></pre></td></tr></table></figure><p>对象obj的方法b是使用箭头函数定义的，这个函数中的this就永远指向它定义时所处的全局执行环境中的this，即便这个函数是作为对象obj的方法调用，this依旧指向Window对象。需要注意，定义对象的大括号<code>&#123;&#125;</code>是无法形成一个单独的执行环境的，它依旧是处于全局执行环境中。</p><p><strong>（4）call()、apply()、bind()等方法不能改变箭头函数中this的指向</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> id = <span class="hljs-string">&#x27;Global&#x27;</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-title function_">fun1</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">id</span>)<br>&#125;;<br><span class="hljs-title function_">fun1</span>();                     <span class="hljs-comment">// &#x27;Global&#x27;</span><br>fun1.<span class="hljs-title function_">call</span>(&#123;<span class="hljs-attr">id</span>: <span class="hljs-string">&#x27;Obj&#x27;</span>&#125;);     <span class="hljs-comment">// &#x27;Global&#x27;</span><br>fun1.<span class="hljs-title function_">apply</span>(&#123;<span class="hljs-attr">id</span>: <span class="hljs-string">&#x27;Obj&#x27;</span>&#125;);    <span class="hljs-comment">// &#x27;Global&#x27;</span><br>fun1.<span class="hljs-title function_">bind</span>(&#123;<span class="hljs-attr">id</span>: <span class="hljs-string">&#x27;Obj&#x27;</span>&#125;)();   <span class="hljs-comment">// &#x27;Global&#x27;</span><br></code></pre></td></tr></table></figure><p><strong>（5）箭头函数不能作为构造函数使用</strong></p><p>构造函数在new的步骤在上面已经说过了，实际上第二步就是将函数中的this指向该对象。 但是由于箭头函数时没有自己的this的，且this指向外层的执行环境，且不能改变指向，所以不能当做构造函数使用。</p><p><strong>（6）箭头函数没有自己的arguments</strong></p><p>箭头函数没有自己的arguments对象。在箭头函数中访问arguments实际上获得的是它外层函数的arguments值。</p><p><strong>（7）箭头函数没有prototype</strong></p><p><strong>（8）箭头函数不能用作Generator函数，不能使用yeild关键字</strong></p><h3 id="5-箭头函数的this指向哪⾥？"><a href="#5-箭头函数的this指向哪⾥？" class="headerlink" title="5. 箭头函数的this指向哪⾥？"></a>5. 箭头函数的<strong>this</strong>指向哪⾥？</h3><p>箭头函数不同于传统JavaScript中的函数，箭头函数并没有属于⾃⼰的this，它所谓的this是捕获其所在上下⽂的 this 值，作为⾃⼰的 this 值，并且由于没有属于⾃⼰的this，所以是不会被new调⽤的，这个所谓的this也不会被改变。</p><p>可以⽤Babel理解⼀下箭头函数: </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// ES6 </span><br><span class="hljs-keyword">const</span> obj = &#123; <br>  <span class="hljs-title function_">getArrow</span>(<span class="hljs-params"></span>) &#123; <br>    <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> &#123; <br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span> === obj); <br>    &#125;; <br>  &#125; <br>&#125;<br></code></pre></td></tr></table></figure><p>转化后：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// ES5，由 Babel 转译</span><br><span class="hljs-keyword">var</span> obj = &#123; <br>   <span class="hljs-attr">getArrow</span>: <span class="hljs-keyword">function</span> <span class="hljs-title function_">getArrow</span>(<span class="hljs-params"></span>) &#123; <br>     <span class="hljs-keyword">var</span> _this = <span class="hljs-variable language_">this</span>; <br>     <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123; <br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(_this === obj); <br>     &#125;; <br>   &#125; <br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="6-扩展运算符的作用及使用场景"><a href="#6-扩展运算符的作用及使用场景" class="headerlink" title="6. 扩展运算符的作用及使用场景"></a>6. 扩展运算符的作用及使用场景</h3><p><strong>（1）对象扩展运算符</strong></p><p>对象的扩展运算符(…)用于取出参数对象中的所有可遍历属性，拷贝到当前对象之中。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> bar = &#123; <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">b</span>: <span class="hljs-number">2</span> &#125;;<br><span class="hljs-keyword">let</span> baz = &#123; ...bar &#125;; <span class="hljs-comment">// &#123; a: 1, b: 2 &#125;</span><br></code></pre></td></tr></table></figure><p>上述方法实际上等价于:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> bar = &#123; <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">b</span>: <span class="hljs-number">2</span> &#125;;<br><span class="hljs-keyword">let</span> baz = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(&#123;&#125;, bar); <span class="hljs-comment">// &#123; a: 1, b: 2 &#125;</span><br></code></pre></td></tr></table></figure><p><code>Object.assign</code>方法用于对象的合并，将源对象<code>（source）</code>的所有可枚举属性，复制到目标对象<code>（target）</code>。<code>Object.assign</code>方法的第一个参数是目标对象，后面的参数都是源对象。(<strong>如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性</strong>)。</p><p>同样，如果用户自定义的属性，放在扩展运算符后面，则扩展运算符内部的同名属性会被覆盖掉。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> bar = &#123;<span class="hljs-attr">a</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">b</span>: <span class="hljs-number">2</span>&#125;;<br><span class="hljs-keyword">let</span> baz = &#123;...bar, ...&#123;<span class="hljs-attr">a</span>:<span class="hljs-number">2</span>, <span class="hljs-attr">b</span>: <span class="hljs-number">4</span>&#125;&#125;;  <span class="hljs-comment">// &#123;a: 2, b: 4&#125;</span><br></code></pre></td></tr></table></figure><p>利用上述特性就可以很方便的修改对象的部分属性。在<code>redux</code>中的<code>reducer</code>函数规定必须是<strong>一个纯函数</strong>，<code>reducer</code>中的<code>state</code>对象要求不能直接修改，可以通过扩展运算符把修改路径的对象都复制一遍，然后产生一个新的对象返回。</p><p>需要注意：<strong>扩展运算符对对象实例的拷贝属于浅拷贝</strong>。</p><p><strong>（2）数组扩展运算符</strong></p><p>数组的扩展运算符可以将一个数组转为用逗号分隔的参数序列，且每次只能展开一层数组。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(...[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>])<br><span class="hljs-comment">// 1 2 3</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(...[<span class="hljs-number">1</span>, [<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>], <span class="hljs-number">5</span>])<br><span class="hljs-comment">// 1 [2, 3, 4] 5</span><br></code></pre></td></tr></table></figure><p>下面是数组的扩展运算符的应用：</p><ul><li><strong>将数组转换为参数序列</strong></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">x, y</span>) &#123;<br>  <span class="hljs-keyword">return</span> x + y;<br>&#125;<br><span class="hljs-keyword">const</span> numbers = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>];<br><span class="hljs-title function_">add</span>(...numbers) <span class="hljs-comment">// 3</span><br></code></pre></td></tr></table></figure><ul><li><strong>复制数组</strong></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> arr1 = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>];<br><span class="hljs-keyword">const</span> arr2 = [...arr1];<br></code></pre></td></tr></table></figure><p>要记住：<strong>扩展运算符(…)用于取出参数对象中的所有可遍历属性，拷贝到当前对象之中</strong>，这里参数对象是个数组，数组里面的所有对象都是基础数据类型，将所有基础数据类型重新拷贝到新的数组中。</p><ul><li><strong>合并数组</strong></li></ul><p>如果想在数组内合并数组，可以这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> arr1 = [<span class="hljs-string">&#x27;two&#x27;</span>, <span class="hljs-string">&#x27;three&#x27;</span>];<span class="hljs-keyword">const</span> arr2 = [<span class="hljs-string">&#x27;one&#x27;</span>, ...arr1, <span class="hljs-string">&#x27;four&#x27;</span>, <span class="hljs-string">&#x27;five&#x27;</span>];<span class="hljs-comment">// [&quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;, &quot;five&quot;]</span><br></code></pre></td></tr></table></figure><ul><li><strong>扩展运算符与解构赋值结合起来，用于生成数组</strong></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> [first, ...rest] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];first <span class="hljs-comment">// 1rest  // [2, 3, 4, 5]</span><br></code></pre></td></tr></table></figure><p>需要注意：<strong>如果将扩展运算符用于数组赋值，只能放在参数的最后一位，否则会报错。</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> [...rest, last] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];         <span class="hljs-comment">// 报错const [first, ...rest, last] = [1, 2, 3, 4, 5];  // 报错</span><br></code></pre></td></tr></table></figure><ul><li><strong>将字符串转为真正的数组</strong></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">[...<span class="hljs-string">&#x27;hello&#x27;</span>]    <span class="hljs-comment">// [ &quot;h&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot; ]</span><br></code></pre></td></tr></table></figure><ul><li><strong>任何 Iterator 接口的对象，都可以用扩展运算符转为真正的数组</strong></li></ul><p>比较常见的应用是可以将某些数据结构转为数组：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// arguments对象</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> args = [...<span class="hljs-variable language_">arguments</span>];<br>&#125;<br></code></pre></td></tr></table></figure><p>用于替换<code>es5</code>中的<code>Array.prototype.slice.call(arguments)</code>写法。</p><ul><li><strong>使用</strong><code>Math</code><strong>函数获取数组中特定的值</strong></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> numbers = [<span class="hljs-number">9</span>, <span class="hljs-number">4</span>, <span class="hljs-number">7</span>, <span class="hljs-number">1</span>];<br><span class="hljs-title class_">Math</span>.<span class="hljs-title function_">min</span>(...numbers); <span class="hljs-comment">// 1</span><br><span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(...numbers); <span class="hljs-comment">// 9</span><br></code></pre></td></tr></table></figure><h3 id="7-Proxy-可以实现什么功能？"><a href="#7-Proxy-可以实现什么功能？" class="headerlink" title="7. Proxy 可以实现什么功能？"></a>7. Proxy 可以实现什么功能？</h3><p>在 Vue3.0 中通过 <code>Proxy</code> 来替换原本的 <code>Object.defineProperty</code> 来实现数据响应式。</p><p>Proxy 是 ES6 中新增的功能，它可以用来自定义对象中的操作。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(target, handler)<br></code></pre></td></tr></table></figure><p><code>target</code> 代表需要添加代理的对象，<code>handler</code> 用来自定义对象中的操作，比如可以用来自定义 <code>set</code> 或者 <code>get</code> 函数。</p><p>下面来通过 <code>Proxy</code> 来实现一个数据响应式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> <span class="hljs-title function_">onWatch</span> = (<span class="hljs-params">obj, setBind, getLogger</span>) =&gt; &#123;<br>  <span class="hljs-keyword">let</span> handler = &#123;<br>    <span class="hljs-title function_">get</span>(<span class="hljs-params">target, property, receiver</span>) &#123;<br>      <span class="hljs-title function_">getLogger</span>(target, property)<br>      <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">get</span>(target, property, receiver)<br>    &#125;,<br>    <span class="hljs-title function_">set</span>(<span class="hljs-params">target, property, value, receiver</span>) &#123;<br>      <span class="hljs-title function_">setBind</span>(value, property)<br>      <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">set</span>(target, property, value)<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(obj, handler)<br>&#125;<br><span class="hljs-keyword">let</span> obj = &#123; <span class="hljs-attr">a</span>: <span class="hljs-number">1</span> &#125;<br><span class="hljs-keyword">let</span> p = <span class="hljs-title function_">onWatch</span>(<br>  obj,<br>  <span class="hljs-function">(<span class="hljs-params">v, property</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`监听到属性<span class="hljs-subst">$&#123;property&#125;</span>改变为<span class="hljs-subst">$&#123;v&#125;</span>`</span>)<br>  &#125;,<br>  <span class="hljs-function">(<span class="hljs-params">target, property</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`&#x27;<span class="hljs-subst">$&#123;property&#125;</span>&#x27; = <span class="hljs-subst">$&#123;target[property]&#125;</span>`</span>)<br>  &#125;<br>)<br>p.<span class="hljs-property">a</span> = <span class="hljs-number">2</span> <span class="hljs-comment">// 监听到属性a改变</span><br>p.<span class="hljs-property">a</span> <span class="hljs-comment">// &#x27;a&#x27; = 2</span><br></code></pre></td></tr></table></figure><p>在上述代码中，通过自定义 <code>set</code> 和 <code>get</code> 函数的方式，在原本的逻辑中插入了我们的函数逻辑，实现了在对对象任何属性进行读写时发出通知。</p><p>当然这是简单版的响应式实现，如果需要实现一个 Vue 中的响应式，需要在 <code>get</code> 中收集依赖，在 <code>set</code> 派发更新，之所以 Vue3.0 要使用 <code>Proxy</code> 替换原本的 API 原因在于 <code>Proxy</code> 无需一层层递归为每个属性添加代理，一次即可完成以上操作，性能上更好，并且原本的实现有一些数据更新不能监听到，但是 <code>Proxy</code> 可以完美监听到任何方式的数据改变，唯一缺陷就是浏览器的兼容性不好。</p><h3 id="8-对对象与数组的解构的理解"><a href="#8-对对象与数组的解构的理解" class="headerlink" title="8. 对对象与数组的解构的理解"></a>8. 对对象与数组的解构的理解</h3><p>解构是 ES6 提供的一种新的提取数据的模式，这种模式能够从对象或数组里有针对性地拿到想要的数值。<br><strong>1）数组的解构</strong><br>在解构数组时，以元素的位置为匹配条件来提取想要的数据的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> [a, b, c] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br></code></pre></td></tr></table></figure><p>最终，a、b、c分别被赋予了数组第0、1、2个索引位的值：<br><img src="4.png" alt="img"><br>数组里的0、1、2索引位的元素值，精准地被映射到了左侧的第0、1、2个变量里去，这就是数组解构的工作模式。还可以通过给左侧变量数组设置空占位的方式，实现对数组中某几个元素的精准提取：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> [a,,c] = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<br></code></pre></td></tr></table></figure><p>通过把中间位留空，可以顺利地把数组第一位和最后一位的值赋给 a、c 两个变量：<br><img src="5.png" alt="img"></p><p><strong>2）对象的解构</strong><br>对象解构比数组结构稍微复杂一些，也更显强大。在解构对象时，是以属性的名称为匹配条件，来提取想要的数据的。现在定义一个对象：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> stu = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Bob&#x27;</span>,<br>  <span class="hljs-attr">age</span>: <span class="hljs-number">24</span><br>&#125;<br></code></pre></td></tr></table></figure><p>假如想要解构它的两个自有属性，可以这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> &#123; name, age &#125; = stu<br></code></pre></td></tr></table></figure><p>这样就得到了 name 和 age 两个和 stu 平级的变量：<br><img src="6.png" alt="img"></p><p>注意，对象解构严格以属性名作为定位依据，所以就算调换了 name 和 age 的位置，结果也是一样的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> &#123; age, name &#125; = stu<br></code></pre></td></tr></table></figure><h3 id="9-如何提取高度嵌套的对象里的指定属性？"><a href="#9-如何提取高度嵌套的对象里的指定属性？" class="headerlink" title="9. 如何提取高度嵌套的对象里的指定属性？"></a>9. <strong>如何提取高度嵌套的对象里的指定属性？</strong></h3><p>有时会遇到一些嵌套程度非常深的对象：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> school = &#123;<br>   <span class="hljs-attr">classes</span>: &#123;<br>      <span class="hljs-attr">stu</span>: &#123;<br>         <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Bob&#x27;</span>,<br>         <span class="hljs-attr">age</span>: <span class="hljs-number">24</span>,<br>      &#125;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>像此处的 name 这个变量，嵌套了四层，此时如果仍然尝试老方法来提取它：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> &#123; name &#125; = school<br></code></pre></td></tr></table></figure><p>显然是不奏效的，因为 school 这个对象本身是没有 name 这个属性的，name 位于 school 对象的“儿子的儿子”对象里面。要想把 name 提取出来，一种比较笨的方法是逐层解构：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> &#123; classes &#125; = school<br><span class="hljs-keyword">const</span> &#123; stu &#125; = classes<br><span class="hljs-keyword">const</span> &#123; name &#125; = stu<br>name <span class="hljs-comment">// &#x27;Bob&#x27;</span><br></code></pre></td></tr></table></figure><p>但是还有一种更标准的做法，可以用一行代码来解决这个问题：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> &#123; <span class="hljs-attr">classes</span>: &#123; <span class="hljs-attr">stu</span>: &#123; name &#125; &#125;&#125; = school<br>       <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(name)  <span class="hljs-comment">// &#x27;Bob&#x27;</span><br></code></pre></td></tr></table></figure><p>可以在解构出来的变量名右侧，通过冒号+{目标属性名}这种形式，进一步解构它，一直解构到拿到目标数据为止。</p><h3 id="10-对-rest-参数的理解"><a href="#10-对-rest-参数的理解" class="headerlink" title="10. 对 rest 参数的理解"></a>10. 对 rest 参数的理解</h3><p>扩展运算符被用在函数形参上时，<strong>它还可以把一个分离的参数序列整合成一个数组</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">mutiple</span>(<span class="hljs-params">...args</span>) &#123;<br>  <span class="hljs-keyword">let</span> result = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> val <span class="hljs-keyword">of</span> args) &#123;<br>    result *= val;<br>  &#125;<br>  <span class="hljs-keyword">return</span> result;<br>&#125;<br><span class="hljs-title function_">mutiple</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>) <span class="hljs-comment">// 24</span><br></code></pre></td></tr></table></figure><p>这里，传入 mutiple 的是四个分离的参数，但是如果在 mutiple 函数里尝试输出 args 的值，会发现它是一个数组：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">mutiple</span>(<span class="hljs-params">...args</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(args)<br>&#125;<br><span class="hljs-title function_">mutiple</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>) <span class="hljs-comment">// [1, 2, 3, 4]</span><br></code></pre></td></tr></table></figure><p>这就是 … rest运算符的又一层威力了，它可以把函数的多个入参收敛进一个数组里。这一点<strong>经常用于获取函数的多余参数，或者像上面这样处理函数参数个数不确定的情况。</strong></p><h3 id="11-ES6中模板语法与字符串处理"><a href="#11-ES6中模板语法与字符串处理" class="headerlink" title="11. ES6中模板语法与字符串处理"></a>11. ES6中模板语法与字符串处理</h3><p>ES6 提出了“模板语法”的概念。在 ES6 以前，拼接字符串是很麻烦的事情：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> name = <span class="hljs-string">&#x27;css&#x27;</span>   <br><span class="hljs-keyword">var</span> career = <span class="hljs-string">&#x27;coder&#x27;</span> <br><span class="hljs-keyword">var</span> hobby = [<span class="hljs-string">&#x27;coding&#x27;</span>, <span class="hljs-string">&#x27;writing&#x27;</span>]<br><span class="hljs-keyword">var</span> finalString = <span class="hljs-string">&#x27;my name is &#x27;</span> + name + <span class="hljs-string">&#x27;, I work as a &#x27;</span> + career + <span class="hljs-string">&#x27;, I love &#x27;</span> + hobby[<span class="hljs-number">0</span>] + <span class="hljs-string">&#x27; and &#x27;</span> + hobby[<span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><p>仅仅几个变量，写了这么多加号，还要时刻小心里面的空格和标点符号有没有跟错地方。但是有了模板字符串，拼接难度直线下降：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> name = <span class="hljs-string">&#x27;css&#x27;</span>   <br><span class="hljs-keyword">var</span> career = <span class="hljs-string">&#x27;coder&#x27;</span> <br><span class="hljs-keyword">var</span> hobby = [<span class="hljs-string">&#x27;coding&#x27;</span>, <span class="hljs-string">&#x27;writing&#x27;</span>]<br><span class="hljs-keyword">var</span> finalString = <span class="hljs-string">`my name is <span class="hljs-subst">$&#123;name&#125;</span>, I work as a <span class="hljs-subst">$&#123;career&#125;</span> I love <span class="hljs-subst">$&#123;hobby[<span class="hljs-number">0</span>]&#125;</span> and <span class="hljs-subst">$&#123;hobby[<span class="hljs-number">1</span>]&#125;</span>`</span><br></code></pre></td></tr></table></figure><p>字符串不仅更容易拼了，也更易读了，代码整体的质量都变高了。这就是模板字符串的第一个优势——允许用${}的方式嵌入变量。但这还不是问题的关键，模板字符串的关键优势有两个：</p><ul><li>在模板字符串中，空格、缩进、换行都会被保留</li><li>模板字符串完全支持“运算”式的表达式，可以在${}里完成一些计算</li></ul><p>基于第一点，可以在模板字符串里无障碍地直接写 html 代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> list = <span class="hljs-string">`</span><br><span class="hljs-string">&lt;ul&gt;</span><br><span class="hljs-string">&lt;li&gt;列表项1&lt;/li&gt;</span><br><span class="hljs-string">&lt;li&gt;列表项2&lt;/li&gt;</span><br><span class="hljs-string">&lt;/ul&gt;</span><br><span class="hljs-string">`</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(message); <span class="hljs-comment">// 正确输出，不存在报错</span><br></code></pre></td></tr></table></figure><p>基于第二点，可以把一些简单的计算和调用丢进 ${} 来做：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">a, b</span>) &#123;<br>  <span class="hljs-keyword">const</span> finalString = <span class="hljs-string">`<span class="hljs-subst">$&#123;a&#125;</span> + <span class="hljs-subst">$&#123;b&#125;</span> = <span class="hljs-subst">$&#123;a+b&#125;</span>`</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(finalString)<br>&#125;<br><span class="hljs-title function_">add</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>) <span class="hljs-comment">// 输出 &#x27;1 + 2 = 3&#x27;</span><br></code></pre></td></tr></table></figure><p>除了模板语法外， ES6中还新增了一系列的字符串方法用于提升开发效率：</p><p>（1）<strong>存在性判定</strong>：在过去，当判断一个字符&#x2F;字符串是否在某字符串中时，只能用 indexOf &gt; -1 来做。现在 ES6 提供了三个方法：includes、startsWith、endsWith，它们都会返回一个布尔值来告诉你是否存在。</p><ul><li><strong>includes</strong>：判断字符串与子串的包含关系：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> son = <span class="hljs-string">&#x27;haha&#x27;</span> <br><span class="hljs-keyword">const</span> father = <span class="hljs-string">&#x27;xixi haha hehe&#x27;</span><br>father.<span class="hljs-title function_">includes</span>(son) <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><ul><li><strong>startsWith</strong>：判断字符串是否以某个&#x2F;某串字符开头：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> father = <span class="hljs-string">&#x27;xixi haha hehe&#x27;</span><br>father.<span class="hljs-title function_">startsWith</span>(<span class="hljs-string">&#x27;haha&#x27;</span>) <span class="hljs-comment">// false</span><br>father.<span class="hljs-title function_">startsWith</span>(<span class="hljs-string">&#x27;xixi&#x27;</span>) <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><ul><li><strong>endsWith</strong>：判断字符串是否以某个&#x2F;某串字符结尾：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> father = <span class="hljs-string">&#x27;xixi haha hehe&#x27;</span><br>  father.<span class="hljs-title function_">endsWith</span>(<span class="hljs-string">&#x27;hehe&#x27;</span>) <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>（2）<strong>自动重复</strong>：可以使用 repeat 方法来使同一个字符串输出多次（被连续复制多次）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> sourceCode = <span class="hljs-string">&#x27;repeat for 3 times;&#x27;</span><br><span class="hljs-keyword">const</span> repeated = sourceCode.<span class="hljs-title function_">repeat</span>(<span class="hljs-number">3</span>) <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(repeated) <span class="hljs-comment">// repeat for 3 times;repeat for 3 times;repeat for 3 times;</span><br></code></pre></td></tr></table></figure><h2 id="三、JavaScript基础"><a href="#三、JavaScript基础" class="headerlink" title="三、JavaScript基础"></a>三、JavaScript基础</h2><h3 id="1-new操作符的实现原理"><a href="#1-new操作符的实现原理" class="headerlink" title="1. new操作符的实现原理"></a>1. new操作符的实现原理</h3><p><strong>new操作符的执行过程：</strong></p><p>（1）首先创建了一个新的空对象</p><p>（2）设置原型，将对象的原型设置为函数的 prototype 对象。</p><p>（3）让函数的 this 指向这个对象，执行构造函数的代码（为这个新对象添加属性）</p><p>（4）判断函数的返回值类型，如果是值类型，返回创建的对象。如果是引用类型，就返回这个引用类型的对象。</p><p>具体实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">objectFactory</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">let</span> newObject = <span class="hljs-literal">null</span>;<br>  <span class="hljs-keyword">let</span> constructor = <span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">shift</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">arguments</span>);<br>  <span class="hljs-keyword">let</span> result = <span class="hljs-literal">null</span>;<br>  <span class="hljs-comment">// 判断参数是否是一个函数</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> constructor !== <span class="hljs-string">&quot;function&quot;</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&quot;type error&quot;</span>);<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>  <span class="hljs-comment">// 新建一个空对象，对象的原型为构造函数的 prototype 对象</span><br>  newObject = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(constructor.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>);<br>  <span class="hljs-comment">// 将 this 指向新建对象，并执行函数</span><br>  result = constructor.<span class="hljs-title function_">apply</span>(newObject, <span class="hljs-variable language_">arguments</span>);<br>  <span class="hljs-comment">// 判断返回对象</span><br>  <span class="hljs-keyword">let</span> flag = result &amp;&amp; (<span class="hljs-keyword">typeof</span> result === <span class="hljs-string">&quot;object&quot;</span> || <span class="hljs-keyword">typeof</span> result === <span class="hljs-string">&quot;function&quot;</span>);<br>  <span class="hljs-comment">// 判断返回结果</span><br>  <span class="hljs-keyword">return</span> flag ? result : newObject;<br>&#125;<br><span class="hljs-comment">// 使用方法</span><br><span class="hljs-title function_">objectFactory</span>(构造函数, 初始化参数);<br></code></pre></td></tr></table></figure><h3 id="2-map和Object的区别"><a href="#2-map和Object的区别" class="headerlink" title="2. map和Object的区别"></a>2. map和Object的区别</h3><table><thead><tr><th></th><th>Map</th><th>Object</th></tr></thead><tbody><tr><td>意外的键</td><td>Map默认情况不包含任何键，只包含显式插入的键。</td><td>Object 有一个原型, 原型链上的键名有可能和自己在对象上的设置的键名产生冲突。</td></tr><tr><td>键的类型</td><td>Map的键可以是任意值，包括函数、对象或任意基本类型。</td><td>Object 的键必须是 String 或是Symbol。</td></tr><tr><td>键的顺序</td><td>Map 中的 key 是有序的。因此，当迭代的时候， Map 对象以插入的顺序返回键值。</td><td>Object 的键是无序的</td></tr><tr><td>Size</td><td>Map 的键值对个数可以轻易地通过size 属性获取</td><td>Object 的键值对个数只能手动计算</td></tr><tr><td>迭代</td><td>Map 是 iterable 的，所以可以直接被迭代。</td><td>迭代Object需要以某种方式获取它的键然后才能迭代。</td></tr><tr><td>性能</td><td>在频繁增删键值对的场景下表现更好。</td><td>在频繁添加和删除键值对的场景下未作出优化。</td></tr></tbody></table><h3 id="3-map和weakMap的区别"><a href="#3-map和weakMap的区别" class="headerlink" title="3. map和weakMap的区别"></a>3. map和weakMap的区别</h3><p><strong>（1）Map</strong><br>map本质上就是键值对的集合，但是普通的Object中的键值对中的键只能是字符串。而ES6提供的Map数据结构类似于对象，但是它的键不限制范围，可以是任意类型，是一种更加完善的Hash结构。如果Map的键是一个原始数据类型，只要两个键严格相同，就视为是同一个键。</p><p>实际上Map是一个数组，它的每一个数据也都是一个数组，其形式如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> map = [<br>     [<span class="hljs-string">&quot;name&quot;</span>,<span class="hljs-string">&quot;张三&quot;</span>],<br>     [<span class="hljs-string">&quot;age&quot;</span>,<span class="hljs-number">18</span>],<br>]<br></code></pre></td></tr></table></figure><p>Map数据结构有以下操作方法：</p><ul><li><strong>size</strong>： <code>map.size</code> 返回Map结构的成员总数。</li><li>**set(key,value)**：设置键名key对应的键值value，然后返回整个Map结构，如果key已经有值，则键值会被更新，否则就新生成该键。（因为返回的是当前Map对象，所以可以链式调用）</li><li>**get(key)**：该方法读取key对应的键值，如果找不到key，返回undefined。</li><li>**has(key)**：该方法返回一个布尔值，表示某个键是否在当前Map对象中。</li><li>**delete(key)**：该方法删除某个键，返回true，如果删除失败，返回false。</li><li>**clear()**：map.clear()清除所有成员，没有返回值。</li></ul><p>Map结构原生提供是三个遍历器生成函数和一个遍历方法</p><ul><li>keys()：返回键名的遍历器。</li><li>values()：返回键值的遍历器。</li><li>entries()：返回所有成员的遍历器。</li><li>forEach()：遍历Map的所有成员。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>([<br>     [<span class="hljs-string">&quot;foo&quot;</span>,<span class="hljs-number">1</span>],<br>     [<span class="hljs-string">&quot;bar&quot;</span>,<span class="hljs-number">2</span>],<br>])<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> key <span class="hljs-keyword">of</span> map.<span class="hljs-title function_">keys</span>())&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(key);  <span class="hljs-comment">// foo bar</span><br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> value <span class="hljs-keyword">of</span> map.<span class="hljs-title function_">values</span>())&#123;<br>     <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value); <span class="hljs-comment">// 1 2</span><br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> items <span class="hljs-keyword">of</span> map.<span class="hljs-title function_">entries</span>())&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(items);  <span class="hljs-comment">// [&quot;foo&quot;,1]  [&quot;bar&quot;,2]</span><br>&#125;<br>map.<span class="hljs-title function_">forEach</span>( <span class="hljs-function">(<span class="hljs-params">value,key,map</span>) =&gt;</span> &#123;<br>     <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(key,value); <span class="hljs-comment">// foo 1    bar 2</span><br>&#125;)<br></code></pre></td></tr></table></figure><p><strong>（2）WeakMap</strong><br>WeakMap 对象也是一组键值对的集合，其中的键是弱引用的。<strong>其键必须是对象</strong>，原始数据类型不能作为key值，而值可以是任意的。</p><p>该对象也有以下几种方法：</p><ul><li>**set(key,value)**：设置键名key对应的键值value，然后返回整个Map结构，如果key已经有值，则键值会被更新，否则就新生成该键。（因为返回的是当前Map对象，所以可以链式调用）</li><li>**get(key)**：该方法读取key对应的键值，如果找不到key，返回undefined。</li><li>**has(key)**：该方法返回一个布尔值，表示某个键是否在当前Map对象中。</li><li>**delete(key)**：该方法删除某个键，返回true，如果删除失败，返回false。</li></ul><p>其clear()方法已经被弃用，所以可以通过创建一个空的WeakMap并替换原对象来实现清除。</p><p>WeakMap的设计目的在于，有时想在某个对象上面存放一些数据，但是这会形成对于这个对象的引用。一旦不再需要这两个对象，就必须手动删除这个引用，否则垃圾回收机制就不会释放对象占用的内存。</p><p>而WeakMap的<strong>键名所引用的对象都是弱引用</strong>，即垃圾回收机制不将该引用考虑在内。因此，只要所引用的对象的其他引用都被清除，垃圾回收机制就会释放该对象所占用的内存。也就是说，一旦不再需要，WeakMap 里面的<strong>键名对象和所对应的键值对会自动消失，不用手动删除引用</strong>。</p><p><strong>总结：</strong></p><ul><li>Map 数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。</li><li>WeakMap 结构与 Map 结构类似，也是用于生成键值对的集合。但是 WeakMap 只接受对象作为键名（ null 除外），不接受其他类型的值作为键名。而且 WeakMap 的键名所指向的对象，不计入垃圾回收机制。</li></ul><h3 id="4-JavaScript有哪些内置对象"><a href="#4-JavaScript有哪些内置对象" class="headerlink" title="4. JavaScript有哪些内置对象"></a>4. JavaScript有哪些内置对象</h3><p>全局的对象（ global objects ）或称标准内置对象，不要和 “全局对象（global object）” 混淆。这里说的全局的对象是说在<br>全局作用域里的对象。全局作用域中的其他对象可以由用户的脚本创建或由宿主程序提供。</p><p><strong>标准内置对象的分类：</strong></p><p>（1）值属性，这些全局属性返回一个简单值，这些值没有自己的属性和方法。例如 Infinity、NaN、undefined、null 字面量</p><p>（2）函数属性，全局函数可以直接调用，不需要在调用时指定所属对象，执行结束后会将结果直接返回给调用者。例如 eval()、parseFloat()、parseInt() 等</p><p>（3）基本对象，基本对象是定义或使用其他对象的基础。基本对象包括一般对象、函数对象和错误对象。例如 Object、Function、Boolean、Symbol、Error 等</p><p>（4）数字和日期对象，用来表示数字、日期和执行数学计算的对象。例如 Number、Math、Date</p><p>（5）字符串，用来表示和操作字符串的对象。例如 String、RegExp</p><p>（6）可索引的集合对象，这些对象表示按照索引值来排序的数据集合，包括数组和类型数组，以及类数组结构的对象。例如 Array</p><p>（7）使用键的集合对象，这些集合对象在存储数据时会使用到键，支持按照插入顺序来迭代元素。<br>例如 Map、Set、WeakMap、WeakSet</p><p>（8）矢量集合，SIMD 矢量集合中的数据会被组织为一个数据序列。<br>例如 SIMD 等</p><p>（9）结构化数据，这些对象用来表示和操作结构化的缓冲区数据，或使用 JSON 编码的数据。例如 JSON 等</p><p>（10）控制抽象对象<br>例如 Promise、Generator 等</p><p>（11）反射。例如 Reflect、Proxy</p><p>（12）国际化，为了支持多语言处理而加入 ECMAScript 的对象。例如 Intl、Intl.Collator 等</p><p>（13）WebAssembly</p><p>（14）其他。例如 arguments</p><p><strong>总结：</strong><br>js 中的内置对象主要指的是在程序执行前存在全局作用域里的由 js 定义的一些全局值属性、函数和用来实例化其他对象的构造函数对象。一般经常用到的如全局变量值 NaN、undefined，全局函数如 parseInt()、parseFloat() 用来实例化对象的构造函数如 Date、Object 等，还有提供数学计算的单体内置对象如 Math 对象。</p><h3 id="5-常用的正则表达式有哪些？"><a href="#5-常用的正则表达式有哪些？" class="headerlink" title="5. 常用的正则表达式有哪些？"></a>5. 常用的正则表达式有哪些？</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// （1）匹配 16 进制颜色值</span><br><span class="hljs-keyword">var</span> regex = <span class="hljs-regexp">/#([0-9a-fA-F]&#123;6&#125;|[0-9a-fA-F]&#123;3&#125;)/g</span>;<br><br><span class="hljs-comment">// （2）匹配日期，如 yyyy-mm-dd 格式</span><br><span class="hljs-keyword">var</span> regex = <span class="hljs-regexp">/^[0-9]&#123;4&#125;-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])$/</span>;<br><br><span class="hljs-comment">// （3）匹配 qq 号</span><br><span class="hljs-keyword">var</span> regex = <span class="hljs-regexp">/^[1-9][0-9]&#123;4,10&#125;$/g</span>;<br><br><span class="hljs-comment">// （4）手机号码正则</span><br><span class="hljs-keyword">var</span> regex = <span class="hljs-regexp">/^1[34578]\d&#123;9&#125;$/g</span>;<br><br><span class="hljs-comment">// （5）用户名正则</span><br><span class="hljs-keyword">var</span> regex = <span class="hljs-regexp">/^[a-zA-Z\$][a-zA-Z0-9_\$]&#123;4,16&#125;$/</span>;<br></code></pre></td></tr></table></figure><h3 id="6-对JSON的理解"><a href="#6-对JSON的理解" class="headerlink" title="6. 对JSON的理解"></a>6. 对JSON的理解</h3><p>JSON 是一种基于文本的轻量级的数据交换格式。它可以被任何的编程语言读取和作为数据格式来传递。</p><p>在项目开发中，使用 JSON 作为前后端数据交换的方式。在前端通过将一个符合 JSON 格式的数据结构序列化为<br>JSON 字符串，然后将它传递到后端，后端通过 JSON 格式的字符串解析后生成对应的数据结构，以此来实现前后端数据的一个传递。</p><p>因为 JSON 的语法是基于 js 的，因此很容易将 JSON 和 js 中的对象弄混，但是应该注意的是 JSON 和 js 中的对象不是一回事，JSON 中对象格式更加严格，比如说在 JSON 中属性值不能为函数，不能出现 NaN 这样的属性值等，因此大多数的 js 对象是不符合 JSON 对象的格式的。</p><p>在 js 中提供了两个函数来实现 js 数据结构和 JSON 格式的转换处理，</p><ul><li>JSON.stringify 函数，通过传入一个符合 JSON 格式的数据结构，将其转换为一个 JSON 字符串。如果传入的数据结构不符合 JSON 格式，那么在序列化的时候会对这些值进行对应的特殊处理，使其符合规范。在前端向后端发送数据时，可以调用这个函数将数据对象转化为 JSON 格式的字符串。</li><li>JSON.parse() 函数，这个函数用来将 JSON 格式的字符串转换为一个 js 数据结构，如果传入的字符串不是标准的 JSON 格式的字符串的话，将会抛出错误。当从后端接收到 JSON 格式的字符串时，可以通过这个方法来将其解析为一个 js 数据结构，以此来进行数据的访问。</li></ul><h3 id="7-JavaScript脚本延迟加载的方式有哪些？"><a href="#7-JavaScript脚本延迟加载的方式有哪些？" class="headerlink" title="7. JavaScript脚本延迟加载的方式有哪些？"></a>7. JavaScript脚本延迟加载的方式有哪些？</h3><p>延迟加载就是等页面加载完成之后再加载 JavaScript 文件。 js 延迟加载有助于提高页面加载速度。</p><p>一般有以下几种方式：</p><ul><li><strong>defer 属性：</strong> 给 js 脚本添加 defer 属性，这个属性会让脚本的加载与文档的解析同步解析，然后在文档解析完成后再执行这个脚本文件，这样的话就能使页面的渲染不被阻塞。多个设置了 defer 属性的脚本按规范来说最后是顺序执行的，但是在一些浏览器中可能不是这样。</li><li><strong>async 属性：</strong> 给 js 脚本添加 async 属性，这个属性会使脚本异步加载，不会阻塞页面的解析过程，但是当脚本加载完成后立即执行 js 脚本，这个时候如果文档没有解析完成的话同样会阻塞。多个 async 属性的脚本的执行顺序是不可预测的，一般不会按照代码的顺序依次执行。</li><li><strong>动态创建 DOM 方式：</strong> 动态创建 DOM 标签的方式，可以对文档的加载事件进行监听，当文档加载完成后再动态的创建 script 标签来引入 js 脚本。</li><li><strong>使用 setTimeout 延迟方法：</strong> 设置一个定时器来延迟加载js脚本文件</li><li><strong>让 JS 最后加载：</strong> 将 js 脚本放在文档的底部，来使 js 脚本尽可能的在最后来加载执行。</li></ul><h3 id="8-JavaScript-类数组对象的定义？"><a href="#8-JavaScript-类数组对象的定义？" class="headerlink" title="8. JavaScript 类数组对象的定义？"></a>8. JavaScript 类数组对象的定义？</h3><p>一个拥有 length 属性和若干索引属性的对象就可以被称为类数组对象，类数组对象和数组类似，但是不能调用数组的方法。常见的类数组对象有 arguments 和 DOM 方法的返回结果，还有一个函数也可以被看作是类数组对象，因为它含有 length 属性值，代表可接收的参数个数。</p><p>常见的类数组转换为数组的方法有这样几种：</p><p>（1）通过 call 调用数组的 slice 方法来实现转换</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">slice</span>.<span class="hljs-title function_">call</span>(arrayLike);<br></code></pre></td></tr></table></figure><p>（2）通过 call 调用数组的 splice 方法来实现转换</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">splice</span>.<span class="hljs-title function_">call</span>(arrayLike, <span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><p>（3）通过 apply 调用数组的 concat 方法来实现转换</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">concat</span>.<span class="hljs-title function_">apply</span>([], arrayLike);<br></code></pre></td></tr></table></figure><p>（4）通过 Array.from 方法来实现转换</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(arrayLike);<br></code></pre></td></tr></table></figure><h3 id="9-数组有哪些原生方法？"><a href="#9-数组有哪些原生方法？" class="headerlink" title="9. 数组有哪些原生方法？"></a>9. 数组有哪些原生方法？</h3><ul><li>数组和字符串的转换方法：toString()、toLocalString()、join() 其中 join() 方法可以指定转换为字符串时的分隔符。</li><li>数组尾部操作的方法 pop() 和 push()，push 方法可以传入多个参数。</li><li>数组首部操作的方法 shift() 和 unshift() 重排序的方法 reverse() 和 sort()，sort() 方法可以传入一个函数来进行比较，传入前后两个值，如果返回值为正数，则交换两个参数的位置。</li><li>数组连接的方法 concat() ，返回的是拼接好的数组，不影响原数组。</li><li>数组截取办法 slice()，用于截取数组中的一部分返回，不影响原数组。</li><li>数组插入方法 splice()，影响原数组查找特定项的索引的方法，indexOf() 和 lastIndexOf() 迭代方法 every()、some()、filter()、map() 和 forEach() 方法</li><li>数组归并方法 reduce() 和 reduceRight() 方法</li></ul><h3 id="10-Unicode、UTF-8、UTF-16、UTF-32的区别？"><a href="#10-Unicode、UTF-8、UTF-16、UTF-32的区别？" class="headerlink" title="10. Unicode、UTF-8、UTF-16、UTF-32的区别？"></a>10. <strong>Unicode、UTF-8、UTF-16、UTF-32的区别？</strong></h3><h4 id="（1）Unicode"><a href="#（1）Unicode" class="headerlink" title="（1）Unicode"></a>（1）Unicode</h4><p>在说<code>Unicode</code>之前需要先了解一下<code>ASCII</code>码：ASCII 码（<code>American Standard Code for Information Interchange</code>）称为美国标准信息交换码。</p><ul><li>它是基于拉丁字母的一套电脑编码系统。</li><li>它定义了一个用于代表常见字符的字典。</li><li>它包含了”A-Z”(包含大小写)，数据”0-9” 以及一些常见的符号。</li><li>它是专门为英语而设计的，有128个编码，对其他语言无能为力</li></ul><p><code>ASCII</code>码可以表示的编码有限，要想表示其他语言的编码，还是要使用<code>Unicode</code>来表示，可以说<code>Unicode</code>是<code>ASCII</code> 的超集。</p><p><code>Unicode</code>全称 <code>Unicode Translation Format</code>，又叫做统一码、万国码、单一码。<code>Unicode</code> 是为了解决传统的字符编码方案的局限而产生的，它为每种语言中的每个字符设定了统一并且唯一的二进制编码，以满足跨语言、跨平台进行文本转换、处理的要求。</p><p><code>Unicode</code>的实现方式（也就是编码方式）有很多种，常见的是<strong>UTF-8</strong>、<strong>UTF-16</strong>、<strong>UTF-32</strong>和<strong>USC-2</strong>。</p><h4 id="（2）UTF-8"><a href="#（2）UTF-8" class="headerlink" title="（2）UTF-8"></a>（2）UTF-8</h4><p><code>UTF-8</code>是使用最广泛的<code>Unicode</code>编码方式，它是一种可变长的编码方式，可以是1—4个字节不等，它可以完全兼容<code>ASCII</code>码的128个字符。</p><p><strong>注意：</strong> <code>UTF-8</code> 是一种编码方式，<code>Unicode</code>是一个字符集合。</p><p><code>UTF-8</code>的编码规则：</p><ul><li>对于<strong>单字节</strong>的符号，字节的第一位为0，后面的7位为这个字符的<code>Unicode</code>编码，因此对于英文字母，它的<code>Unicode</code>编码和<code>ACSII</code>编码一样。</li><li>对于<strong>n字节</strong>的符号，第一个字节的前n位都是1，第n+1位设为0，后面字节的前两位一律设为10，剩下的没有提及的二进制位，全部为这个符号的<code>Unicode</code>码 。</li></ul><p>来看一下具体的<code>Unicode</code>编号范围与对应的<code>UTF-8</code>二进制格式 ：</p><table><thead><tr><th>编码范围（编号对应的十进制数）</th><th>二进制格式</th></tr></thead><tbody><tr><td>0x00—0x7F （0-127）</td><td>0xxxxxxx</td></tr><tr><td>0x80—0x7FF （128-2047）</td><td>110xxxxx 10xxxxxx</td></tr><tr><td>0x800—0xFFFF  （2048-65535）</td><td>1110xxxx 10xxxxxx 10xxxxxx</td></tr><tr><td>0x10000—0x10FFFF  （65536以上）</td><td>11110xxx 10xxxxxx 10xxxxxx 10xxxxxx</td></tr></tbody></table><p>那该如何通过具体的<code>Unicode</code>编码，进行具体的<code>UTF-8</code>编码呢？<strong>步骤如下：</strong></p><ul><li>找到该<code>Unicode</code>编码的所在的编号范围，进而找到与之对应的二进制格式</li><li>将<code>Unicode</code>编码转换为二进制数（去掉最高位的0）</li><li>将二进制数从右往左一次填入二进制格式的<code>X</code>中，如果有<code>X</code>未填，就设为0</li></ul><p>来看一个实际的例子：<br>“<strong>马</strong>” 字的<code>Unicode</code>编码是：<code>0x9A6C</code>，整数编号是<code>39532</code><br>（1）首选确定了该字符在第三个范围内，它的格式是 <code>1110xxxx 10xxxxxx 10xxxxxx</code><br>（2）39532对应的二进制数为<code>1001 1010 0110 1100</code><br>（3）将二进制数填入X中，结果是：<code>11101001 10101001 10101100</code></p><h4 id="（3）UTF-16"><a href="#（3）UTF-16" class="headerlink" title="（3）UTF-16"></a>（3）UTF-16</h4><p><strong>1. 平面的概念</strong></p><p>在了解<code>UTF-16</code>之前，先看一下<strong>平面</strong>的概念：<br><code>Unicode</code>编码中有很多很多的字符，它并不是一次性定义的，而是分区进行定义的，每个区存放<strong>65536</strong>（216）个字符，这称为一个<strong>平面</strong>，目前总共有17 个平面。</p><p>最前面的一个平面称为<strong>基本平面</strong>，它的码点从<strong>0 — 216-1</strong>，写成16进制就是<code>U+0000 — U+FFFF</code>，那剩下的16个平面就是<strong>辅助平面</strong>，码点范围是 <code>U+10000—U+10FFFF</code>。</p><p><strong>2. UTF-16 概念：</strong></p><p><code>UTF-16</code>也是<code>Unicode</code>编码集的一种编码形式，把<code>Unicode</code>字符集的抽象码位映射为16位长的整数（即码元）的序列，用于数据存储或传递。<code>Unicode</code>字符的码位需要1个或者2个16位长的码元来表示，因此<code>UTF-16</code>也是用变长字节表示的。</p><p><strong>3. UTF-16 编码规则：</strong></p><ul><li>编号在 <code>U+0000—U+FFFF</code> 的字符（常用字符集），直接用两个字节表示。</li><li>编号在 <code>U+10000—U+10FFFF</code> 之间的字符，需要用四个字节表示。</li></ul><p><strong>4. 编码识别</strong></p><p>那么问题来了，当遇到两个字节时，怎么知道是把它当做一个字符还是和后面的两个字节一起当做一个字符呢？</p><p><code>UTF-16</code> 编码肯定也考虑到了这个问题，在基本平面内，从 <code>U+D800 — U+DFFF</code> 是一个空段，也就是说这个区间的码点不对应任何的字符，因此这些空段就可以用来映射辅助平面的字符。</p><p>辅助平面共有 <strong>220</strong> 个字符位，因此表示这些字符至少需要 20 个二进制位。<code>UTF-16</code> 将这 20 个二进制位分成两半，前 10 位映射在 <code>U+D800 — U+DBFF</code>，称为<strong>高位</strong>（H），后 10 位映射在 <code>U+DC00 — U+DFFF</code>，称为<strong>低位</strong>（L）。这就相当于，将一个辅助平面的字符拆成了两个基本平面的字符来表示。</p><p>因此，当遇到两个字节时，发现它的码点在 <code>U+D800 —U+DBFF</code>之间，就可以知道，它后面的两个字节的码点应该在 <code>U+DC00 — U+DFFF</code> 之间，这四个字节必须放在一起进行解读。</p><p><strong>5. 举例说明</strong></p><p>以 “<strong>𡠀</strong>“ 字为例，它的 <code>Unicode</code> 码点为 <code>0x21800</code>，该码点超出了基本平面的范围，因此需要用四个字节来表示，步骤如下：</p><ul><li>首先计算超出部分的结果：<code>0x21800 - 0x10000</code></li><li>将上面的计算结果转为20位的二进制数，不足20位就在前面补0，结果为：<code>0001000110 0000000000</code></li><li>将得到的两个10位二进制数分别对应到两个区间中</li><li><code>U+D800</code> 对应的二进制数为 <code>1101100000000000</code>， 将<code>0001000110</code>填充在它的后10 个二进制位，得到 <code>1101100001000110</code>，转成 16 进制数为 <code>0xD846</code>。同理，低位为 <code>0xDC00</code>，所以这个字的<code>UTF-16</code> 编码为 <code>0xD846 0xDC00</code></li></ul><h4 id="（4）-UTF-32"><a href="#（4）-UTF-32" class="headerlink" title="（4） UTF-32"></a>（4） UTF-32</h4><p><code>UTF-32</code> 就是字符所对应编号的整数二进制形式，每个字符占四个字节，这个是直接进行转换的。该编码方式占用的储存空间较多，所以使用较少。</p><p>比如“<strong>马</strong>” 字的Unicode编号是：<code>U+9A6C</code>，整数编号是<code>39532</code>，直接转化为二进制：<code>1001 1010 0110 1100</code>，这就是它的UTF-32编码。</p><h4 id="（5）总结"><a href="#（5）总结" class="headerlink" title="（5）总结"></a>（5）总结</h4><p><strong>Unicode、UTF-8、UTF-16、UTF-32有什么区别？</strong></p><ul><li><code>Unicode</code> 是编码字符集（字符集），而<code>UTF-8</code>、<code>UTF-16</code>、<code>UTF-32</code>是字符集编码（编码规则）；</li><li><code>UTF-16</code> 使用变长码元序列的编码方式，相较于定长码元序列的<code>UTF-32</code>算法更复杂，甚至比同样是变长码元序列的<code>UTF-8</code>也更为复杂，因为其引入了独特的<strong>代理对</strong>这样的代理机制；</li><li><code>UTF-8</code>需要判断每个字节中的开头标志信息，所以如果某个字节在传送过程中出错了，就会导致后面的字节也会解析出错；而<code>UTF-16</code>不会判断开头标志，即使错也只会错一个字符，所以容错能力教强；</li><li>如果字符内容全部英文或英文与其他文字混合，但英文占绝大部分，那么用<code>UTF-8</code>就比<code>UTF-16</code>节省了很多空间；而如果字符内容全部是中文这样类似的字符或者混合字符中中文占绝大多数，那么<code>UTF-16</code>就占优势了，可以节省很多空间；</li></ul><h3 id="11-常见的位运算符有哪些？其计算规则是什么？"><a href="#11-常见的位运算符有哪些？其计算规则是什么？" class="headerlink" title="11. 常见的位运算符有哪些？其计算规则是什么？"></a>11. 常见的位运算符有哪些？其计算规则是什么？</h3><p>现代计算机中数据都是以二进制的形式存储的，即0、1两种状态，计算机对二进制数据进行的运算加减乘除等都是叫位运算，即将符号位共同参与运算的运算。</p><p>常见的位运算有以下几种：</p><table><thead><tr><th>运算符</th><th>描述</th><th>运算规则</th></tr></thead><tbody><tr><td><code>&amp;</code></td><td>与</td><td>两个位都为1时，结果才为1</td></tr><tr><td>&#96;</td><td>&#96;</td><td>或</td></tr><tr><td><code>^</code></td><td>异或</td><td>两个位相同为0，相异为1</td></tr><tr><td><code>~</code></td><td>取反</td><td>0变1，1变0</td></tr><tr><td><code>&lt;&lt;</code></td><td>左移</td><td>各二进制位全部左移若干位，高位丢弃，低位补0</td></tr><tr><td><code>&gt;&gt;</code></td><td>右移</td><td>各二进制位全部右移若干位，正数左补0，负数左补1，右边丢弃</td></tr></tbody></table><h4 id="1-按位与运算符（-amp-）"><a href="#1-按位与运算符（-amp-）" class="headerlink" title="1. 按位与运算符（&amp;）"></a>1. 按位与运算符（&amp;）</h4><p><strong>定义：</strong> 参加运算的两个数据<strong>按二进制位</strong>进行“与”运算。<br><strong>运算规则：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-number">0</span> &amp; <span class="hljs-number">0</span> = <span class="hljs-number">0</span>  <br><span class="hljs-number">0</span> &amp; <span class="hljs-number">1</span> = <span class="hljs-number">0</span>  <br><span class="hljs-number">1</span> &amp; <span class="hljs-number">0</span> = <span class="hljs-number">0</span>  <br><span class="hljs-number">1</span> &amp; <span class="hljs-number">1</span> = <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>总结：两位同时为1，结果才为1，否则结果为0。<br>例如：3&amp;5 即：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-number">0000</span> <span class="hljs-number">0011</span> <br>   <span class="hljs-number">0000</span> <span class="hljs-number">0101</span> <br> = <span class="hljs-number">0000</span> <span class="hljs-number">0001</span><br></code></pre></td></tr></table></figure><p>因此 3&amp;5 的值为1。<br>注意：负数按补码形式参加按位与运算。</p><p><strong>用途：</strong></p><p><strong>（1）判断奇偶</strong></p><p>只要根据最未位是0还是1来决定，为0就是偶数，为1就是奇数。因此可以用<code>if ((i &amp; 1) == 0)</code>代替<code>if (i % 2 == 0)</code>来判断a是不是偶数。</p><p><strong>（2）清零</strong></p><p>如果想将一个单元清零，即使其全部二进制位为0，只要与一个各位都为零的数值相与，结果为零。</p><h4 id="2-按位或运算符（-）"><a href="#2-按位或运算符（-）" class="headerlink" title="2. 按位或运算符（|）"></a>2. 按位或运算符（|）</h4><p><strong>定义：</strong> 参加运算的两个对象按二进制位进行“或”运算。</p><p><strong>运算规则：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-number">0</span> | <span class="hljs-number">0</span> = <span class="hljs-number">0</span><br><span class="hljs-number">0</span> | <span class="hljs-number">1</span> = <span class="hljs-number">1</span>  <br><span class="hljs-number">1</span> | <span class="hljs-number">0</span> = <span class="hljs-number">1</span>  <br><span class="hljs-number">1</span> | <span class="hljs-number">1</span> = <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>总结：参加运算的两个对象只要有一个为1，其值为1。<br>例如：3|5即：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-number">0000</span> <span class="hljs-number">0011</span><br>  <span class="hljs-number">0000</span> <span class="hljs-number">0101</span> <br>= <span class="hljs-number">0000</span> <span class="hljs-number">0111</span><br></code></pre></td></tr></table></figure><p>因此，3|5的值为7。<br>注意：负数按补码形式参加按位或运算。</p><h4 id="3-异或运算符（-）"><a href="#3-异或运算符（-）" class="headerlink" title="3. 异或运算符（^）"></a>3. 异或运算符（^）</h4><p><strong>定义：</strong> 参加运算的两个数据按二进制位进行“异或”运算。</p><p><strong>运算规则：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-number">0</span> ^ <span class="hljs-number">0</span> = <span class="hljs-number">0</span>  <br><span class="hljs-number">0</span> ^ <span class="hljs-number">1</span> = <span class="hljs-number">1</span>  <br><span class="hljs-number">1</span> ^ <span class="hljs-number">0</span> = <span class="hljs-number">1</span>  <br><span class="hljs-number">1</span> ^ <span class="hljs-number">1</span> = <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>总结：参加运算的两个对象，如果两个相应位相同为0，相异为1。<br>例如：3|5即：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-number">0000</span> <span class="hljs-number">0011</span><br>  <span class="hljs-number">0000</span> <span class="hljs-number">0101</span> <br>= <span class="hljs-number">0000</span> <span class="hljs-number">0110</span><br></code></pre></td></tr></table></figure><p>因此，3^5的值为6。<br>异或运算的性质:</p><ul><li>交换律：<code>(a^b)^c == a^(b^c)</code></li><li>结合律：<code>(a + b)^c == a^b + b^c</code></li><li>对于任何数x，都有 <code>x^x=0，x^0=x</code></li><li>自反性: <code>a^b^b=a^0=a</code>;</li></ul><h4 id="4-取反运算符"><a href="#4-取反运算符" class="headerlink" title="4. 取反运算符 (~)"></a>4. 取反运算符 (~)</h4><p><strong>定义：</strong> 参加运算的一个数据按二进制进行“取反”运算。</p><p><strong>运算规则：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">~ <span class="hljs-number">1</span> = <span class="hljs-number">0</span>~ <span class="hljs-number">0</span> = <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>总结：对一个二进制数按位取反，即将0变1，1变0。<br>例如：~6 即：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-number">0000</span> <span class="hljs-number">0110</span>= <span class="hljs-number">1111</span> <span class="hljs-number">1001</span><br></code></pre></td></tr></table></figure><p>在计算机中，正数用原码表示，负数使用补码存储，首先看最高位，最高位1表示负数，0表示正数。此计算机二进制码为负数，最高位为符号位。<br>当发现按位取反为负数时，就<strong>直接取其补码</strong>，变为十进制：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-number">0000</span> <span class="hljs-number">0110</span>   = <span class="hljs-number">1111</span> <span class="hljs-number">1001</span>反码：<span class="hljs-number">1000</span> <span class="hljs-number">0110</span>补码：<span class="hljs-number">1000</span> <span class="hljs-number">0111</span><br></code></pre></td></tr></table></figure><p>因此，~6的值为-7。</p><h4 id="5-左移运算符（-lt-lt-）"><a href="#5-左移运算符（-lt-lt-）" class="headerlink" title="5. 左移运算符（&lt;&lt;）"></a>5. 左移运算符（&lt;&lt;）</h4><p><strong>定义：</strong> 将一个运算对象的各二进制位全部左移若干位，左边的二进制位丢弃，右边补0。<br>设 a&#x3D;1010 1110，a &#x3D; a&lt;&lt; 2 将a的二进制位左移2位、右补0，即得a&#x3D;1011 1000。<br>若左移时舍弃的高位不包含1，则每左移一位，相当于该数乘以2。</p><h4 id="6-右移运算符（-gt-gt-）"><a href="#6-右移运算符（-gt-gt-）" class="headerlink" title="6. 右移运算符（&gt;&gt;）"></a>6. 右移运算符（&gt;&gt;）</h4><p><strong>定义：</strong> 将一个数的各二进制位全部右移若干位，正数左补0，负数左补1，右边丢弃。<br>例如：a&#x3D;a&gt;&gt;2 将a的二进制位右移2位，左补0 或者 左补1得看被移数是正还是负。<br>操作数每右移一位，相当于该数除以2。</p><h4 id="7-原码、补码、反码"><a href="#7-原码、补码、反码" class="headerlink" title="7. 原码、补码、反码"></a>7. 原码、补码、反码</h4><p>上面提到了补码、反码等知识，这里就补充一下。<br>计算机中的<strong>有符号数</strong>有三种表示方法，即原码、反码和补码。三种表示方法均有符号位和数值位两部分，符号位都是用0表示“正”，用1表示“负”，而数值位，三种表示方法各不相同。</p><p><strong>（1）原码</strong></p><p>原码就是一个数的二进制数。例如：10的原码为0000 1010</p><p><strong>（2）反码</strong></p><ul><li>正数的反码与原码相同，如：10 反码为 0000 1010</li><li>负数的反码为除符号位，按位取反，即0变1，1变0。</li></ul><p>例如：-10</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">原码：<span class="hljs-number">1000</span> <span class="hljs-number">1010</span><br>反码：<span class="hljs-number">1111</span> <span class="hljs-number">0101</span><br></code></pre></td></tr></table></figure><p><strong>（3）补码</strong></p><ul><li>正数的补码与原码相同，如：10 补码为 0000 1010</li><li>负数的补码是原码除符号位外的所有位取反即0变1，1变0，然后加1，也就是反码加1。</li></ul><p>例如：-10</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript">原码：<span class="hljs-number">1000</span> <span class="hljs-number">1010</span><br>反码：<span class="hljs-number">1111</span> <span class="hljs-number">0101</span><br>补码：<span class="hljs-number">1111</span> <span class="hljs-number">0110</span><br></code></pre></td></tr></table></figure><h3 id="12-为什么函数的-arguments-参数是类数组而不是数组？如何遍历类数组"><a href="#12-为什么函数的-arguments-参数是类数组而不是数组？如何遍历类数组" class="headerlink" title="12. 为什么函数的 arguments 参数是类数组而不是数组？如何遍历类数组?"></a>12. 为什么函数的 arguments 参数是类数组而不是数组？如何遍历类数组?</h3><p><code>arguments</code>是一个对象，它的属性是从 0 开始依次递增的数字，还有<code>callee</code>和<code>length</code>等属性，与数组相似；但是它却没有数组常见的方法属性，如<code>forEach</code>, <code>reduce</code>等，所以叫它们类数组。</p><p>要遍历类数组，有三个方法：</p><p>（1）将数组的方法应用到类数组上，这时候就可以使用<code>call</code>和<code>apply</code>方法，如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>)&#123; <br>  <span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">forEach</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">arguments</span>, <span class="hljs-function"><span class="hljs-params">a</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a))<br>&#125;<br></code></pre></td></tr></table></figure><p>（2）使用Array.from方法将类数组转化成数组：‌</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>)&#123; <br>  <span class="hljs-keyword">const</span> arrArgs = <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(<span class="hljs-variable language_">arguments</span>) <br>  arrArgs.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">a</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a))<br>&#125;<br></code></pre></td></tr></table></figure><p>（3）使用展开运算符将类数组转化成数组</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>)&#123; <br>    <span class="hljs-keyword">const</span> arrArgs = [...<span class="hljs-variable language_">arguments</span>] <br>    arrArgs.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">a</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a)) <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="13-什么是-DOM-和-BOM？"><a href="#13-什么是-DOM-和-BOM？" class="headerlink" title="13. 什么是 DOM 和 BOM？"></a>13. 什么是 DOM 和 BOM？</h3><ul><li>DOM 指的是文档对象模型，它指的是把文档当做一个对象，这个对象主要定义了处理网页内容的方法和接口。</li><li>BOM 指的是浏览器对象模型，它指的是把浏览器当做一个对象来对待，这个对象主要定义了与浏览器进行交互的法和接口。BOM的核心是 window，而 window 对象具有双重角色，它既是通过 js 访问浏览器窗口的一个接口，又是一个 Global（全局）对象。这意味着在网页中定义的任何对象，变量和函数，都作为全局对象的一个属性或者方法存在。window 对象含有 location 对象、navigator 对象、screen 对象等子对象，并且 DOM 的最根本的对象 document 对象也是 BOM 的 window 对象的子对象。</li></ul><h3 id="14-对类数组对象的理解，如何转化为数组"><a href="#14-对类数组对象的理解，如何转化为数组" class="headerlink" title="14. 对类数组对象的理解，如何转化为数组"></a>14. 对类数组对象的理解，如何转化为数组</h3><p>一个拥有 length 属性和若干索引属性的对象就可以被称为类数组对象，类数组对象和数组类似，但是不能调用数组的方法。常见的类数组对象有 arguments 和 DOM 方法的返回结果，函数参数也可以被看作是类数组对象，因为它含有 length属性值，代表可接收的参数个数。</p><p>常见的类数组转换为数组的方法有这样几种：</p><ul><li>通过 call 调用数组的 slice 方法来实现转换</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">slice</span>.<span class="hljs-title function_">call</span>(arrayLike);<br></code></pre></td></tr></table></figure><ul><li>通过 call 调用数组的 splice 方法来实现转换</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">splice</span>.<span class="hljs-title function_">call</span>(arrayLike, <span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><ul><li>通过 apply 调用数组的 concat 方法来实现转换</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">concat</span>.<span class="hljs-title function_">apply</span>([], arrayLike);<br></code></pre></td></tr></table></figure><ul><li>通过 Array.from 方法来实现转换</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(arrayLike);<br></code></pre></td></tr></table></figure><h3 id="15-escape、encodeURI、encodeURIComponent-的区别"><a href="#15-escape、encodeURI、encodeURIComponent-的区别" class="headerlink" title="15. escape、encodeURI、encodeURIComponent 的区别"></a>15. escape、encodeURI、encodeURIComponent 的区别</h3><ul><li>encodeURI 是对整个 URI 进行转义，将 URI 中的非法字符转换为合法字符，所以对于一些在 URI 中有特殊意义的字符不会进行转义。</li><li>encodeURIComponent 是对 URI 的组成部分进行转义，所以一些特殊字符也会得到转义。</li><li>escape 和 encodeURI 的作用相同，不过它们对于 unicode 编码为 0xff 之外字符的时候会有区别，escape 是直接在字符的 unicode 编码前加上 %u，而 encodeURI 首先会将字符转换为 UTF-8 的格式，再在每个字节前加上 %。</li></ul><h3 id="16-对AJAX的理解，实现一个AJAX请求"><a href="#16-对AJAX的理解，实现一个AJAX请求" class="headerlink" title="16. 对AJAX的理解，实现一个AJAX请求"></a>16. 对AJAX的理解，实现一个AJAX请求</h3><p>AJAX是 Asynchronous JavaScript and XML 的缩写，指的是通过 JavaScript 的 异步通信，从服务器获取 XML 文档从中提取数据，再更新当前网页的对应部分，而不用刷新整个网页。</p><p>创建AJAX请求的步骤：</p><ul><li><strong>创建一个 XMLHttpRequest 对象。</strong></li><li>在这个对象上<strong>使用 open 方法创建一个 HTTP 请求</strong>，open 方法所需要的参数是请求的方法、请求的地址、是否异步和用户的认证信息。</li><li>在发起请求前，可以为这个对象<strong>添加一些信息和监听函数</strong>。比如说可以通过 setRequestHeader 方法来为请求添加头信息。还可以为这个对象添加一个状态监听函数。一个 XMLHttpRequest 对象一共有 5 个状态，当它的状态变化时会触发onreadystatechange 事件，可以通过设置监听函数，来处理请求成功后的结果。当对象的 readyState 变为 4 的时候，代表服务器返回的数据接收完成，这个时候可以通过判断请求的状态，如果状态是 2xx 或者 304 的话则代表返回正常。这个时候就可以通过 response 中的数据来对页面进行更新了。</li><li>当对象的属性和监听函数设置完成后，最后调<strong>用 sent 方法来向服务器发起请求</strong>，可以传入参数作为发送的数据体。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">SERVER_URL</span> = <span class="hljs-string">&quot;/server&quot;</span>;<br><span class="hljs-keyword">let</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>();<br><span class="hljs-comment">// 创建 Http 请求</span><br>xhr.<span class="hljs-title function_">open</span>(<span class="hljs-string">&quot;GET&quot;</span>, url, <span class="hljs-literal">true</span>);<br><span class="hljs-comment">// 设置状态监听函数</span><br>xhr.<span class="hljs-property">onreadystatechange</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">readyState</span> !== <span class="hljs-number">4</span>) <span class="hljs-keyword">return</span>;<br>  <span class="hljs-comment">// 当请求成功时</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> === <span class="hljs-number">200</span>) &#123;<br>    <span class="hljs-title function_">handle</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">response</span>);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">statusText</span>);<br>  &#125;<br>&#125;;<br><span class="hljs-comment">// 设置请求失败时的监听函数</span><br>xhr.<span class="hljs-property">onerror</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">statusText</span>);<br>&#125;;<br><span class="hljs-comment">// 设置请求头信息</span><br>xhr.<span class="hljs-property">responseType</span> = <span class="hljs-string">&quot;json&quot;</span>;<br>xhr.<span class="hljs-title function_">setRequestHeader</span>(<span class="hljs-string">&quot;Accept&quot;</span>, <span class="hljs-string">&quot;application/json&quot;</span>);<br><span class="hljs-comment">// 发送 Http 请求</span><br>xhr.<span class="hljs-title function_">send</span>(<span class="hljs-literal">null</span>);<br></code></pre></td></tr></table></figure><p>使用Promise封装AJAX：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// promise 封装实现：</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">getJSON</span>(<span class="hljs-params">url</span>) &#123;<br>  <span class="hljs-comment">// 创建一个 promise 对象</span><br>  <span class="hljs-keyword">let</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">resolve, reject</span>) &#123;<br>    <span class="hljs-keyword">let</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>();<br>    <span class="hljs-comment">// 新建一个 http 请求</span><br>    xhr.<span class="hljs-title function_">open</span>(<span class="hljs-string">&quot;GET&quot;</span>, url, <span class="hljs-literal">true</span>);<br>    <span class="hljs-comment">// 设置状态的监听函数</span><br>    xhr.<span class="hljs-property">onreadystatechange</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">readyState</span> !== <span class="hljs-number">4</span>) <span class="hljs-keyword">return</span>;<br>      <span class="hljs-comment">// 当请求成功或失败时，改变 promise 的状态</span><br>      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> === <span class="hljs-number">200</span>) &#123;<br>        <span class="hljs-title function_">resolve</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">response</span>);<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">statusText</span>));<br>      &#125;<br>    &#125;;<br>    <span class="hljs-comment">// 设置错误监听函数</span><br>    xhr.<span class="hljs-property">onerror</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">statusText</span>));<br>    &#125;;<br>    <span class="hljs-comment">// 设置响应的数据类型</span><br>    xhr.<span class="hljs-property">responseType</span> = <span class="hljs-string">&quot;json&quot;</span>;<br>    <span class="hljs-comment">// 设置请求头信息</span><br>    xhr.<span class="hljs-title function_">setRequestHeader</span>(<span class="hljs-string">&quot;Accept&quot;</span>, <span class="hljs-string">&quot;application/json&quot;</span>);<br>    <span class="hljs-comment">// 发送 http 请求</span><br>    xhr.<span class="hljs-title function_">send</span>(<span class="hljs-literal">null</span>);<br>  &#125;);<br>  <span class="hljs-keyword">return</span> promise;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="17-JavaScript为什么要进行变量提升，它导致了什么问题？"><a href="#17-JavaScript为什么要进行变量提升，它导致了什么问题？" class="headerlink" title="17. JavaScript为什么要进行变量提升，它导致了什么问题？"></a>17. JavaScript为什么要进行变量提升，它导致了什么问题？</h3><p>变量提升的表现是，无论在函数中何处位置声明的变量，好像都被提升到了函数的首部，可以在变量声明前访问到而不会报错。</p><p>造成变量声明提升的<strong>本质原因</strong>是 js 引擎在代码执行前有一个解析的过程，创建了执行上下文，初始化了一些代码执行时需要用到的对象。当访问一个变量时，会到当前执行上下文中的作用域链中去查找，而作用域链的首端指向的是当前执行上下文的变量对象，这个变量对象是执行上下文的一个属性，它包含了函数的形参、所有的函数和变量声明，这个对象的是在代码解析的时候创建的。</p><p>首先要知道，JS在拿到一个变量或者一个函数的时候，会有两步操作，即解析和执行。</p><ul><li><strong>在解析阶段</strong>，JS会检查语法，并对函数进行预编译。解析的时候会先创建一个全局执行上下文环境，先把代码中即将执行的变量、函数声明都拿出来，变量先赋值为undefined，函数先声明好可使用。在一个函数执行之前，也会创建一个函数执行上下文环境，跟全局执行上下文类似，不过函数执行上下文会多出this、arguments和函数的参数。<ul><li>全局上下文：变量定义，函数声明</li><li>函数上下文：变量定义，函数声明，this，arguments</li></ul></li><li><strong>在执行阶段</strong>，就是按照代码的顺序依次执行。</li></ul><p>那为什么会进行变量提升呢？主要有以下两个原因：</p><ul><li>提高性能</li><li>容错性更好</li></ul><p><strong>（1）提高性能</strong><br>在JS代码执行之前，会进行语法检查和预编译，并且这一操作只进行一次。这么做就是为了提高性能，如果没有这一步，那么每次执行代码前都必须重新解析一遍该变量（函数），而这是没有必要的，因为变量（函数）的代码并不会改变，解析一遍就够了。</p><p>在解析的过程中，还会为函数生成预编译代码。在预编译时，会统计声明了哪些变量、创建了哪些函数，并对函数的代码进行压缩，去除注释、不必要的空白等。这样做的好处就是每次执行函数时都可以直接为该函数分配栈空间（不需要再解析一遍去获取代码中声明了哪些变量，创建了哪些函数），并且因为代码压缩的原因，代码执行也更快了。</p><p><strong>（2）容错性更好</strong></p><p>变量提升可以在一定程度上提高JS的容错性，看下面的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">a = <span class="hljs-number">1</span>;<span class="hljs-keyword">var</span> a;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a);<br></code></pre></td></tr></table></figure><p>如果没有变量提升，这两行代码就会报错，但是因为有了变量提升，这段代码就可以正常执行。</p><p>虽然，在可以开发过程中，可以完全避免这样写，但是有时代码很复杂的时候。可能因为疏忽而先使用后定义了，这样也不会影响正常使用。由于变量提升的存在，而会正常运行。</p><p><strong>总结：</strong></p><ul><li>解析和预编译过程中的声明提升可以提高性能，让函数可以在执行时预先为变量分配栈空间</li><li>声明提升还可以提高JS代码的容错性，使一些不规范的代码也可以正常执行</li></ul><p>变量提升虽然有一些优点，但是他也会造成一定的问题，在ES6中提出了let、const来定义变量，它们就没有变量提升的机制。下面看一下变量提升可能会导致的问题：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> tmp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>();<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params"></span>)&#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(tmp);<br><span class="hljs-keyword">if</span>(<span class="hljs-literal">false</span>)&#123;<br><span class="hljs-keyword">var</span> tmp = <span class="hljs-string">&#x27;hello world&#x27;</span>;<br>&#125;<br>&#125;<br><br><span class="hljs-title function_">fn</span>();  <span class="hljs-comment">// undefined</span><br></code></pre></td></tr></table></figure><p>在这个函数中，原本是要打印出外层的tmp变量，但是因为变量提升的问题，内层定义的tmp被提到函数内部的最顶部，相当于覆盖了外层的tmp，所以打印结果为undefined。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> tmp = <span class="hljs-string">&#x27;hello world&#x27;</span>;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; tmp.<span class="hljs-property">length</span>; i++) &#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(tmp[i]);<br>&#125;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i); <span class="hljs-comment">// 11</span><br></code></pre></td></tr></table></figure><p>由于遍历时定义的i会变量提升成为一个全局变量，在函数结束之后不会被销毁，所以打印出来11。</p><h3 id="18-什么是尾调用，使用尾调用有什么好处？"><a href="#18-什么是尾调用，使用尾调用有什么好处？" class="headerlink" title="18. 什么是尾调用，使用尾调用有什么好处？"></a>18. 什么是尾调用，使用尾调用有什么好处？</h3><p>尾调用指的是函数的最后一步调用另一个函数。代码执行是基于执行栈的，所以当在一个函数里调用另一个函数时，会保留当前的执行上下文，然后再新建另外一个执行上下文加入栈中。使用尾调用的话，因为已经是函数的最后一步，所以这时可以不必再保留当前的执行上下文，从而节省了内存，这就是尾调用优化。但是 ES6 的尾调用优化只在严格模式下开启，正常模式是无效的。</p><h3 id="19-ES6模块与CommonJS模块有什么异同？"><a href="#19-ES6模块与CommonJS模块有什么异同？" class="headerlink" title="19.  ES6模块与CommonJS模块有什么异同？"></a>19.  <strong>ES6</strong>模块与<strong>CommonJS</strong>模块有什么异同？</h3><p>ES6 Module和CommonJS模块的区别： </p><ul><li>CommonJS是对模块的浅拷⻉，ES6 Module是对模块的引⽤，即ES6 Module只存只读，不能改变其值，也就是指针指向不能变，类似const；</li><li>import的接⼝是read-only（只读状态），不能修改其变量值。 即不能修改其变量的指针指向，但可以改变变量内部指针指向，可以对commonJS对重新赋值（改变指针指向），但是对ES6 Module赋值会编译报错。</li></ul><p>ES6 Module和CommonJS模块的共同点： </p><ul><li>CommonJS和ES6 Module都可以对引⼊的对象进⾏赋值，即对对象内部属性的值进⾏改变。</li></ul><h3 id="20-常见的DOM操作有哪些"><a href="#20-常见的DOM操作有哪些" class="headerlink" title="20. 常见的DOM操作有哪些"></a>20. 常见的DOM操作有哪些</h3><h4 id="1）DOM-节点的获取"><a href="#1）DOM-节点的获取" class="headerlink" title="1）DOM 节点的获取"></a>1）DOM 节点的获取</h4><p>DOM 节点的获取的API及使用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript">getElementById <span class="hljs-comment">// 按照 id 查询</span><br>getElementsByTagName <span class="hljs-comment">// 按照标签名查询</span><br>getElementsByClassName <span class="hljs-comment">// 按照类名查询</span><br>querySelectorAll <span class="hljs-comment">// 按照 css 选择器查询</span><br><br><span class="hljs-comment">// 按照 id 查询</span><br><span class="hljs-keyword">var</span> imooc = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;imooc&#x27;</span>) <span class="hljs-comment">// 查询到 id 为 imooc 的元素</span><br><span class="hljs-comment">// 按照标签名查询</span><br><span class="hljs-keyword">var</span> pList = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementsByTagName</span>(<span class="hljs-string">&#x27;p&#x27;</span>)  <span class="hljs-comment">// 查询到标签为 p 的集合</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(divList.<span class="hljs-property">length</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(divList[<span class="hljs-number">0</span>])<br><span class="hljs-comment">// 按照类名查询</span><br><span class="hljs-keyword">var</span> moocList = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementsByClassName</span>(<span class="hljs-string">&#x27;mooc&#x27;</span>) <span class="hljs-comment">// 查询到类名为 mooc 的集合</span><br><span class="hljs-comment">// 按照 css 选择器查询</span><br><span class="hljs-keyword">var</span> pList = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelectorAll</span>(<span class="hljs-string">&#x27;.mooc&#x27;</span>) <span class="hljs-comment">// 查询到类名为 mooc 的集合</span><br></code></pre></td></tr></table></figure><h4 id="2）DOM-节点的创建"><a href="#2）DOM-节点的创建" class="headerlink" title="2）DOM 节点的创建"></a>2）DOM 节点的创建</h4><p><strong>创建一个新节点，并把它添加到指定节点的后面。</strong> 已知的 HTML 结构如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>DEMO<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;container&quot;</span>&gt;</span> <br>      <span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;title&quot;</span>&gt;</span>我是标题<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>   <br>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>要求添加一个有内容的 span 节点到 id 为 title 的节点后面，做法就是：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 首先获取父节点</span><br><span class="hljs-keyword">var</span> container = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;container&#x27;</span>)<br><span class="hljs-comment">// 创建新节点</span><br><span class="hljs-keyword">var</span> targetSpan = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;span&#x27;</span>)<br><span class="hljs-comment">// 设置 span 节点的内容</span><br>targetSpan.<span class="hljs-property">innerHTML</span> = <span class="hljs-string">&#x27;hello world&#x27;</span><br><span class="hljs-comment">// 把新创建的元素塞进父节点里去</span><br>container.<span class="hljs-title function_">appendChild</span>(targetSpan)<br></code></pre></td></tr></table></figure><h4 id="3）DOM-节点的删除"><a href="#3）DOM-节点的删除" class="headerlink" title="3）DOM 节点的删除"></a>3）DOM 节点的删除</h4><p><strong>删除指定的 DOM 节点，</strong> 已知的 HTML 结构如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;html&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>DEMO<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span></span><br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;container&quot;</span>&gt;</span> </span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;title&quot;</span>&gt;</span>我是标题<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>   </span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></span><br>&lt;/html&gt;<br></code></pre></td></tr></table></figure><p>需要删除 id 为 title 的元素，做法是：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 获取目标元素的父元素</span><br><span class="hljs-keyword">var</span> container = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;container&#x27;</span>)<br><span class="hljs-comment">// 获取目标元素</span><br><span class="hljs-keyword">var</span> targetNode = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;title&#x27;</span>)<br><span class="hljs-comment">// 删除目标元素</span><br>container.<span class="hljs-title function_">removeChild</span>(targetNode)<br></code></pre></td></tr></table></figure><p>或者通过子节点数组来完成删除：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 获取目标元素的父元素var container = document.getElementById(&#x27;container&#x27;)// 获取目标元素var targetNode = container.childNodes[1]// 删除目标元素container.removeChild(targetNode)</span><br></code></pre></td></tr></table></figure><h4 id="4）修改-DOM-元素"><a href="#4）修改-DOM-元素" class="headerlink" title="4）修改 DOM 元素"></a>4）修改 DOM 元素</h4><p>修改 DOM 元素这个动作可以分很多维度，比如说移动 DOM 元素的位置，修改 DOM 元素的属性等。</p><p><strong>将指定的两个 DOM 元素交换位置，</strong> 已知的 HTML 结构如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;html&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>DEMO<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span></span><br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;container&quot;</span>&gt;</span> </span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;title&quot;</span>&gt;</span>我是标题<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;content&quot;</span>&gt;</span>我是内容<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>   </span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></span><br>&lt;/html&gt;<br></code></pre></td></tr></table></figure><p>现在需要调换 title 和 content 的位置，可以考虑 insertBefore 或者 appendChild：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 获取父元素</span><br><span class="hljs-keyword">var</span> container = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;container&#x27;</span>)   <br> <br><span class="hljs-comment">// 获取两个需要被交换的元素</span><br><span class="hljs-keyword">var</span> title = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;title&#x27;</span>)<br><span class="hljs-keyword">var</span> content = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;content&#x27;</span>)<br><span class="hljs-comment">// 交换两个元素，把 content 置于 title 前面</span><br>container.<span class="hljs-title function_">insertBefore</span>(content, title)<br></code></pre></td></tr></table></figure><h3 id="21-use-strict是什么意思-使用它区别是什么？"><a href="#21-use-strict是什么意思-使用它区别是什么？" class="headerlink" title="21. use strict是什么意思 ? 使用它区别是什么？"></a>21. use strict是什么意思 ? 使用它区别是什么？</h3><p>use strict 是一种 ECMAscript5 添加的（严格模式）运行模式，这种模式使得 Javascript 在更严格的条件下运行。设立严格模式的目的如下：</p><ul><li>消除 Javascript 语法的不合理、不严谨之处，减少怪异行为;</li><li>消除代码运行的不安全之处，保证代码运行的安全；</li><li>提高编译器效率，增加运行速度；</li><li>为未来新版本的 Javascript 做好铺垫。</li></ul><p>区别：</p><ul><li>禁止使用 with 语句。</li><li>禁止 this 关键字指向全局对象。</li><li>对象不能有重名的属性。</li></ul><h3 id="22-如何判断一个对象是否属于某个类？"><a href="#22-如何判断一个对象是否属于某个类？" class="headerlink" title="22. 如何判断一个对象是否属于某个类？"></a>22. 如何判断一个对象是否属于某个类？</h3><ul><li>第一种方式，使用 instanceof 运算符来判断构造函数的 prototype 属性是否出现在对象的原型链中的任何位置。</li><li>第二种方式，通过对象的 constructor 属性来判断，对象的 constructor 属性指向该对象的构造函数，但是这种方式不是很安全，因为 constructor 属性可以被改写。</li><li>第三种方式，如果需要判断的是某个内置的引用类型的话，可以使用 Object.prototype.toString() 方法来打印对象的[[Class]] 属性来进行判断。</li></ul><h3 id="23-强类型语言和弱类型语言的区别"><a href="#23-强类型语言和弱类型语言的区别" class="headerlink" title="23. 强类型语言和弱类型语言的区别"></a>23. 强类型语言和弱类型语言的区别</h3><ul><li><strong>强类型语言</strong>：强类型语言也称为强类型定义语言，是一种总是强制类型定义的语言，要求变量的使用要严格符合定义，所有变量都必须先定义后使用。Java和C++等语言都是强制类型定义的，也就是说，一旦一个变量被指定了某个数据类型，如果不经过强制转换，那么它就永远是这个数据类型了。例如你有一个整数，如果不显式地进行转换，你不能将其视为一个字符串。</li><li><strong>弱类型语言</strong>：弱类型语言也称为弱类型定义语言，与强类型定义相反。JavaScript语言就属于弱类型语言。简单理解就是一种变量类型可以被忽略的语言。比如JavaScript是弱类型定义的，在JavaScript中就可以将字符串’12’和整数3进行连接得到字符串’123’，在相加的时候会进行强制类型转换。</li></ul><p>两者对比：强类型语言在速度上可能略逊色于弱类型语言，但是强类型语言带来的严谨性可以有效地帮助避免许多错误。</p><h3 id="24-解释性语言和编译型语言的区别"><a href="#24-解释性语言和编译型语言的区别" class="headerlink" title="24. 解释性语言和编译型语言的区别"></a>24. 解释性语言和编译型语言的区别</h3><p>（1）解释型语言<br>使用专门的解释器对源程序逐行解释成特定平台的机器码并立即执行。是代码在执行时才被解释器一行行动态翻译和执行，而不是在执行之前就完成翻译。解释型语言不需要事先编译，其直接将源代码解释成机器码并立即执行，所以只要某一平台提供了相应的解释器即可运行该程序。其特点总结如下</p><ul><li>解释型语言每次运行都需要将源代码解释称机器码并执行，效率较低；</li><li>只要平台提供相应的解释器，就可以运行源代码，所以可以方便源程序移植；</li><li>JavaScript、Python等属于解释型语言。</li></ul><p>（2）编译型语言<br>使用专门的编译器，针对特定的平台，将高级语言源代码一次性的编译成可被该平台硬件执行的机器码，并包装成该平台所能识别的可执行性程序的格式。在编译型语言写的程序执行之前，需要一个专门的编译过程，把源代码编译成机器语言的文件，如exe格式的文件，以后要再运行时，直接使用编译结果即可，如直接运行exe文件。因为只需编译一次，以后运行时不需要编译，所以编译型语言执行效率高。其特点总结如下：</p><ul><li>一次性的编译成平台相关的机器语言文件，运行时脱离开发环境，运行效率高；</li><li>与特定平台相关，一般无法移植到其他平台；</li><li>C、C++等属于编译型语言。</li></ul><p><strong>两者主要区别在于：</strong> 前者源程序编译后即可在该平台运行，后者是在运行期间才编译。所以前者运行速度快，后者跨平台性好。</p><h3 id="25-for…in和for…of的区别"><a href="#25-for…in和for…of的区别" class="headerlink" title="25. for…in和for…of的区别"></a>25. for…in和for…of的区别</h3><p>for…of 是ES6新增的遍历方式，允许遍历一个含有iterator接口的数据结构（数组、对象等）并且返回各项的值，和ES3中的for…in的区别如下</p><ul><li>for…of 遍历获取的是对象的键值，for…in 获取的是对象的键名；</li><li>for… in 会遍历对象的整个原型链，性能非常差不推荐使用，而 for … of 只遍历当前对象不会遍历原型链；</li><li>对于数组的遍历，for…in 会返回数组中所有可枚举的属性(包括原型链上可枚举的属性)，for…of 只返回数组的下标对应的属性值；</li></ul><p><strong>总结：</strong> for…in 循环主要是为了遍历对象而生，不适用于遍历数组；for…of 循环可以用来遍历数组、类数组对象，字符串、Set、Map 以及 Generator 对象。</p><h3 id="26-如何使用for…of遍历对象"><a href="#26-如何使用for…of遍历对象" class="headerlink" title="26. 如何使用for…of遍历对象"></a>26. 如何使用for…of遍历对象</h3><p>for…of是作为ES6新增的遍历方式，允许遍历一个含有iterator接口的数据结构（数组、对象等）并且返回各项的值，普通的对象用for..of遍历是会报错的。</p><p>如果需要遍历的对象是类数组对象，用Array.from转成数组即可。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123;<br>    <span class="hljs-number">0</span>:<span class="hljs-string">&#x27;one&#x27;</span>,<br>    <span class="hljs-number">1</span>:<span class="hljs-string">&#x27;two&#x27;</span>,<br>    <span class="hljs-attr">length</span>: <span class="hljs-number">2</span><br>&#125;;<br>obj = <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(obj);<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> k <span class="hljs-keyword">of</span> obj)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(k)<br>&#125;<br></code></pre></td></tr></table></figure><p>如果不是类数组对象，就给对象添加一个[Symbol.iterator]属性，并指向一个迭代器即可。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//方法一：</span><br><span class="hljs-keyword">var</span> obj = &#123;<br>    <span class="hljs-attr">a</span>:<span class="hljs-number">1</span>,<br>    <span class="hljs-attr">b</span>:<span class="hljs-number">2</span>,<br>    <span class="hljs-attr">c</span>:<span class="hljs-number">3</span><br>&#125;;<br><br>obj[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">iterator</span>] = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br><span class="hljs-keyword">var</span> keys = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(<span class="hljs-variable language_">this</span>);<br><span class="hljs-keyword">var</span> count = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">return</span> &#123;<br><span class="hljs-title function_">next</span>(<span class="hljs-params"></span>)&#123;<br><span class="hljs-keyword">if</span>(count&lt;keys.<span class="hljs-property">length</span>)&#123;<br><span class="hljs-keyword">return</span> &#123;<span class="hljs-attr">value</span>: obj[keys[count++]],<span class="hljs-attr">done</span>:<span class="hljs-literal">false</span>&#125;;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br><span class="hljs-keyword">return</span> &#123;<span class="hljs-attr">value</span>:<span class="hljs-literal">undefined</span>,<span class="hljs-attr">done</span>:<span class="hljs-literal">true</span>&#125;;<br>&#125;<br>&#125;<br>&#125;<br>&#125;;<br><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> k <span class="hljs-keyword">of</span> obj)&#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(k);<br>&#125;<br><br><br><span class="hljs-comment">// 方法二</span><br><span class="hljs-keyword">var</span> obj = &#123;<br>    <span class="hljs-attr">a</span>:<span class="hljs-number">1</span>,<br>    <span class="hljs-attr">b</span>:<span class="hljs-number">2</span>,<br>    <span class="hljs-attr">c</span>:<span class="hljs-number">3</span><br>&#125;;<br>obj[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">iterator</span>] = <span class="hljs-keyword">function</span>*()&#123;<br>    <span class="hljs-keyword">var</span> keys = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(obj);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> k <span class="hljs-keyword">of</span> keys)&#123;<br>        <span class="hljs-keyword">yield</span> [k,obj[k]]<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> [k,v] <span class="hljs-keyword">of</span> obj)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(k,v);<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="27-ajax、axios、fetch的区别"><a href="#27-ajax、axios、fetch的区别" class="headerlink" title="27. ajax、axios、fetch的区别"></a>27. ajax、axios、fetch的区别</h3><p><strong>（1）AJAX</strong><br>Ajax 即“AsynchronousJavascriptAndXML”（异步 JavaScript 和 XML），是指一种创建交互式网页应用的网页开发技术。它是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。通过在后台与服务器进行少量数据交换，Ajax 可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。传统的网页（不使用 Ajax）如果需要更新内容，必须重载整个网页页面。其缺点如下：</p><ul><li>本身是针对MVC编程，不符合前端MVVM的浪潮</li><li>基于原生XHR开发，XHR本身的架构不清晰</li><li>不符合关注分离（Separation of Concerns）的原则</li><li>配置和调用方式非常混乱，而且基于事件的异步模型不友好。</li></ul><p><strong>（2）Fetch</strong><br>fetch号称是AJAX的替代品，是在ES6出现的，使用了ES6中的promise对象。Fetch是基于promise设计的。Fetch的代码结构比起ajax简单多。<strong>fetch不是ajax的进一步封装，而是原生js，没有使用XMLHttpRequest对象</strong>。</p><p>fetch的优点：</p><ul><li>语法简洁，更加语义化</li><li>基于标准 Promise 实现，支持 async&#x2F;await</li><li>更加底层，提供的API丰富（request, response）</li><li>脱离了XHR，是ES规范里新的实现方式</li></ul><p>fetch的缺点：</p><ul><li>fetch只对网络请求报错，对400，500都当做成功的请求，服务器返回 400，500 错误码时并不会 reject，只有网络错误这些导致请求不能完成时，fetch 才会被 reject。</li><li>fetch默认不会带cookie，需要添加配置项： fetch(url, {credentials: ‘include’})</li><li>fetch不支持abort，不支持超时控制，使用setTimeout及Promise.reject的实现的超时控制并不能阻止请求过程继续在后台运行，造成了流量的浪费</li><li>fetch没有办法原生监测请求的进度，而XHR可以</li></ul><p><strong>（3）Axios</strong><br>Axios 是一种基于Promise封装的HTTP客户端，其特点如下：</p><ul><li>浏览器端发起XMLHttpRequests请求</li><li>node端发起http请求</li><li>支持Promise API</li><li>监听请求和返回</li><li>对请求和返回进行转化</li><li>取消请求</li><li>自动转换json数据</li><li>客户端支持抵御XSRF攻击</li></ul><h3 id="28-数组的遍历方法有哪些"><a href="#28-数组的遍历方法有哪些" class="headerlink" title="28. 数组的遍历方法有哪些"></a>28. 数组的遍历方法有哪些</h3><table><thead><tr><th><strong>方法</strong></th><th><strong>是否改变原数组</strong></th><th><strong>特点</strong></th></tr></thead><tbody><tr><td>forEach()</td><td>否</td><td>数组方法，不改变原数组，没有返回值</td></tr><tr><td>map()</td><td>否</td><td>数组方法，不改变原数组，有返回值，可链式调用</td></tr><tr><td>filter()</td><td>否</td><td>数组方法，过滤数组，返回包含符合条件的元素的数组，可链式调用</td></tr><tr><td>for…of</td><td>否</td><td>for…of遍历具有Iterator迭代器的对象的属性，返回的是数组的元素、对象的属性值，不能遍历普通的obj对象，将异步循环变成同步循环</td></tr><tr><td>every() 和 some()</td><td>否</td><td>数组方法，some()只要有一个是true，便返回true；而every()只要有一个是false，便返回false.</td></tr><tr><td>find() 和 findIndex()</td><td>否</td><td>数组方法，find()返回的是第一个符合条件的值；findIndex()返回的是第一个返回条件的值的索引值</td></tr><tr><td>reduce() 和 reduceRight()</td><td>否</td><td>数组方法，reduce()对数组正序操作；reduceRight()对数组逆序操作</td></tr></tbody></table><p>遍历方法的详细解释：<a href="https://cuggz.blog.csdn.net/article/details/107649549">《细数JavaScript中那些遍历和循环》</a></p><h3 id="29-forEach和map方法有什么区别"><a href="#29-forEach和map方法有什么区别" class="headerlink" title="29. forEach和map方法有什么区别"></a>29. forEach和map方法有什么区别</h3><p>这方法都是用来遍历数组的，两者区别如下：</p><ul><li>forEach()方法会针对每一个元素执行提供的函数，对数据的操作会改变原数组，该方法没有返回值；</li><li>map()方法不会改变原数组的值，返回一个新数组，新数组中的值为原数组调用函数处理之后的值；</li></ul><h2 id="四、原型与原型链"><a href="#四、原型与原型链" class="headerlink" title="四、原型与原型链"></a>四、原型与原型链</h2><h3 id="1-对原型、原型链的理解"><a href="#1-对原型、原型链的理解" class="headerlink" title="1. 对原型、原型链的理解"></a>1. 对原型、原型链的理解</h3><p>在JavaScript中是使用构造函数来新建一个对象的，每一个构造函数的内部都有一个 prototype 属性，它的属性值是一个对象，这个对象包含了可以由该构造函数的所有实例共享的属性和方法。当使用构造函数新建一个对象后，在这个对象的内部将包含一个指针，这个指针指向构造函数的 prototype 属性对应的值，在 ES5 中这个指针被称为对象的原型。一般来说不应该能够获取到这个值的，但是现在浏览器中都实现了 <strong>proto</strong> 属性来访问这个属性，但是最好不要使用这个属性，因为它不是规范中规定的。ES5 中新增了一个 Object.getPrototypeOf() 方法，可以通过这个方法来获取对象的原型。</p><p>当访问一个对象的属性时，如果这个对象内部不存在这个属性，那么它就会去它的原型对象里找这个属性，这个原型对象又会有自己的原型，于是就这样一直找下去，也就是原型链的概念。原型链的尽头一般来说都是 Object.prototype 所以这就是新建的对象为什么能够使用 toString() 等方法的原因。</p><p><strong>特点：</strong> JavaScript 对象是通过引用来传递的，创建的每个新对象实体中并没有一份属于自己的原型副本。当修改原型时，与之相关的对象也会继承这一改变。<br><img src="7.png" alt="img"></p><h3 id="2-原型修改、重写"><a href="#2-原型修改、重写" class="headerlink" title="2. 原型修改、重写"></a>2. 原型修改、重写</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name<br>&#125;<br><span class="hljs-comment">// 修改原型</span><br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">getName</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;&#125;<br><span class="hljs-keyword">var</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&#x27;hello&#x27;</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p.<span class="hljs-property">__proto__</span> === <span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>) <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p.<span class="hljs-property">__proto__</span> === p.<span class="hljs-property">constructor</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>) <span class="hljs-comment">// true</span><br><span class="hljs-comment">// 重写原型</span><br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = &#123;<br>    <span class="hljs-attr">getName</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;&#125;<br>&#125;<br><span class="hljs-keyword">var</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&#x27;hello&#x27;</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p.<span class="hljs-property">__proto__</span> === <span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>)        <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p.<span class="hljs-property">__proto__</span> === p.<span class="hljs-property">constructor</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>) <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><p>可以看到修改原型的时候p的构造函数不是指向Person了，因为直接给Person的原型对象直接用对象赋值时，它的构造函数指向的了根构造函数Object，所以这时候<code>p.constructor === Object</code> ，而不是<code>p.constructor === Person</code>。要想成立，就要用constructor指回来：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = &#123;<br>    <span class="hljs-attr">getName</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;&#125;<br>&#125;<br><span class="hljs-keyword">var</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&#x27;hello&#x27;</span>)<br>p.<span class="hljs-property">constructor</span> = <span class="hljs-title class_">Person</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p.<span class="hljs-property">__proto__</span> === <span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>)        <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p.<span class="hljs-property">__proto__</span> === p.<span class="hljs-property">constructor</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>) <span class="hljs-comment">// true</span><br><br></code></pre></td></tr></table></figure><h3 id="3-原型链指向"><a href="#3-原型链指向" class="headerlink" title="3. 原型链指向"></a>3. 原型链指向</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript">p.<span class="hljs-property">__proto__</span>  <span class="hljs-comment">// Person.prototype</span><br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">__proto__</span>  <span class="hljs-comment">// Object.prototype</span><br>p.<span class="hljs-property">__proto__</span>.<span class="hljs-property">__proto__</span> <span class="hljs-comment">//Object.prototype</span><br>p.<span class="hljs-property">__proto__</span>.<span class="hljs-property">constructor</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">__proto__</span> <span class="hljs-comment">// Object.prototype</span><br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constructor</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">__proto__</span> <span class="hljs-comment">// Object.prototype</span><br>p1.<span class="hljs-property">__proto__</span>.<span class="hljs-property">constructor</span> <span class="hljs-comment">// Person</span><br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constructor</span>  <span class="hljs-comment">// Person</span><br></code></pre></td></tr></table></figure><h3 id="4-原型链的终点是什么？如何打印出原型链的终点？"><a href="#4-原型链的终点是什么？如何打印出原型链的终点？" class="headerlink" title="4. 原型链的终点是什么？如何打印出原型链的终点？"></a>4. 原型链的终点是什么？如何打印出原型链的终点？</h3><p>由于<code>Object</code>是构造函数，原型链终点是<code>Object.prototype.__proto__</code>，而<code>Object.prototype.__proto__=== null // true</code>，所以，原型链的终点是<code>null</code>。原型链上的所有原型都是对象，所有的对象最终都是由<code>Object</code>构造的，而<code>Object.prototype</code>的下一级是<code>Object.prototype.__proto__</code>。<br><img src="8.jpg" alt="img"></p><h3 id="5-如何获得对象非原型链上的属性？"><a href="#5-如何获得对象非原型链上的属性？" class="headerlink" title="5. 如何获得对象非原型链上的属性？"></a>5. 如何获得对象非原型链上的属性？</h3><p>使用后<code>hasOwnProperty()</code>方法来判断属性是否属于原型链的属性：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">iterate</span>(<span class="hljs-params">obj</span>)&#123;<br>   <span class="hljs-keyword">var</span> res=[];<br>   <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> key <span class="hljs-keyword">in</span> obj)&#123;<br>        <span class="hljs-keyword">if</span>(obj.<span class="hljs-title function_">hasOwnProperty</span>(key))<br>           res.<span class="hljs-title function_">push</span>(key+<span class="hljs-string">&#x27;: &#x27;</span>+obj[key]);<br>   &#125;<br>   <span class="hljs-keyword">return</span> res;<br>&#125; <br></code></pre></td></tr></table></figure><h2 id="五、执行上下文-x2F-作用域链-x2F-闭包"><a href="#五、执行上下文-x2F-作用域链-x2F-闭包" class="headerlink" title="五、执行上下文&#x2F;作用域链&#x2F;闭包"></a>五、执行上下文&#x2F;作用域链&#x2F;闭包</h2><h3 id="1-对闭包的理解"><a href="#1-对闭包的理解" class="headerlink" title="1. 对闭包的理解"></a>1. 对闭包的理解</h3><p><strong>闭包是指有权访问另一个函数作用域中变量的函数</strong>，创建闭包的最常见的方式就是在一个函数内创建另一个函数，创建的函数可以访问到当前函数的局部变量。</p><p>闭包有两个常用的用途；</p><ul><li>闭包的第一个用途是使我们在函数外部能够访问到函数内部的变量。通过使用闭包，可以通过在外部调用闭包函数，从而在外部访问到函数内部的变量，可以使用这种方法来创建私有变量。</li><li>闭包的另一个用途是使已经运行结束的函数上下文中的变量对象继续留在内存中，因为闭包函数保留了这个变量对象的引用，所以这个变量对象不会被回收。</li></ul><p>比如，函数 A 内部有一个函数 B，函数 B 可以访问到函数 A 中的变量，那么函数 B 就是闭包。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">A</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">let</span> a = <span class="hljs-number">1</span><br>  <span class="hljs-variable language_">window</span>.<span class="hljs-property">B</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a)<br>  &#125;<br>&#125;<br><span class="hljs-title function_">A</span>()<br><span class="hljs-title function_">B</span>() <span class="hljs-comment">// 1</span><br></code></pre></td></tr></table></figure><p>在 JS 中，闭包存在的意义就是让我们可以间接访问函数内部的变量。经典面试题：循环中使用闭包解决 var 定义函数的问题</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">5</span>; i++) &#123;<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span> <span class="hljs-title function_">timer</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i)<br>  &#125;, i * <span class="hljs-number">1000</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>首先因为 <code>setTimeout</code> 是个异步函数，所以会先把循环全部执行完毕，这时候 <code>i</code> 就是 6 了，所以会输出一堆 6。解决办法有三种：</p><ul><li>第一种是使用闭包的方式</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">5</span>; i++) &#123;  ;(<span class="hljs-keyword">function</span>(<span class="hljs-params">j</span>) &#123;    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span> <span class="hljs-title function_">timer</span>(<span class="hljs-params"></span>) &#123;      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(j)    &#125;, j * <span class="hljs-number">1000</span>)  &#125;)(i)&#125;<br></code></pre></td></tr></table></figure><p>在上述代码中，首先使用了立即执行函数将 <code>i</code> 传入函数内部，这个时候值就被固定在了参数 <code>j</code> 上面不会改变，当下次执行 <code>timer</code> 这个闭包的时候，就可以使用外部函数的变量 <code>j</code>，从而达到目的。</p><ul><li>第二种就是使用 <code>setTimeout</code> 的第三个参数，这个参数会被当成 <code>timer</code> 函数的参数传入。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">5</span>; i++) &#123;<br>  <span class="hljs-built_in">setTimeout</span>(<br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">timer</span>(<span class="hljs-params">j</span>) &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(j)<br>    &#125;,<br>    i * <span class="hljs-number">1000</span>,<br>    i<br>  )<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>第三种就是使用 <code>let</code> 定义 <code>i</code> 了来解决问题了，这个也是最为推荐的方式</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">5</span>; i++) &#123;<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span> <span class="hljs-title function_">timer</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i)<br>  &#125;, i * <span class="hljs-number">1000</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-对作用域、作用域链的理解"><a href="#2-对作用域、作用域链的理解" class="headerlink" title="2. 对作用域、作用域链的理解"></a>2. 对作用域、作用域链的理解</h3><h5 id="1）全局作用域和函数作用域"><a href="#1）全局作用域和函数作用域" class="headerlink" title="1）全局作用域和函数作用域"></a>1）全局作用域和函数作用域</h5><p>（1）全局作用域</p><ul><li>最外层函数和最外层函数外面定义的变量拥有全局作用域</li><li>所有未定义直接赋值的变量自动声明为全局作用域</li><li>所有window对象的属性拥有全局作用域</li><li>全局作用域有很大的弊端，过多的全局作用域变量会污染全局命名空间，容易引起命名冲突。</li></ul><p>（2）函数作用域</p><ul><li>函数作用域声明在函数内部的变零，一般只有固定的代码片段可以访问到</li><li>作用域是分层的，内层作用域可以访问外层作用域，反之不行</li></ul><h5 id="2）块级作用域"><a href="#2）块级作用域" class="headerlink" title="2）块级作用域"></a>2）块级作用域</h5><ul><li>使用ES6中新增的let和const指令可以声明块级作用域，块级作用域可以在函数中创建也可以在一个代码块中的创建（由<code>&#123; &#125;</code>包裹的代码片段）</li><li>let和const声明的变量不会有变量提升，也不可以重复声明</li><li>在循环中比较适合绑定块级作用域，这样就可以把声明的计数器变量限制在循环内部。</li></ul><p><strong>作用域链：</strong><br>在当前作用域中查找所需变量，但是该作用域没有这个变量，那这个变量就是自由变量。如果在自己作用域找不到该变量就去父级作用域查找，依次向上级作用域查找，直到访问到window对象就被终止，这一层层的关系就是作用域链。</p><p>作用域链的作用是<strong>保证对执行环境有权访问的所有变量和函数的有序访问，通过作用域链，可以访问到外层环境的变量和函数。</strong></p><p>作用域链的本质上是一个指向变量对象的指针列表。变量对象是一个包含了执行环境中所有变量和函数的对象。作用域链的前端始终都是当前执行上下文的变量对象。全局执行上下文的变量对象（也就是全局对象）始终是作用域链的最后一个对象。</p><p>当查找一个变量时，如果当前执行环境中没有找到，可以沿着作用域链向后查找。</p><h3 id="3-对执行上下文的理解"><a href="#3-对执行上下文的理解" class="headerlink" title="3. 对执行上下文的理解"></a>3. 对执行上下文的理解</h3><h5 id="1-执行上下文类型"><a href="#1-执行上下文类型" class="headerlink" title="1. 执行上下文类型"></a>1. 执行上下文类型</h5><p><strong>（1）全局执行上下文</strong></p><p>任何不在函数内部的都是全局执行上下文，它首先会创建一个全局的window对象，并且设置this的值等于这个全局对象，一个程序中只有一个全局执行上下文。</p><p><strong>（2）函数执行上下文</strong></p><p>当一个函数被调用时，就会为该函数创建一个新的执行上下文，函数的上下文可以有任意多个。</p><p><strong>（3）</strong><code>eval</code><strong>函数执行上下文</strong></p><p>执行在eval函数中的代码会有属于他自己的执行上下文，不过eval函数不常使用，不做介绍。</p><h5 id="2-执行上下文栈"><a href="#2-执行上下文栈" class="headerlink" title="2. 执行上下文栈"></a>2. 执行上下文栈</h5><ul><li>JavaScript引擎使用执行上下文栈来管理执行上下文</li><li>当JavaScript执行代码时，首先遇到全局代码，会创建一个全局执行上下文并且压入执行栈中，每当遇到一个函数调用，就会为该函数创建一个新的执行上下文并压入栈顶，引擎会执行位于执行上下文栈顶的函数，当函数执行完成之后，执行上下文从栈中弹出，继续执行下一个上下文。当所有的代码都执行完毕之后，从栈中弹出全局执行上下文。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> a = <span class="hljs-string">&#x27;Hello World!&#x27;</span>;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">first</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Inside first function&#x27;</span>);<br>  <span class="hljs-title function_">second</span>();<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Again inside first function&#x27;</span>);<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">second</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Inside second function&#x27;</span>);<br>&#125;<br><span class="hljs-title function_">first</span>();<br><span class="hljs-comment">//执行顺序</span><br><span class="hljs-comment">//先执行second(),在执行first()</span><br></code></pre></td></tr></table></figure><h5 id="3-创建执行上下文"><a href="#3-创建执行上下文" class="headerlink" title="3. 创建执行上下文"></a>3. 创建执行上下文</h5><p>创建执行上下文有两个阶段：<strong>创建阶段</strong>和<strong>执行阶段</strong></p><p><strong>1）创建阶段</strong></p><p>（1）this绑定</p><ul><li>在全局执行上下文中，this指向全局对象（window对象）</li><li>在函数执行上下文中，this指向取决于函数如何调用。如果它被一个引用对象调用，那么 this 会被设置成那个对象，否则 this 的值被设置为全局对象或者 undefined</li></ul><p>（2）创建词法环境组件</p><ul><li>词法环境是一种有<strong>标识符——变量映射</strong>的数据结构，标识符是指变量&#x2F;函数名，变量是对实际对象或原始数据的引用。</li><li>词法环境的内部有两个组件：<strong>加粗样式</strong>：环境记录器:用来储存变量个函数声明的实际位置<strong>外部环境的引用</strong>：可以访问父级作用域</li></ul><p>（3）创建变量环境组件</p><ul><li>变量环境也是一个词法环境，其环境记录器持有变量声明语句在执行上下文中创建的绑定关系。</li></ul><p><strong>2）执行阶段</strong><br>此阶段会完成对变量的分配，最后执行完代码。</p><p><strong>简单来说执行上下文就是指：</strong></p><p>在执行一点JS代码之前，需要先解析代码。解析的时候会先创建一个全局执行上下文环境，先把代码中即将执行的变量、函数声明都拿出来，变量先赋值为undefined，函数先声明好可使用。这一步执行完了，才开始正式的执行程序。</p><p>在一个函数执行之前，也会创建一个函数执行上下文环境，跟全局执行上下文类似，不过函数执行上下文会多出this、arguments和函数的参数。</p><ul><li>全局上下文：变量定义，函数声明</li><li>函数上下文：变量定义，函数声明，<code>this</code>，<code>arguments</code></li></ul><p><strong>注：</strong> 由于字数限制，剩余内容在下篇进行总结哦。</p>]]></content>
    
    
    <categories>
      
      <category>BGW</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>BGW-JavaScript2</title>
    <link href="/2023/04/18/BGW-JavaScript2/"/>
    <url>/2023/04/18/BGW-JavaScript2/</url>
    
    <content type="html"><![CDATA[<p>BGW-JavaScript2</p><p><img src="1.png" alt="img"></p><p>- </p><h2 id="六、this-x2F-call-x2F-apply-x2F-bind"><a href="#六、this-x2F-call-x2F-apply-x2F-bind" class="headerlink" title="六、this&#x2F;call&#x2F;apply&#x2F;bind"></a>六、this&#x2F;call&#x2F;apply&#x2F;bind</h2><h3 id="1-对this对象的理解"><a href="#1-对this对象的理解" class="headerlink" title="1. 对this对象的理解"></a>1. 对this对象的理解</h3><p>this 是执行上下文中的一个属性，它指向最后一次调用这个方法的对象。在实际开发中，this 的指向可以通过四种调用模式来判断。</p><ul><li>第一种是<strong>函数调用模式</strong>，当一个函数不是一个对象的属性时，直接作为函数来调用时，this 指向全局对象。</li><li>第二种是<strong>方法调用模式</strong>，如果一个函数作为一个对象的方法来调用时，this 指向这个对象。</li><li>第三种是<strong>构造器调用模式</strong>，如果一个函数用 new 调用时，函数执行前会新创建一个对象，this 指向这个新创建的对象。</li><li>第四种是 <strong>apply 、 call 和 bind 调用模式</strong>，这三个方法都可以显示的指定调用函数的 this 指向。其中 apply 方法接收两个参数：一个是 this 绑定的对象，一个是参数数组。call 方法接收的参数，第一个是 this 绑定的对象，后面的其余参数是传入函数执行的参数。也就是说，在使用 call() 方法时，传递给函数的参数必须逐个列举出来。bind 方法通过传入一个对象，返回一个 this 绑定了传入对象的新函数。这个函数的 this 指向除了使用 new 时会被改变，其他情况下都不会改变。</li></ul><p>这四种方式，使用构造器调用模式的优先级最高，然后是 apply、call 和 bind 调用模式，然后是方法调用模式，然后是函数调用模式。</p><h3 id="2-call-和-apply-的区别？"><a href="#2-call-和-apply-的区别？" class="headerlink" title="2. call() 和 apply() 的区别？"></a>2. call() 和 apply() 的区别？</h3><p>它们的作用一模一样，区别仅在于传入参数的形式的不同。</p><ul><li>apply 接受两个参数，第一个参数指定了函数体内 this 对象的指向，第二个参数为一个带下标的集合，这个集合可以为数组，也可以为类数组，apply 方法把这个集合中的元素作为参数传递给被调用的函数。</li><li>call 传入的参数数量不固定，跟 apply 相同的是，第一个参数也是代表函数体内的 this 指向，从第二个参数开始往后，每个参数被依次传入函数。</li></ul><h3 id="3-实现call、apply-及-bind-函数"><a href="#3-实现call、apply-及-bind-函数" class="headerlink" title="3. 实现call、apply 及 bind 函数"></a>3. 实现call、apply 及 bind 函数</h3><p><strong>（1）call 函数的实现步骤：</strong></p><ul><li>判断调用对象是否为函数，即使是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。</li><li>判断传入上下文对象是否存在，如果不存在，则设置为 window 。</li><li>处理传入的参数，截取第一个参数后的所有参数。</li><li>将函数作为上下文对象的一个属性。</li><li>使用上下文对象来调用这个方法，并保存返回结果。</li><li>删除刚才新增的属性。</li><li>返回结果。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">myCall</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">context</span>) &#123;<br>  <span class="hljs-comment">// 判断调用对象</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-variable language_">this</span> !== <span class="hljs-string">&quot;function&quot;</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&quot;type error&quot;</span>);<br>  &#125;<br>  <span class="hljs-comment">// 获取参数</span><br>  <span class="hljs-keyword">let</span> args = [...<span class="hljs-variable language_">arguments</span>].<span class="hljs-title function_">slice</span>(<span class="hljs-number">1</span>),<br>    result = <span class="hljs-literal">null</span>;<br>  <span class="hljs-comment">// 判断 context 是否传入，如果未传入则设置为 window</span><br>  context = context || <span class="hljs-variable language_">window</span>;<br>  <span class="hljs-comment">// 将调用函数设为对象的方法</span><br>  context.<span class="hljs-property">fn</span> = <span class="hljs-variable language_">this</span>;<br>  <span class="hljs-comment">// 调用函数</span><br>  result = context.<span class="hljs-title function_">fn</span>(...args);<br>  <span class="hljs-comment">// 将属性删除</span><br>  <span class="hljs-keyword">delete</span> context.<span class="hljs-property">fn</span>;<br>  <span class="hljs-keyword">return</span> result;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>（2）apply 函数的实现步骤：</strong></p><ul><li>判断调用对象是否为函数，即使是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。</li><li>判断传入上下文对象是否存在，如果不存在，则设置为 window 。</li><li>将函数作为上下文对象的一个属性。</li><li>判断参数值是否传入</li><li>使用上下文对象来调用这个方法，并保存返回结果。</li><li>删除刚才新增的属性</li><li>返回结果</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">myApply</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">context</span>) &#123;<br>  <span class="hljs-comment">// 判断调用对象是否为函数</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-variable language_">this</span> !== <span class="hljs-string">&quot;function&quot;</span>) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeError</span>(<span class="hljs-string">&quot;Error&quot;</span>);<br>  &#125;<br>  <span class="hljs-keyword">let</span> result = <span class="hljs-literal">null</span>;<br>  <span class="hljs-comment">// 判断 context 是否存在，如果未传入则为 window</span><br>  context = context || <span class="hljs-variable language_">window</span>;<br>  <span class="hljs-comment">// 将函数设为对象的方法</span><br>  context.<span class="hljs-property">fn</span> = <span class="hljs-variable language_">this</span>;<br>  <span class="hljs-comment">// 调用方法</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">arguments</span>[<span class="hljs-number">1</span>]) &#123;<br>    result = context.<span class="hljs-title function_">fn</span>(...<span class="hljs-variable language_">arguments</span>[<span class="hljs-number">1</span>]);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    result = context.<span class="hljs-title function_">fn</span>();<br>  &#125;<br>  <span class="hljs-comment">// 将属性删除</span><br>  <span class="hljs-keyword">delete</span> context.<span class="hljs-property">fn</span>;<br>  <span class="hljs-keyword">return</span> result;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>（3）bind 函数的实现步骤：</strong></p><ul><li>判断调用对象是否为函数，即使是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。</li><li>保存当前函数的引用，获取其余传入参数值。</li><li>创建一个函数返回</li><li>函数内部使用 apply 来绑定函数调用，需要判断函数作为构造函数的情况，这个时候需要传入当前函数的 this 给 apply 调用，其余情况都传入指定的上下文对象。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">myBind</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">context</span>) &#123;<br>  <span class="hljs-comment">// 判断调用对象是否为函数</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-variable language_">this</span> !== <span class="hljs-string">&quot;function&quot;</span>) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeError</span>(<span class="hljs-string">&quot;Error&quot;</span>);<br>  &#125;<br>  <span class="hljs-comment">// 获取参数</span><br>  <span class="hljs-keyword">var</span> args = [...<span class="hljs-variable language_">arguments</span>].<span class="hljs-title function_">slice</span>(<span class="hljs-number">1</span>),<br>    fn = <span class="hljs-variable language_">this</span>;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Fn</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// 根据调用方式，传入不同绑定值</span><br>    <span class="hljs-keyword">return</span> fn.<span class="hljs-title function_">apply</span>(<br>      <span class="hljs-variable language_">this</span> <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Fn</span> ? <span class="hljs-variable language_">this</span> : context,<br>      args.<span class="hljs-title function_">concat</span>(...<span class="hljs-variable language_">arguments</span>)<br>    );<br>  &#125;;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="七、异步编程"><a href="#七、异步编程" class="headerlink" title="七、异步编程"></a>七、异步编程</h2><h3 id="1-异步编程的实现方式？"><a href="#1-异步编程的实现方式？" class="headerlink" title="1. 异步编程的实现方式？"></a>1. 异步编程的实现方式？</h3><p>JavaScript中的异步机制可以分为以下几种：</p><ul><li><strong>回调函数</strong> 的方式，使用回调函数的方式有一个缺点是，多个回调函数嵌套的时候会造成回调函数地狱，上下两层的回调函数间的代码耦合度太高，不利于代码的可维护。</li><li><strong>Promise</strong> 的方式，使用 Promise 的方式可以将嵌套的回调函数作为链式调用。但是使用这种方法，有时会造成多个 then 的链式调用，可能会造成代码的语义不够明确。</li><li><strong>generator</strong> 的方式，它可以在函数的执行过程中，将函数的执行权转移出去，在函数外部还可以将执行权转移回来。当遇到异步函数执行的时候，将函数执行权转移出去，当异步函数执行完毕时再将执行权给转移回来。因此在 generator 内部对于异步操作的方式，可以以同步的顺序来书写。使用这种方式需要考虑的问题是何时将函数的控制权转移回来，因此需要有一个自动执行 generator 的机制，比如说 co 模块等方式来实现 generator 的自动执行。</li><li><strong>async 函数</strong> 的方式，async 函数是 generator 和 promise 实现的一个自动执行的语法糖，它内部自带执行器，当函数内部执行到一个 await 语句的时候，如果语句返回一个 promise 对象，那么函数将会等待 promise 对象的状态变为 resolve 后再继续向下执行。因此可以将异步逻辑，转化为同步的顺序来书写，并且这个函数可以自动执行。</li></ul><h3 id="2-setTimeout、Promise、Async-x2F-Await-的区别"><a href="#2-setTimeout、Promise、Async-x2F-Await-的区别" class="headerlink" title="2. setTimeout、Promise、Async&#x2F;Await 的区别"></a>2. setTimeout、Promise、Async&#x2F;Await 的区别</h3><h4 id="（1）setTimeout"><a href="#（1）setTimeout" class="headerlink" title="（1）setTimeout"></a>（1）setTimeout</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;script start&#x27;</span>)<span class="hljs-comment">//1. 打印 script start</span><br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;settimeout&#x27;</span>)<span class="hljs-comment">// 4. 打印 settimeout</span><br>&#125;)<span class="hljs-comment">// 2. 调用 setTimeout 函数，并定义其完成后执行的回调函数</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;script end&#x27;</span>)<span class="hljs-comment">//3. 打印 script start</span><br><span class="hljs-comment">// 输出顺序：script start-&gt;script end-&gt;settimeout</span><br></code></pre></td></tr></table></figure><h4 id="（2）Promise"><a href="#（2）Promise" class="headerlink" title="（2）Promise"></a>（2）Promise</h4><p>Promise本身是<strong>同步的立即执行函数</strong>， 当在executor中执行resolve或者reject的时候, 此时是异步操作， 会先执行then&#x2F;catch等，当主栈完成后，才会去调用resolve&#x2F;reject中存放的方法执行，打印p的时候，是打印的返回结果，一个Promise实例。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;script start&#x27;</span>)<br><span class="hljs-keyword">let</span> promise1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">resolve</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;promise1&#x27;</span>)<br>    <span class="hljs-title function_">resolve</span>()<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;promise1 end&#x27;</span>)<br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;promise2&#x27;</span>)<br>&#125;)<br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;settimeout&#x27;</span>)<br>&#125;)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;script end&#x27;</span>)<br><span class="hljs-comment">// 输出顺序: script start-&gt;promise1-&gt;promise1 end-&gt;script end-&gt;promise2-&gt;settimeout</span><br></code></pre></td></tr></table></figure><p>当JS主线程执行到Promise对象时：</p><ul><li>promise1.then() 的回调就是一个 task</li><li>promise1 是 resolved或rejected: 那这个 task 就会放入当前事件循环回合的 microtask queue</li><li>promise1 是 pending: 这个 task 就会放入 事件循环的未来的某个(可能下一个)回合的 microtask queue 中</li><li>setTimeout 的回调也是个 task ，它会被放入 macrotask queue 即使是 0ms 的情况</li></ul><h4 id="（3）async-x2F-await"><a href="#（3）async-x2F-await" class="headerlink" title="（3）async&#x2F;await"></a>（3）async&#x2F;await</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">async1</span>(<span class="hljs-params"></span>)&#123;<br>   <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;async1 start&#x27;</span>);<br>    <span class="hljs-keyword">await</span> <span class="hljs-title function_">async2</span>();<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;async1 end&#x27;</span>)<br>&#125;<br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">async2</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;async2&#x27;</span>)<br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;script start&#x27;</span>);<br><span class="hljs-title function_">async1</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;script end&#x27;</span>)<br><span class="hljs-comment">// 输出顺序：script start-&gt;async1 start-&gt;async2-&gt;script end-&gt;async1 end</span><br></code></pre></td></tr></table></figure><p>async 函数返回一个 Promise 对象，当函数执行的时候，一旦遇到 await 就会先返回，等到触发的异步操作完成，再执行函数体内后面的语句。可以理解为，是让出了线程，跳出了 async 函数体。</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">func1</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">func1</span>())<br></code></pre></td></tr></table></figure><p><img src="2.png" alt="img"><br>func1的运行结果其实就是一个Promise对象。因此也可以使用then来处理后续逻辑。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">func1</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res);  <span class="hljs-comment">// 30</span><br>&#125;)<br></code></pre></td></tr></table></figure><p>await的含义为等待，也就是 async 函数需要等待await后的函数执行完成并且有了返回结果（Promise对象）之后，才能继续执行下面的代码。await通过返回一个Promise对象来实现同步的效果。</p><h3 id="3-对Promise的理解"><a href="#3-对Promise的理解" class="headerlink" title="3. 对Promise的理解"></a>3. 对Promise的理解</h3><p>Promise是异步编程的一种解决方案，它是一个对象，可以获取异步操作的消息，他的出现大大改善了异步编程的困境，避免了地狱回调，它比传统的解决方案回调函数和事件更合理和更强大。</p><p>所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。</p><p>（1）Promise的实例有<strong>三个状态</strong>:</p><ul><li>Pending（进行中）</li><li>Resolved（已完成）</li><li>Rejected（已拒绝）</li></ul><p>当把一件事情交给promise时，它的状态就是Pending，任务完成了状态就变成了Resolved、没有完成失败了就变成了Rejected。</p><p>（2）Promise的实例有<strong>两个过程</strong>：</p><ul><li>pending -&gt; fulfilled : Resolved（已完成）</li><li>pending -&gt; rejected：Rejected（已拒绝）</li></ul><p>注意：一旦从进行状态变成为其他状态就永远不能更改状态了。</p><p><strong>Promise的特点：</strong></p><ul><li>对象的状态不受外界影响。promise对象代表一个异步操作，有三种状态，<code>pending</code>（进行中）、<code>fulfilled</code>（已成功）、<code>rejected</code>（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态，这也是promise这个名字的由来——“<strong>承诺</strong>”；</li><li>一旦状态改变就不会再变，任何时候都可以得到这个结果。promise对象的状态改变，只有两种可能：从<code>pending</code>变为<code>fulfilled</code>，从<code>pending</code>变为<code>rejected</code>。这时就称为<code>resolved</code>（已定型）。如果改变已经发生了，你再对promise对象添加回调函数，也会立即得到这个结果。这与事件（event）完全不同，事件的特点是：如果你错过了它，再去监听是得不到结果的。</li></ul><p><strong>Promise的缺点：</strong></p><ul><li>无法取消Promise，一旦新建它就会立即执行，无法中途取消。</li><li>如果不设置回调函数，Promise内部抛出的错误，不会反应到外部。</li><li>当处于pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。</li></ul><p><strong>总结：</strong><br>Promise 对象是异步编程的一种解决方案，最早由社区提出。Promise 是一个构造函数，接收一个函数作为参数，返回一个 Promise 实例。一个 Promise 实例有三种状态，分别是pending、resolved 和 rejected，分别代表了进行中、已成功和已失败。实例的状态只能由 pending 转变 resolved 或者rejected 状态，并且状态一经改变，就凝固了，无法再被改变了。</p><p>状态的改变是通过 resolve() 和 reject() 函数来实现的，可以在异步操作结束后调用这两个函数改变 Promise 实例的状态，它的原型上定义了一个 then 方法，使用这个 then 方法可以为两个状态的改变注册回调函数。这个回调函数属于微任务，会在本轮事件循环的末尾执行。</p><p><strong>注意：</strong> 在构造 <code>Promise</code> 的时候，构造函数内部的代码是立即执行的</p><h3 id="4-Promise的基本用法"><a href="#4-Promise的基本用法" class="headerlink" title="4. Promise的基本用法"></a>4. Promise的基本用法</h3><h4 id="（1）创建Promise对象"><a href="#（1）创建Promise对象" class="headerlink" title="（1）创建Promise对象"></a>（1）创建Promise对象</h4><p>Promise对象代表一个异步操作，有三种状态：pending（进行中）、fulfilled（已成功）和rejected（已失败）。</p><p>Promise构造函数接受一个函数作为参数，该函数的两个参数分别是<code>resolve</code>和<code>reject</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">resolve, reject</span>) &#123;<br>  <span class="hljs-comment">// ... some code</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-comment">/* 异步操作成功 */</span>)&#123;<br>    <span class="hljs-title function_">resolve</span>(value);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-title function_">reject</span>(error);<br>  &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><p><strong>一般情况下都会使用</strong><code>new Promise()</code><strong>来创建promise对象，但是也可以使用</strong><code>promise.resolve</code><strong>和</strong><code>promise.reject</code><strong>这两个方法：</strong></p><ul><li><strong>Promise.resolve</strong></li></ul><p><code>Promise.resolve(value)</code>的返回值也是一个promise对象，可以对返回值进行.then调用，代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-number">11</span>).<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">value</span>)&#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value); <span class="hljs-comment">// 打印出11</span><br>&#125;);<br></code></pre></td></tr></table></figure><p><code>resolve(11)</code>代码中，会让promise对象进入确定(<code>resolve</code>状态)，并将参数<code>11</code>传递给后面的<code>then</code>所指定的<code>onFulfilled</code> 函数；</p><p>创建promise对象可以使用<code>new Promise</code>的形式创建对象，也可以使用<code>Promise.resolve(value)</code>的形式创建promise对象；</p><ul><li><strong>Promise.reject</strong></li></ul><p><code>Promise.reject</code> 也是<code>new Promise</code>的快捷形式，也创建一个promise对象。代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(“我错了，请原谅俺！！”));<br></code></pre></td></tr></table></figure><p>就是下面的代码new Promise的简单形式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">resolve,reject</span>)&#123;<br>   <span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;我错了！&quot;</span>));<br>&#125;);<br></code></pre></td></tr></table></figure><p>下面是使用resolve方法和reject方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">testPromise</span>(<span class="hljs-params">ready</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">resolve,reject</span>)&#123;<br>    <span class="hljs-keyword">if</span>(ready) &#123;<br>      <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&quot;hello world&quot;</span>);<br>    &#125;<span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-title function_">reject</span>(<span class="hljs-string">&quot;No thanks&quot;</span>);<br>    &#125;<br>  &#125;);<br>&#125;;<br><span class="hljs-comment">// 方法调用</span><br><span class="hljs-title function_">testPromise</span>(<span class="hljs-literal">true</span>).<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">msg</span>)&#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(msg);<br>&#125;,<span class="hljs-keyword">function</span>(<span class="hljs-params">error</span>)&#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(error);<br>&#125;);<br></code></pre></td></tr></table></figure><p>上面的代码的含义是给<code>testPromise</code>方法传递一个参数，返回一个promise对象，如果为<code>true</code>的话，那么调用promise对象中的<code>resolve()</code>方法，并且把其中的参数传递给后面的<code>then</code>第一个函数内，因此打印出 “<code>hello world</code>”, 如果为<code>false</code>的话，会调用promise对象中的<code>reject()</code>方法，则会进入<code>then</code>的第二个函数内，会打印<code>No thanks</code>；</p><h4 id="（2）Promise方法"><a href="#（2）Promise方法" class="headerlink" title="（2）Promise方法"></a>（2）Promise方法</h4><p>Promise有五个常用的方法：then()、catch()、all()、race()、finally。下面就来看一下这些方法。</p><ol><li><strong>then()</strong></li></ol><p>当Promise执行的内容符合成功条件时，调用<code>resolve</code>函数，失败就调用<code>reject</code>函数。Promise创建完了，那该如何调用呢？</p><figure class="highlight wren"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs wren"><span class="hljs-variable">promise</span>.<span class="hljs-property">then</span>(<span class="hljs-title function_">function</span>(<span class="hljs-params">value</span>) &#123;<br>  <span class="hljs-comment">// success</span><br>&#125;, <span class="hljs-title function_">function</span>(<span class="hljs-params">error</span>) &#123;<br>  <span class="hljs-comment">// failure</span><br>&#125;);<br></code></pre></td></tr></table></figure><p><code>then</code>方法可以接受两个回调函数作为参数。第一个回调函数是Promise对象的状态变为<code>resolved</code>时调用，第二个回调函数是Promise对象的状态变为<code>rejected</code>时调用。其中第二个参数可以省略。<br><code>then</code>方法返回的是一个新的Promise实例（不是原来那个Promise实例）。因此可以采用链式写法，即<code>then</code>方法后面再调用另一个then方法。</p><p>当要写有顺序的异步事件时，需要串行时，可以这样写：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br>    <span class="hljs-title function_">ajax</span>(<span class="hljs-string">&#x27;first&#x27;</span>).<span class="hljs-title function_">success</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">res</span>)&#123;<br>        <span class="hljs-title function_">resolve</span>(res);<br>    &#125;)<br>&#125;)<br>promise.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span>=&gt;</span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resovle,reject</span>)=&gt;</span>&#123;<br>        <span class="hljs-title function_">ajax</span>(<span class="hljs-string">&#x27;second&#x27;</span>).<span class="hljs-title function_">success</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">res</span>)&#123;<br>            <span class="hljs-title function_">resolve</span>(res)<br>        &#125;)<br>    &#125;)<br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span>=&gt;</span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resovle,reject</span>)=&gt;</span>&#123;<br>        <span class="hljs-title function_">ajax</span>(<span class="hljs-string">&#x27;second&#x27;</span>).<span class="hljs-title function_">success</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">res</span>)&#123;<br>            <span class="hljs-title function_">resolve</span>(res)<br>        &#125;)<br>    &#125;)<br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span>=&gt;</span>&#123;<br>    <br>&#125;)<br></code></pre></td></tr></table></figure><p>那当要写的事件没有顺序或者关系时，还如何写呢？可以使用<code>all</code> 方法来解决。</p><p><strong>2. catch()</strong></p><p>Promise对象除了有then方法，还有一个catch方法，该方法相当于<code>then</code>方法的第二个参数，指向<code>reject</code>的回调函数。不过<code>catch</code>方法还有一个作用，就是在执行<code>resolve</code>回调函数时，如果出现错误，抛出异常，不会停止运行，而是进入<code>catch</code>方法中。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript">p.<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> &#123;<br>     <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;resolved&#x27;</span>,data);<br>&#125;,<span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;<br>     <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;rejected&#x27;</span>,err);<br>     &#125;<br>); <br>p.<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;resolved&#x27;</span>,data);<br>&#125;).<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;rejected&#x27;</span>,err);<br>&#125;);<br></code></pre></td></tr></table></figure><p><strong>3. all()</strong></p><p><code>all</code>方法可以完成并行任务， 它接收一个数组，数组的每一项都是一个<code>promise</code>对象。当数组中所有的<code>promise</code>的状态都达到<code>resolved</code>的时候，<code>all</code>方法的状态就会变成<code>resolved</code>，如果有一个状态变成了<code>rejected</code>，那么<code>all</code>方法的状态就会变成<code>rejected</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript">javascript<br><span class="hljs-keyword">let</span> promise1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>       <span class="hljs-title function_">resolve</span>(<span class="hljs-number">1</span>);<br>&#125;,<span class="hljs-number">2000</span>)<br>&#125;);<br><span class="hljs-keyword">let</span> promise2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>       <span class="hljs-title function_">resolve</span>(<span class="hljs-number">2</span>);<br>&#125;,<span class="hljs-number">1000</span>)<br>&#125;);<br><span class="hljs-keyword">let</span> promise3 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>       <span class="hljs-title function_">resolve</span>(<span class="hljs-number">3</span>);<br>&#125;,<span class="hljs-number">3000</span>)<br>&#125;);<br><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>([promise1,promise2,promise3]).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span>=&gt;</span>&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res);<br>    <span class="hljs-comment">//结果为：[1,2,3] </span><br>&#125;)<br></code></pre></td></tr></table></figure><p>调用<code>all</code>方法时的结果成功的时候是回调函数的参数也是一个数组，这个数组按顺序保存着每一个promise对象<code>resolve</code>执行时的值。</p><p><strong>（4）race()</strong></p><p><code>race</code>方法和<code>all</code>一样，接受的参数是一个每项都是<code>promise</code>的数组，但是与<code>all</code>不同的是，当最先执行完的事件执行完之后，就直接返回该<code>promise</code>对象的值。如果第一个<code>promise</code>对象状态变成<code>resolved</code>，那自身的状态变成了<code>resolved</code>；反之第一个<code>promise</code>变成<code>rejected</code>，那自身状态就会变成<code>rejected</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> promise1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>       <span class="hljs-title function_">reject</span>(<span class="hljs-number">1</span>);<br>&#125;,<span class="hljs-number">2000</span>)<br>&#125;);<br><span class="hljs-keyword">let</span> promise2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>       <span class="hljs-title function_">resolve</span>(<span class="hljs-number">2</span>);<br>&#125;,<span class="hljs-number">1000</span>)<br>&#125;);<br><span class="hljs-keyword">let</span> promise3 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>       <span class="hljs-title function_">resolve</span>(<span class="hljs-number">3</span>);<br>&#125;,<span class="hljs-number">3000</span>)<br>&#125;);<br><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">race</span>([promise1,promise2,promise3]).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span>=&gt;</span>&#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res);<br><span class="hljs-comment">//结果：2</span><br>&#125;,<span class="hljs-function"><span class="hljs-params">rej</span>=&gt;</span>&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(rej)&#125;;<br>)<br></code></pre></td></tr></table></figure><p>那么<code>race</code>方法有什么实际作用呢？当要做一件事，超过多长时间就不做了，可以用这个方法来解决：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">race</span>([promise1,<span class="hljs-title function_">timeOutPromise</span>(<span class="hljs-number">5000</span>)]).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span>=&gt;</span>&#123;&#125;)<br></code></pre></td></tr></table></figure><p><strong>5. finally()</strong></p><p><code>finally</code>方法用于指定不管 Promise 对象最后状态如何，都会执行的操作。该方法是 ES2018 引入标准的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript">promise<br>.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> &#123;···&#125;)<br>.<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> &#123;···&#125;)<br>.<span class="hljs-title function_">finally</span>(<span class="hljs-function">() =&gt;</span> &#123;···&#125;);<br></code></pre></td></tr></table></figure><p>上面代码中，不管<code>promise</code>最后的状态，在执行完<code>then</code>或<code>catch</code>指定的回调函数以后，都会执行<code>finally</code>方法指定的回调函数。</p><p>下面是一个例子，服务器使用 Promise 处理请求，然后使用<code>finally</code>方法关掉服务器。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript">server.<span class="hljs-title function_">listen</span>(port)<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// ...</span><br>  &#125;)<br>  .<span class="hljs-title function_">finally</span>(server.<span class="hljs-property">stop</span>);<br></code></pre></td></tr></table></figure><p><code>finally</code>方法的回调函数不接受任何参数，这意味着没有办法知道，前面的 Promise 状态到底是<code>fulfilled</code>还是<code>rejected</code>。这表明，<code>finally</code>方法里面的操作，应该是与状态无关的，不依赖于 Promise 的执行结果。<code>finally</code>本质上是<code>then</code>方法的特例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript">promise<br>.<span class="hljs-title function_">finally</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-comment">// 语句</span><br>&#125;);<br><span class="hljs-comment">// 等同于</span><br>promise<br>.<span class="hljs-title function_">then</span>(<br>  <span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> &#123;<br>    <span class="hljs-comment">// 语句</span><br>    <span class="hljs-keyword">return</span> result;<br>  &#125;,<br>  <span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> &#123;<br>    <span class="hljs-comment">// 语句</span><br>    <span class="hljs-keyword">throw</span> error;<br>  &#125;<br>);<br></code></pre></td></tr></table></figure><p>上面代码中，如果不使用<code>finally</code>方法，同样的语句需要为成功和失败两种情况各写一次。有了<code>finally</code>方法，则只需要写一次。</p><h3 id="5-Promise解决了什么问题"><a href="#5-Promise解决了什么问题" class="headerlink" title="5. Promise解决了什么问题"></a>5. Promise解决了什么问题</h3><p>在工作中经常会碰到这样一个需求，比如我使用ajax发一个A请求后，成功后拿到数据，需要把数据传给B请求；那么需要如下编写代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>)<br>fs.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">&#x27;./a.txt&#x27;</span>,<span class="hljs-string">&#x27;utf8&#x27;</span>,<span class="hljs-keyword">function</span>(<span class="hljs-params">err,data</span>)&#123;<br>  fs.<span class="hljs-title function_">readFile</span>(data,<span class="hljs-string">&#x27;utf8&#x27;</span>,<span class="hljs-keyword">function</span>(<span class="hljs-params">err,data</span>)&#123;<br>    fs.<span class="hljs-title function_">readFile</span>(data,<span class="hljs-string">&#x27;utf8&#x27;</span>,<span class="hljs-keyword">function</span>(<span class="hljs-params">err,data</span>)&#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data)<br>    &#125;)<br>  &#125;)<br>&#125;)<br></code></pre></td></tr></table></figure><p>上面的代码有如下缺点：</p><ul><li>后一个请求需要依赖于前一个请求成功后，将数据往下传递，会导致多个ajax请求嵌套的情况，代码不够直观。</li><li>如果前后两个请求不需要传递参数的情况下，那么后一个请求也需要前一个请求成功后再执行下一步操作，这种情况下，那么也需要如上编写代码，导致代码不够直观。</li></ul><p><code>Promise</code>出现之后，代码变成这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>)<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">read</span>(<span class="hljs-params">url</span>)&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br>    fs.<span class="hljs-title function_">readFile</span>(url,<span class="hljs-string">&#x27;utf8&#x27;</span>,<span class="hljs-keyword">function</span>(<span class="hljs-params">error,data</span>)&#123;<br>      error &amp;&amp; <span class="hljs-title function_">reject</span>(error)<br>      <span class="hljs-title function_">resolve</span>(data)<br>    &#125;)<br>  &#125;)<br>&#125;<br><span class="hljs-title function_">read</span>(<span class="hljs-string">&#x27;./a.txt&#x27;</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">data</span>=&gt;</span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title function_">read</span>(data) <br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">data</span>=&gt;</span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title function_">read</span>(data)  <br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">data</span>=&gt;</span>&#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data)<br>&#125;)<br></code></pre></td></tr></table></figure><p>这样代码看起了就简洁了很多，解决了地狱回调的问题。</p><h3 id="6-Promise-all和Promise-race的区别的使用场景"><a href="#6-Promise-all和Promise-race的区别的使用场景" class="headerlink" title="6. Promise.all和Promise.race的区别的使用场景"></a>6. Promise.all和Promise.race的区别的使用场景</h3><p><strong>（1）Promise.all</strong><br><code>Promise.all</code>可以将多个<code>Promise</code>实例包装成一个新的Promise实例。同时，成功和失败的返回值是不同的，成功的时候返回的是<strong>一个结果数组</strong>，而失败的时候则返回<strong>最先被reject失败状态的值</strong>。</p><p>Promise.all中传入的是数组，返回的也是是数组，并且会将进行映射，传入的promise对象返回的值是按照顺序在数组中排列的，但是注意的是他们执行的顺序并不是按照顺序的，除非可迭代对象为空。</p><p>需要注意，Promise.all获得的成功结果的数组里面的数据顺序和Promise.all接收到的数组顺序是一致的，这样当遇到发送多个请求并根据请求顺序获取和使用数据的场景，就可以使用Promise.all来解决。</p><p><strong>（2）Promise.race</strong></p><p>顾名思义，Promse.race就是赛跑的意思，意思就是说，Promise.race([p1, p2, p3])里面哪个结果获得的快，就返回那个结果，不管结果本身是成功状态还是失败状态。当要做一件事，超过多长时间就不做了，可以用这个方法来解决：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">race</span>([promise1,<span class="hljs-title function_">timeOutPromise</span>(<span class="hljs-number">5000</span>)]).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span>=&gt;</span>&#123;&#125;)<br></code></pre></td></tr></table></figure><h3 id="7-对async-x2F-await-的理解"><a href="#7-对async-x2F-await-的理解" class="headerlink" title="7.  对async&#x2F;await 的理解"></a>7.  对async&#x2F;await 的理解</h3><p>async&#x2F;await其实是<code>Generator</code> 的语法糖，它能实现的效果都能用then链来实现，它是为优化then链而开发出来的。从字面上来看，async是“异步”的简写，await则为等待，所以很好理解async 用于申明一个 function 是异步的，而 await 用于等待一个异步方法执行完成。当然语法上强制规定await只能出现在asnyc函数中，先来看看async函数返回了什么： </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">testAsy</span>(<span class="hljs-params"></span>)&#123;<br>   <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;hello world&#x27;</span>;<br>&#125;<br><span class="hljs-keyword">let</span> result = <span class="hljs-title function_">testAsy</span>(); <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result)<br></code></pre></td></tr></table></figure><p><img src="3.png" alt="img"></p><p>所以，async 函数返回的是一个 Promise 对象。async 函数（包含函数语句、函数表达式、Lambda表达式）会返回一个 Promise 对象，如果在函数中 <code>return</code> 一个直接量，async 会把这个直接量通过 <code>Promise.resolve()</code> 封装成 Promise 对象。</p><p>async 函数返回的是一个 Promise 对象，所以在最外层不能用 await 获取其返回值的情况下，当然应该用原来的方式：<code>then()</code> 链来处理这个 Promise 对象，就像这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">testAsy</span>(<span class="hljs-params"></span>)&#123;<br>   <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;hello world&#x27;</span><br>&#125;<br><span class="hljs-keyword">let</span> result = <span class="hljs-title function_">testAsy</span>() <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result)<br>result.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">v</span>=&gt;</span>&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(v)   <span class="hljs-comment">// hello world</span><br>&#125;)<br></code></pre></td></tr></table></figure><p>那如果 async 函数没有返回值，又该如何？很容易想到，它会返回 <code>Promise.resolve(undefined)</code>。</p><p>联想一下 Promise 的特点——无等待，所以在没有 <code>await</code> 的情况下执行 async 函数，它会立即执行，返回一个 Promise 对象，并且，绝不会阻塞后面的语句。这和普通返回 Promise 对象的函数并无二致。</p><p><strong>注意：</strong><code>Promise.resolve(x)</code> 可以看作是 <code>new Promise(resolve =&gt; resolve(x))</code> 的简写，可以用于快速封装字面量对象或其他对象，将其封装成 Promise 实例。</p><h3 id="8-await-到底在等啥？"><a href="#8-await-到底在等啥？" class="headerlink" title="8. await 到底在等啥？"></a>8. await 到底在等啥？</h3><p><strong>await 在等待什么呢？</strong> 一般来说，都认为 await 是在等待一个 async 函数完成。不过按语法说明，await 等待的是一个表达式，这个表达式的计算结果是 Promise 对象或者其它值（换句话说，就是没有特殊限定）。</p><p>因为 async 函数返回一个 Promise 对象，所以 await 可以用于等待一个 async 函数的返回值——这也可以说是 await 在等 async 函数，但要清楚，它等的实际是一个返回值。注意到 await 不仅仅用于等 Promise 对象，它可以等任意表达式的结果，所以，await 后面实际是可以接普通函数调用或者直接量的。所以下面这个示例完全可以正确运行：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">getSomething</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;something&quot;</span>;<br>&#125;<br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">testAsync</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-string">&quot;hello async&quot;</span>);<br>&#125;<br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">test</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">const</span> v1 = <span class="hljs-keyword">await</span> <span class="hljs-title function_">getSomething</span>();<br>    <span class="hljs-keyword">const</span> v2 = <span class="hljs-keyword">await</span> <span class="hljs-title function_">testAsync</span>();<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(v1, v2);<br>&#125;<br><span class="hljs-title function_">test</span>();<br></code></pre></td></tr></table></figure><p>await 表达式的运算结果取决于它等的是什么。</p><ul><li>如果它等到的不是一个 Promise 对象，那 await 表达式的运算结果就是它等到的东西。</li><li>如果它等到的是一个 Promise 对象，await 就忙起来了，它会阻塞后面的代码，等着 Promise 对象 resolve，然后得到 resolve 的值，作为 await 表达式的运算结果。</li></ul><p>来看一个例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">testAsy</span>(<span class="hljs-params">x</span>)&#123;<br>   <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span>=&gt;</span>&#123;<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>       <span class="hljs-title function_">resolve</span>(x);<br>     &#125;, <span class="hljs-number">3000</span>)<br>    &#125;<br>   )<br>&#125;<br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">testAwt</span>(<span class="hljs-params"></span>)&#123;    <br>  <span class="hljs-keyword">let</span> result =  <span class="hljs-keyword">await</span> <span class="hljs-title function_">testAsy</span>(<span class="hljs-string">&#x27;hello world&#x27;</span>);<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result);    <span class="hljs-comment">// 3秒钟之后出现hello world</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;cuger&#x27;</span>)   <span class="hljs-comment">// 3秒钟之后出现cug</span><br>&#125;<br><span class="hljs-title function_">testAwt</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;cug&#x27;</span>)  <span class="hljs-comment">//立即输出cug</span><br></code></pre></td></tr></table></figure><p>这就是 await 必须用在 async 函数中的原因。async 函数调用不会造成阻塞，它内部所有的阻塞都被封装在一个 Promise 对象中异步执行。await暂停当前async的执行，所以’cug’’最先输出，hello world’和‘cuger’是3秒钟后同时出现的。</p><h3 id="9-async-x2F-await的优势"><a href="#9-async-x2F-await的优势" class="headerlink" title="9.  async&#x2F;await的优势"></a>9.  async&#x2F;await的优势</h3><p>单一的 Promise 链并不能发现 async&#x2F;await 的优势，但是，如果需要处理由多个 Promise 组成的 then 链的时候，优势就能体现出来了（很有意思，Promise 通过 then 链来解决多层回调的问题，现在又用 async&#x2F;await 来进一步优化它）。</p><p>假设一个业务，分多个步骤完成，每个步骤都是异步的，而且依赖于上一个步骤的结果。仍然用 <code>setTimeout</code> 来模拟异步操作：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 传入参数 n，表示这个函数执行的时间（毫秒）</span><br><span class="hljs-comment"> * 执行的结果是 n + 200，这个值将用于下一步骤</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">takeLongTime</span>(<span class="hljs-params">n</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> &#123;<br>        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">resolve</span>(n + <span class="hljs-number">200</span>), n);<br>    &#125;);<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">step1</span>(<span class="hljs-params">n</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`step1 with <span class="hljs-subst">$&#123;n&#125;</span>`</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">takeLongTime</span>(n);<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">step2</span>(<span class="hljs-params">n</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`step2 with <span class="hljs-subst">$&#123;n&#125;</span>`</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">takeLongTime</span>(n);<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">step3</span>(<span class="hljs-params">n</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`step3 with <span class="hljs-subst">$&#123;n&#125;</span>`</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">takeLongTime</span>(n);<br>&#125;<br></code></pre></td></tr></table></figure><p>现在用 Promise 方式来实现这三个步骤的处理：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">doIt</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">time</span>(<span class="hljs-string">&quot;doIt&quot;</span>);<br>    <span class="hljs-keyword">const</span> time1 = <span class="hljs-number">300</span>;<br>    <span class="hljs-title function_">step1</span>(time1)<br>        .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">time2</span> =&gt;</span> <span class="hljs-title function_">step2</span>(time2))<br>        .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">time3</span> =&gt;</span> <span class="hljs-title function_">step3</span>(time3))<br>        .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> &#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`result is <span class="hljs-subst">$&#123;result&#125;</span>`</span>);<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">timeEnd</span>(<span class="hljs-string">&quot;doIt&quot;</span>);<br>        &#125;);<br>&#125;<br><span class="hljs-title function_">doIt</span>();<br><span class="hljs-comment">// c:\var\test&gt;node --harmony_async_await .</span><br><span class="hljs-comment">// step1 with 300</span><br><span class="hljs-comment">// step2 with 500</span><br><span class="hljs-comment">// step3 with 700</span><br><span class="hljs-comment">// result is 900</span><br><span class="hljs-comment">// doIt: 1507.251ms</span><br></code></pre></td></tr></table></figure><p>输出结果 <code>result</code> 是 <code>step3()</code> 的参数 <code>700 + 200</code> &#x3D; <code>900</code>。<code>doIt()</code> 顺序执行了三个步骤，一共用了 <code>300 + 500 + 700 = 1500</code> 毫秒，和 <code>console.time()/console.timeEnd()</code> 计算的结果一致。</p><p>如果用 async&#x2F;await 来实现呢，会是这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">doIt</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">time</span>(<span class="hljs-string">&quot;doIt&quot;</span>);<br>    <span class="hljs-keyword">const</span> time1 = <span class="hljs-number">300</span>;<br>    <span class="hljs-keyword">const</span> time2 = <span class="hljs-keyword">await</span> <span class="hljs-title function_">step1</span>(time1);<br>    <span class="hljs-keyword">const</span> time3 = <span class="hljs-keyword">await</span> <span class="hljs-title function_">step2</span>(time2);<br>    <span class="hljs-keyword">const</span> result = <span class="hljs-keyword">await</span> <span class="hljs-title function_">step3</span>(time3);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`result is <span class="hljs-subst">$&#123;result&#125;</span>`</span>);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">timeEnd</span>(<span class="hljs-string">&quot;doIt&quot;</span>);<br>&#125;<br><span class="hljs-title function_">doIt</span>();<br></code></pre></td></tr></table></figure><p>结果和之前的 Promise 实现是一样的，但是这个代码看起来是不是清晰得多，几乎跟同步代码一样</p><h3 id="10-async-x2F-await对比Promise的优势"><a href="#10-async-x2F-await对比Promise的优势" class="headerlink" title="10. async&#x2F;await对比Promise的优势"></a>10. async&#x2F;await对比Promise的优势</h3><ul><li>代码读起来更加同步，Promise虽然摆脱了回调地狱，但是then的链式调⽤也会带来额外的阅读负担 </li><li>Promise传递中间值⾮常麻烦，⽽async&#x2F;await⼏乎是同步的写法，⾮常优雅 </li><li>错误处理友好，async&#x2F;await可以⽤成熟的try&#x2F;catch，Promise的错误捕获⾮常冗余 </li><li>调试友好，Promise的调试很差，由于没有代码块，你不能在⼀个返回表达式的箭头函数中设置断点，如果你在⼀个.then代码块中使⽤调试器的步进(step-over)功能，调试器并不会进⼊后续的.then代码块，因为调试器只能跟踪同步代码的每⼀步。</li></ul><h3 id="11-async-x2F-await-如何捕获异常"><a href="#11-async-x2F-await-如何捕获异常" class="headerlink" title="11. async&#x2F;await 如何捕获异常"></a>11. async&#x2F;await 如何捕获异常</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">try</span>&#123;<br>        <span class="hljs-keyword">let</span> a = <span class="hljs-keyword">await</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(<span class="hljs-string">&#x27;error&#x27;</span>)<br>    &#125;<span class="hljs-keyword">catch</span>(error)&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(error)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="12-并发与并行的区别？"><a href="#12-并发与并行的区别？" class="headerlink" title="12. 并发与并行的区别？"></a>12. 并发与并行的区别？</h3><ul><li>并发是宏观概念，我分别有任务 A 和任务 B，在一段时间内通过任务间的切换完成了这两个任务，这种情况就可以称之为并发。</li><li>并行是微观概念，假设 CPU 中存在两个核心，那么我就可以同时完成任务 A、B。同时完成多个任务的情况就可以称之为并行。</li></ul><h3 id="13-什么是回调函数？回调函数有什么缺点？如何解决回调地狱问题？"><a href="#13-什么是回调函数？回调函数有什么缺点？如何解决回调地狱问题？" class="headerlink" title="13. 什么是回调函数？回调函数有什么缺点？如何解决回调地狱问题？"></a>13. 什么是回调函数？回调函数有什么缺点？如何解决回调地狱问题？</h3><p>以下代码就是一个回调函数的例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">ajax</span>(url, <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-comment">// 处理逻辑</span><br>&#125;)<br></code></pre></td></tr></table></figure><p>回调函数有一个致命的弱点，就是容易写出回调地狱（Callback hell）。假设多个请求存在依赖性，可能会有如下代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">ajax</span>(url, <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-comment">// 处理逻辑</span><br>    <span class="hljs-title function_">ajax</span>(url1, <span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-comment">// 处理逻辑</span><br>        <span class="hljs-title function_">ajax</span>(url2, <span class="hljs-function">() =&gt;</span> &#123;<br>            <span class="hljs-comment">// 处理逻辑</span><br>        &#125;)<br>    &#125;)<br>&#125;)<br></code></pre></td></tr></table></figure><p>以上代码看起来不利于阅读和维护，当然，也可以把函数分开来写：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">firstAjax</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-title function_">ajax</span>(url1, <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-comment">// 处理逻辑</span><br>    <span class="hljs-title function_">secondAjax</span>()<br>  &#125;)<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">secondAjax</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-title function_">ajax</span>(url2, <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-comment">// 处理逻辑</span><br>  &#125;)<br>&#125;<br><span class="hljs-title function_">ajax</span>(url, <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-comment">// 处理逻辑</span><br>  <span class="hljs-title function_">firstAjax</span>()<br>&#125;)<br></code></pre></td></tr></table></figure><p>以上的代码虽然看上去利于阅读了，但是还是没有解决根本问题。回调地狱的根本问题就是：</p><ol><li>嵌套函数存在耦合性，一旦有所改动，就会牵一发而动全身</li><li>嵌套函数一多，就很难处理错误</li></ol><p>当然，回调函数还存在着别的几个缺点，比如不能使用 <code>try catch</code> 捕获错误，不能直接 <code>return</code>。</p><h3 id="14-setTimeout、setInterval、requestAnimationFrame-各有什么特点？"><a href="#14-setTimeout、setInterval、requestAnimationFrame-各有什么特点？" class="headerlink" title="14. setTimeout、setInterval、requestAnimationFrame 各有什么特点？"></a>14. setTimeout、setInterval、requestAnimationFrame 各有什么特点？</h3><p>异步编程当然少不了定时器了，常见的定时器函数有 <code>setTimeout</code>、<code>setInterval</code>、<code>requestAnimationFrame</code>。最常用的是<code>setTimeout</code>，很多人认为 <code>setTimeout</code> 是延时多久，那就应该是多久后执行。</p><p>其实这个观点是错误的，因为 JS 是单线程执行的，如果前面的代码影响了性能，就会导致 <code>setTimeout</code> 不会按期执行。当然了，可以通过代码去修正 <code>setTimeout</code>，从而使定时器相对准确：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> period = <span class="hljs-number">60</span> * <span class="hljs-number">1000</span> * <span class="hljs-number">60</span> * <span class="hljs-number">2</span><br><span class="hljs-keyword">let</span> startTime = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>().<span class="hljs-title function_">getTime</span>()<br><span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span><br><span class="hljs-keyword">let</span> end = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>().<span class="hljs-title function_">getTime</span>() + period<br><span class="hljs-keyword">let</span> interval = <span class="hljs-number">1000</span><br><span class="hljs-keyword">let</span> currentInterval = interval<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">loop</span>(<span class="hljs-params"></span>) &#123;<br>  count++<br>  <span class="hljs-comment">// 代码执行所消耗的时间</span><br>  <span class="hljs-keyword">let</span> offset = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>().<span class="hljs-title function_">getTime</span>() - (startTime + count * interval);<br>  <span class="hljs-keyword">let</span> diff = end - <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>().<span class="hljs-title function_">getTime</span>()<br>  <span class="hljs-keyword">let</span> h = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(diff / (<span class="hljs-number">60</span> * <span class="hljs-number">1000</span> * <span class="hljs-number">60</span>))<br>  <span class="hljs-keyword">let</span> hdiff = diff % (<span class="hljs-number">60</span> * <span class="hljs-number">1000</span> * <span class="hljs-number">60</span>)<br>  <span class="hljs-keyword">let</span> m = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(hdiff / (<span class="hljs-number">60</span> * <span class="hljs-number">1000</span>))<br>  <span class="hljs-keyword">let</span> mdiff = hdiff % (<span class="hljs-number">60</span> * <span class="hljs-number">1000</span>)<br>  <span class="hljs-keyword">let</span> s = mdiff / (<span class="hljs-number">1000</span>)<br>  <span class="hljs-keyword">let</span> sCeil = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">ceil</span>(s)<br>  <span class="hljs-keyword">let</span> sFloor = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(s)<br>  <span class="hljs-comment">// 得到下一次循环所消耗的时间</span><br>  currentInterval = interval - offset <br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;时：&#x27;</span>+h, <span class="hljs-string">&#x27;分：&#x27;</span>+m, <span class="hljs-string">&#x27;毫秒：&#x27;</span>+s, <span class="hljs-string">&#x27;秒向上取整：&#x27;</span>+sCeil, <span class="hljs-string">&#x27;代码执行时间：&#x27;</span>+offset, <span class="hljs-string">&#x27;下次循环间隔&#x27;</span>+currentInterval) <br>  <span class="hljs-built_in">setTimeout</span>(loop, currentInterval)<br>&#125;<br><span class="hljs-built_in">setTimeout</span>(loop, currentInterval)<br></code></pre></td></tr></table></figure><p>接下来看 <code>setInterval</code>，其实这个函数作用和 <code>setTimeout</code> 基本一致，只是该函数是每隔一段时间执行一次回调函数。</p><p>通常来说不建议使用 <code>setInterval</code>。第一，它和 <code>setTimeout</code> 一样，不能保证在预期的时间执行任务。第二，它存在执行累积的问题，请看以下伪代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">demo</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-built_in">setInterval</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">2</span>)<br>  &#125;,<span class="hljs-number">1000</span>)<br>  <span class="hljs-title function_">sleep</span>(<span class="hljs-number">2000</span>)<br>&#125;<br><span class="hljs-title function_">demo</span>()<br></code></pre></td></tr></table></figure><p>以上代码在浏览器环境中，如果定时器执行过程中出现了耗时操作，多个回调函数会在耗时操作结束以后同时执行，这样可能就会带来性能上的问题。</p><p>如果有循环定时器的需求，其实完全可以通过 <code>requestAnimationFrame</code> 来实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">setInterval</span>(<span class="hljs-params">callback, interval</span>) &#123;<br>  <span class="hljs-keyword">let</span> timer<br>  <span class="hljs-keyword">const</span> now = <span class="hljs-title class_">Date</span>.<span class="hljs-property">now</span><br>  <span class="hljs-keyword">let</span> startTime = <span class="hljs-title function_">now</span>()<br>  <span class="hljs-keyword">let</span> endTime = startTime<br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">loop</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    timer = <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">requestAnimationFrame</span>(loop)<br>    endTime = <span class="hljs-title function_">now</span>()<br>    <span class="hljs-keyword">if</span> (endTime - startTime &gt;= interval) &#123;<br>      startTime = endTime = <span class="hljs-title function_">now</span>()<br>      <span class="hljs-title function_">callback</span>(timer)<br>    &#125;<br>  &#125;<br>  timer = <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">requestAnimationFrame</span>(loop)<br>  <span class="hljs-keyword">return</span> timer<br>&#125;<br><span class="hljs-keyword">let</span> a = <span class="hljs-number">0</span><br><span class="hljs-built_in">setInterval</span>(<span class="hljs-function"><span class="hljs-params">timer</span> =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">1</span>)<br>  a++<br>  <span class="hljs-keyword">if</span> (a === <span class="hljs-number">3</span>) <span class="hljs-title function_">cancelAnimationFrame</span>(timer)<br>&#125;, <span class="hljs-number">1000</span>)<br></code></pre></td></tr></table></figure><p>首先 <code>requestAnimationFrame</code> 自带函数节流功能，基本可以保证在 16.6 毫秒内只执行一次（不掉帧的情况下），并且该函数的延时效果是精确的，没有其他定时器时间不准的问题，当然你也可以通过该函数来实现 <code>setTimeout</code>。</p><h2 id="八、面向对象"><a href="#八、面向对象" class="headerlink" title="八、面向对象"></a>八、面向对象</h2><h3 id="1-对象创建的方式有哪些？"><a href="#1-对象创建的方式有哪些？" class="headerlink" title="1. 对象创建的方式有哪些？"></a>1. 对象创建的方式有哪些？</h3><p>一般使用字面量的形式直接创建对象，但是这种创建方式对于创建大量相似对象的时候，会产生大量的重复代码。但 js和一般的面向对象的语言不同，在 ES6 之前它没有类的概念。但是可以使用函数来进行模拟，从而产生出可复用的对象创建方式，常见的有以下几种：</p><p>（1）第一种是工厂模式，工厂模式的主要工作原理是用函数来封装创建对象的细节，从而通过调用函数来达到复用的目的。但是它有一个很大的问题就是创建出来的对象无法和某个类型联系起来，它只是简单的封装了复用代码，而没有建立起对象和类型间的关系。</p><p>（2）第二种是构造函数模式。js 中每一个函数都可以作为构造函数，只要一个函数是通过 new 来调用的，那么就可以把它称为构造函数。执行构造函数首先会创建一个对象，然后将对象的原型指向构造函数的 prototype 属性，然后将执行上下文中的 this 指向这个对象，最后再执行整个函数，如果返回值不是对象，则返回新建的对象。因为 this 的值指向了新建的对象，因此可以使用 this 给对象赋值。构造函数模式相对于工厂模式的优点是，所创建的对象和构造函数建立起了联系，因此可以通过原型来识别对象的类型。但是构造函数存在一个缺点就是，造成了不必要的函数对象的创建，因为在 js 中函数也是一个对象，因此如果对象属性中如果包含函数的话，那么每次都会新建一个函数对象，浪费了不必要的内存空间，因为函数是所有的实例都可以通用的。</p><p>（3）第三种模式是原型模式，因为每一个函数都有一个 prototype 属性，这个属性是一个对象，它包含了通过构造函数创建的所有实例都能共享的属性和方法。因此可以使用原型对象来添加公用属性和方法，从而实现代码的复用。这种方式相对于构造函数模式来说，解决了函数对象的复用问题。但是这种模式也存在一些问题，一个是没有办法通过传入参数来初始化值，另一个是如果存在一个引用类型如 Array 这样的值，那么所有的实例将共享一个对象，一个实例对引用类型值的改变会影响所有的实例。</p><p>（4）第四种模式是组合使用构造函数模式和原型模式，这是创建自定义类型的最常见方式。因为构造函数模式和原型模式分开使用都存在一些问题，因此可以组合使用这两种模式，通过构造函数来初始化对象的属性，通过原型对象来实现函数方法的复用。这种方法很好的解决了两种模式单独使用时的缺点，但是有一点不足的就是，因为使用了两种不同的模式，所以对于代码的封装性不够好。</p><p>（5）第五种模式是动态原型模式，这一种模式将原型方法赋值的创建过程移动到了构造函数的内部，通过对属性是否存在的判断，可以实现仅在第一次调用函数时对原型对象赋值一次的效果。这一种方式很好地对上面的混合模式进行了封装。</p><p>（6）第六种模式是寄生构造函数模式，这一种模式和工厂模式的实现基本相同，我对这个模式的理解是，它主要是基于一个已有的类型，在实例化时对实例化的对象进行扩展。这样既不用修改原来的构造函数，也达到了扩展对象的目的。它的一个缺点和工厂模式一样，无法实现对象的识别。</p><h3 id="2-对象继承的方式有哪些？"><a href="#2-对象继承的方式有哪些？" class="headerlink" title="2. 对象继承的方式有哪些？"></a>2. 对象继承的方式有哪些？</h3><p>（1）第一种是以原型链的方式来实现继承，但是这种实现方式存在的缺点是，在包含有引用类型的数据时，会被所有的实例对象所共享，容易造成修改的混乱。还有就是在创建子类型的时候不能向超类型传递参数。</p><p>（2）第二种方式是使用借用构造函数的方式，这种方式是通过在子类型的函数中调用超类型的构造函数来实现的，这一种方法解决了不能向超类型传递参数的缺点，但是它存在的一个问题就是无法实现函数方法的复用，并且超类型原型定义的方法子类型也没有办法访问到。</p><p>（3）第三种方式是组合继承，组合继承是将原型链和借用构造函数组合起来使用的一种方式。通过借用构造函数的方式来实现类型的属性的继承，通过将子类型的原型设置为超类型的实例来实现方法的继承。这种方式解决了上面的两种模式单独使用时的问题，但是由于我们是以超类型的实例来作为子类型的原型，所以调用了两次超类的构造函数，造成了子类型的原型中多了很多不必要的属性。</p><p>（4）第四种方式是原型式继承，原型式继承的主要思路就是基于已有的对象来创建新的对象，实现的原理是，向函数中传入一个对象，然后返回一个以这个对象为原型的对象。这种继承的思路主要不是为了实现创造一种新的类型，只是对某个对象实现一种简单继承，ES5 中定义的 Object.create() 方法就是原型式继承的实现。缺点与原型链方式相同。</p><p>（5）第五种方式是寄生式继承，寄生式继承的思路是创建一个用于封装继承过程的函数，通过传入一个对象，然后复制一个对象的副本，然后对象进行扩展，最后返回这个对象。这个扩展的过程就可以理解是一种继承。这种继承的优点就是对一个简单对象实现继承，如果这个对象不是自定义类型时。缺点是没有办法实现函数的复用。</p><p>（6）第六种方式是寄生式组合继承，组合继承的缺点就是使用超类型的实例做为子类型的原型，导致添加了不必要的原型属性。寄生式组合继承的方式是使用超类型的原型的副本来作为子类型的原型，这样就避免了创建不必要的属性。</p><h2 id="九、垃圾回收与内存泄漏"><a href="#九、垃圾回收与内存泄漏" class="headerlink" title="九、垃圾回收与内存泄漏"></a>九、垃圾回收与内存泄漏</h2><h3 id="1-浏览器的垃圾回收机制"><a href="#1-浏览器的垃圾回收机制" class="headerlink" title="1. 浏览器的垃圾回收机制"></a>1. 浏览器的垃圾回收机制</h3><h4 id="（1）垃圾回收的概念"><a href="#（1）垃圾回收的概念" class="headerlink" title="（1）垃圾回收的概念"></a>（1）垃圾回收的概念</h4><p><strong>垃圾回收</strong>：JavaScript代码运行时，需要分配内存空间来储存变量和值。当变量不在参与运行时，就需要系统收回被占用的内存空间，这就是垃圾回收。</p><p><strong>回收机制</strong>：</p><ul><li>Javascript 具有自动垃圾回收机制，会定期对那些不再使用的变量、对象所占用的内存进行释放，原理就是找到不再使用的变量，然后释放掉其占用的内存。</li><li>JavaScript中存在两种变量：局部变量和全局变量。全局变量的生命周期会持续要页面卸载；而局部变量声明在函数中，它的生命周期从函数执行开始，直到函数执行结束，在这个过程中，局部变量会在堆或栈中存储它们的值，当函数执行结束后，这些局部变量不再被使用，它们所占有的空间就会被释放。</li><li>不过，当局部变量被外部函数使用时，其中一种情况就是闭包，在函数执行结束后，函数外部的变量依然指向函数内部的局部变量，此时局部变量依然在被使用，所以不会回收。</li></ul><h4 id="（2）垃圾回收的方式"><a href="#（2）垃圾回收的方式" class="headerlink" title="（2）垃圾回收的方式"></a>（2）垃圾回收的方式</h4><p>浏览器通常使用的垃圾回收方法有两种：标记清除，引用计数。<br><strong>1）标记清除</strong></p><ul><li>标记清除是浏览器常见的垃圾回收方式，当变量进入执行环境时，就标记这个变量“进入环境”，被标记为“进入环境”的变量是不能被回收的，因为他们正在被使用。当变量离开环境时，就会被标记为“离开环境”，被标记为“离开环境”的变量会被内存释放。</li><li>垃圾收集器在运行的时候会给存储在内存中的所有变量都加上标记。然后，它会去掉环境中的变量以及被环境中的变量引用的标记。而在此之后再被加上标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。最后。垃圾收集器完成内存清除工作，销毁那些带标记的值，并回收他们所占用的内存空间。</li></ul><p><strong>2）引用计数</strong></p><ul><li>另外一种垃圾回收机制就是引用计数，这个用的相对较少。引用计数就是跟踪记录每个值被引用的次数。当声明了一个变量并将一个引用类型赋值给该变量时，则这个值的引用次数就是1。相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数就减1。当这个引用次数变为0时，说明这个变量已经没有价值，因此，在在机回收期下次再运行时，这个变量所占有的内存空间就会被释放出来。</li><li>这种方法会引起<strong>循环引用</strong>的问题：例如：<code> obj1</code>和<code>obj2</code>通过属性进行相互引用，两个对象的引用次数都是2。当使用循环计数时，由于函数执行完后，两个对象都离开作用域，函数执行结束，<code>obj1</code>和<code>obj2</code>还将会继续存在，因此它们的引用次数永远不会是0，就会引起循环引用。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fun</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">let</span> obj1 = &#123;&#125;;<br>    <span class="hljs-keyword">let</span> obj2 = &#123;&#125;;<br>    obj1.<span class="hljs-property">a</span> = obj2; <span class="hljs-comment">// obj1 引用 obj2</span><br>    obj2.<span class="hljs-property">a</span> = obj1; <span class="hljs-comment">// obj2 引用 obj1</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这种情况下，就要手动释放变量占用的内存：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">obj1.<span class="hljs-property">a</span> =  <span class="hljs-literal">null</span><br> obj2.<span class="hljs-property">a</span> =  <span class="hljs-literal">null</span><br></code></pre></td></tr></table></figure><h4 id="（3）减少垃圾回收"><a href="#（3）减少垃圾回收" class="headerlink" title="（3）减少垃圾回收"></a>（3）减少垃圾回收</h4><p>虽然浏览器可以进行垃圾自动回收，但是当代码比较复杂时，垃圾回收所带来的代价比较大，所以应该尽量减少垃圾回收。</p><ul><li><strong>对数组进行优化：</strong> 在清空一个数组时，最简单的方法就是给其赋值为[ ]，但是与此同时会创建一个新的空对象，可以将数组的长度设置为0，以此来达到清空数组的目的。</li><li><strong>对</strong><code>object</code><strong>进行优化：</strong> 对象尽量复用，对于不再使用的对象，就将其设置为null，尽快被回收。</li><li><strong>对函数进行优化：</strong> 在循环中的函数表达式，如果可以复用，尽量放在函数的外面。</li></ul><h3 id="2-哪些情况会导致内存泄漏"><a href="#2-哪些情况会导致内存泄漏" class="headerlink" title="2. 哪些情况会导致内存泄漏"></a>2. 哪些情况会导致内存泄漏</h3><p>以下四种情况会造成内存的泄漏：</p><ul><li><strong>意外的全局变量：</strong> 由于使用未声明的变量，而意外的创建了一个全局变量，而使这个变量一直留在内存中无法被回收。</li><li><strong>被遗忘的计时器或回调函数：</strong> 设置了 setInterval 定时器，而忘记取消它，如果循环函数有对外部变量的引用的话，那么这个变量会被一直留在内存中，而无法被回收。</li><li><strong>脱离 DOM 的引用：</strong> 获取一个 DOM 元素的引用，而后面这个元素被删除，由于一直保留了对这个元素的引用，所以它也无法被回收。</li><li><strong>闭包：</strong> 不合理的使用闭包，从而导致某些变量一直被留在内存当中。</li></ul>]]></content>
    
    
    <categories>
      
      <category>BGW</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>BGW-CSS</title>
    <link href="/2023/04/18/BGW-CSS/"/>
    <url>/2023/04/18/BGW-CSS/</url>
    
    <content type="html"><![CDATA[<p>BGW-CSS</p><p> <img src="1.png" alt="img"></p><h2 id="一、CSS基础"><a href="#一、CSS基础" class="headerlink" title="一、CSS基础"></a>一、CSS基础</h2><h3 id="1-CSS选择器及其优先级"><a href="#1-CSS选择器及其优先级" class="headerlink" title="1. CSS选择器及其优先级"></a>1. CSS选择器及其优先级</h3><table><thead><tr><th><strong>选择器</strong></th><th><strong>格式</strong></th><th><strong>优先级权重</strong></th></tr></thead><tbody><tr><td>id选择器</td><td>#id</td><td>100</td></tr><tr><td>类选择器</td><td>#classname</td><td>10</td></tr><tr><td>属性选择器</td><td>a[ref&#x3D;“eee”]</td><td>10</td></tr><tr><td>伪类选择器</td><td>li:last-child</td><td>10</td></tr><tr><td>标签选择器</td><td>div</td><td>1</td></tr><tr><td>伪元素选择器</td><td>li:after</td><td>1</td></tr><tr><td>相邻兄弟选择器</td><td>h1+p</td><td>0</td></tr><tr><td>子选择器</td><td>ul&gt;li</td><td>0</td></tr><tr><td>后代选择器</td><td>li a</td><td>0</td></tr><tr><td>通配符选择器</td><td>*</td><td>0</td></tr></tbody></table><p>对于选择器的<strong>优先级</strong>：</p><ul><li>标签选择器、伪元素选择器：1</li><li>类选择器、伪类选择器、属性选择器：10</li><li>id 选择器：100</li><li>内联样式：1000</li></ul><p><strong>注意事项：</strong></p><ul><li>!important声明的样式的优先级最高；</li><li>如果优先级相同，则最后出现的样式生效；</li><li>继承得到的样式的优先级最低；</li><li>通用选择器（*）、子选择器（&gt;）和相邻同胞选择器（+）并不在这四个等级中，所以它们的权值都为 0 ；</li><li>样式表的来源不同时，优先级顺序为：内联样式 &gt; 内部样式 &gt; 外部样式 &gt; 浏览器用户自定义样式 &gt; 浏览器默认样式。</li></ul><h3 id="2-CSS中可继承与不可继承属性有哪些"><a href="#2-CSS中可继承与不可继承属性有哪些" class="headerlink" title="2. CSS中可继承与不可继承属性有哪些"></a>2. CSS中可继承与不可继承属性有哪些</h3><p><strong>一、无继承性的属性</strong></p><ol><li><strong>display</strong>：规定元素应该生成的框的类型</li><li><strong>文本属性</strong>：</li></ol><ul><li>vertical-align：垂直文本对齐</li><li>text-decoration：规定添加到文本的装饰</li><li>text-shadow：文本阴影效果</li><li>white-space：空白符的处理</li><li>unicode-bidi：设置文本的方向</li></ul><ol start="3"><li><strong>盒子模型的属性</strong>：width、height、margin、border、padding</li><li><strong>背景属性</strong>：background、background-color、background-image、background-repeat、background-position、background-attachment</li><li><strong>定位属性</strong>：float、clear、position、top、right、bottom、left、min-width、min-height、max-width、max-height、overflow、clip、z-index</li><li><strong>生成内容属性</strong>：content、counter-reset、counter-increment</li><li><strong>轮廓样式属性</strong>：outline-style、outline-width、outline-color、outline</li><li><strong>页面样式属性</strong>：size、page-break-before、page-break-after</li><li><strong>声音样式属性</strong>：pause-before、pause-after、pause、cue-before、cue-after、cue、play-during</li></ol><p><strong>二、有继承性的属性</strong></p><ol><li><strong>字体系列属性</strong></li></ol><ul><li>font-family：字体系列</li><li>font-weight：字体的粗细</li><li>font-size：字体的大小</li><li>font-style：字体的风格</li></ul><ol start="2"><li><strong>文本系列属性</strong></li></ol><ul><li>text-indent：文本缩进</li><li>text-align：文本水平对齐</li><li>line-height：行高</li><li>word-spacing：单词之间的间距</li><li>letter-spacing：中文或者字母之间的间距</li><li>text-transform：控制文本大小写（就是uppercase、lowercase、capitalize这三个）</li><li>color：文本颜色</li></ul><ol start="3"><li><strong>元素可见性</strong></li></ol><ul><li>visibility：控制元素显示隐藏</li></ul><ol start="4"><li><strong>列表布局属性</strong></li></ol><ul><li>list-style：列表风格，包括list-style-type、list-style-image等</li></ul><ol start="5"><li><strong>光标属性</strong></li></ol><ul><li>cursor：光标显示为何种形态</li></ul><h3 id="3-display的属性值及其作用"><a href="#3-display的属性值及其作用" class="headerlink" title="3. display的属性值及其作用"></a>3. display的属性值及其作用</h3><table><thead><tr><th><strong>属性值</strong></th><th><strong>作用</strong></th></tr></thead><tbody><tr><td>none</td><td>元素不显示，并且会从文档流中移除。</td></tr><tr><td>block</td><td>块类型。默认宽度为父元素宽度，可设置宽高，换行显示。</td></tr><tr><td>inline</td><td>行内元素类型。默认宽度为内容宽度，不可设置宽高，同行显示。</td></tr><tr><td>inline-block</td><td>默认宽度为内容宽度，可以设置宽高，同行显示。</td></tr><tr><td>list-item</td><td>像块类型元素一样显示，并添加样式列表标记。</td></tr><tr><td>table</td><td>此元素会作为块级表格来显示。</td></tr><tr><td>inherit</td><td>规定应该从父元素继承display属性的值。</td></tr></tbody></table><h3 id="4-display的block、inline和inline-block的区别"><a href="#4-display的block、inline和inline-block的区别" class="headerlink" title="4. display的block、inline和inline-block的区别"></a>4. display的block、inline和inline-block的区别</h3><p>（1）<strong>block：</strong> 会独占一行，多个元素会另起一行，可以设置width、height、margin和padding属性；</p><p>（2）<strong>inline：</strong> 元素不会独占一行，设置width、height属性无效。但可以设置水平方向的margin和padding属性，不能设置垂直方向的padding和margin；</p><p>（3）<strong>inline-block：</strong> 将对象设置为inline对象，但对象的内容作为block对象呈现，之后的内联对象会被排列在同一行内。</p><p>对于行内元素和块级元素，其特点如下：</p><p><strong>（1）行内元素</strong></p><ul><li>设置宽高无效；</li><li>可以设置水平方向的margin和padding属性，不能设置垂直方向的padding和margin；</li><li>不会自动换行；</li></ul><p><strong>（2）块级元素</strong></p><ul><li>可以设置宽高；</li><li>设置margin和padding都有效；</li><li>可以自动换行；</li><li>多个块状，默认排列从上到下。</li></ul><h3 id="5-隐藏元素的方法有哪些"><a href="#5-隐藏元素的方法有哪些" class="headerlink" title="5. 隐藏元素的方法有哪些"></a>5. 隐藏元素的方法有哪些</h3><ul><li><strong>display: none</strong>：渲染树不会包含该渲染对象，因此该元素不会在页面中占据位置，也不会响应绑定的监听事件。</li><li><strong>visibility: hidden</strong>：元素在页面中仍占据空间，但是不会响应绑定的监听事件。</li><li><strong>opacity: 0</strong>：将元素的透明度设置为 0，以此来实现元素的隐藏。元素在页面中仍然占据空间，并且能够响应元素绑定的监听事件。</li><li><strong>position: absolute</strong>：通过使用绝对定位将元素移除可视区域内，以此来实现元素的隐藏。</li><li><strong>z-index: 负值</strong>：来使其他元素遮盖住该元素，以此来实现隐藏。</li><li><strong>clip&#x2F;clip-path</strong> ：使用元素裁剪的方法来实现元素的隐藏，这种方法下，元素仍在页面中占据位置，但是不会响应绑定的监听事件。</li><li>**transform: scale(0,0)**：将元素缩放为 0，来实现元素的隐藏。这种方法下，元素仍在页面中占据位置，但是不会响应绑定的监听事件。</li></ul><h3 id="6-link和-import的区别"><a href="#6-link和-import的区别" class="headerlink" title="6. link和@import的区别"></a>6. link和@import的区别</h3><p>两者都是外部引用CSS的方式，它们的区别如下：</p><ul><li>link是XHTML标签，除了加载CSS外，还可以定义RSS等其他事务；@import属于CSS范畴，只能加载CSS。</li><li>link引用CSS时，在页面载入时同时加载；@import需要页面网页完全载入以后加载。</li><li>link是XHTML标签，无兼容问题；@import是在CSS2.1提出的，低版本的浏览器不支持。</li><li>link支持使用Javascript控制DOM去改变样式；而@import不支持。</li></ul><h3 id="7-transition和animation的区别"><a href="#7-transition和animation的区别" class="headerlink" title="7. transition和animation的区别"></a>7. transition和animation的区别</h3><ul><li><strong>transition是过度属性</strong>，强调过度，它的实现需要触发一个事件（比如鼠标移动上去，焦点，点击等）才执行动画。它类似于flash的补间动画，设置一个开始关键帧，一个结束关键帧。</li><li><strong>animation是动画属性</strong>，它的实现不需要触发事件，设定好时间之后可以自己执行，且可以循环一个动画。它也类似于flash的补间动画，但是它可以设置多个关键帧（用@keyframe定义）完成动画。</li></ul><h3 id="8-display-none与visibility-hidden的区别"><a href="#8-display-none与visibility-hidden的区别" class="headerlink" title="8. display:none与visibility:hidden的区别"></a>8. display:none与visibility:hidden的区别</h3><p>这两个属性都是让元素隐藏，不可见。<strong>两者区别如下：</strong></p><p>（1）<strong>在渲染树中</strong></p><ul><li><code>display:none</code>会让元素完全从渲染树中消失，渲染时不会占据任何空间；</li><li><code>visibility:hidden</code>不会让元素从渲染树中消失，渲染的元素还会占据相应的空间，只是内容不可见。</li></ul><p>（2）<strong>是否是继承属性</strong></p><ul><li><code>display:none</code>是非继承属性，子孙节点会随着父节点从渲染树消失，通过修改子孙节点的属性也无法显示；</li><li><code>visibility:hidden</code>是继承属性，子孙节点消失是由于继承了<code>hidden</code>，通过设置<code>visibility:visible</code>可以让子孙节点显示；<br>（3）修改常规文档流中元素的 <code>display</code> 通常会造成文档的重排，但是修改<code>visibility</code>属性只会造成本元素的重绘；</li></ul><p>（4）如果使用读屏器，设置为<code>display:none</code>的内容不会被读取，设置为<code>visibility:hidden</code>的内容会被读取。</p><h3 id="9-伪元素和伪类的区别和作用？"><a href="#9-伪元素和伪类的区别和作用？" class="headerlink" title="9. 伪元素和伪类的区别和作用？"></a>9. <strong>伪元素和伪类的区别和作用？</strong></h3><ul><li>伪元素：在内容元素的前后插入额外的元素或样式，但是这些元素实际上并不在文档中生成。它们只在外部显示可见，但不会在文档的源代码中找到它们，因此，称为“伪”元素。例如：</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">p</span><span class="hljs-selector-pseudo">::before</span> &#123;<span class="hljs-attribute">content</span>:<span class="hljs-string">&quot;第一章：&quot;</span>;&#125;<br><span class="hljs-selector-tag">p</span><span class="hljs-selector-pseudo">::after</span> &#123;<span class="hljs-attribute">content</span>:<span class="hljs-string">&quot;Hot!&quot;</span>;&#125;<br><span class="hljs-selector-tag">p</span><span class="hljs-selector-pseudo">::first-line</span> &#123;<span class="hljs-attribute">background</span>:red;&#125;<br><span class="hljs-selector-tag">p</span><span class="hljs-selector-pseudo">::first-letter</span> &#123;<span class="hljs-attribute">font-size</span>:<span class="hljs-number">30px</span>;&#125;<br></code></pre></td></tr></table></figure><ul><li>伪类：将特殊的效果添加到特定选择器上。它是已有元素上添加类别的，不会产生新的元素。例如：</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:hover</span> &#123;<span class="hljs-attribute">color</span>: <span class="hljs-number">#FF00FF</span>&#125;<br><span class="hljs-selector-tag">p</span><span class="hljs-selector-pseudo">:first</span>-child &#123;<span class="hljs-attribute">color</span>: red&#125;<br></code></pre></td></tr></table></figure><p><strong>总结：</strong> 伪类是通过在元素选择器上加⼊伪类改变元素状态，⽽伪元素通过对元素的操作进⾏对元素的改变。 </p><h3 id="10-对requestAnimationframe的理解"><a href="#10-对requestAnimationframe的理解" class="headerlink" title="10. 对requestAnimationframe的理解"></a>10. 对requestAnimationframe的理解</h3><p>实现动画效果的方法比较多，Javascript 中可以通过定时器 setTimeout 来实现，CSS3 中可以使用 transition 和 animation 来实现，HTML5 中的 canvas 也可以实现。除此之外，HTML5 提供一个专门用于请求动画的API，那就是 requestAnimationFrame，顾名思义就是<strong>请求动画帧</strong>。</p><p>MDN对该方法的描述：</p><blockquote><p>window.requestAnimationFrame() 告诉浏览器——你希望执行一个动画，并且要求浏览器在下次重绘之前调用指定的回调函数更新动画。该方法需要传入一个回调函数作为参数，该回调函数会在浏览器下一次重绘之前执行。</p></blockquote><p><strong>语法：</strong> <code>window.requestAnimationFrame(callback);</code>  其中，callback是<strong>下一次重绘之前更新动画帧所调用的函数</strong>(即上面所说的回调函数)。该回调函数会被传入DOMHighResTimeStamp参数，它表示requestAnimationFrame() 开始去执行回调函数的时刻。该方法属于<strong>宏任务</strong>，所以会在执行完微任务之后再去执行。</p><p><strong>取消动画：</strong> 使用cancelAnimationFrame()来取消执行动画，该方法接收一个参数——requestAnimationFrame默认返回的id，只需要传入这个id就可以取消动画了。</p><p><strong>优势：</strong></p><ul><li><strong>CPU节能</strong>：使用SetTinterval 实现的动画，当页面被隐藏或最小化时，SetTinterval 仍然在后台执行动画任务，由于此时页面处于不可见或不可用状态，刷新动画是没有意义的，完全是浪费CPU资源。而RequestAnimationFrame则完全不同，当页面处理未激活的状态下，该页面的屏幕刷新任务也会被系统暂停，因此跟着系统走的RequestAnimationFrame也会停止渲染，当页面被激活时，动画就从上次停留的地方继续执行，有效节省了CPU开销。</li><li><strong>函数节流</strong>：在高频率事件( resize, scroll 等)中，为了防止在一个刷新间隔内发生多次函数执行，RequestAnimationFrame可保证每个刷新间隔内，函数只被执行一次，这样既能保证流畅性，也能更好的节省函数执行的开销，一个刷新间隔内函数执行多次时没有意义的，因为多数显示器每16.7ms刷新一次，多次绘制并不会在屏幕上体现出来。</li><li><strong>减少DOM操作</strong>：requestAnimationFrame 会把每一帧中的所有DOM操作集中起来，在一次重绘或回流中就完成，并且重绘或回流的时间间隔紧紧跟随浏览器的刷新频率，一般来说，这个频率为每秒60帧。</li></ul><p><strong>setTimeout执行动画的缺点</strong>：它通过设定间隔时间来不断改变图像位置，达到动画效果。但是容易出现卡顿、抖动的现象；原因是：</p><ul><li>settimeout任务被放入异步队列，只有当主线程任务执行完后才会执行队列中的任务，因此实际执行时间总是比设定时间要晚；</li><li>settimeout的固定时间间隔不一定与屏幕刷新间隔时间相同，会引起丢帧。</li></ul><h3 id="11-对盒模型的理解"><a href="#11-对盒模型的理解" class="headerlink" title="11. 对盒模型的理解"></a>11. 对盒模型的理解</h3><p>CSS3中的盒模型有以下两种：标准盒子模型、IE盒子模型<br><img src="2.png" alt="img"><br><img src="3.png" alt="img"><br>盒模型都是由四个部分组成的，分别是margin、border、padding和content。</p><p>标准盒模型和IE盒模型的区别在于设置width和height时，所对应的范围不同：</p><ul><li>标准盒模型的width和height属性的范围只包含了content，</li><li>IE盒模型的width和height属性的范围包含了border、padding和content。</li></ul><p>可以通过修改元素的box-sizing属性来改变元素的盒模型：</p><ul><li><code>box-sizeing: content-box</code>表示标准盒模型（默认值）</li><li><code>box-sizeing: border-box</code>表示IE盒模型（怪异盒模型）</li></ul><h3 id="12-为什么有时候⽤translate来改变位置⽽不是定位？"><a href="#12-为什么有时候⽤translate来改变位置⽽不是定位？" class="headerlink" title="12. 为什么有时候⽤translate来改变位置⽽不是定位？"></a>12. 为什么有时候⽤<strong>translate</strong>来改变位置⽽不是定位？</h3><p>translate 是 transform 属性的⼀个值。改变transform或opacity不会触发浏览器重新布局（reflow）或重绘（repaint），只会触发复合（compositions）。⽽改变绝对定位会触发重新布局，进⽽触发重绘和复合。transform使浏览器为元素创建⼀个 GPU 图层，但改变绝对定位会使⽤到 CPU。 因此translate()更⾼效，可以缩短平滑动画的绘制时间。 ⽽translate改变位置时，元素依然会占据其原始空间，绝对定位就不会发⽣这种情况。</p><h3 id="13-li-与-li-之间有看不见的空白间隔是什么原因引起的？如何解决？"><a href="#13-li-与-li-之间有看不见的空白间隔是什么原因引起的？如何解决？" class="headerlink" title="13. li 与 li 之间有看不见的空白间隔是什么原因引起的？如何解决？"></a>13. li 与 li 之间有看不见的空白间隔是什么原因引起的？如何解决？</h3><p>浏览器会把inline内联元素间的空白字符（空格、换行、Tab等）渲染成一个空格。为了美观，通常是一个<code>&lt;li&gt;</code>放在一行，这导致<code>&lt;li&gt;</code>换行后产生换行字符，它变成一个空格，占用了一个字符的宽度。</p><p><strong>解决办法：</strong></p><p>（1）为<code>&lt;li&gt;</code>设置float:left。不足：有些容器是不能设置浮动，如左右切换的焦点图等。</p><p>（2）将所有<code>&lt;li&gt;</code>写在同一行。不足：代码不美观。</p><p>（3）将<code>&lt;ul&gt;</code>内的字符尺寸直接设为0，即font-size:0。不足：<code>&lt;ul&gt;</code>中的其他字符尺寸也被设为0，需要额外重新设定其他字符尺寸，且在Safari浏览器依然会出现空白间隔。</p><p>（4）消除<code>&lt;ul&gt;</code>的字符间隔letter-spacing:-8px，不足：这也设置了<code>&lt;li&gt;</code>内的字符间隔，因此需要将<code>&lt;li&gt;</code>内的字符间隔设为默认letter-spacing:normal。</p><h3 id="14-CSS3中有哪些新特性"><a href="#14-CSS3中有哪些新特性" class="headerlink" title="14. CSS3中有哪些新特性"></a>14. CSS3中有哪些新特性</h3><ul><li>新增各种CSS选择器 （: not(.input)：所有 class 不是“input”的节点）</li><li>圆角 （border-radius:8px）</li><li>多列布局 （multi-column layout）</li><li>阴影和反射 （Shadoweflect）</li><li>文字特效 （text-shadow）</li><li>文字渲染 （Text-decoration）</li><li>线性渐变 （gradient）</li><li>旋转 （transform）</li><li>增加了旋转,缩放,定位,倾斜,动画,多背景</li></ul><h3 id="15-替换元素的概念及计算规则"><a href="#15-替换元素的概念及计算规则" class="headerlink" title="15. 替换元素的概念及计算规则"></a>15. 替换元素的概念及计算规则</h3><p>通过修改某个属性值呈现的内容就可以被替换的元素就称为“替换元素”。</p><p>替换元素除了内容可替换这一特性以外，还有以下特性：</p><ul><li><strong>内容的外观不受页面上的CSS的影响</strong>：用专业的话讲就是在样式表现在CSS作用域之外。如何更改替换元素本身的外观需要类似appearance属性，或者浏览器自身暴露的一些样式接口。</li><li><strong>有自己的尺寸</strong>：在Web中，很多替换元素在没有明确尺寸设定的情况下，其默认的尺寸（不包括边框）是300像素×150像素，如</li><li><strong>在很多CSS属性上有自己的一套表现规则</strong>：比较具有代表性的就是vertical-align属性，对于替换元素和非替换元素，vertical-align属性值的解释是不一样的。比方说vertical-align的默认值的baseline，很简单的属性值，基线之意，被定义为字符x的下边缘，而替换元素的基线却被硬生生定义成了元素的下边缘。</li><li><strong>所有的替换元素都是内联水平元素</strong>：也就是替换元素和替换元素、替换元素和文字都是可以在一行显示的。但是，替换元素默认的display值却是不一样的，有的是inline，有的是inline-block。</li></ul><p>替换元素的尺寸从内而外分为三类：</p><ul><li><strong>固有尺寸：</strong> 指的是替换内容原本的尺寸。例如，图片、视频作为一个独立文件存在的时候，都是有着自己的宽度和高度的。</li><li><strong>HTML尺寸：</strong> 只能通过HTML原生属性改变，这些HTML原生属性包括的width和height属性、的size属性。</li><li><strong>CSS尺寸：</strong> 特指可以通过CSS的width和height或者max-width&#x2F;min-width和max-height&#x2F;min-height设置的尺寸，对应盒尺寸中的content box。</li></ul><p>这三层结构的计算规则具体如下：<br>（1）如果没有CSS尺寸和HTML尺寸，则使用固有尺寸作为最终的宽高。<br>（2）如果没有CSS尺寸，则使用HTML尺寸作为最终的宽高。<br>（3）如果有CSS尺寸，则最终尺寸由CSS属性决定。<br>（4）如果“固有尺寸”含有固有的宽高比例，同时仅设置了宽度或仅设置了高度，则元素依然按照固有的宽高比例显示。<br>（5）如果上面的条件都不符合，则最终宽度表现为300像素，高度为150像素。<br>（6）内联替换元素和块级替换元素使用上面同一套尺寸计算规则。</p><h3 id="16-常见的图片格式及使用场景"><a href="#16-常见的图片格式及使用场景" class="headerlink" title="16. 常见的图片格式及使用场景"></a>16. 常见的图片格式及使用场景</h3><p>（1）<strong>BMP</strong>，是无损的、既支持索引色也支持直接色的点阵图。这种图片格式几乎没有对数据进行压缩，所以BMP格式的图片通常是较大的文件。</p><p>（2）<strong>GIF</strong>是无损的、采用索引色的点阵图。采用LZW压缩算法进行编码。文件小，是GIF格式的优点，同时，GIF格式还具有支持动画以及透明的优点。但是GIF格式仅支持8bit的索引色，所以GIF格式适用于对色彩要求不高同时需要文件体积较小的场景。</p><p>（3）<strong>JPEG</strong>是有损的、采用直接色的点阵图。JPEG的图片的优点是采用了直接色，得益于更丰富的色彩，JPEG非常适合用来存储照片，与GIF相比，JPEG不适合用来存储企业Logo、线框类的图。因为有损压缩会导致图片模糊，而直接色的选用，又会导致图片文件较GIF更大。</p><p>（4）<strong>PNG-8</strong>是无损的、使用索引色的点阵图。PNG是一种比较新的图片格式，PNG-8是非常好的GIF格式替代者，在可能的情况下，应该尽可能的使用PNG-8而不是GIF，因为在相同的图片效果下，PNG-8具有更小的文件体积。除此之外，PNG-8还支持透明度的调节，而GIF并不支持。除非需要动画的支持，否则没有理由使用GIF而不是PNG-8。</p><p>（5）<strong>PNG-24</strong>是无损的、使用直接色的点阵图。PNG-24的优点在于它压缩了图片的数据，使得同样效果的图片，PNG-24格式的文件大小要比BMP小得多。当然，PNG24的图片还是要比JPEG、GIF、PNG-8大得多。</p><p>（6）<strong>SVG</strong>是无损的矢量图。SVG是矢量图意味着SVG图片由直线和曲线以及绘制它们的方法组成。当放大SVG图片时，看到的还是线和曲线，而不会出现像素点。SVG图片在放大时，不会失真，所以它适合用来绘制Logo、Icon等。</p><p>（7）<strong>WebP</strong>是谷歌开发的一种新图片格式，WebP是同时支持有损和无损压缩的、使用直接色的点阵图。从名字就可以看出来它是为Web而生的，什么叫为Web而生呢？就是说相同质量的图片，WebP具有更小的文件体积。现在网站上充满了大量的图片，如果能够降低每一个图片的文件大小，那么将大大减少浏览器和服务器之间的数据传输量，进而降低访问延迟，提升访问体验。目前只有Chrome浏览器和Opera浏览器支持WebP格式，兼容性不太好。</p><ul><li>在无损压缩的情况下，相同质量的WebP图片，文件大小要比PNG小26%；</li><li>在有损压缩的情况下，具有相同图片精度的WebP图片，文件大小要比JPEG小25%~34%；</li><li>WebP图片格式支持图片透明度，一个无损压缩的WebP图片，如果要支持透明度只需要22%的格外文件大小。</li></ul><h3 id="17-对-CSSSprites-的理解"><a href="#17-对-CSSSprites-的理解" class="headerlink" title="17. 对 CSSSprites 的理解"></a>17. 对 CSSSprites 的理解</h3><p>CSSSprites（精灵图），将一个页面涉及到的所有图片都包含到一张大图中去，然后利用CSS的 background-image，background-repeat，background-position属性的组合进行背景定位。</p><p><strong>优点：</strong></p><ul><li>利用<code>CSS Sprites</code>能很好地减少网页的http请求，从而大大提高了页面的性能，这是<code>CSS Sprites</code>最大的优点；</li><li><code>CSS Sprites</code>能减少图片的字节，把3张图片合并成1张图片的字节总是小于这3张图片的字节总和。</li></ul><p><strong>缺点：</strong></p><ul><li>在图片合并时，要把多张图片有序的、合理的合并成一张图片，还要留好足够的空间，防止板块内出现不必要的背景。在宽屏及高分辨率下的自适应页面，如果背景不够宽，很容易出现背景断裂；</li><li><code>CSSSprites</code>在开发的时候相对来说有点麻烦，需要借助<code>photoshop</code>或其他工具来对每个背景单元测量其准确的位置。</li><li>维护方面：<code>CSS Sprites</code>在维护的时候比较麻烦，页面背景有少许改动时，就要改这张合并的图片，无需改的地方尽量不要动，这样避免改动更多的<code>CSS</code>，如果在原来的地方放不下，又只能（最好）往下加图片，这样图片的字节就增加了，还要改动<code>CSS</code>。</li></ul><h3 id="18-什么是物理像素，逻辑像素和像素密度，为什么在移动端开发时需要用到-3x-2x这种图片？"><a href="#18-什么是物理像素，逻辑像素和像素密度，为什么在移动端开发时需要用到-3x-2x这种图片？" class="headerlink" title="18. 什么是物理像素，逻辑像素和像素密度，为什么在移动端开发时需要用到@3x, @2x这种图片？"></a>18. 什么是物理像素，逻辑像素和像素密度，为什么在移动端开发时需要用到@3x, @2x这种图片？</h3><p>以 iPhone XS 为例，当写 CSS 代码时，针对于单位 px，其宽度为 414px &amp; 896px，也就是说当赋予一个 DIV元素宽度为 414px，这个 DIV 就会填满手机的宽度；</p><p>而如果有一把尺子来实际测量这部手机的物理像素，实际为 1242*2688 物理像素；经过计算可知，1242&#x2F;414&#x3D;3，也就是说，在单边上，一个逻辑像素&#x3D;3个物理像素，就说这个屏幕的像素密度为 3，也就是常说的 3 倍屏。</p><p>对于图片来说，为了保证其不失真，1 个图片像素至少要对应一个物理像素，假如原始图片是 500300 像素，那么在 3 倍屏上就要放一个 1500900 像素的图片才能保证 1 个物理像素至少对应一个图片像素，才能不失真。<br><img src="4.jpg" alt="img"><br>当然，也可以针对所有屏幕，都只提供最高清图片。虽然低密度屏幕用不到那么多图片像素，而且会因为下载多余的像素造成带宽浪费和下载延迟，但从结果上说能保证图片在所有屏幕上都不会失真。</p><p>还可以使用 CSS 媒体查询来判断不同的像素密度，从而选择不同的图片:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript">my-image &#123; <span class="hljs-attr">background</span>: (low.<span class="hljs-property">png</span>); &#125;<br>@media only screen and (min-device-pixel-<span class="hljs-attr">ratio</span>: <span class="hljs-number">1.5</span>) &#123;<br>  #my-image &#123; <span class="hljs-attr">background</span>: (high.<span class="hljs-property">png</span>); &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="19-margin-和-padding-的使用场景"><a href="#19-margin-和-padding-的使用场景" class="headerlink" title="19. margin 和 padding 的使用场景"></a>19. <strong>margin 和 padding 的使用场景</strong></h3><ul><li>需要在border外侧添加空白，且空白处不需要背景（色）时，使用 margin；</li><li>需要在border内测添加空白，且空白处需要背景（色）时，使用 padding。</li></ul><h3 id="20-对line-height-的理解及其赋值方式"><a href="#20-对line-height-的理解及其赋值方式" class="headerlink" title="20. 对line-height 的理解及其赋值方式"></a>20. 对<strong>line-height 的理解及其赋值方式</strong></h3><p><strong>（1）line-height的概念：</strong></p><ul><li>line-height 指一行文本的高度，包含了字间距，实际上是下一行基线到上一行基线距离；</li><li>如果一个标签没有定义 height 属性，那么其最终表现的高度由 line-height 决定；</li><li>一个容器没有设置高度，那么撑开容器高度的是 line-height，而不是容器内的文本内容；</li><li>把 line-height 值设置为 height 一样大小的值可以实现单行文字的垂直居中；</li><li>line-height 和 height 都能撑开一个高度；</li></ul><p><strong>（2）line-height 的赋值方式：</strong></p><ul><li>带单位：px 是固定值，而 em 会参考父元素 font-size 值计算自身的行高</li><li>纯数字：会把比例传递给后代。例如，父级行高为 1.5，子元素字体为 18px，则子元素行高为 1.5 * 18 &#x3D; 27px</li><li>百分比：将计算后的值传递给后代</li></ul><h3 id="21-CSS-优化和提高性能的方法有哪些？"><a href="#21-CSS-优化和提高性能的方法有哪些？" class="headerlink" title="21. CSS 优化和提高性能的方法有哪些？"></a>21. CSS 优化和提高性能的方法有哪些？</h3><p><strong>加载性能：</strong></p><p>（1）css压缩：将写好的css进行打包压缩，可以减小文件体积。</p><p>（2）css单一样式：当需要下边距和左边距的时候，很多时候会选择使用 margin:top 0 bottom 0；但margin-bottom:bottom;margin-left:left;执行效率会更高。</p><p>（3）减少使用@import，建议使用link，因为后者在页面加载时一起加载，前者是等待页面加载完成之后再进行加载。</p><p><strong>选择器性能：</strong></p><p>（1）关键选择器（key selector）。选择器的最后面的部分为关键选择器（即用来匹配目标元素的部分）。CSS选择符是从右到左进行匹配的。当使用后代选择器的时候，浏览器会遍历所有子元素来确定是否是指定的元素等等；</p><p>（2）如果规则拥有ID选择器作为其关键选择器，则不要为规则增加标签。过滤掉无关的规则（这样样式系统就不会浪费时间去匹配它们了）。</p><p>（3）避免使用通配规则，如*{}计算次数惊人，只对需要用到的元素进行选择。</p><p>（4）尽量少的去对标签进行选择，而是用class。</p><p>（5）尽量少的去使用后代选择器，降低选择器的权重值。后代选择器的开销是最高的，尽量将选择器的深度降到最低，最高不要超过三层，更多的使用类来关联每一个标签元素。</p><p>（6）了解哪些属性是可以通过继承而来的，然后避免对这些属性重复指定规则。</p><p><strong>渲染性能：</strong></p><p>（1）慎重使用高性能属性：浮动、定位。</p><p>（2）尽量减少页面重排、重绘。</p><p>（3）去除空规则：｛｝。空规则的产生原因一般来说是为了预留样式。去除这些空规则无疑能减少css文档体积。</p><p>（4）属性值为0时，不加单位。</p><p>（5）属性值为浮动小数0.**，可以省略小数点之前的0。</p><p>（6）标准化各种浏览器前缀：带浏览器前缀的在前。标准属性在后。</p><p>（7）不使用@import前缀，它会影响css的加载速度。</p><p>（8）选择器优化嵌套，尽量避免层级过深。</p><p>（9）css雪碧图，同一页面相近部分的小图标，方便使用，减少页面的请求次数，但是同时图片本身会变大，使用时，优劣考虑清楚，再使用。</p><p>（10）正确使用display的属性，由于display的作用，某些样式组合会无效，徒增样式体积的同时也影响解析性能。</p><p>（11）不滥用web字体。对于中文网站来说WebFonts可能很陌生，国外却很流行。web fonts通常体积庞大，而且一些浏览器在下载web fonts时会阻塞页面渲染损伤性能。</p><p><strong>可维护性、健壮性：</strong></p><p>（1）将具有相同属性的样式抽离出来，整合并通过class在页面中进行使用，提高css的可维护性。</p><p>（2）样式与内容分离：将css代码定义到外部css中。</p><h3 id="22-CSS预处理器-x2F-后处理器是什么？为什么要使用它们？"><a href="#22-CSS预处理器-x2F-后处理器是什么？为什么要使用它们？" class="headerlink" title="22. CSS预处理器&#x2F;后处理器是什么？为什么要使用它们？"></a>22. CSS预处理器&#x2F;后处理器是什么？为什么要使用它们？</h3><p><strong>预处理器，</strong> 如：<code>less</code>，<code>sass</code>，<code>stylus</code>，用来预编译<code>sass</code>或者<code>less</code>，增加了<code>css</code>代码的复用性。层级，<code>mixin</code>， 变量，循环， 函数等对编写以及开发UI组件都极为方便。</p><p><strong>后处理器，</strong> 如： <code>postCss</code>，通常是在完成的样式表中根据<code>css</code>规范处理<code>css</code>，让其更加有效。目前最常做的是给<code>css</code>属性添加浏览器私有前缀，实现跨浏览器兼容性的问题。</p><p><code>css</code>预处理器为<code>css</code>增加一些编程特性，无需考虑浏览器的兼容问题，可以在<code>CSS</code>中使用变量，简单的逻辑程序，函数等在编程语言中的一些基本的性能，可以让<code>css</code>更加的简洁，增加适应性以及可读性，可维护性等。</p><p>其它<code>css</code>预处理器语言：<code>Sass（Scss）</code>, <code>Less</code>, <code>Stylus</code>, <code>Turbine</code>, <code>Swithch css</code>, <code>CSS Cacheer</code>, <code>DT Css</code>。</p><p>使用原因：</p><ul><li>结构清晰， 便于扩展</li><li>可以很方便的屏蔽浏览器私有语法的差异</li><li>可以轻松实现多重继承</li><li>完美的兼容了<code>CSS</code>代码，可以应用到老项目中</li></ul><h3 id="23-before-和-after-的双冒号和单冒号有什么区别？"><a href="#23-before-和-after-的双冒号和单冒号有什么区别？" class="headerlink" title="23. ::before 和 :after 的双冒号和单冒号有什么区别？"></a>23. ::before 和 :after 的双冒号和单冒号有什么区别？</h3><p>（1）冒号(<code>:</code>)用于<code>CSS3</code>伪类，双冒号(<code>::</code>)用于<code>CSS3</code>伪元素。<br>（2）<code>::before</code>就是以一个子元素的存在，定义在元素主体内容之前的一个伪元素。并不存在于<code>dom</code>之中，只存在在页面之中。</p><p><strong>注意：</strong> <code>:before </code>和 <code>:after</code> 这两个伪元素，是在<code>CSS2.1</code>里新出现的。起初，伪元素的前缀使用的是单冒号语法，但随着<code>Web</code>的进化，在<code>CSS3</code>的规范里，伪元素的语法被修改成使用双冒号，成为<code>::before</code>、<code>::after</code>。</p><h3 id="24-display-inline-block-什么时候会显示间隙？"><a href="#24-display-inline-block-什么时候会显示间隙？" class="headerlink" title="24. display:inline-block 什么时候会显示间隙？"></a>24. display:inline-block 什么时候会显示间隙？</h3><ul><li>有空格时会有间隙，可以删除空格解决；</li><li><code>margin</code>正值时，可以让<code>margin</code>使用负值解决；</li><li>使用<code>font-size</code>时，可通过设置<code>font-size:0</code>、<code>letter-spacing</code>、<code>word-spacing</code>解决；</li></ul><h3 id="25-单行、多行文本溢出隐藏"><a href="#25-单行、多行文本溢出隐藏" class="headerlink" title="25. 单行、多行文本溢出隐藏"></a>25. 单行、多行文本溢出隐藏</h3><ul><li>单行文本溢出</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">overflow</span>: hidden;            // 溢出隐藏<br><span class="hljs-attribute">text-overflow</span>: ellipsis;      // 溢出用省略号显示<br><span class="hljs-attribute">white-space</span>: nowrap;         // 规定段落中的文本不进行换行<br></code></pre></td></tr></table></figure><ul><li>多行文本溢出</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">overflow</span>: hidden;            // 溢出隐藏<br><span class="hljs-attribute">text-overflow</span>: ellipsis;     // 溢出用省略号显示<br><span class="hljs-attribute">display</span>:-webkit-box;         // 作为弹性伸缩盒子模型显示。<br>-webkit-box-orient:vertical; // 设置伸缩盒子的子元素排列方式：从上到下垂直排列<br>-webkit-line-clamp:<span class="hljs-number">3</span>;        // 显示的行数<br></code></pre></td></tr></table></figure><p>注意：由于上面的三个属性都是 CSS3 的属性，没有浏览器可以兼容，所以要在前面加一个<code>-webkit-</code> 来兼容一部分浏览器。</p><h3 id="26-Sass、Less-是什么？为什么要使用他们？"><a href="#26-Sass、Less-是什么？为什么要使用他们？" class="headerlink" title="26. Sass、Less 是什么？为什么要使用他们？"></a>26. Sass、Less 是什么？为什么要使用他们？</h3><p>他们都是 CSS 预处理器，是 CSS 上的一种抽象层。他们是一种特殊的语法&#x2F;语言编译成 CSS。 例如 Less 是一种动态样式语言，将 CSS 赋予了动态语言的特性，如变量，继承，运算， 函数，LESS 既可以在客户端上运行 (支持 IE 6+, Webkit, Firefox)，也可以在服务端运行 (借助 Node.js)。 </p><p><strong>为什么要使用它们？</strong></p><ul><li>结构清晰，便于扩展。 可以方便地屏蔽浏览器私有语法差异。封装对浏览器语法差异的重复处理， 减少无意义的机械劳动。 </li><li>可以轻松实现多重继承。 完全兼容 CSS 代码，可以方便地应用到老项目中。LESS 只是在 CSS 语法上做了扩展，所以老的 CSS 代码也可以与 LESS 代码一同编译。</li></ul><h3 id="27-对媒体查询的理解？"><a href="#27-对媒体查询的理解？" class="headerlink" title="27. 对媒体查询的理解？"></a>27. 对媒体查询的理解？</h3><p>媒体查询由⼀个可选的媒体类型和零个或多个使⽤媒体功能的限制了样式表范围的表达式组成，例如宽度、⾼度和颜⾊。媒体查询，添加⾃CSS3，允许内容的呈现针对⼀个特定范围的输出设备⽽进⾏裁剪，⽽不必改变内容本身，适合web⽹⻚应对不同型号的设备⽽做出对应的响应适配。 </p><p>媒体查询包含⼀个可选的媒体类型和满⾜CSS3规范的条件下，包含零个或多个表达式，这些表达式描述了媒体特征，最终会被解析为true或false。如果媒体查询中指定的媒体类型匹配展示⽂档所使⽤的设备类型，并且所有的表达式的值都是true，那么该媒体查询的结果为true。那么媒体查询内的样式将会⽣效。 </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;!-- link元素中的<span class="hljs-variable constant_">CSS</span>媒体查询 --&gt; <br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span> <span class="hljs-attr">media</span>=<span class="hljs-string">&quot;(max-width: 800px)&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;example.css&quot;</span> /&gt;</span></span> <br>&lt;!-- 样式表中的<span class="hljs-variable constant_">CSS</span>媒体查询 --&gt; <br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"> </span></span><br><span class="language-css"><span class="language-xml"><span class="hljs-keyword">@media</span> (<span class="hljs-attribute">max-width</span>: <span class="hljs-number">600px</span>) &#123; </span></span><br><span class="language-css"><span class="language-xml">  <span class="hljs-selector-class">.facet_sidebar</span> &#123; </span></span><br><span class="language-css"><span class="language-xml">    <span class="hljs-attribute">display</span>: none; </span></span><br><span class="language-css"><span class="language-xml">  &#125; </span></span><br><span class="language-css"><span class="language-xml">&#125;</span></span><br><span class="language-css"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>简单来说，使用 @media 查询，可以针对不同的媒体类型定义不同的样式。@media 可以针对不同的屏幕尺寸设置不同的样式，特别是需要设置设计响应式的页面，@media 是非常有用的。当重置浏览器大小的过程中，页面也会根据浏览器的宽度和高度重新渲染页面。</p><h3 id="28-对-CSS-工程化的理解"><a href="#28-对-CSS-工程化的理解" class="headerlink" title="28. 对 CSS 工程化的理解"></a>28. 对 CSS 工程化的理解</h3><p>CSS 工程化是为了解决以下问题：</p><ol><li><strong>宏观设计</strong>：CSS 代码如何组织、如何拆分、模块结构怎样设计？</li><li><strong>编码优化</strong>：怎样写出更好的 CSS？</li><li><strong>构建</strong>：如何处理我的 CSS，才能让它的打包结果最优？</li><li><strong>可维护性</strong>：代码写完了，如何最小化它后续的变更成本？如何确保任何一个同事都能轻松接手？</li></ol><p>以下三个方向都是时下比较流行的、普适性非常好的 CSS 工程化实践：</p><ul><li>预处理器：Less、 Sass 等；</li><li>重要的工程化插件： PostCss；</li><li>Webpack loader 等 。</li></ul><p>基于这三个方向，可以衍生出一些具有典型意义的子问题，这里我们逐个来看：</p><p><strong>（1）预处理器：为什么要用预处理器？它的出现是为了解决什么问题？</strong></p><p>预处理器，其实就是 CSS 世界的“轮子”。预处理器支持我们写一种类似 CSS、但实际并不是 CSS 的语言，然后把它编译成 CSS 代码：<br><img src="5.png" alt="img"><br>那为什么写 CSS 代码写得好好的，偏偏要转去写“类 CSS”呢？这就和本来用 JS 也可以实现所有功能，但最后却写 React 的 jsx 或者 Vue 的模板语法一样——为了爽！要想知道有了预处理器有多爽，首先要知道的是传统 CSS 有多不爽。随着前端业务复杂度的提高，前端工程中对 CSS 提出了以下的诉求：</p><ol><li>宏观设计上：我们希望能优化 CSS 文件的目录结构，对现有的 CSS 文件实现复用；</li><li>编码优化上：我们希望能写出结构清晰、简明易懂的 CSS，需要它具有一目了然的嵌套层级关系，而不是无差别的一铺到底写法；我们希望它具有变量特征、计算能力、循环能力等等更强的可编程性，这样我们可以少写一些无用的代码；</li><li>可维护性上：更强的可编程性意味着更优质的代码结构，实现复用意味着更简单的目录结构和更强的拓展能力，这两点如果能做到，自然会带来更强的可维护性。</li></ol><p>这三点是传统 CSS 所做不到的，也正是预处理器所解决掉的问题。预处理器普遍会具备这样的特性：</p><ul><li>嵌套代码的能力，通过嵌套来反映不同 css 属性之间的层级关系 ；</li><li>支持定义 css 变量；</li><li>提供计算函数；</li><li>允许对代码片段进行 extend 和 mixin；</li><li>支持循环语句的使用；</li><li>支持将 CSS 文件模块化，实现复用。</li></ul><p><strong>（2）PostCss：PostCss 是如何工作的？我们在什么场景下会使用 PostCss？</strong></p><p><img src="6.png" alt="img"><br>它和预处理器的不同就在于，预处理器处理的是 类CSS，而 PostCss 处理的就是 CSS 本身。Babel 可以将高版本的 JS 代码转换为低版本的 JS 代码。PostCss 做的是类似的事情：它可以编译尚未被浏览器广泛支持的先进的 CSS 语法，还可以自动为一些需要额外兼容的语法增加前缀。更强的是，由于 PostCss 有着强大的插件机制，支持各种各样的扩展，极大地强化了 CSS 的能力。</p><p>PostCss 在业务中的使用场景非常多：</p><ul><li>提高 CSS 代码的可读性：PostCss 其实可以做类似预处理器能做的工作；</li><li>当我们的 CSS 代码需要适配低版本浏览器时，PostCss 的 <a href="https://github.com/postcss/autoprefixer">Autoprefixer</a> 插件可以帮助我们自动增加浏览器前缀；</li><li>允许我们编写面向未来的 CSS：PostCss 能够帮助我们编译 CSS next 代码；</li></ul><p><strong>（3）Webpack 能处理 CSS 吗？如何实现？</strong><br>Webpack 能处理 CSS 吗：</p><ul><li><strong>Webpack 在裸奔的状态下，是不能处理 CSS 的</strong>，Webpack 本身是一个面向 JavaScript 且只能处理 JavaScript 代码的模块化打包工具；</li><li>Webpack 在 loader 的辅助下，是可以处理 CSS 的。</li></ul><p>如何用 Webpack 实现对 CSS 的处理：</p><ul><li>Webpack 中操作 CSS 需要使用的两个关键的 loader：css-loader 和 style-loader</li><li>注意，答出“用什么”有时候可能还不够，面试官会怀疑你是不是在背答案，所以你还需要了解每个 loader 都做了什么事情：<ul><li>css-loader：导入 CSS 模块，对 CSS 代码进行编译处理；</li><li>style-loader：创建style标签，把 CSS 内容写入标签。</li></ul></li></ul><p>在实际使用中，<strong>css-loader 的执行顺序一定要安排在 style-loader 的前面</strong>。因为只有完成了编译过程，才可以对 css 代码进行插入；若提前插入了未编译的代码，那么 webpack 是无法理解这坨东西的，它会无情报错。</p><h3 id="29-如何判断元素是否到达可视区域"><a href="#29-如何判断元素是否到达可视区域" class="headerlink" title="29. 如何判断元素是否到达可视区域"></a>29. 如何判断元素是否到达可视区域</h3><p>以图片显示为例：</p><ul><li><code>window.innerHeight</code> 是浏览器可视区的高度；</li><li><code>document.body.scrollTop || document.documentElement.scrollTop</code> 是浏览器滚动的过的距离；</li><li><code>imgs.offsetTop</code> 是元素顶部距离文档顶部的高度（包括滚动条的距离）；</li><li>内容达到显示区域的：<code>img.offsetTop &lt; window.innerHeight + document.body.scrollTop;</code></li></ul><p><img src="7.png" alt="img"></p><h3 id="30-z-index属性在什么情况下会失效"><a href="#30-z-index属性在什么情况下会失效" class="headerlink" title="30. z-index属性在什么情况下会失效"></a>30. z-index属性在什么情况下会失效</h3><p>通常 z-index 的使用是在有两个重叠的标签，在一定的情况下控制其中一个在另一个的上方或者下方出现。z-index值越大就越是在上层。z-index元素的position属性需要是relative，absolute或是fixed。</p><p>z-index属性在下列情况下会失效：</p><ul><li>父元素position为relative时，子元素的z-index失效。解决：父元素position改为absolute或static；</li><li>元素没有设置position属性为非static属性。解决：设置该元素的position属性为relative，absolute或是fixed中的一种；</li><li>元素在设置z-index的同时还设置了float浮动。解决：float去除，改为display：inline-block；</li></ul><h3 id="31-CSS3中的transform有哪些属性"><a href="#31-CSS3中的transform有哪些属性" class="headerlink" title="31. CSS3中的transform有哪些属性"></a>31. CSS3中的transform有哪些属性</h3><h2 id="二、页面布局"><a href="#二、页面布局" class="headerlink" title="二、页面布局"></a>二、页面布局</h2><h3 id="1-常见的CSS布局单位"><a href="#1-常见的CSS布局单位" class="headerlink" title="1. 常见的CSS布局单位"></a>1. 常见的CSS布局单位</h3><p>常用的布局单位包括像素（<code>px</code>），百分比（<code>%</code>），<code>em</code>，<code>rem</code>，<code>vw/vh</code>。</p><p><strong>（1）像素</strong>（<code>px</code>）是页面布局的基础，一个像素表示终端（电脑、手机、平板等）屏幕所能显示的最小的区域，像素分为两种类型：CSS像素和物理像素：</p><ul><li><strong>CSS像素</strong>：为web开发者提供，在CSS中使用的一个抽象单位；</li><li><strong>物理像素</strong>：只与设备的硬件密度有关，任何设备的物理像素都是固定的。</li></ul><p><strong>（2）百分比</strong>（<code>%</code>），当浏览器的宽度或者高度发生变化时，通过百分比单位可以使得浏览器中的组件的宽和高随着浏览器的变化而变化，从而实现响应式的效果。一般认为子元素的百分比相对于直接父元素。</p><p><strong>（3）em和rem</strong>相对于px更具灵活性，它们都是相对长度单位，它们之间的区别：<strong>em相对于父元素，rem相对于根元素。</strong></p><ul><li><strong>em：</strong> 文本相对长度单位。相对于当前对象内文本的字体尺寸。如果当前行内文本的字体尺寸未被人为设置，则相对于浏览器的默认字体尺寸(默认16px)。(相对父元素的字体大小倍数)。</li><li><strong>rem：</strong> rem是CSS3新增的一个相对单位，相对于根元素（html元素）的font-size的倍数。<strong>作用</strong>：利用rem可以实现简单的响应式布局，可以利用html元素中字体的大小与屏幕间的比值来设置font-size的值，以此实现当屏幕分辨率变化时让元素也随之变化。</li></ul><p><strong>（4）vw&#x2F;vh</strong>是与视图窗口有关的单位，vw表示相对于视图窗口的宽度，vh表示相对于视图窗口高度，除了vw和vh外，还有vmin和vmax两个相关的单位。</p><ul><li>vw：相对于视窗的宽度，视窗宽度是100vw；</li><li>vh：相对于视窗的高度，视窗高度是100vh；</li><li>vmin：vw和vh中的较小值；</li><li>vmax：vw和vh中的较大值；</li></ul><p><strong>vw&#x2F;vh</strong> 和百分比很类似，两者的区别：</p><ul><li>百分比（<code>%</code>）：大部分相对于祖先元素，也有相对于自身的情况比如（border-radius、translate等)</li><li>vw&#x2F;vm：相对于视窗的尺寸</li></ul><h3 id="2-px、em、rem的区别及使用场景"><a href="#2-px、em、rem的区别及使用场景" class="headerlink" title="2. px、em、rem的区别及使用场景"></a>2. px、em、rem的区别及使用场景</h3><p><strong>三者的区别：</strong></p><ul><li>px是固定的像素，一旦设置了就无法因为适应页面大小而改变。</li><li>em和rem相对于px更具有灵活性，他们是相对长度单位，其长度不是固定的，更适用于响应式布局。</li><li>em是相对于其父元素来设置字体大小，这样就会存在一个问题，进行任何元素设置，都有可能需要知道他父元素的大小。而rem是相对于根元素，这样就意味着，只需要在根元素确定一个参考值。</li></ul><p><strong>使用场景：</strong></p><ul><li>对于只需要适配少部分移动设备，且分辨率对页面影响不大的，使用px即可 。</li><li>对于需要适配各种移动设备，使用rem，例如需要适配iPhone和iPad等分辨率差别比较挺大的设备。</li></ul><h3 id="3-两栏布局的实现"><a href="#3-两栏布局的实现" class="headerlink" title="3. 两栏布局的实现"></a>3. 两栏布局的实现</h3><p>一般两栏布局指的是<strong>左边一栏宽度固定，右边一栏宽度自适应</strong>，两栏布局的具体实现：</p><ul><li>利用浮动，将左边元素宽度设置为200px，并且设置向左浮动。将右边元素的margin-left设置为200px，宽度设置为auto（默认为auto，撑满整个父元素）。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.outer</span> &#123;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>&#125;<br><span class="hljs-selector-class">.left</span> &#123;<br>  <span class="hljs-attribute">float</span>: left;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">background</span>: tomato;<br>&#125;<br><span class="hljs-selector-class">.right</span> &#123;<br>  <span class="hljs-attribute">margin-left</span>: <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">width</span>: auto;<br>  <span class="hljs-attribute">background</span>: gold;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>利用浮动，左侧元素设置固定大小，并左浮动，右侧元素设置overflow: hidden; 这样右边就触发了BFC，BFC的区域不会与浮动元素发生重叠，所以两侧就不会发生重叠。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.left</span>&#123;<br>     <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br>     <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;<br>     <span class="hljs-attribute">background</span>: red;<br>     <span class="hljs-attribute">float</span>: left;<br> &#125;<br> <span class="hljs-selector-class">.right</span>&#123;<br>     <span class="hljs-attribute">height</span>: <span class="hljs-number">300px</span>;<br>     <span class="hljs-attribute">background</span>: blue;<br>     <span class="hljs-attribute">overflow</span>: hidden;<br> &#125;<br></code></pre></td></tr></table></figure><ul><li>利用flex布局，将左边元素设置为固定宽度200px，将右边的元素设置为flex:1。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.outer</span> &#123;<br>  <span class="hljs-attribute">display</span>: flex;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>&#125;<br><span class="hljs-selector-class">.left</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">background</span>: tomato;<br>&#125;<br><span class="hljs-selector-class">.right</span> &#123;<br>  <span class="hljs-attribute">flex</span>: <span class="hljs-number">1</span>;<br>  <span class="hljs-attribute">background</span>: gold;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>利用绝对定位，将父级元素设置为相对定位。左边元素设置为absolute定位，并且宽度设置为200px。将右边元素的margin-left的值设置为200px。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.outer</span> &#123;<br>  <span class="hljs-attribute">position</span>: relative;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>&#125;<br><span class="hljs-selector-class">.left</span> &#123;<br>  <span class="hljs-attribute">position</span>: absolute;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">background</span>: tomato;<br>&#125;<br><span class="hljs-selector-class">.right</span> &#123;<br>  <span class="hljs-attribute">margin-left</span>: <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">background</span>: gold;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>利用绝对定位，将父级元素设置为相对定位。左边元素宽度设置为200px，右边元素设置为绝对定位，左边定位为200px，其余方向定位为0。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.outer</span> &#123;<br>  <span class="hljs-attribute">position</span>: relative;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>&#125;<br><span class="hljs-selector-class">.left</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">background</span>: tomato;<br>&#125;<br><span class="hljs-selector-class">.right</span> &#123;<br>  <span class="hljs-attribute">position</span>: absolute;<br>  <span class="hljs-attribute">top</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">right</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">bottom</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">left</span>: <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">background</span>: gold;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-三栏布局的实现"><a href="#4-三栏布局的实现" class="headerlink" title="4. 三栏布局的实现"></a>4. 三栏布局的实现</h3><p>三栏布局一般指的是页面中一共有三栏，<strong>左右两栏宽度固定，中间自适应的布局</strong>，三栏布局的具体实现：</p><ul><li>利用<strong>绝对定位</strong>，左右两栏设置为绝对定位，中间设置对应方向大小的margin的值。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.outer</span> &#123;<br>  <span class="hljs-attribute">position</span>: relative;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>&#125;<br><br><span class="hljs-selector-class">.left</span> &#123;<br>  <span class="hljs-attribute">position</span>: absolute;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">background</span>: tomato;<br>&#125;<br><br><span class="hljs-selector-class">.right</span> &#123;<br>  <span class="hljs-attribute">position</span>: absolute;<br>  <span class="hljs-attribute">top</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">right</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">background</span>: gold;<br>&#125;<br><br><span class="hljs-selector-class">.center</span> &#123;<br>  <span class="hljs-attribute">margin-left</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">margin-right</span>: <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">background</span>: lightgreen;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>利用flex布局，左右两栏设置固定大小，中间一栏设置为flex:1。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.outer</span> &#123;<br>  <span class="hljs-attribute">display</span>: flex;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>&#125;<br><br><span class="hljs-selector-class">.left</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">background</span>: tomato;<br>&#125;<br><br><span class="hljs-selector-class">.right</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">background</span>: gold;<br>&#125;<br><br><span class="hljs-selector-class">.center</span> &#123;<br>  <span class="hljs-attribute">flex</span>: <span class="hljs-number">1</span>;<br>  <span class="hljs-attribute">background</span>: lightgreen;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>利用浮动，左右两栏设置固定大小，并设置对应方向的浮动。中间一栏设置左右两个方向的margin值，注意这种方式<strong>，中间一栏必须放到最后：</strong></li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.outer</span> &#123;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>&#125;<br><br><span class="hljs-selector-class">.left</span> &#123;<br>  <span class="hljs-attribute">float</span>: left;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">background</span>: tomato;<br>&#125;<br><br><span class="hljs-selector-class">.right</span> &#123;<br>  <span class="hljs-attribute">float</span>: right;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">background</span>: gold;<br>&#125;<br><br><span class="hljs-selector-class">.center</span> &#123;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">margin-left</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">margin-right</span>: <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">background</span>: lightgreen;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>圣杯布局，利用浮动和负边距来实现。父级元素设置左右的 padding，三列均设置向左浮动，中间一列放在最前面，宽度设置为父级元素的宽度，因此后面两列都被挤到了下一行，通过设置 margin 负值将其移动到上一行，再利用相对定位，定位到两边。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.outer</span> &#123;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">padding-left</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">padding-right</span>: <span class="hljs-number">200px</span>;<br>&#125;<br><br><span class="hljs-selector-class">.left</span> &#123;<br>  <span class="hljs-attribute">position</span>: relative;<br>  <span class="hljs-attribute">left</span>: -<span class="hljs-number">100px</span>;<br><br>  <span class="hljs-attribute">float</span>: left;<br>  <span class="hljs-attribute">margin-left</span>: -<span class="hljs-number">100%</span>;<br><br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">background</span>: tomato;<br>&#125;<br><br><span class="hljs-selector-class">.right</span> &#123;<br>  <span class="hljs-attribute">position</span>: relative;<br>  <span class="hljs-attribute">left</span>: <span class="hljs-number">200px</span>;<br><br>  <span class="hljs-attribute">float</span>: right;<br>  <span class="hljs-attribute">margin-left</span>: -<span class="hljs-number">200px</span>;<br><br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">background</span>: gold;<br>&#125;<br><br><span class="hljs-selector-class">.center</span> &#123;<br>  <span class="hljs-attribute">float</span>: left;<br><br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">background</span>: lightgreen;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>双飞翼布局，双飞翼布局相对于圣杯布局来说，左右位置的保留是通过中间列的 margin 值来实现的，而不是通过父元素的 padding 来实现的。本质上来说，也是通过浮动和外边距负值来实现的。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.outer</span> &#123;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>&#125;<br><br><span class="hljs-selector-class">.left</span> &#123;<br>  <span class="hljs-attribute">float</span>: left;<br>  <span class="hljs-attribute">margin-left</span>: -<span class="hljs-number">100%</span>;<br><br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">background</span>: tomato;<br>&#125;<br><br><span class="hljs-selector-class">.right</span> &#123;<br>  <span class="hljs-attribute">float</span>: left;<br>  <span class="hljs-attribute">margin-left</span>: -<span class="hljs-number">200px</span>;<br><br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">background</span>: gold;<br>&#125;<br><br><span class="hljs-selector-class">.wrapper</span> &#123;<br>  <span class="hljs-attribute">float</span>: left;<br><br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">background</span>: lightgreen;<br>&#125;<br><br><span class="hljs-selector-class">.center</span> &#123;<br>  <span class="hljs-attribute">margin-left</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">margin-right</span>: <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-水平垂直居中的实现"><a href="#5-水平垂直居中的实现" class="headerlink" title="5. 水平垂直居中的实现"></a>5. 水平垂直居中的实现</h3><ul><li>利用绝对定位，先将元素的左上角通过top:50%和left:50%定位到页面的中心，然后再通过translate来调整元素的中心点到页面的中心。该方法需要<strong>考虑浏览器兼容问题。</strong></li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.parent</span> &#123;    <span class="hljs-attribute">position</span>: relative;&#125; <span class="hljs-selector-class">.child</span> &#123;    <span class="hljs-attribute">position</span>: absolute;    <span class="hljs-attribute">left</span>: <span class="hljs-number">50%</span>;    <span class="hljs-attribute">top</span>: <span class="hljs-number">50%</span>;    <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translate</span>(-<span class="hljs-number">50%</span>,-<span class="hljs-number">50%</span>);&#125;<br></code></pre></td></tr></table></figure><ul><li>利用绝对定位，设置四个方向的值都为0，并将margin设置为auto，由于宽高固定，因此对应方向实现平分，可以实现水平和垂直方向上的居中。该方法适用于<strong>盒子有宽高</strong>的情况：</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.parent</span> &#123;<br>    <span class="hljs-attribute">position</span>: relative;<br>&#125;<br> <br><span class="hljs-selector-class">.child</span> &#123;<br>    <span class="hljs-attribute">position</span>: absolute;<br>    <span class="hljs-attribute">top</span>: <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">bottom</span>: <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">left</span>: <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">right</span>: <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">margin</span>: auto;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>利用绝对定位，先将元素的左上角通过top:50%和left:50%定位到页面的中心，然后再通过margin负值来调整元素的中心点到页面的中心。该方法适用于<strong>盒子宽高已知</strong>的情况</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.parent</span> &#123;<br>    <span class="hljs-attribute">position</span>: relative;<br>&#125;<br> <br><span class="hljs-selector-class">.child</span> &#123;<br>    <span class="hljs-attribute">position</span>: absolute;<br>    <span class="hljs-attribute">top</span>: <span class="hljs-number">50%</span>;<br>    <span class="hljs-attribute">left</span>: <span class="hljs-number">50%</span>;<br>    <span class="hljs-attribute">margin-top</span>: -<span class="hljs-number">50px</span>;     <span class="hljs-comment">/* 自身 height 的一半 */</span><br>    <span class="hljs-attribute">margin-left</span>: -<span class="hljs-number">50px</span>;    <span class="hljs-comment">/* 自身 width 的一半 */</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>使用flex布局，通过align-items:center和justify-content:center设置容器的垂直和水平方向上为居中对齐，然后它的子元素也可以实现垂直和水平的居中。该方法要<strong>考虑兼容的问题</strong>，该方法在移动端用的较多：</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.parent</span> &#123;<br>    <span class="hljs-attribute">display</span>: flex;<br>    <span class="hljs-attribute">justify-content</span>:center;<br>    <span class="hljs-attribute">align-items</span>:center;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6-如何根据设计稿进行移动端适配？"><a href="#6-如何根据设计稿进行移动端适配？" class="headerlink" title="6. 如何根据设计稿进行移动端适配？"></a>6. 如何根据设计稿进行移动端适配？</h3><p>移动端适配主要有两个维度：</p><ul><li><strong>适配不同像素密度，</strong> 针对不同的像素密度，使用 CSS 媒体查询，选择不同精度的图片，以保证图片不会失真；</li><li><strong>适配不同屏幕大小，</strong> 由于不同的屏幕有着不同的逻辑像素大小，所以如果直接使用 px 作为开发单位，会使得开发的页面在某一款手机上可以准确显示，但是在另一款手机上就会失真。为了适配不同屏幕的大小，应按照比例来还原设计稿的内容。</li></ul><p>为了能让页面的尺寸自适应，可以使用 rem，em，vw，vh 等相对单位。</p><h3 id="7-对Flex布局的理解及其使用场景"><a href="#7-对Flex布局的理解及其使用场景" class="headerlink" title="7. 对Flex布局的理解及其使用场景"></a>7. 对Flex布局的理解及其使用场景</h3><p>Flex是FlexibleBox的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。任何一个容器都可以指定为Flex布局。行内元素也可以使用Flex布局。注意，设为Flex布局以后，<strong>子元素的float、clear和vertical-align属性将失效</strong>。采用Flex布局的元素，称为Flex容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为Flex项目（flex item），简称”项目”。容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis），项目默认沿水平主轴排列。</p><p>以下6个属性设置在<strong>容器上</strong>：</p><ul><li>flex-direction属性决定主轴的方向（即项目的排列方向）。</li><li>flex-wrap属性定义，如果一条轴线排不下，如何换行。</li><li>flex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。</li><li>justify-content属性定义了项目在主轴上的对齐方式。</li><li>align-items属性定义项目在交叉轴上如何对齐。</li><li>align-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。</li></ul><p>以下6个属性设置在<strong>项目上</strong>：</p><ul><li>order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。</li><li>flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。</li><li>flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。</li><li>flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。</li><li>flex属性是flex-grow，flex-shrink和flex-basis的简写，默认值为0 1 auto。</li><li>align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。</li></ul><p><strong>简单来说：</strong><br>flex布局是CSS3新增的一种布局方式，可以通过将一个元素的display属性值设置为flex从而使它成为一个flex容器，它的所有子元素都会成为它的项目。一个容器默认有两条轴：一个是水平的主轴，一个是与主轴垂直的交叉轴。可以使用flex-direction来指定主轴的方向。可以使用justify-content来指定元素在主轴上的排列方式，使用align-items来指定元素在交叉轴上的排列方式。还可以使用flex-wrap来规定当一行排列不下时的换行方式。对于容器中的项目，可以使用order属性来指定项目的排列顺序，还可以使用flex-grow来指定当排列空间有剩余的时候，项目的放大比例，还可以使用flex-shrink来指定当排列空间不足时，项目的缩小比例。</p><h3 id="8-响应式设计的概念及基本原理"><a href="#8-响应式设计的概念及基本原理" class="headerlink" title="8. 响应式设计的概念及基本原理"></a>8. 响应式设计的概念及基本原理</h3><p>响应式网站设计<code>（Responsive Web design</code>）是一个网站能够兼容多个终端，而不是为每一个终端做一个特定的版本。</p><p>关于原理： 基本原理是通过媒体查询<code>（@media）</code>查询检测不同的设备屏幕尺寸做处理。<br>关于兼容： 页面头部必须有mate声明的<code>viewport</code>。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;’viewport’&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;”width=device-width,&quot;</span> <span class="hljs-attr">initial-scale</span>=<span class="hljs-string">&quot;1.&quot;</span> <span class="hljs-attr">maximum-scale</span>=<span class="hljs-string">&quot;1,user-scalable=no”&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><h2 id="三、定位与浮动"><a href="#三、定位与浮动" class="headerlink" title="三、定位与浮动"></a>三、定位与浮动</h2><h3 id="1-为什么需要清除浮动？清除浮动的方式"><a href="#1-为什么需要清除浮动？清除浮动的方式" class="headerlink" title="1. 为什么需要清除浮动？清除浮动的方式"></a>1. 为什么需要清除浮动？清除浮动的方式</h3><p><strong>浮动的定义：</strong> 非IE浏览器下，容器不设高度且子元素浮动时，容器高度不能被内容撑开。 此时，内容会溢出到容器外面而影响布局。这种现象被称为浮动（溢出）。</p><p><strong>浮动的工作原理：</strong></p><ul><li>浮动元素脱离文档流，不占据空间（引起“高度塌陷”现象）</li><li>浮动元素碰到包含它的边框或者其他浮动元素的边框停留</li></ul><p>浮动元素可以左右移动，直到遇到另一个浮动元素或者遇到它外边缘的包含框。浮动框不属于文档流中的普通流，当元素浮动之后，不会影响块级元素的布局，只会影响内联元素布局。此时文档流中的普通流就会表现得该浮动框不存在一样的布局模式。当包含框的高度小于浮动框的时候，此时就会出现“高度塌陷”。</p><p><strong>浮动元素引起的问题？</strong></p><ul><li>父元素的高度无法被撑开，影响与父元素同级的元素</li><li>与浮动元素同级的非浮动元素会跟随其后</li><li>若浮动的元素不是第一个元素，则该元素之前的元素也要浮动，否则会影响页面的显示结构</li></ul><p><strong>清除浮动的方式如下：</strong></p><ul><li>给父级div定义<code>height</code>属性</li><li>最后一个浮动元素之后添加一个空的div标签，并添加<code>clear:both</code>样式</li><li>包含浮动元素的父级标签添加<code>overflow:hidden</code>或者<code>overflow:auto</code></li><li>使用 :after 伪元素。由于IE6-7不支持 :after，使用 zoom:1 触发 hasLayout**</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.clearfix</span><span class="hljs-selector-pseudo">:after</span>&#123;<br>    <span class="hljs-attribute">content</span>: <span class="hljs-string">&quot;\200B&quot;</span>;<br>    <span class="hljs-attribute">display</span>: table; <br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">clear</span>: both;<br>  &#125;<br>  <span class="hljs-selector-class">.clearfix</span>&#123;<br>    *zoom: <span class="hljs-number">1</span>;<br>  &#125;<br></code></pre></td></tr></table></figure><h3 id="2-使用-clear-属性清除浮动的原理？"><a href="#2-使用-clear-属性清除浮动的原理？" class="headerlink" title="2. 使用 clear 属性清除浮动的原理？"></a>2. 使用 clear 属性清除浮动的原理？</h3><p>使用clear属性清除浮动，其语法如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">clear</span>:none|left|right|both<br></code></pre></td></tr></table></figure><p>如果单看字面意思，clear:left 是“清除左浮动”，clear:right 是“清除右浮动”，实际上，这种解释是有问题的，因为浮动一直还在，并没有清除。</p><p>官方对clear属性解释：“<strong>元素盒子的边不能和前面的浮动元素相邻</strong>”，对元素设置clear属性是为了避免浮动元素对该元素的影响，而不是清除掉浮动。</p><p>还需要注意 clear 属性指的是元素盒子的边不能和前面的浮动元素相邻，注意这里“<strong>前面的</strong>”3个字，也就是clear属性对“后面的”浮动元素是不闻不问的。考虑到float属性要么是left，要么是right，不可能同时存在，同时由于clear属性对“后面的”浮动元素不闻不问，因此，当clear:left有效的时候，clear:right必定无效，也就是此时clear:left等同于设置clear:both；同样地，clear:right如果有效也是等同于设置clear:both。由此可见，clear:left和clear:right这两个声明就没有任何使用的价值，至少在CSS世界中是如此，直接使用clear:both吧。</p><p>一般使用伪元素的方式清除浮动：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.clear</span><span class="hljs-selector-pseudo">::after</span>&#123;  <span class="hljs-attribute">content</span>:<span class="hljs-string">&#x27;&#x27;</span>;  <span class="hljs-attribute">display</span>: block;   <span class="hljs-attribute">clear</span>:both;&#125;<br></code></pre></td></tr></table></figure><p>clear属性只有块级元素才有效的，而::after等伪元素默认都是内联水平，这就是借助伪元素清除浮动影响时需要设置display属性值的原因。</p><h3 id="3-对BFC的理解，如何创建BFC"><a href="#3-对BFC的理解，如何创建BFC" class="headerlink" title="3. 对BFC的理解，如何创建BFC"></a>3. 对BFC的理解，如何创建BFC</h3><p>先来看两个相关的概念：</p><ul><li>Box: Box 是 CSS 布局的对象和基本单位，⼀个⻚⾯是由很多个 Box 组成的，这个Box就是我们所说的盒模型。 </li><li>Formatting context：块级上下⽂格式化，它是⻚⾯中的⼀块渲染区域，并且有⼀套渲染规则，它决定了其⼦元素将如何定位，以及和其他元素的关系和相互作⽤。</li></ul><p>块格式化上下文（Block Formatting Context，BFC）是Web页面的可视化CSS渲染的一部分，是布局过程中生成块级盒子的区域，也是浮动元素与其他元素的交互限定区域。</p><p>通俗来讲：BFC是一个独立的布局环境，可以理解为一个容器，在这个容器中按照一定规则进行物品摆放，并且不会影响其它环境中的物品。如果一个元素符合触发BFC的条件，则BFC中的元素布局不受外部影响。</p><p><strong>创建BFC的条件：</strong></p><ul><li>根元素：body；</li><li>元素设置浮动：float 除 none 以外的值；</li><li>元素设置绝对定位：position (absolute、fixed)；</li><li>display 值为：inline-block、table-cell、table-caption、flex等；</li><li>overflow 值为：hidden、auto、scroll；</li></ul><p><strong>BFC的特点：</strong></p><ul><li>垂直方向上，自上而下排列，和文档流的排列方式一致。</li><li>在BFC中上下相邻的两个容器的margin会重叠</li><li>计算BFC的高度时，需要计算浮动元素的高度</li><li>BFC区域不会与浮动的容器发生重叠</li><li>BFC是独立的容器，容器内部元素不会影响外部元素</li><li>每个元素的左margin值和容器的左border相接触</li></ul><p><strong>BFC的作用：</strong></p><ul><li><strong>解决margin的重叠问题</strong>：由于BFC是一个独立的区域，内部的元素和外部的元素互不影响，将两个元素变为两个BFC，就解决了margin重叠的问题。</li><li><strong>解决高度塌陷的问题</strong>：在对子元素设置浮动后，父元素会发生高度塌陷，也就是父元素的高度变为0。解决这个问题，只需要把父元素变成一个BFC。常用的办法是给父元素设置<code>overflow:hidden</code>。</li><li><strong>创建自适应两栏布局</strong>：可以用来创建自适应两栏布局：左边的宽度固定，右边的宽度自适应。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.left</span>&#123;<br>     <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br>     <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;<br>     <span class="hljs-attribute">background</span>: red;<br>     <span class="hljs-attribute">float</span>: left;<br> &#125;<br> <span class="hljs-selector-class">.right</span>&#123;<br>     <span class="hljs-attribute">height</span>: <span class="hljs-number">300px</span>;<br>     <span class="hljs-attribute">background</span>: blue;<br>     <span class="hljs-attribute">overflow</span>: hidden;<br> &#125;<br> <br>&lt;<span class="hljs-selector-tag">div</span> class=&quot;<span class="hljs-attribute">left</span>&quot;&gt;&lt;/<span class="hljs-selector-tag">div</span>&gt;<br>&lt;<span class="hljs-selector-tag">div</span> class=&quot;<span class="hljs-attribute">right</span>&quot;&gt;&lt;/<span class="hljs-selector-tag">div</span>&gt;<br></code></pre></td></tr></table></figure><p>左侧设置<code>float:left</code>，右侧设置<code>overflow: hidden</code>。这样右边就触发了BFC，BFC的区域不会与浮动元素发生重叠，所以两侧就不会发生重叠，实现了自适应两栏布局。</p><h3 id="4-什么是margin重叠问题？如何解决？"><a href="#4-什么是margin重叠问题？如何解决？" class="headerlink" title="4. 什么是margin重叠问题？如何解决？"></a>4. 什么是margin重叠问题？如何解决？</h3><p><strong>问题描述：</strong><br>两个块级元素的上外边距和下外边距可能会合并（折叠）为一个外边距，其大小会取其中外边距值大的那个，这种行为就是外边距折叠。需要注意的是，<strong>浮动的元素和绝对定位</strong>这种脱离文档流的元素的外边距不会折叠。重叠只会出现在<strong>垂直方向</strong>。</p><p><strong>计算原则：</strong><br>折叠合并后外边距的计算原则如下：</p><ul><li>如果两者都是正数，那么就去最大者</li><li>如果是一正一负，就会正值减去负值的绝对值</li><li>两个都是负值时，用0减去两个中绝对值大的那个</li></ul><p><strong>解决办法：</strong><br>对于折叠的情况，主要有两种：<strong>兄弟之间重叠</strong>和<strong>父子之间重叠</strong><br>（1）兄弟之间重叠</p><ul><li>底部元素变为行内盒子：<code>display: inline-block</code></li><li>底部元素设置浮动：<code>float</code></li><li>底部元素的position的值为<code>absolute/fixed</code></li></ul><p>（2）父子之间重叠</p><ul><li>父元素加入：<code>overflow: hidden</code></li><li>父元素添加透明边框：<code>border:1px solid transparent</code></li><li>子元素变为行内盒子：<code>display: inline-block</code></li><li>子元素加入浮动属性或定位</li></ul><h3 id="5-元素的层叠顺序"><a href="#5-元素的层叠顺序" class="headerlink" title="5. 元素的层叠顺序"></a>5. 元素的层叠顺序</h3><p>层叠顺序，英文称作 stacking order，表示元素发生层叠时有着特定的垂直显示顺序。下面是盒模型的层叠规则：<br><img src="8.png" alt="img"><br>对于上图，由上到下分别是：<br>（1）背景和边框：建立当前层叠上下文元素的背景和边框。<br>（2）负的z-index：当前层叠上下文中，z-index属性值为负的元素。<br>（3）块级盒：文档流内非行内级非定位后代元素。<br>（4）浮动盒：非定位浮动元素。<br>（5）行内盒：文档流内行内级非定位后代元素。<br>（6）z-index:0：层叠级数为0的定位元素。<br>（7）正z-index：z-index属性值为正的定位元素。</p><p><strong>注意:</strong> 当定位元素z-index:auto，生成盒在当前层叠上下文中的层级为 0，不会建立新的层叠上下文，除非是根元素。</p><h3 id="6-position的属性有哪些，区别是什么"><a href="#6-position的属性有哪些，区别是什么" class="headerlink" title="6. position的属性有哪些，区别是什么"></a>6. position的属性有哪些，区别是什么</h3><p>position有以下属性值：</p><table><thead><tr><th>属性值</th><th>概述</th></tr></thead><tbody><tr><td>absolute</td><td>生成绝对定位的元素，相对于static定位以外的一个父元素进行定位。元素的位置通过left、top、right、bottom属性进行规定。</td></tr><tr><td>relative</td><td>生成相对定位的元素，相对于其原来的位置进行定位。元素的位置通过left、top、right、bottom属性进行规定。</td></tr><tr><td>fixed</td><td>生成绝对定位的元素，指定元素相对于屏幕视⼝（viewport）的位置来指定元素位置。元素的位置在屏幕滚动时不会改变，⽐如回到顶部的按钮⼀般都是⽤此定位⽅式。</td></tr><tr><td>static</td><td>默认值，没有定位，元素出现在正常的文档流中，会忽略 top, bottom, left, right 或者 z-index 声明，块级元素从上往下纵向排布，⾏级元素从左向右排列。</td></tr><tr><td>inherit</td><td>规定从父元素继承position属性的值</td></tr></tbody></table><p>前面三者的定位方式如下：</p><ul><li><strong>relative：</strong> 元素的定位永远是相对于元素自身位置的，和其他元素没关系，也不会影响其他元素。</li></ul><p><img src="9.png" alt="img"></p><ul><li><strong>fixed：</strong> 元素的定位是相对于 window （或者 iframe）边界的，和其他元素没有关系。但是它具有破坏性，会导致其他元素位置的变化。</li></ul><p><img src="10.png" alt="img"></p><ul><li><strong>absolute：</strong> 元素的定位相对于前两者要复杂许多。如果为 absolute 设置了 top、left，浏览器会根据什么去确定它的纵向和横向的偏移量呢？答案是浏览器会递归查找该元素的所有父元素，如果找到一个设置了<code>position:relative/absolute/fixed</code>的元素，就以该元素为基准定位，如果没找到，就以浏览器边界定位。如下两个图所示：</li></ul><p><img src="11.png" alt="img"><br><img src="12.png" alt="img"></p><h3 id="7-display、float、position的关系"><a href="#7-display、float、position的关系" class="headerlink" title="7. display、float、position的关系"></a>7. <strong>display、float、position的关系</strong></h3><p>（1）首先判断display属性是否为none，如果为none，则position和float属性的值不影响元素最后的表现。</p><p>（2）然后判断position的值是否为absolute或者fixed，如果是，则float属性失效，并且display的值应该被设置为table或者block，具体转换需要看初始转换值。</p><p>（3）如果position的值不为absolute或者fixed，则判断float属性的值是否为none，如果不是，则display的值则按上面的规则转换。注意，如果position的值为relative并且float属性的值存在，则relative相对于浮动后的最终位置定位。</p><p>（4）如果float的值为none，则判断元素是否为根元素，如果是根元素则display属性按照上面的规则转换，如果不是，则保持指定的display属性值不变。</p><p>总的来说，可以把它看作是一个类似优先级的机制，”position:absolute”和”position:fixed”优先级最高，有它存在的时候，浮动不起作用，’display’的值也需要调整；其次，元素的’float’特性的值不是”none”的时候或者它是根元素的时候，调整’display’的值；最后，非根元素，并且非浮动元素，并且非绝对定位的元素，’display’特性值同设置值。</p><h3 id="8-absolute与fixed共同点与不同点"><a href="#8-absolute与fixed共同点与不同点" class="headerlink" title="8. absolute与fixed共同点与不同点"></a>8. absolute与fixed共同点与不同点</h3><p><strong>共同点：</strong></p><ul><li>改变行内元素的呈现方式，将display置为inline-block  </li><li>使元素脱离普通文档流，不再占据文档物理空间</li><li>覆盖非定位文档元素</li></ul><p><strong>不同点：</strong></p><ul><li>abuselute与fixed的根元素不同，abuselute的根元素可以设置，fixed根元素是浏览器。</li><li>在有滚动条的页面中，absolute会跟着父元素进行移动，fixed固定在页面的具体位置。</li></ul><h3 id="9-对-sticky-定位的理解"><a href="#9-对-sticky-定位的理解" class="headerlink" title="9. 对 sticky 定位的理解"></a>9. 对 sticky 定位的理解</h3><p>sticky 英文字面意思是粘贴，所以可以把它称之为粘性定位。语法：<strong>position: sticky;</strong> 基于用户的滚动位置来定位。</p><p>粘性定位的元素是依赖于用户的滚动，在 <strong>position:relative</strong> 与 <strong>position:fixed</strong> 定位之间切换。它的行为就像 <strong>position:relative;</strong> 而当页面滚动超出目标区域时，它的表现就像 **position:fixed;**，它会固定在目标位置。元素定位表现为在跨越特定阈值前为相对定位，之后为固定定位。这个特定阈值指的是 top, right, bottom 或 left 之一，换言之，指定 top, right, bottom 或 left 四个阈值其中之一，才可使粘性定位生效。否则其行为与相对定位相同。</p><h2 id="四、场景应用"><a href="#四、场景应用" class="headerlink" title="四、场景应用"></a>四、场景应用</h2><h3 id="1-实现一个三角形"><a href="#1-实现一个三角形" class="headerlink" title="1. 实现一个三角形"></a>1. 实现一个三角形</h3><p>CSS绘制三角形主要用到的是border属性，也就是边框。</p><p>平时在给盒子设置边框时，往往都设置很窄，就可能误以为边框是由矩形组成的。实际上，border属性是右三角形组成的，下面看一个例子：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span> &#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">border</span>: <span class="hljs-number">100px</span> solid;<br>    <span class="hljs-attribute">border-color</span>: orange blue red green;<br>&#125;<br></code></pre></td></tr></table></figure><p>将元素的长宽都设置为0，显示出来的效果是这样的：<br><img src="13.png" alt="img"><br>所以可以根据border这个特性来绘制三角形：<br><strong>（1）三角1</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span> &#123;    <span class="hljs-attribute">width</span>: <span class="hljs-number">0</span>;    <span class="hljs-attribute">height</span>: <span class="hljs-number">0</span>;    <span class="hljs-attribute">border-top</span>: <span class="hljs-number">50px</span> solid red;    <span class="hljs-attribute">border-right</span>: <span class="hljs-number">50px</span> solid transparent;    <span class="hljs-attribute">border-left</span>: <span class="hljs-number">50px</span> solid transparent;&#125;<br></code></pre></td></tr></table></figure><p><img src="14.png" alt="img"><br><strong>（2）三角2</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span> &#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">border-bottom</span>: <span class="hljs-number">50px</span> solid red;<br>    <span class="hljs-attribute">border-right</span>: <span class="hljs-number">50px</span> solid transparent;<br>    <span class="hljs-attribute">border-left</span>: <span class="hljs-number">50px</span> solid transparent;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="15.png" alt="img"><br><strong>（3）三角3</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span> &#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">border-left</span>: <span class="hljs-number">50px</span> solid red;<br>    <span class="hljs-attribute">border-top</span>: <span class="hljs-number">50px</span> solid transparent;<br>    <span class="hljs-attribute">border-bottom</span>: <span class="hljs-number">50px</span> solid transparent;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="16.png" alt="img"><br><strong>（4）三角4</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span> &#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">border-right</span>: <span class="hljs-number">50px</span> solid red;<br>    <span class="hljs-attribute">border-top</span>: <span class="hljs-number">50px</span> solid transparent;<br>    <span class="hljs-attribute">border-bottom</span>: <span class="hljs-number">50px</span> solid transparent;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="17.png" alt="img"><br><strong>（5）三角5</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span> &#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">border-top</span>: <span class="hljs-number">100px</span> solid red;<br>    <span class="hljs-attribute">border-right</span>: <span class="hljs-number">100px</span> solid transparent;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="18.png" alt="img"><br>还有很多，就不一一实现了，总体的原则就是通过上下左右边框来控制三角形的方向，用边框的宽度比来控制三角形的角度。</p><h3 id="2-实现一个扇形"><a href="#2-实现一个扇形" class="headerlink" title="2. 实现一个扇形"></a>2. 实现一个扇形</h3><p>用CSS实现扇形的思路和三角形基本一致，就是多了一个圆角的样式，实现一个90°的扇形：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span>&#123;<br>    <span class="hljs-attribute">border</span>: <span class="hljs-number">100px</span> solid transparent;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">0</span>;<br>    heigt: <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">100px</span>;<br>    <span class="hljs-attribute">border-top-color</span>: red;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="19.png" alt="img"></p><h3 id="3-实现一个宽高自适应的正方形"><a href="#3-实现一个宽高自适应的正方形" class="headerlink" title="3. 实现一个宽高自适应的正方形"></a>3. 实现一个宽高自适应的正方形</h3><ul><li>利用vw来实现：</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.square</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">10%</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">10vw</span>;<br>  <span class="hljs-attribute">background</span>: tomato;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>利用元素的margin&#x2F;padding百分比是相对父元素width的性质来实现：</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.square</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">20%</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">padding-top</span>: <span class="hljs-number">20%</span>;<br>  <span class="hljs-attribute">background</span>: orange;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>利用子元素的margin-top的值来实现：</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.square</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">30%</span>;<br>  <span class="hljs-attribute">overflow</span>: hidden;<br>  <span class="hljs-attribute">background</span>: yellow;<br>&#125;<br><span class="hljs-selector-class">.square</span><span class="hljs-selector-pseudo">::after</span> &#123;<br>  <span class="hljs-attribute">content</span>: <span class="hljs-string">&#x27;&#x27;</span>;<br>  <span class="hljs-attribute">display</span>: block;<br>  <span class="hljs-attribute">margin-top</span>: <span class="hljs-number">100%</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-画一条0-5px的线"><a href="#4-画一条0-5px的线" class="headerlink" title="4. 画一条0.5px的线"></a>4. 画一条0.5px的线</h3><ul><li><strong>采用transform: scale()的方式</strong>，该方法用来定义元素的2D 缩放转换：</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">transform</span>: <span class="hljs-built_in">scale</span>(<span class="hljs-number">0.5</span>,<span class="hljs-number">0.5</span>);<br></code></pre></td></tr></table></figure><ul><li><strong>采用meta viewport的方式</strong></li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">&lt;meta name=&quot;viewport&quot; <span class="hljs-attribute">content</span>=&quot;<span class="hljs-attribute">width</span>=device-<span class="hljs-attribute">width</span>, initial-scale=<span class="hljs-number">0.5</span>, minimum-scale=<span class="hljs-number">0.5</span>, maximum-scale=<span class="hljs-number">0.5</span>&quot;/&gt;<br></code></pre></td></tr></table></figure><p>这样就能缩放到原来的0.5倍，如果是1px那么就会变成0.5px。viewport只针对于移动端，只在移动端上才能看到效果</p><h3 id="5-设置小于12px的字体"><a href="#5-设置小于12px的字体" class="headerlink" title="5. 设置小于12px的字体"></a>5. 设置小于12px的字体</h3><p>在谷歌下css设置字体大小为12px及以下时，显示都是一样大小，都是默认12px。</p><p><strong>解决办法：</strong></p><ul><li>使用Webkit的内核的-webkit-text-size-adjust的私有CSS属性来解决，只要加了-webkit-text-size-adjust:none;字体大小就不受限制了。但是chrome更新到27版本之后就不可以用了。所以高版本chrome谷歌浏览器已经不再支持-webkit-text-size-adjust样式，所以要使用时候慎用。</li><li>使用css3的transform缩放属性-webkit-transform:scale(0.5); 注意-webkit-transform:scale(0.75);收缩的是整个元素的大小，这时候，如果是内联元素，必须要将内联元素转换成块元素，可以使用display：block&#x2F;inline-block&#x2F;…；</li><li>使用图片：如果是内容固定不变情况下，使用将小于12px文字内容切出做图片，这样不影响兼容也不影响美观。</li></ul><h3 id="6-如何解决-1px-问题？"><a href="#6-如何解决-1px-问题？" class="headerlink" title="6. 如何解决 1px 问题？"></a>6. 如何解决 1px 问题？</h3><p>1px 问题指的是：在一些 <code>Retina屏幕</code> 的机型上，移动端页面的 1px 会变得很粗，呈现出不止 1px 的效果。原因很简单——CSS 中的 1px 并不能和移动设备上的 1px 划等号。它们之间的比例关系有一个专门的属性来描述：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html">window.devicePixelRatio = 设备的物理像素 / CSS像素。<br></code></pre></td></tr></table></figure><p>打开 Chrome 浏览器，启动移动端调试模式，在控制台去输出这个 <code>devicePixelRatio</code> 的值。这里选中 iPhone6&#x2F;7&#x2F;8 这系列的机型，输出的结果就是2：<br><img src="20.png" alt="img"><br>这就意味着设置的 1px CSS 像素，在这个设备上实际会用 2 个物理像素单元来进行渲染，所以实际看到的一定会比 1px 粗一些。<br><strong>解决1px 问题的三种思路：</strong></p><h4 id="思路一：直接写-0-5px"><a href="#思路一：直接写-0-5px" class="headerlink" title="思路一：直接写 0.5px"></a>思路一：直接写 0.5px</h4><p>如果之前 1px 的样式这样写：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">border</span>:<span class="hljs-number">1px</span> solid <span class="hljs-number">#333</span><br></code></pre></td></tr></table></figure><p>可以先在 JS 中拿到 window.devicePixelRatio 的值，然后把这个值通过 JSX 或者模板语法给到 CSS 的 data 里，达到这样的效果（这里用 JSX 语法做示范）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;div id=<span class="hljs-string">&quot;container&quot;</span> data-device=&#123;&#123;<span class="hljs-variable language_">window</span>.<span class="hljs-property">devicePixelRatio</span>&#125;&#125;&gt;&lt;/div&gt;<br></code></pre></td></tr></table></figure><p>然后就可以在 CSS 中用属性选择器来命中 devicePixelRatio 为某一值的情况，比如说这里尝试命中 devicePixelRatio 为2的情况：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-id">#container</span><span class="hljs-selector-attr">[data-device=<span class="hljs-string">&quot;2&quot;</span>]</span> &#123;<br>  <span class="hljs-attribute">border</span>:<span class="hljs-number">0.5px</span> solid <span class="hljs-number">#333</span><br>&#125;<br></code></pre></td></tr></table></figure><p>直接把 1px 改成 1&#x2F;devicePixelRatio 后的值，这是目前为止最简单的一种方法。这种方法的缺陷在于兼容性不行，IOS 系统需要8及以上的版本，安卓系统则直接不兼容。</p><h4 id="思路二：伪元素先放大后缩小"><a href="#思路二：伪元素先放大后缩小" class="headerlink" title="思路二：伪元素先放大后缩小"></a>思路二：伪元素先放大后缩小</h4><p>这个方法的可行性会更高，兼容性也更好。唯一的缺点是代码会变多。</p><p>思路是<strong>先放大、后缩小：在目标元素的后面追加一个 ::after 伪元素，让这个元素布局为 absolute 之后、整个伸展开铺在目标元素上，然后把它的宽和高都设置为目标元素的两倍，border值设为 1px。接着借助 CSS 动画特效中的放缩能力，把整个伪元素缩小为原来的 50%。此时，伪元素的宽高刚好可以和原有的目标元素对齐，而 border 也缩小为了 1px 的二分之一，间接地实现了 0.5px 的效果。</strong></p><p>代码如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-id">#container</span><span class="hljs-selector-attr">[data-device=<span class="hljs-string">&quot;2&quot;</span>]</span> &#123;<br>    <span class="hljs-attribute">position</span>: relative;<br>&#125;<br><span class="hljs-selector-id">#container</span><span class="hljs-selector-attr">[data-device=<span class="hljs-string">&quot;2&quot;</span>]</span><span class="hljs-selector-pseudo">::after</span>&#123;<br>      <span class="hljs-attribute">position</span>:absolute;<br>      <span class="hljs-attribute">top</span>: <span class="hljs-number">0</span>;<br>      <span class="hljs-attribute">left</span>: <span class="hljs-number">0</span>;<br>      <span class="hljs-attribute">width</span>: <span class="hljs-number">200%</span>;<br>      <span class="hljs-attribute">height</span>: <span class="hljs-number">200%</span>;<br>      <span class="hljs-attribute">content</span>:<span class="hljs-string">&quot;&quot;</span>;<br>      <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">scale</span>(<span class="hljs-number">0.5</span>);<br>      <span class="hljs-attribute">transform-origin</span>: left top;<br>      <span class="hljs-attribute">box-sizing</span>: border-box;<br>      <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid <span class="hljs-number">#333</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="思路三：viewport-缩放来解决"><a href="#思路三：viewport-缩放来解决" class="headerlink" title="思路三：viewport 缩放来解决"></a>思路三：viewport 缩放来解决</h4><p>这个思路就是对 meta 标签里几个关键属性下手：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;initial-scale=0.5, maximum-scale=0.5, minimum-scale=0.5, user-scalable=no&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><p>这里针对像素比为2的页面，把整个页面缩放为了原来的1&#x2F;2大小。这样，本来占用2个物理像素的 1px 样式，现在占用的就是标准的一个物理像素。根据像素比的不同，这个缩放比例可以被计算为不同的值，用 js 代码实现如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> scale = <span class="hljs-number">1</span> / <span class="hljs-variable language_">window</span>.<span class="hljs-property">devicePixelRatio</span>;<br><span class="hljs-comment">// 这里 metaEl 指的是 meta 标签对应的 Dom</span><br>metaEl.<span class="hljs-title function_">setAttribute</span>(<span class="hljs-string">&#x27;content&#x27;</span>, <span class="hljs-string">`width=device-width,user-scalable=no,initial-scale=<span class="hljs-subst">$&#123;scale&#125;</span>,maximum-scale=<span class="hljs-subst">$&#123;scale&#125;</span>,minimum-scale=<span class="hljs-subst">$&#123;scale&#125;</span>`</span>);<br></code></pre></td></tr></table></figure><p>这样解决了，但这样做的副作用也很大，整个页面被缩放了。这时 1px 已经被处理成物理像素大小，这样的大小在手机上显示边框很合适。但是，一些原本不需要被缩小的内容，比如文字、图片等，也被无差别缩小掉了。</p>]]></content>
    
    
    <categories>
      
      <category>BGW</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>BGW-HTML</title>
    <link href="/2023/04/17/BGW-HTML/"/>
    <url>/2023/04/17/BGW-HTML/</url>
    
    <content type="html"><![CDATA[<p>BGW-HTML</p><p><img src="1.png" alt="img"></p><h3 id="1-src和href的区别"><a href="#1-src和href的区别" class="headerlink" title="1. src和href的区别"></a>1. src和href的区别</h3><p>src和href都是<strong>用来引用外部的资源</strong>，它们的区别如下：</p><ul><li><strong>src：</strong> 表示对资源的引用，它指向的内容会嵌入到当前标签所在的位置。src会将其指向的资源下载并应⽤到⽂档内，如请求js脚本。当浏览器解析到该元素时，会暂停其他资源的下载和处理，直到将该资源加载、编译、执⾏完毕，所以⼀般js脚本会放在页面底部。</li><li><strong>href：</strong> 表示超文本引用，它指向一些网络资源，建立和当前元素或本文档的链接关系。当浏览器识别到它他指向的⽂件时，就会并⾏下载资源，不会停⽌对当前⽂档的处理。 常用在a、link等标签上。</li></ul><h3 id="2-对HTML语义化的理解"><a href="#2-对HTML语义化的理解" class="headerlink" title="2. 对HTML语义化的理解"></a>2. 对HTML语义化的理解</h3><p><strong>语义化是指根据内容的结构化（内容语义化），选择合适的标签（代码语义化）</strong>。通俗来讲就是用正确的标签做正确的事情。</p><p>语义化的优点如下：</p><ul><li>对机器友好，带有语义的文字表现力丰富，更适合搜索引擎的爬虫爬取有效信息，有利于SEO。除此之外，语义类还支持读屏软件，根据文章可以自动生成目录；</li><li>对开发者友好，使用语义类标签增强了可读性，结构更加清晰，开发者能清晰的看出网页的结构，便于团队的开发与维护。</li></ul><p> 常见的语义化标签：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">header</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">header</span>&gt;</span>  头部<br><br><span class="hljs-tag">&lt;<span class="hljs-name">nav</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">nav</span>&gt;</span>  导航栏<br><br><span class="hljs-tag">&lt;<span class="hljs-name">section</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">section</span>&gt;</span>  区块（有语义化的div）<br><br><span class="hljs-tag">&lt;<span class="hljs-name">main</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">main</span>&gt;</span>  主要区域<br><br><span class="hljs-tag">&lt;<span class="hljs-name">article</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">article</span>&gt;</span>  主要内容<br><br><span class="hljs-tag">&lt;<span class="hljs-name">aside</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">aside</span>&gt;</span>  侧边栏<br><br><span class="hljs-tag">&lt;<span class="hljs-name">footer</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">footer</span>&gt;</span>  底部<br></code></pre></td></tr></table></figure><h3 id="3-DOCTYPE-⽂档类型-的作⽤"><a href="#3-DOCTYPE-⽂档类型-的作⽤" class="headerlink" title="3. DOCTYPE(⽂档类型) 的作⽤"></a>3. DOCTYPE(⽂档类型) 的作⽤</h3><p>DOCTYPE是HTML5中一种标准通用标记语言的文档类型声明，它的目的是<strong>告诉浏览器（解析器）应该以什么样（html或xhtml）的文档类型定义来解析文档</strong>，不同的渲染模式会影响浏览器对 CSS 代码甚⾄ JavaScript 脚本的解析。它必须声明在HTML⽂档的第⼀⾏。</p><p>浏览器渲染页面的两种模式（可通过document.compatMode获取，比如，语雀官网的文档类型是<strong>CSS1Compat</strong>）：</p><ul><li><strong>CSS1Compat：标准模式（Strick mode）</strong>，默认模式，浏览器使用W3C的标准解析渲染页面。在标准模式中，浏览器以其支持的最高标准呈现页面。</li><li>**BackCompat：怪异模式(混杂模式)(Quick mode)**，浏览器使用自己的怪异模式解析渲染页面。在怪异模式中，页面以一种比较宽松的向后兼容的方式显示。</li></ul><h3 id="4-script标签中defer和async的区别"><a href="#4-script标签中defer和async的区别" class="headerlink" title="4. script标签中defer和async的区别"></a>4. script标签中defer和async的区别</h3><p>如果没有defer或async属性，浏览器会立即加载并执行相应的脚本。它不会等待后续加载的文档元素，读取到就会开始加载和执行，这样就阻塞了后续文档的加载。</p><p>下图可以直观的看出三者之间的区别:<br><img src="2.png" alt="img">其中蓝色代表js脚本网络加载时间，红色代表js脚本执行时间，绿色代表html解析。</p><p><strong>defer 和 async属性都是去异步加载外部的JS脚本文件，它们都不会阻塞页面的解析</strong>，其区别如下：</p><ul><li><strong>执行顺序：</strong> 多个带async属性的标签，不能保证加载的顺序；多个带defer属性的标签，按照加载顺序执行；</li><li><strong>脚本是否并行执行：</strong>async属性，表示<strong>后续文档的加载和执行与js脚本的加载和执行是并行进行的</strong>，即异步执行；defer属性，加载后续文档的过程和js脚本的加载(此时仅加载不执行)是并行进行的(异步)，js脚本需要等到文档所有元素解析完成之后才执行，DOMContentLoaded事件触发执行之前。</li></ul><h3 id="5-常⽤的meta标签有哪些"><a href="#5-常⽤的meta标签有哪些" class="headerlink" title="5. 常⽤的meta标签有哪些"></a>5. 常⽤的meta标签有哪些</h3><p><code>meta</code> 标签由 <code>name</code> 和 <code>content</code> 属性定义，<strong>用来描述网页文档的属性</strong>，比如网页的作者，网页描述，关键词等，除了HTTP标准固定了一些<code>name</code>作为大家使用的共识，开发者还可以自定义name。</p><p>常用的meta标签：<br>（1）<code>charset</code>，用来描述HTML文档的编码类型：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span> &gt;</span><br></code></pre></td></tr></table></figure><p>（2） <code>keywords</code>，页面关键词：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;keywords&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;关键词&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure><p>（3）<code>description</code>，页面描述：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;description&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;页面描述内容&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure><p>（4）<code>refresh</code>，页面重定向和刷新：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;refresh&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;0;url=&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure><p>（5）<code>viewport</code>，适配移动端，可以控制视口的大小和比例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1, maximum-scale=1&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><p>其中，<code>content</code> 参数有以下几种：</p><ul><li><code>width viewport</code> ：宽度(数值&#x2F;device-width)</li><li><code>height viewport</code> ：高度(数值&#x2F;device-height)</li><li><code>initial-scale</code> ：初始缩放比例</li><li><code>maximum-scale</code> ：最大缩放比例</li><li><code>minimum-scale</code> ：最小缩放比例</li><li><code>user-scalable</code> ：是否允许用户缩放(yes&#x2F;no）</li></ul><p>（6）搜索引擎索引方式：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;robots&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;index,follow&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure><p>其中，<code>content</code> 参数有以下几种：</p><ul><li><code>all</code>：文件将被检索，且页面上的链接可以被查询；</li><li><code>none</code>：文件将不被检索，且页面上的链接不可以被查询；</li><li><code>index</code>：文件将被检索；</li><li><code>follow</code>：页面上的链接可以被查询；</li><li><code>noindex</code>：文件将不被检索；</li><li><code>nofollow</code>：页面上的链接不可以被查询。</li></ul><h3 id="6-HTML5有哪些更新"><a href="#6-HTML5有哪些更新" class="headerlink" title="6. HTML5有哪些更新"></a>6. HTML5有哪些更新</h3><h4 id="1-语义化标签"><a href="#1-语义化标签" class="headerlink" title="1. 语义化标签"></a>1. 语义化标签</h4><ul><li>header：定义文档的页眉（头部）；</li><li>nav：定义导航链接的部分；</li><li>footer：定义文档或节的页脚（底部）；</li><li>article：定义文章内容；</li><li>section：定义文档中的节（section、区段）；</li><li>aside：定义其所处内容之外的内容（侧边）；</li></ul><h4 id="2-媒体标签"><a href="#2-媒体标签" class="headerlink" title="2. 媒体标签"></a>2. 媒体标签</h4><p>（1） audio：音频</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">audio</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&#x27;&#x27;</span> <span class="hljs-attr">controls</span> <span class="hljs-attr">autoplay</span> <span class="hljs-attr">loop</span>=<span class="hljs-string">&#x27;true&#x27;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">audio</span>&gt;</span><br></code></pre></td></tr></table></figure><p>属性：</p><ul><li>controls 控制面板</li><li>autoplay 自动播放</li><li>loop&#x3D;‘true’ 循环播放</li></ul><p>（2）video视频</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">video</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&#x27;&#x27;</span> <span class="hljs-attr">poster</span>=<span class="hljs-string">&#x27;imgs/aa.jpg&#x27;</span> <span class="hljs-attr">controls</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">video</span>&gt;</span><br></code></pre></td></tr></table></figure><p>属性：</p><ul><li>poster：指定视频还没有完全下载完毕，或者用户还没有点击播放前显示的封面。默认显示当前视频文件的第一针画面，当然通过poster也可以自己指定。</li><li>controls 控制面板</li><li>width</li><li>height</li></ul><p>（3）source标签<br>因为浏览器对视频格式支持程度不一样，为了能够兼容不同的浏览器，可以通过source来指定视频源。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">video</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">source</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&#x27;aa.flv&#x27;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&#x27;video/flv&#x27;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">source</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">source</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&#x27;aa.mp4&#x27;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&#x27;video/mp4&#x27;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">source</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">video</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="3-表单"><a href="#3-表单" class="headerlink" title="3. 表单"></a>3. 表单</h4><p><strong>表单类型：</strong></p><ul><li>email ：能够验证当前输入的邮箱地址是否合法</li><li>url ： 验证URL</li><li>number ： 只能输入数字，其他输入不了，而且自带上下增大减小箭头，max属性可以设置为最大值，min可以设置为最小值，value为默认值。</li><li>search ： 输入框后面会给提供一个小叉，可以删除输入的内容，更加人性化。</li><li>range ： 可以提供给一个范围，其中可以设置max和min以及value，其中value属性可以设置为默认值</li><li>color ： 提供了一个颜色拾取器</li><li>time ： 时分秒</li><li>data ： 日期选择年月日</li><li>datatime ： 时间和日期(目前只有Safari支持)</li><li>datatime-local ：日期时间控件</li><li>week ：周控件</li><li>month：月控件</li></ul><p><strong>表单属性：</strong></p><ul><li>placeholder ：提示信息</li><li>autofocus ：自动获取焦点</li><li>autocomplete&#x3D;“on” 或者 autocomplete&#x3D;“off” 使用这个属性需要有两个前提：<ul><li>表单必须提交过</li><li>必须有name属性。</li></ul></li><li>required：要求输入框不能为空，必须有值才能够提交。</li><li>pattern&#x3D;” “ 里面写入想要的正则模式，例如手机号patte&#x3D;”^(+86)?\d{10}$”</li><li>multiple：可以选择多个文件或者多个邮箱</li><li>form&#x3D;” form表单的ID”</li></ul><p><strong>表单事件：</strong></p><ul><li>oninput 每当input里的输入框内容发生变化都会触发此事件。</li><li>oninvalid 当验证不通过时触发此事件。</li></ul><h4 id="4-进度条、度量器"><a href="#4-进度条、度量器" class="headerlink" title="4. 进度条、度量器"></a>4. 进度条、度量器</h4><ul><li>progress标签：用来表示任务的进度（IE、Safari不支持），max用来表示任务的进度，value表示已完成多少</li><li>meter属性：用来显示剩余容量或剩余库存（IE、Safari不支持）<ul><li>high&#x2F;low：规定被视作高&#x2F;低的范围</li><li>max&#x2F;min：规定最大&#x2F;小值</li><li>value：规定当前度量值</li></ul></li></ul><p>设置规则：min &lt; low &lt; high &lt; max</p><h4 id="5-DOM查询操作"><a href="#5-DOM查询操作" class="headerlink" title="5.DOM查询操作"></a>5.DOM查询操作</h4><ul><li>document.querySelector()</li><li>document.querySelectorAll()</li></ul><p>它们选择的对象可以是标签，可以是类(需要加点)，可以是ID(需要加#)</p><h4 id="6-Web存储"><a href="#6-Web存储" class="headerlink" title="6. Web存储"></a>6. Web存储</h4><p>HTML5 提供了两种在客户端存储数据的新方法：</p><ul><li>localStorage - 没有时间限制的数据存储</li><li>sessionStorage - 针对一个 session 的数据存储</li></ul><h4 id="7-其他"><a href="#7-其他" class="headerlink" title="7. 其他"></a>7. 其他</h4><ul><li>拖放：拖放是一种常见的特性，即抓取对象以后拖到另一个位置。设置元素可拖放：</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">draggable</span>=<span class="hljs-string">&quot;true&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure><ul><li>画布（canvas ）： canvas 元素使用 JavaScript 在网页上绘制图像。画布是一个矩形区域，可以控制其每一像素。canvas 拥有多种绘制路径、矩形、圆形、字符以及添加图像的方法。</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">canvas</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;myCanvas&quot;</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;200&quot;</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;100&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">canvas</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>SVG：SVG 指可伸缩矢量图形，用于定义用于网络的基于矢量的图形，使用 XML 格式定义图形，图像在放大或改变尺寸的情况下其图形质量不会有损失，它是万维网联盟的标准</li><li>地理定位：Geolocation（地理定位）用于定位用户的位置。‘</li></ul><p><strong>总结：</strong><br>（1）新增语义化标签：nav、header、footer、aside、section、article<br>（2）音频、视频标签：audio、video<br>（3）数据存储：localStorage、sessionStorage<br>（4）canvas（画布）、Geolocation（地理定位）、websocket（通信协议）<br>（5）input标签新增属性：placeholder、autocomplete、autofocus、required<br>（6）history API：go、forward、back、pushstate</p><p><strong>移除的元素有：</strong></p><ul><li>纯表现的元素：basefont，big，center，font, s，strike，tt，u;</li><li>对可用性产生负面影响的元素：frame，frameset，noframes；</li></ul><h3 id="7-img的srcset属性的作⽤？"><a href="#7-img的srcset属性的作⽤？" class="headerlink" title="7. img的srcset属性的作⽤？"></a>7. img的srcset属性的作⽤？</h3><p>响应式页面中经常用到根据屏幕密度设置不同的图片。这时就用到了 img 标签的srcset属性。srcset属性用于设置不同屏幕密度下，img 会自动加载不同的图片。用法如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;image-128.png&quot;</span> <span class="hljs-attr">srcset</span>=<span class="hljs-string">&quot;image-256.png 2x&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure><p>使用上面的代码，就能实现在屏幕密度为1x的情况下加载image-128.png, 屏幕密度为2x时加载image-256.png。</p><p>按照上面的实现，不同的屏幕密度都要设置图片地址，目前的屏幕密度有1x,2x,3x,4x四种，如果每一个图片都设置4张图片，加载就会很慢。所以就有了新的srcset标准。代码如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;image-128.png&quot;</span></span><br><span class="hljs-tag">     <span class="hljs-attr">srcset</span>=<span class="hljs-string">&quot;image-128.png 128w, image-256.png 256w, image-512.png 512w&quot;</span></span><br><span class="hljs-tag">     <span class="hljs-attr">sizes</span>=<span class="hljs-string">&quot;(max-width: 360px) 340px, 128px&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure><p>其中srcset指定图片的地址和对应的图片质量。sizes用来设置图片的尺寸零界点。对于 srcset 中的 w 单位，可以理解成图片质量。如果可视区域小于这个质量的值，就可以使用。浏览器会自动选择一个最小的可用图片。</p><p>sizes语法如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html">sizes=&quot;[media query] [length], [media query] [length] ... &quot;<br></code></pre></td></tr></table></figure><p>sizes就是指默认显示128px, 如果视区宽度大于360px, 则显示340px。</p><h3 id="8-行内元素有哪些？块级元素有哪些？-空-void-元素有那些？"><a href="#8-行内元素有哪些？块级元素有哪些？-空-void-元素有那些？" class="headerlink" title="8.  行内元素有哪些？块级元素有哪些？ 空(void)元素有那些？"></a>8.  行内元素有哪些？块级元素有哪些？ 空(void)元素有那些？</h3><ul><li>行内元素有：<code>a b span img input select strong</code>；</li><li>块级元素有：<code>div ul ol li dl dt dd h1 h2 h3 h4 h5 h6 p</code>；</li></ul><p>空元素，即没有内容的HTML元素。空元素是在开始标签中关闭的，也就是空元素没有闭合标签：</p><ul><li>常见的有：<code>&lt;br&gt;</code>、<code>&lt;hr&gt;</code>、<code>&lt;img&gt;</code>、<code>&lt;input&gt;</code>、<code>&lt;link&gt;</code>、<code>&lt;meta&gt;</code>；</li><li>鲜见的有：<code>&lt;area&gt;</code>、<code>&lt;base&gt;</code>、<code>&lt;col&gt;</code>、<code>&lt;colgroup&gt;</code>、<code>&lt;command&gt;</code>、<code>&lt;embed&gt;</code>、<code>&lt;keygen&gt;</code>、<code>&lt;param&gt;</code>、<code>&lt;source&gt;</code>、<code>&lt;track&gt;</code>、<code>&lt;wbr&gt;</code>。</li></ul><h3 id="9-说一下-web-worker"><a href="#9-说一下-web-worker" class="headerlink" title="9. 说一下 web worker"></a>9. 说一下 web worker</h3><p>在 HTML 页面中，如果在执行脚本时，页面的状态是不可相应的，直到脚本执行完成后，页面才变成可相应。web worker 是运行在后台的 js，独立于其他脚本，不会影响页面的性能。 并且通过 postMessage 将结果回传到主线程。这样在进行复杂操作的时候，就不会阻塞主线程了。 </p><p>如何创建 web worker： </p><ol><li>检测浏览器对于 web worker 的支持性 </li><li>创建 web worker 文件（js，回传函数等） </li><li>创建 web worker 对象</li></ol><h3 id="10-HTML5的离线储存怎么使用，它的工作原理是什么"><a href="#10-HTML5的离线储存怎么使用，它的工作原理是什么" class="headerlink" title="10. HTML5的离线储存怎么使用，它的工作原理是什么"></a>10. HTML5的离线储存怎么使用，它的工作原理是什么</h3><p>离线存储指的是：在用户没有与因特网连接时，可以正常访问站点或应用，在用户与因特网连接时，更新用户机器上的缓存文件。</p><p><strong>原理：</strong>HTML5的离线存储是基于一个新建的 <code>.appcache</code> 文件的缓存机制(不是存储技术)，通过这个文件上的解析清单离线存储资源，这些资源就会像cookie一样被存储了下来。之后当网络在处于离线状态下时，浏览器会通过被离线存储的数据进行页面展示</p><p><strong>使用方法：</strong><br>（1）创建一个和 html 同名的 manifest 文件，然后在页面头部加入 manifest 属性：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span> <span class="hljs-attr">manifest</span>=<span class="hljs-string">&quot;index.manifest&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><p>（2）在 <code>cache.manifest</code> 文件中编写需要离线存储的资源：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs html">CACHE MANIFEST<br>    #v0.11<br>    CACHE:<br>    js/app.js<br>    css/style.css<br>    NETWORK:<br>    resourse/logo.png<br>    FALLBACK:<br>    / /offline.html<br></code></pre></td></tr></table></figure><ul><li><strong>CACHE</strong>: 表示需要离线存储的资源列表，由于包含 manifest 文件的页面将被自动离线存储，所以不需要把页面自身也列出来。</li><li><strong>NETWORK</strong>: 表示在它下面列出来的资源只有在在线的情况下才能访问，他们不会被离线存储，所以在离线情况下无法使用这些资源。不过，如果在 CACHE 和 NETWORK 中有一个相同的资源，那么这个资源还是会被离线存储，也就是说 CACHE 的优先级更高。</li><li><strong>FALLBACK</strong>: 表示如果访问第一个资源失败，那么就使用第二个资源来替换他，比如上面这个文件表示的就是如果访问根目录下任何一个资源失败了，那么就去访问 offline.html 。</li></ul><p>（3）在离线状态时，操作 <code>window.applicationCache</code> 进行离线缓存的操作。</p><p><strong>如何更新缓存：</strong></p><p>（1）更新 manifest 文件</p><p> （2）通过 javascript 操作</p><p> （3）清除浏览器缓存</p><p><strong>注意事项：</strong></p><p> （1）浏览器对缓存数据的容量限制可能不太一样（某些浏览器设置的限制是每个站点 5MB）。</p><p> （2）如果 manifest 文件，或者内部列举的某一个文件不能正常下载，整个更新过程都将失败，浏览器继续全部使用老的缓存。</p><p> （3）引用 manifest 的 html 必须与 manifest 文件同源，在同一个域下。</p><p> （4）FALLBACK 中的资源必须和 manifest 文件同源。</p><p> （5）当一个资源被缓存后，该浏览器直接请求这个绝对路径也会访问缓存中的资源。</p><p> （6）站点中的其他页面即使没有设置 manifest 属性，请求的资源如果在缓存中也从缓存中访问。</p><p>（7）当 manifest 文件发生改变时，资源请求本身也会触发更新。</p><h3 id="11-浏览器是如何对-HTML5-的离线储存资源进行管理和加载？"><a href="#11-浏览器是如何对-HTML5-的离线储存资源进行管理和加载？" class="headerlink" title="11. 浏览器是如何对 HTML5 的离线储存资源进行管理和加载？"></a>11. 浏览器是如何对 HTML5 的离线储存资源进行管理和加载？</h3><ul><li><strong>在线的情况下</strong>，浏览器发现 html 头部有 manifest 属性，它会请求 manifest 文件，如果是第一次访问页面 ，那么浏览器就会根据 manifest 文件的内容下载相应的资源并且进行离线存储。如果已经访问过页面并且资源已经进行离线存储了，那么浏览器就会使用离线的资源加载页面，然后浏览器会对比新的 manifest 文件与旧的 manifest 文件，如果文件没有发生改变，就不做任何操作，如果文件改变了，就会重新下载文件中的资源并进行离线存储。</li><li><strong>离线的情况下</strong>，浏览器会直接使用离线存储的资源。</li></ul><h3 id="12-title与h1的区别、b与strong的区别、i与em的区别？"><a href="#12-title与h1的区别、b与strong的区别、i与em的区别？" class="headerlink" title="12. title与h1的区别、b与strong的区别、i与em的区别？"></a>12. title与h1的区别、b与strong的区别、i与em的区别？</h3><ul><li>strong标签有语义，是起到加重语气的效果，而b标签是没有的，b标签只是一个简单加粗标签。b标签之间的字符都设为粗体，strong标签加强字符的语气都是通过粗体来实现的，而搜索引擎更侧重strong标签。</li><li>title属性没有明确意义只表示是个标题，H1则表示层次明确的标题，对页面信息的抓取有很大的影响</li><li><strong>i内容展示为斜体，em表示强调的文本</strong></li></ul><h3 id="13-iframe-有那些优点和缺点？"><a href="#13-iframe-有那些优点和缺点？" class="headerlink" title="13. iframe 有那些优点和缺点？"></a>13. <strong>iframe 有那些优点和缺点？</strong></h3><p>iframe 元素会创建包含另外一个文档的内联框架（即行内框架）。</p><p><strong>优点：</strong></p><ul><li>用来加载速度较慢的内容（如广告）</li><li>可以使脚本可以并行下载</li><li>可以实现跨子域通信</li></ul><p><strong>缺点：</strong></p><ul><li>iframe 会阻塞主页面的 onload 事件</li><li>无法被一些搜索引擎索识别</li><li>会产生很多页面，不容易管理</li></ul><h3 id="14-label-的作用是什么？如何使用？"><a href="#14-label-的作用是什么？如何使用？" class="headerlink" title="14. label 的作用是什么？如何使用？"></a>14. label 的作用是什么？如何使用？</h3><p>label标签来定义表单控件的关系：当用户选择label标签时，浏览器会自动将焦点转到和label标签相关的表单控件上。</p><ul><li>使用方法1：</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;mobile&quot;</span>&gt;</span>Number:<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;mobile&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><ul><li>使用方法2：</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span>Date:<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="15-Canvas和SVG的区别"><a href="#15-Canvas和SVG的区别" class="headerlink" title="15. Canvas和SVG的区别"></a>15. Canvas和SVG的区别</h3><p><strong>（1）SVG：</strong><br>SVG可缩放矢量图形（Scalable Vector Graphics）是基于可扩展标记语言XML描述的2D图形的语言，SVG基于XML就意味着SVG DOM中的每个元素都是可用的，可以为某个元素附加Javascript事件处理器。在 SVG 中，每个被绘制的图形均被视为对象。如果 SVG 对象的属性发生变化，那么浏览器能够自动重现图形。</p><p>其特点如下：</p><ul><li>不依赖分辨率</li><li>支持事件处理器</li><li>最适合带有大型渲染区域的应用程序（比如谷歌地图）</li><li>复杂度高会减慢渲染速度（任何过度使用 DOM 的应用都不快）</li><li>不适合游戏应用</li></ul><p><strong>（2）Canvas：</strong><br>Canvas是画布，通过Javascript来绘制2D图形，是逐像素进行渲染的。其位置发生改变，就会重新进行绘制。</p><p>其特点如下：</p><ul><li>依赖分辨率</li><li>不支持事件处理器</li><li>弱的文本渲染能力</li><li>能够以 .png 或 .jpg 格式保存结果图像</li><li>最适合图像密集型的游戏，其中的许多对象会被频繁重绘</li></ul><p>注：矢量图，也称为面向对象的图像或绘图图像，在数学上定义为一系列由线连接的点。矢量文件中的图形元素称为对象。每个对象都是一个自成一体的实体，它具有颜色、形状、轮廓、大小和屏幕位置等属性。</p><h3 id="16-head-标签有什么作用，其中什么标签必不可少？"><a href="#16-head-标签有什么作用，其中什么标签必不可少？" class="headerlink" title="16. head 标签有什么作用，其中什么标签必不可少？"></a>16. head 标签有什么作用，其中什么标签必不可少？</h3><head> 标签用于定义文档的头部，它是所有头部元素的容器。<head> 中的元素可以引用脚本、指示浏览器在哪里找到样式表、提供元信息等。<p>文档的头部描述了文档的各种属性和信息，包括文档的标题、在 Web 中的位置以及和其他文档的关系等。绝大多数文档头部包含的数据都不会真正作为内容显示给读者。</p><p>下面这些标签可用在 head 部分：<code>&lt;base&gt;, &lt;link&gt;, &lt;meta&gt;, &lt;script&gt;, &lt;style&gt;, &lt;title&gt;</code>。 </p><p>其中 <code>&lt;title&gt;</code> 定义文档的标题，它是 head 部分中唯一必需的元素。</p><h3 id="17-文档声明（Doctype）和-lt-Doctype-html-gt-有何作用-严格模式与混杂模式如何区分？它们有何意义"><a href="#17-文档声明（Doctype）和-lt-Doctype-html-gt-有何作用-严格模式与混杂模式如何区分？它们有何意义" class="headerlink" title="17. 文档声明（Doctype）和&lt;!Doctype html&gt;有何作用? 严格模式与混杂模式如何区分？它们有何意义?"></a>17. 文档声明（Doctype）和<code>&lt;!Doctype html&gt;</code>有何作用? 严格模式与混杂模式如何区分？它们有何意义?</h3><p><strong>文档声明的作用：</strong> 文档声明是为了告诉浏览器，当前<code>HTML</code>文档使用什么版本的<code>HTML</code>来写的，这样浏览器才能按照声明的版本来正确的解析。</p><p><strong><!Doctype html>的作用：</strong><code>&lt;!doctype html&gt;</code> 的作用就是让浏览器进入标准模式，使用最新的 <code>HTML5</code> 标准来解析渲染页面；如果不写，浏览器就会进入混杂模式，我们需要避免此类情况发生。</p><p><strong>严格模式与混杂模式的区分：</strong></p><ul><li><strong>严格模式</strong>： 又称为标准模式，指浏览器按照<code>W3C</code>标准解析代码；</li><li><strong>混杂模式</strong>： 又称怪异模式、兼容模式，是指浏览器用自己的方式解析代码。混杂模式通常模拟老式浏览器的行为，以防止老站点无法工作；</li></ul><p><strong>区分</strong>：网页中的<code>DTD</code>，直接影响到使用的是严格模式还是浏览模式，可以说<code>DTD</code>的使用与这两种方式的区别息息相关。</p><ul><li>如果文档包含严格的<code>DOCTYPE</code> ，那么它一般以严格模式呈现（<strong>严格 DTD ——严格模式</strong>）；</li><li>包含过渡 <code>DTD</code> 和 <code>URI</code> 的 <code>DOCTYPE</code> ，也以严格模式呈现，但有过渡 <code>DTD</code> 而没有 <code>URI</code> （统一资源标识符，就是声明最后的地址）会导致页面以混杂模式呈现（<strong>有 URI 的过渡 DTD ——严格模式；没有 URI 的过渡 DTD ——混杂模式</strong>）；</li><li><code>DOCTYPE</code> 不存在或形式不正确会导致文档以混杂模式呈现（<strong>DTD不存在或者格式不正确——混杂模式</strong>）；</li><li><code>HTML5</code> 没有 <code>DTD</code> ，因此也就没有严格模式与混杂模式的区别，<code>HTML5</code> 有相对宽松的 法，实现时，已经尽可能大的实现了向后兼容(<strong>HTML5 没有严格和混杂之分</strong>)。</li></ul><p>总之，<strong>严格模式让各个浏览器统一执行一套规范兼容模式保证了旧网站的正常运行。</strong></p><h3 id="18-浏览器乱码的原因是什么？如何解决？"><a href="#18-浏览器乱码的原因是什么？如何解决？" class="headerlink" title="18. 浏览器乱码的原因是什么？如何解决？"></a>18. 浏览器乱码的原因是什么？如何解决？</h3><p><strong>产生乱码的原因：</strong></p><ul><li>网页源代码是<code>gbk</code>的编码，而内容中的中文字是<code>utf-8</code>编码的，这样浏览器打开即会出现<code>html</code>乱码，反之也会出现乱码；</li><li><code>html</code>网页编码是<code>gbk</code>，而程序从数据库中调出呈现是<code>utf-8</code>编码的内容也会造成编码乱码；</li><li>浏览器不能自动检测网页编码，造成网页乱码。</li></ul><p><strong>解决办法：</strong></p><ul><li>使用软件编辑HTML网页内容；</li><li>如果网页设置编码是<code>gbk</code>，而数据库储存数据编码格式是<code>UTF-8</code>，此时需要程序查询数据库数据显示数据前进程序转码；</li><li>如果浏览器浏览时候出现网页乱码，在浏览器中找到转换编码的菜单进行转换。</li></ul><h3 id="19-渐进增强和优雅降级之间的区别"><a href="#19-渐进增强和优雅降级之间的区别" class="headerlink" title="19. 渐进增强和优雅降级之间的区别"></a>19. 渐进增强和优雅降级之间的区别</h3><p><strong>（1）渐进增强（progressive enhancement）</strong>：主要是针对低版本的浏览器进行页面重构，保证基本的功能情况下，再针对高级浏览器进行效果、交互等方面的改进和追加功能，以达到更好的用户体验。<br><strong>（2）优雅降级 graceful degradation</strong>： 一开始就构建完整的功能，然后再针对低版本的浏览器进行兼容。</p><p><strong>两者区别：</strong></p><ul><li>优雅降级是从复杂的现状开始的，并试图减少用户体验的供给；而渐进增强是从一个非常基础的，能够起作用的版本开始的，并在此基础上不断扩充，以适应未来环境的需要；</li><li>降级（功能衰竭）意味着往回看，而渐进增强则意味着往前看，同时保证其根基处于安全地带。</li></ul><p>“优雅降级”观点认为应该针对那些最高级、最完善的浏览器来设计网站。而将那些被认为“过时”或有功能缺失的浏览器下的测试工作安排在开发周期的最后阶段，并把测试对象限定为主流浏览器（如 IE、Mozilla 等）的前一个版本。 在这种设计范例下，旧版的浏览器被认为仅能提供“简陋却无妨 (poor, but passable)” 的浏览体验。可以做一些小的调整来适应某个特定的浏览器。但由于它们并非我们所关注的焦点，因此除了修复较大的错误之外，其它的差异将被直接忽略。 </p><p>“渐进增强”观点则认为应关注于内容本身。内容是建立网站的诱因，有的网站展示它，有的则收集它，有的寻求，有的操作，还有的网站甚至会包含以上的种种，但相同点是它们全都涉及到内容。这使得“渐进增强”成为一种更为合理的设计范例。这也是它立即被 Yahoo 所采纳并用以构建其“分级式浏览器支持 (Graded Browser Support)”策略的原因所在。 </p><h3 id="20-说一下-HTML5-drag-API"><a href="#20-说一下-HTML5-drag-API" class="headerlink" title="20. 说一下 HTML5 drag API"></a>20. 说一下 HTML5 drag API</h3><ul><li>dragstart：事件主体是被拖放元素，在开始拖放被拖放元素时触发。 </li><li>darg：事件主体是被拖放元素，在正在拖放被拖放元素时触发。 </li><li>dragenter：事件主体是目标元素，在被拖放元素进入某元素时触发。 </li><li>dragover：事件主体是目标元素，在被拖放在某元素内移动时触发。 </li><li>dragleave：事件主体是目标元素，在被拖放元素移出目标元素是触发。 </li><li>drop：事件主体是目标元素，在目标元素完全接受被拖放元素时触发。 </li><li>dragend：事件主体是被拖放元素，在整个拖放操作结束时触发。</li></ul>]]></content>
    
    
    <categories>
      
      <category>BGW</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>flex弹性布局</title>
    <link href="/2023/04/17/flex%E5%BC%B9%E6%80%A7%E5%B8%83%E5%B1%80/"/>
    <url>/2023/04/17/flex%E5%BC%B9%E6%80%A7%E5%B8%83%E5%B1%80/</url>
    
    <content type="html"><![CDATA[<p><img src="image-20230417104014425.png" alt="image-20230417104014425"></p>]]></content>
    
    
    <categories>
      
      <category>css</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>懒加载</title>
    <link href="/2023/04/17/%E6%87%92%E5%8A%A0%E8%BD%BD/"/>
    <url>/2023/04/17/%E6%87%92%E5%8A%A0%E8%BD%BD/</url>
    
    <content type="html"><![CDATA[<h2>懒加载判断是否触底</h2><p><img src="%E6%87%92%E5%8A%A0%E8%BD%BD%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E8%A7%A6%E5%BA%95.png" alt="懒加载判断是否触底"></p><p><font color="red">所有元素高度和  &#x3D;？ 可视窗口高度 + 页面滚动距离 </font></p>]]></content>
    
    
    <categories>
      
      <category>javascript</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>函数防抖</title>
    <link href="/2023/04/17/%E5%87%BD%E6%95%B0%E9%98%B2%E6%8A%96/"/>
    <url>/2023/04/17/%E5%87%BD%E6%95%B0%E9%98%B2%E6%8A%96/</url>
    
    <content type="html"><![CDATA[<p>函数防抖 debounce</p><p>JavaScript 中的函数大多数情况下都是由用户主动调用触发的，比如说点击、拖拽、改变浏览器尺寸、提交表单等。除非是函数本身的实现不合理，否则一般不会遇到跟性能相关的问题。</p><p>但是在一些少数情况下，函数的触发不是由用户直接控制的。在这些场景下，函数有可能被非常频繁地调用，而造成性能问题：</p><p> 例如：</p><p>mousemove 事件。如果要实现一个拖拽功能，需要一路监听 mousemove 事件，在回调中获取元素当前位置来进行样式改变。如果不加以控制，每移动一定像素而触发的回调数量非常惊人，回调中又伴随着 DOM 操作，继而引发浏览器的重排与重绘，性能差的浏览器可能就会直接假死。</p><p>window.onresize 事件。为 window 对象绑定了 resize 事件，当浏览器窗口大小被拖动而改变尺寸的时候，这个事件就会一直被触发。如果在 window.onresize 事件函数里又有一些跟 DOM 节点相关的操作，浏览器可能就会吃不消而造成卡顿现象。 </p><p>射击游戏的 mousedown&#x2F;keydown 事件（单位时间只能发射一颗子弹）不能因为连续点击或快速按键连续发射多颗子弹。 </p><p>搜索联想（keyup事件） </p><p>监听滚动（scroll事件）</p><p>解决这些情况的方案就可以使用函数防抖（debounce），其核心就是**<font color="#dd0000">限制某一个方法的频繁触发。防止函数在极短的时间内反复调用，造成资源的浪费</font>**。</p>]]></content>
    
    
    <categories>
      
      <category>javascript</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>spark-md5生成文件hash值</title>
    <link href="/2023/04/08/spark-md5%E7%94%9F%E6%88%90%E6%96%87%E4%BB%B6hash%E5%80%BC/"/>
    <url>/2023/04/08/spark-md5%E7%94%9F%E6%88%90%E6%96%87%E4%BB%B6hash%E5%80%BC/</url>
    
    <content type="html"><![CDATA[<p>1.安装spark-md5插件</p><figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs q">npm install spark-<span class="hljs-built_in">md5</span> --<span class="hljs-built_in">save</span><br></code></pre></td></tr></table></figure><p>2.引入</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">SparkMD5</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;spark-md5&quot;</span><br></code></pre></td></tr></table></figure><p>3.定义方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">getFileMd5</span> = (<span class="hljs-params">file</span>) =&gt; &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">let</span> blobSlice =<br>            <span class="hljs-title class_">File</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">slice</span> ||<br>            <span class="hljs-title class_">File</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">mozSlice</span> ||<br>            <span class="hljs-title class_">File</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">webkitSlice</span>,<br>          chunkSize = <span class="hljs-number">2097152</span>, <span class="hljs-comment">// 每次读取2MB</span><br>          chunks = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">ceil</span>(file.<span class="hljs-property">size</span> / chunkSize),<br>          currentChunk = <span class="hljs-number">0</span>,<br>          spark = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SparkMD5</span>.<span class="hljs-title class_">ArrayBuffer</span>(),<br>          fileReader = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>();<br>        fileReader.<span class="hljs-property">onload</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) &#123;<br>          spark.<span class="hljs-title function_">append</span>(e.<span class="hljs-property">target</span>.<span class="hljs-property">result</span>);<br>          currentChunk++;<br>          <span class="hljs-keyword">if</span> (currentChunk &lt; chunks) &#123;<br>            <span class="hljs-title function_">loadNext</span>();<br>          &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">let</span> md5 = spark.<span class="hljs-title function_">end</span>();<br>            <span class="hljs-title function_">resolve</span>(md5);<br>          &#125;<br>        &#125;;<br>        fileReader.<span class="hljs-property">onerror</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) &#123;<br>          <span class="hljs-title function_">reject</span>(e);<br>        &#125;;<br>        <span class="hljs-keyword">function</span> <span class="hljs-title function_">loadNext</span>(<span class="hljs-params"></span>) &#123;<br>          <span class="hljs-keyword">let</span> start = currentChunk * chunkSize,<br>            end =<br>              start + chunkSize &gt;= file.<span class="hljs-property">size</span> ? file.<span class="hljs-property">size</span> : start + chunkSize;<br>          fileReader.<span class="hljs-title function_">readAsArrayBuffer</span>(blobSlice.<span class="hljs-title function_">call</span>(file, start, end));<br>        &#125;<br>        <span class="hljs-title function_">loadNext</span>();<br>      &#125;);<br>    &#125;;<br></code></pre></td></tr></table></figure><p>4.需要的地方调用</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>管理员后台管理系统<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;file&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;file&quot;</span> @<span class="hljs-attr">change</span>=<span class="hljs-string">&quot;fileChange&quot;</span> <span class="hljs-attr">multiple</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;submit&quot;</span>&gt;</span>上传<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">fileChange</span> = (<span class="hljs-params">e</span>) =&gt; &#123;<br>      <span class="hljs-comment">//   console.log(e.target.files[0]); </span><br>      <span class="hljs-keyword">let</span> file = e.<span class="hljs-property">target</span>.<span class="hljs-property">files</span>[<span class="hljs-number">0</span>]; <span class="hljs-comment">//获取文件</span><br>      <span class="hljs-title function_">getFileMd5</span>(file) <span class="hljs-comment">//调用方法</span><br>        .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;<br>          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;该文件md5为 &quot;</span>, res);<br>          &#125;;<br>        &#125;)<br>        .<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;<br>          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err);<br>        &#125;);<br>    &#125;;<br></code></pre></td></tr></table></figure><p>其余后续补充！！！</p>]]></content>
    
    
    <categories>
      
      <category>javascript</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>blob对象实现文件下载</title>
    <link href="/2023/04/08/blob%E5%AF%B9%E8%B1%A1%E5%AE%9E%E7%8E%B0%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD/"/>
    <url>/2023/04/08/blob%E5%AF%B9%E8%B1%A1%E5%AE%9E%E7%8E%B0%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD/</url>
    
    <content type="html"><![CDATA[<p>1.blob相关（详细见<a href="https://www.cnblogs.com/weichen913/p/16775484.html%EF%BC%89">https://www.cnblogs.com/weichen913/p/16775484.html）</a></p><p>（1）blob是什么</p><p>Blob（Binary Large Object）表示二进制类型的大对象。blob是构造函数，语法如下：let blobObj &#x3D; new Blob(blobParts,options);</p><p>（2）blob类的属性和方法</p><p>（3）<strong>blob使用场景</strong></p><p>分片上传 、Blob用作URL 、文件下载、图片压缩、</p><p><strong>2.常用文件下载的方式</strong></p><p>利用 a 链接直接来下载当前页面的本服务器的图片</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">download</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&#x27;./img/1.jpg&#x27;</span>&gt;</span>下载<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br></code></pre></td></tr></table></figure><p>点击“下载”按钮以后浏览器便会自动开始下载文件</p><p><strong>但是</strong>如果不是同一服务器的文件，浏览器只会打开预览可预览的文件（图片、pdf等），并不会下载。如 </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">download</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&#x27;https://gimg3.baidu.com/search/src=http%3A%2F%2Fpics4.baidu.com%2Ffeed%2F72f082025aafa40ffe336b651b9eff447af01993.jpeg%40f_auto%3Ftoken%3D3b1663b7bf2da680e95eeaf88ee6436c&amp;refer=http%3A%2F%2Fwww.baidu.com&amp;app=2021&amp;size=f360,240&amp;n=0&amp;g=0n&amp;q=75&amp;fmt=auto?sec=1681059600&amp;t=7eb2ce8efdaf0adf46a272ca2432230e&#x27;</span>&gt;</span>下载<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>非同域名下的文件保存下载的方法</strong></p><p>先通过js将文件的数据获取下来，然后通过a标签的方式保存</p><p><em>流程：发送请求获取到响应数据 &#x3D;》 将响应数据生成一个blob对象 &#x3D;》 URL.createObjectURL添加一个blob的映射 &#x3D;》利用a标签，href地址为映射地址</em></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">downloadFile</span> = (<span class="hljs-params">id</span>) =&gt; &#123;<br>      <span class="hljs-keyword">let</span> downloadinfo = &#123;<br>        <span class="hljs-attr">id</span>: id,<br>      &#125;;<br>      <span class="hljs-title function_">axios</span>(&#123;<br>        <span class="hljs-attr">method</span>: <span class="hljs-string">&quot;POST&quot;</span>,<br>        <span class="hljs-attr">url</span>: <span class="hljs-string">&quot;/pdf&quot;</span>,<br>        <span class="hljs-attr">headers</span>: &#123; <span class="hljs-string">&quot;content-type&quot;</span>: <span class="hljs-string">&quot;application/x-www-form-urlencoded&quot;</span> &#125;,<br>        <span class="hljs-attr">data</span>: downloadinfo,<br>        <span class="hljs-attr">responseType</span>: <span class="hljs-string">&quot;blob&quot;</span>,  <span class="hljs-comment">//响应类型数据为blob</span><br>      &#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">const</span> content = res.<span class="hljs-property">data</span>;  <span class="hljs-comment">//后端返回的类型为blob的数据</span><br>        <span class="hljs-keyword">const</span> blob = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Blob</span>([content]); <span class="hljs-comment">//生成一个blob对象，注意Blob中间必须为数组</span><br>        <span class="hljs-keyword">const</span> fileName = resultlist.<span class="hljs-property">fileName</span> + <span class="hljs-string">&quot;.pdf&quot;</span>;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;download&quot;</span> <span class="hljs-keyword">in</span> <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&quot;a&quot;</span>)) &#123;<br>          <span class="hljs-comment">// 非IE下载</span><br>          <span class="hljs-keyword">const</span> elink = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&quot;a&quot;</span>);  <span class="hljs-comment">//通过a标签的方式来下载</span><br>          elink.<span class="hljs-property">download</span> = fileName;<br>          elink.<span class="hljs-property">style</span>.<span class="hljs-property">display</span> = <span class="hljs-string">&quot;none&quot;</span>;<br>          elink.<span class="hljs-property">href</span> = <span class="hljs-variable constant_">URL</span>.<span class="hljs-title function_">createObjectURL</span>(blob); <span class="hljs-comment">//添加一个blob的映射，blob在内存中</span><br>          <span class="hljs-comment">//console.log(elink.href)  //此时域名已经和本地一样 </span><br>          <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">appendChild</span>(elink);<br>          elink.<span class="hljs-title function_">click</span>(); <span class="hljs-comment">//自动下载</span><br>          <span class="hljs-variable constant_">URL</span>.<span class="hljs-title function_">revokeObjectURL</span>(elink.<span class="hljs-property">href</span>); <span class="hljs-comment">// 释放URL 对象</span><br>          <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">removeChild</span>(elink);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          <span class="hljs-comment">// IE10+下载</span><br>          navigator.<span class="hljs-title function_">msSaveBlob</span>(blob, fileName);<br>        &#125;<br>      &#125;);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>javascript</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>跳转404页面</title>
    <link href="/2023/03/23/vue%E8%B7%B3%E8%BD%AC404%E9%A1%B5%E9%9D%A2/"/>
    <url>/2023/03/23/vue%E8%B7%B3%E8%BD%AC404%E9%A1%B5%E9%9D%A2/</url>
    
    <content type="html"><![CDATA[<h3 id="vue中页面未找到跳转至404页面的方法"><a href="#vue中页面未找到跳转至404页面的方法" class="headerlink" title="vue中页面未找到跳转至404页面的方法"></a>vue中页面未找到跳转至404页面的方法</h3><h4 id="1-使用vuerouter钩子函数beforeEach，每次进行路由跳转时都进行判断，若页面不存在就跳转到404页面。"><a href="#1-使用vuerouter钩子函数beforeEach，每次进行路由跳转时都进行判断，若页面不存在就跳转到404页面。" class="headerlink" title="1.使用vuerouter钩子函数beforeEach，每次进行路由跳转时都进行判断，若页面不存在就跳转到404页面。"></a>1.使用vuerouter钩子函数beforeEach，每次进行路由跳转时都进行判断，若页面不存在就跳转到404页面。</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Error</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27; &#x27;</span>  <br><span class="hljs-keyword">const</span> router = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Router</span>(&#123;<br>    <span class="hljs-attr">routes</span>:[<br>        <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;error&#x27;</span>,<br>        <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/error&#x27;</span>,<br>        <span class="hljs-attr">component</span>: <span class="hljs-title class_">Error</span><br>    ]<br>&#125;<br>  <br><span class="hljs-comment">//beforeEach每次进行路由跳转时都会执行</span><br>router.<span class="hljs-title function_">beforeEach</span>((to,<span class="hljs-keyword">from</span>,next)&#123;<br>    <span class="hljs-keyword">if</span>(to.<span class="hljs-property">matched</span>.<span class="hljs-property">length</span> === <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-keyword">from</span>.<span class="hljs-property">path</span> ? <span class="hljs-title function_">next</span>(&#123;<span class="hljs-attr">name</span>: <span class="hljs-keyword">from</span>.<span class="hljs-property">name</span>&#125;) : <span class="hljs-title function_">next</span>(<span class="hljs-string">&#x27;/error&#x27;</span>)<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-title function_">next</span>()<br>    &#125;<br>&#125;)<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> router<br></code></pre></td></tr></table></figure><h4 id="2-router路由redirect重定向"><a href="#2-router路由redirect重定向" class="headerlink" title="2.router路由redirect重定向"></a>2.router路由redirect重定向</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"> &#123;     <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/404&#x27;</span>,       <br>       <span class="hljs-attr">component</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;@/views/error-page/404&#x27;</span>),       <br>       <span class="hljs-attr">hidden</span>: <span class="hljs-literal">true</span>     <br>  &#125;, <br>     <br><span class="hljs-comment">//这个*匹配必须放在最后，将改路由配置放到所有路由的配置信息的最后，否则会其他路由path匹配造成影响。     </span><br> &#123;     <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;*&#x27;</span>,<br>       <span class="hljs-attr">redirect</span>: <span class="hljs-string">&#x27;/404&#x27;</span>, <br>       <span class="hljs-attr">hidden</span>: <span class="hljs-literal">true</span> <br>  &#125;<br><br>注意！！！vue3对<span class="hljs-number">404</span>配置进行了修改,必须要使用正则匹配，不能直接用*进行通配<br>&#123;<br>    path：<span class="hljs-string">&quot;/:pathMatch(.*)&quot;</span>,<br>        <span class="hljs-attr">redirect</span>:<span class="hljs-string">&#x27;/404&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>另外一种重定向方法，原理都是通过beforeEach判断跳转的路由，无设置的路由就跳转404</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">PageNotFound</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@/views/pages/404.vue&#x27;</span><br><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">use</span>(<span class="hljs-title class_">Router</span>)<br><span class="hljs-keyword">const</span> routes=[<br>  &#123;<br>    <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;*&#x27;</span>,<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;PageNotFound&#x27;</span>,<br>    <span class="hljs-attr">component</span>: <span class="hljs-title class_">PageNotFound</span>,<br>  &#125;,<br>] <br>  <br><span class="hljs-keyword">const</span> router = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Router</span>(&#123;<br>  <span class="hljs-attr">mode</span>: <span class="hljs-string">&#x27;history&#x27;</span>,<br>  <span class="hljs-attr">routes</span>: routes<br>&#125;)<br>  <br>router.<span class="hljs-title function_">beforeEach</span>(<span class="hljs-function">(<span class="hljs-params">to, <span class="hljs-keyword">from</span>, next</span>) =&gt;</span> &#123;<br>  <span class="hljs-comment">//  从其他地方访问是否有这个地址</span><br>    <span class="hljs-keyword">if</span>(to.<span class="hljs-property">matched</span>.<span class="hljs-property">length</span> == <span class="hljs-number">0</span>)&#123;<br>      <span class="hljs-keyword">from</span>.<span class="hljs-property">path</span> ? <span class="hljs-title function_">next</span>(&#123;<span class="hljs-attr">name</span>: <span class="hljs-keyword">from</span>.<span class="hljs-property">name</span>&#125;) : <span class="hljs-title function_">next</span>(<span class="hljs-string">&#x27;*&#x27;</span>)<br>    &#125;<br>    <span class="hljs-title function_">next</span>();<br>&#125;);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>vue</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>阿里iconfont使用方法</title>
    <link href="/2023/03/23/%E9%98%BF%E9%87%8Ciconfont%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/"/>
    <url>/2023/03/23/%E9%98%BF%E9%87%8Ciconfont%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="vue项目中iconfont的几种使用方法步骤"><a href="#vue项目中iconfont的几种使用方法步骤" class="headerlink" title="vue项目中iconfont的几种使用方法步骤"></a>vue项目中iconfont的几种使用方法步骤</h1><h3 id="1-symbol引入"><a href="#1-symbol引入" class="headerlink" title="1.symbol引入"></a>1.symbol引入</h3><ol><li><p>搜索需要的图表，添加至购物车，购物车中添加至项目</p></li><li><p>index.html文件中用script标签引入symbol在线链接</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;script src=<span class="hljs-string">&quot;http://at.alicdn.com/t/c/font_3928771_lvtnwdcesnq.js&quot;</span>&gt;&lt;/script&gt;<br></code></pre></td></tr></table></figure></li><li><p>全局样式中设置引入的图表样式</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.icon</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">1em</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">1em</span>;<br>  <span class="hljs-attribute">vertical-align</span>: -<span class="hljs-number">0.15em</span>;<br>  fill: currentColor;<br>  <span class="hljs-attribute">overflow</span>: hidden;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>页面中需要的地方引入对应的标签</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">svg</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;icon&quot;</span> <span class="hljs-attr">aria-hidden</span>=<span class="hljs-string">&quot;true&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">use</span> <span class="hljs-attr">xlink:href</span>=<span class="hljs-string">&quot;#icon-xxx&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">use</span>&gt;</span> <br><span class="hljs-tag">&lt;/<span class="hljs-name">svg</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ol><p>!!!注意：每次添加新的图表至项目文件夹以后，需要在index.html文件中更新最新的symbol链接</p><h3 id="2-单个图标图片格式引入"><a href="#2-单个图标图片格式引入" class="headerlink" title="2.单个图标图片格式引入"></a>2.单个图标图片格式引入</h3><p>直接搜索需要的图表，自行下载需要的格式（png、ai、svg），下载图标至本地项目文件夹中，页面中用img标签引入。</p>]]></content>
    
    
    <categories>
      
      <category>插件使用</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>git常用命令</title>
    <link href="/2023/03/22/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <url>/2023/03/22/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h1 id="git命令"><a href="#git命令" class="headerlink" title="git命令"></a>git命令</h1><p>本地操作</p><p>   1.<code>git init</code>初始化本地仓库</p><ol start="2"><li><p><code>git add .</code>添加到暂存区</p></li><li><p><code>git status</code> 查看git此时提交状态</p></li><li><p><code>git commit -m &#39;zhushi&#39;</code> 提交到本地仓库</p></li><li><p><code>git log</code> 查看提交记录</p></li><li><p><code>git reflog</code> 操作记录</p></li><li><p>回退版本</p><p><code>git reset --hard HEAD^</code> 回退到上一个版本</p><p><code>git reset --hard HEAD~2</code> 回退到上两个版本</p><p><code>git reset --hard 6位版本号</code> 回退到指定版本</p></li><li><p><code>git remote add origin http://gitee.com/****</code> 添加一个远程的源，仅第一次创建的时候需要此命令</p></li><li><p><code>git push </code>本地仓库同步到远程仓库</p><p>注意区分：</p><p><code>git push origin master</code>  推送本地master分支到远程（origin）master分支上</p><p><code>git push origin master:master</code>作用等同于上一句，冒号前后分别代表本地分支和远程分支</p><p><code>git push origin :master</code>意思是推送本地空分支到远程master上，即等同于删除远程master分支。等同于<code>git push origin --delete master</code></p><p>附：</p><p><code>git push -f</code>  f即force,强制推送，当版本不一致时，如果强制推送，本地分支会完全覆盖远程分支（慎用！！！）。正确做法是：先pull拉取远程分支，合并，再推送。</p><p><code>git push origin --tags</code> 添加标签</p></li><li><p><code>git pull origin master</code> 远程仓库拉取到本地仓库</p></li></ol><br><p>！！注意：</p><p><code>git push origin master 与 git push -u origin master</code> 的区别 ，即-u的含义</p><p><font color='yellow'>-u,即upstream,“上游”的意思，意思是指定本地分支与远程分支的关联关系，一旦设定以后，才能用git push等命令，反之，会报错</font>。</p><p>-u完整写法<code>git push --set-upstream origin master</code></p><p>！！！因此，在新建的初始化仓库中，首次推送要执行 <strong>git push -u origin master</strong>，非首次执行<strong>git push origin master</strong></p><br><p>常见情景：</p><p>本人项目云端仓库备份代码</p><ol><li><p><code>git init</code>初始化本地仓库</p></li><li><p><code>git add .</code>添加到暂存区</p></li><li><p><code>git remote add origin http://gitee.com/****</code> 添加一个远程的源，仅第一次创建的时候需要此命令</p></li><li><p><code>git commit -m  &quot;first commit&quot;</code>提交到本地仓库</p></li><li><p><code>git push -u origin master（首次-u）</code> 本地仓库push到远程仓库</p></li></ol><br><p>协作共同完成的项目</p><ol><li><p><code>git clone http://****</code></p></li><li><p>正常 add commit push pull，无需初始化（默认克隆的远程仓库）</p></li></ol><br><p>克隆别人的项目到本人远程仓库</p><ol><li><p><code>git clone http://****</code></p></li><li><p>本地进行修改</p></li><li><p>远程建立自己的仓库</p></li><li><p><code>git add .</code>添加到暂存区</p></li><li><p><code> git remote rm origin</code>删除本地仓库原有绑定的远程仓库</p></li><li><p><code>git remote add origin http://gitee.com/****</code> 添加一个远程的源，仅第一次创建的时候需要此命令</p></li><li><p><code>git push -u origin master（首次）</code> 本地仓库push到远程仓库</p></li></ol><p>​</p>]]></content>
    
    
    <categories>
      
      <category>git</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>js字符串常用方法</title>
    <link href="/2023/03/11/js%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/"/>
    <url>/2023/03/11/js%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p><strong>charAt</strong></p><ul><li><p><code>charAt(索引)</code>  是找到字符串中指定索引位置的内容返回</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> str = <span class="hljs-string">&#x27;Jack&#x27;</span><br><br><span class="hljs-comment">// 使用 charAt 找到字符串中的某一个内容</span><br><span class="hljs-keyword">var</span> index = str.<span class="hljs-title function_">charAt</span>(<span class="hljs-number">2</span>)<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(index) <span class="hljs-comment">// c</span><br></code></pre></td></tr></table></figure><ul><li>因为字符串也是按照索引进行排列的，也是同样从 0 开始</li><li>所以索引 2 的位置就是 <code>c</code></li></ul></li><li><p>如果没有对应的索引，那么就会返回 空字符串</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> str = <span class="hljs-string">&#x27;Jack&#x27;</span><br><br><span class="hljs-comment">// 使用 charAt 找到字符串中的某一个内容</span><br><span class="hljs-keyword">var</span> index = str.<span class="hljs-title function_">charAt</span>(<span class="hljs-number">10</span>)<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(index) <span class="hljs-comment">// &#x27;&#x27;</span><br></code></pre></td></tr></table></figure><ul><li>这个字符串根本没有索引 10 的位置</li><li>所以就会返回一个空字符串 <code>&#39;&#39;</code></li></ul></li></ul><p><strong>charCodeAt</strong></p><ul><li><p><code>charCodeAt(索引)</code> 就是返回对应索引位置的 <code>unicode</code> 编码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> str = <span class="hljs-string">&#x27;Jack&#x27;</span><br><br><span class="hljs-comment">// 使用 charAt 找到字符串中的某一个内容</span><br><span class="hljs-keyword">var</span> index = str.<span class="hljs-title function_">charCodeAt</span>(<span class="hljs-number">0</span>)<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(index) <span class="hljs-comment">// 74</span><br></code></pre></td></tr></table></figure><ul><li>因为 <code>J</code> 在 <code>unicode</code> 对照表里面存储的是 74，所以就会返回 74</li></ul></li></ul><p><strong>indexOf</strong></p><ul><li><p><code>indexOf</code> 就是按照字符找到对应的索引</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> str = <span class="hljs-string">&#x27;Jack&#x27;</span><br><br><span class="hljs-comment">// 使用 indexOf 找到对应的索引</span><br><span class="hljs-keyword">var</span> index = str.<span class="hljs-title function_">indexOf</span>(<span class="hljs-string">&#x27;J&#x27;</span>)<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(index) <span class="hljs-comment">// 0</span><br></code></pre></td></tr></table></figure><ul><li>因为字符 <code>J</code> 在字符串 <code>Jack</code> 中的索引位置是 0</li><li>所以会返回 0</li></ul></li></ul><p><strong>substring</strong></p><ul><li><p><code>substring</code> 是用来截取字符串使用的</p></li><li><p>语法： <code>substring(从哪个索引开始，到哪个索引截止)</code>，包含开始索引，不包含结束索引</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> str = <span class="hljs-string">&#x27;hello&#x27;</span><br><span class="hljs-comment">//         01234</span><br><br><span class="hljs-comment">// 使用 substring 截取字符串</span><br><span class="hljs-keyword">var</span> newStr = str.<span class="hljs-title function_">substring</span>(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>)<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(newStr) <span class="hljs-comment">// el</span><br></code></pre></td></tr></table></figure><ul><li>从索引 1 开始，到索引 3 截止，包含前面的索引不包含后面的索引</li><li>所以返回的是 el</li></ul></li></ul><p><strong>substr</strong></p><ul><li><p><code>substr</code> 也是用来截取字符串的</p></li><li><p>语法：<code>substr(从哪个索引开始，截取多少个)</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> str = <span class="hljs-string">&#x27;hello&#x27;</span><br><span class="hljs-comment">//         01234</span><br><br><span class="hljs-comment">// 使用 substr 截取字符串</span><br><span class="hljs-keyword">var</span> newStr = str.<span class="hljs-title function_">substr</span>(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>)<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(newStr) <span class="hljs-comment">// ell</span><br></code></pre></td></tr></table></figure><ul><li>这个方法和 <code>substring</code> 不一样的是，第二个参数是截取多少个</li><li>从索引 1 开始，截取 3 个，所以得到的是 <code>ell</code></li></ul></li></ul><p><strong>toLowerCase 和 toUpperCase</strong></p><ul><li><p>这两个方法分别使用用来给字符串转成 <strong>小写字母</strong> 和 <strong>大写字母</strong> 的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> str = hello<br><br><span class="hljs-comment">// 使用 toUpperCase 转换成大写</span><br><span class="hljs-keyword">var</span> upper = str.<span class="hljs-title function_">toUpperCase</span>()<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(upper) <span class="hljs-comment">// HELLO</span><br><br><span class="hljs-comment">// 使用 toLowerCase 转换成小写</span><br><span class="hljs-keyword">var</span> lower = upper.<span class="hljs-title function_">toLowerCase</span>()<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(lower) <span class="hljs-comment">// hello</span><br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>javascript</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>javascript笔记</title>
    <link href="/2023/03/11/javascript%E7%AC%94%E8%AE%B0/"/>
    <url>/2023/03/11/javascript%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p>[toc]</p><h3 id="JavaScript-（最全）基础-项目"><a href="#JavaScript-（最全）基础-项目" class="headerlink" title="JavaScript （最全）基础+项目"></a>JavaScript （最全）基础+项目</h3><p>​作者：kerwin</p><p>​版本：QF1.0</p><p>​版权：千锋HTML5大前端教研院</p><p>​公众号: 大前端私房菜</p><h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><h5 id="1-计算机语言"><a href="#1-计算机语言" class="headerlink" title="1.计算机语言"></a>1.计算机语言</h5><p>计算机语言（Computer Language）指用于人与计算机之间通讯的语言。计算机语言是人与计算机之间传递信息的媒介。计算机系统最大特征是指令通过一种语言传达给机器。为了使电子计算机进行各种工作，就需要有一套用以编写计算机程序的数字、字符和语法规划，由这些<a href="https://baike.baidu.com/item/%E5%AD%97%E7%AC%A6/4768913">字符</a>和<a href="https://baike.baidu.com/item/%E8%AF%AD%E6%B3%95%E8%A7%84%E5%88%99/1095093">语法规则</a>组成计算机各种指令（或各种语句）。这些就是计算机能接受的语言。</p><h5 id="2-分类"><a href="#2-分类" class="headerlink" title="2.分类"></a>2.分类</h5><img src="F:/前端学习/视频笔记/javascript/笔记/笔记/笔记.assets/image-20220510141309000.png" alt="image-20220510141309000" style="zoom:50%;float:left;" /><p><img src="F:/前端学习/视频笔记/javascript/笔记/笔记/笔记.assets/image-20220510141952652.png" alt="image-20220510141952652"></p><h4 id="一-JavaScript基础"><a href="#一-JavaScript基础" class="headerlink" title="一. JavaScript基础"></a>一. JavaScript基础</h4><h5 id="1-JavaScript发展历史（JS）"><a href="#1-JavaScript发展历史（JS）" class="headerlink" title="1. JavaScript发展历史（JS）"></a>1. JavaScript发展历史（JS）</h5><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs txt">1. 1994年，网景公司(Netscape)发布了Navigator浏览器0.9版，这是世界上第一款比较成熟的网络浏览器，轰动一时。但是这是一款名副其实的浏览器--只能浏览页面，浏览器无法与用户互动,当时解决这个问题有两个办法，一个是采用现有的语言,许它们直接嵌入网页。另一个是发明一种全新的语言。<br>liveScript ==&gt; javaScript ==&gt; ECMAscript<br><br>2. 1995年Sun公司将Oak语言改名为Java，正式向市场推出。Sun公司大肆宣传，许诺这种语言可以&quot;一次编写，到处运 行&quot;(Write Once, Run Anywhere)，它看上去很可能成为未来的主宰。<br><br>3. 网景公司动了心，决定与Sun公司结成联盟<br><br>4. 34岁的系统程序员Brendan Eich登场了。1995年4月，网景公司录用了他,他只用10天时间就把Javascript设计出来了。<br><br>5.<br>(1)借鉴C语言的基本语法<br>(2)借鉴Java语言的数据类型和内存管理<br>(3)借鉴Scheme语言，将函数提升到&quot;第一等公民&quot;(first class)的地位<br>(4)借鉴Self语言，使用基于原型(prototype)的继承机制<br></code></pre></td></tr></table></figure><h5 id="2-JavaScript的组成"><a href="#2-JavaScript的组成" class="headerlink" title="2. JavaScript的组成"></a>2. JavaScript的组成</h5><img src="F:/前端学习/视频笔记/javascript/笔记/笔记/笔记.assets/image-20220510145615748.png" alt="image-20220510145615748" style="zoom:50%;" /><p><img src="F:/前端学习/视频笔记/javascript/笔记/笔记/笔记.assets/image-20220510144904468.png" alt="image-20220510144904468"></p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs txt">1. ECMASCRIPT: 定义了javascript的语法规范,描述了语言的基本语法和数据类型<br>2. BOM (Browser Object Model): 浏览器对象模型<br>  - 有一套成熟的可以操作浏览器的 API，通过 BOM 可以操作浏览器。比如： 弹出框、浏览器跳转、获取分辨率等<br>3. DOM (Document Object Model): 文档对象模型<br>  - 有一套成熟的可以操作页面元素的 API，通过 DOM 可以操作页面中的元素。比如： 增加个 div，减少个 div，给 div 换个位置等<br></code></pre></td></tr></table></figure><p>总结： <strong>JS 就是通过固定的语法去操作 浏览器 和 标签结构 来实现网页上的各种效果</strong></p><h5 id="3-JavaScript能干什么"><a href="#3-JavaScript能干什么" class="headerlink" title="3 . JavaScript能干什么"></a>3 . JavaScript能干什么</h5><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs txt">1. 常见的网页效果【表单验证，轮播图。。。】<br>2. 与H5配合实现游戏【水果忍者： http://www.jq22.com/demo/html5-fruit-ninja/】<br>3. 实现应用级别的程序【http://naotu.baidu.com】<br>4. 实现图表统计效果【https://echarts.apache.org/examples/zh/】<br>5. js可以实现人工智能【面部识别】<br>6. 后端开发，app开发，桌面端开发......<br></code></pre></td></tr></table></figure><h5 id="4-JavaScript代码的书写位置"><a href="#4-JavaScript代码的书写位置" class="headerlink" title="4. JavaScript代码的书写位置"></a>4. JavaScript代码的书写位置</h5><ul><li>和 <code>css</code> 一样，我们的 <code>js</code> 也可以有多种方式书写在页面上让其生效</li><li><code>js</code> 也有多种方式书写，分为 <strong>行内式</strong>， <strong>内嵌式</strong>，<strong>外链式</strong></li></ul><h6 id="4-1-行内式-JS-代码（不推荐）"><a href="#4-1-行内式-JS-代码（不推荐）" class="headerlink" title="4-1 行内式 JS 代码（不推荐）"></a>4-1 行内式 JS 代码（不推荐）</h6><ul><li>写在标签上的 js 代码需要依靠事件（行为）来触发</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 写在 a 标签的 href 属性上 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;javascript:alert(&#x27;我是一个弹出层&#x27;);&quot;</span>&gt;</span>点击一下试试<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 写在其他元素上 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;alert(&#x27;我是一个弹出层&#x27;)&quot;</span>&gt;</span>点一下试试看<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br><span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">注：onclick 是一个事件（点击事件），当点击元素的时候执行后面的 js 代码</span><br><span class="hljs-comment">--&gt;</span><br></code></pre></td></tr></table></figure><h6 id="4-2-内嵌式-JS-代码"><a href="#4-2-内嵌式-JS-代码" class="headerlink" title="4-2 内嵌式 JS 代码"></a>4-2 内嵌式 JS 代码</h6><ul><li>内嵌式的 js 代码会在页面打开的时候直接触发</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 在 html 页面书写一个 script 标签，标签内部书写 js 代码 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;我是一个弹出层&#x27;</span>)</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">注：script 标签可以放在 head 里面也可以放在 body 里面</span><br><span class="hljs-comment">--&gt;</span><br></code></pre></td></tr></table></figure><h6 id="4-3-外链式-JS-代码（推荐）"><a href="#4-3-外链式-JS-代码（推荐）" class="headerlink" title="4-3 外链式 JS 代码（推荐）"></a>4-3 外链式 JS 代码（推荐）</h6><ul><li>外链式 js 代码只要引入了 html 页面，就会在页面打开的时候直接触发</li><li>新建一个 <code>.js</code> 后缀的文件，在文件内书写 <code>js</code> 代码，把写好的 <code>js</code> 文件引入 <code>html</code> 页面</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 我是 index.js 文件</span><br><span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;我是一个弹出层&#x27;</span>)<br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 我是一个 html 文件 --&gt;</span><br><br><span class="hljs-comment">&lt;!-- 通过 script 标签的 src 属性，把写好的 js 文件引入页面 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;index.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 一个页面可以引入多个 js 文件 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;index1.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;index2.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;index3.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h5 id="5-JS-中的注释"><a href="#5-JS-中的注释" class="headerlink" title="5. JS 中的注释"></a>5. JS 中的注释</h5><ul><li>学习一个语言，先学习一个语言的注释，因为注释是给我们自己看的，也是给开发人员看的</li><li>写好一个注释，有利于我们以后阅读代码</li></ul><h6 id="5-1-单行注释"><a href="#5-1-单行注释" class="headerlink" title="5-1 单行注释"></a>5-1 单行注释</h6><ul><li>一般就是用来描述下面一行代码的作用</li><li>可以直接写两个 <code>/</code> ，也可以按 <code>ctrl + /</code></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 我是一个单行注释</span><br><br><span class="hljs-comment">// 下面代码表示在浏览器里面出现一个弹出层</span><br><span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;我是一个弹出层&#x27;</span>)<br></code></pre></td></tr></table></figure><h6 id="5-2-多行注释"><a href="#5-2-多行注释" class="headerlink" title="5-2 多行注释"></a>5-2 多行注释</h6><ul><li>一般用来写一大段话，或者注释一段代码</li><li>可以直接写 <code>/**/</code> 然后在两个星号中间写注释<ul><li>各个编辑器的快捷键不一样，<code>vscode</code> 是 <code>alt + shift + a</code></li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/*</span><br><span class="hljs-comment">我是一个多行注释</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">注释的代码不会执行</span><br><span class="hljs-comment">alert(&#x27;我是一个弹出层&#x27;)</span><br><span class="hljs-comment">alert(&#x27;我是一个弹出层&#x27;)</span><br><span class="hljs-comment">*/</span><br><span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;我是一个弹出层&#x27;</span>)<br></code></pre></td></tr></table></figure><h5 id="6-变量（重点）"><a href="#6-变量（重点）" class="headerlink" title="6. 变量（重点）"></a>6. 变量（重点）</h5><ul><li>变量指的是在程序中保存数据的一个容器</li><li>变量是计算机内存中存储数据的标识符，根据变量名称可以获取到内存中存储的数据</li><li>也就是说，我们向内存中存储了一个数据，然后要给这个数据起一个名字，为了是我们以后再次找到他</li><li>语法： <code>var 变量名 = 值</code></li></ul><h6 id="6-1-定义变量及赋值"><a href="#6-1-定义变量及赋值" class="headerlink" title="6-1 定义变量及赋值"></a>6-1 定义变量及赋值</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 定义一个变量</span><br><span class="hljs-keyword">var</span> num;<br><br><span class="hljs-comment">// 给一个变量赋值</span><br>num = <span class="hljs-number">100</span>;<br><br><span class="hljs-comment">// 定义一个变量的同时给其赋值</span><br><span class="hljs-keyword">var</span> num2 = <span class="hljs-number">200</span>;<br></code></pre></td></tr></table></figure><ul><li>注意：<ol><li>一个变量名只能存储一个值</li><li>当再次给一个变量赋值的时候，前面一次的值就没有了</li><li>变量名称区分大小写（<code>JS</code> 严格区分大小写）</li></ol></li></ul><h6 id="6-2-变量的命名规则和命名规范"><a href="#6-2-变量的命名规则和命名规范" class="headerlink" title="6-2 变量的命名规则和命名规范"></a>6-2 变量的命名规则和命名规范</h6><ul><li><p>规则： 必须遵守的，不遵守就是错</p><blockquote><ol><li>一个变量名称可以由 <strong>数字</strong>、<strong>字母</strong>、<strong>英文下划线（_）</strong>、<strong>美元符号（$）</strong> 组成</li><li>严格区分大小写</li><li>不能由数字开头</li><li>不能是 <strong>保留字</strong> 或者 <strong>关键字</strong></li><li>不要出现空格</li></ol></blockquote></li><li><p>规范： 建议遵守的（开发者默认），不遵守不会报错</p><blockquote><ol><li>变量名尽量有意义（语义化）</li><li>遵循驼峰命名规则，由多个单词组成的时候，从第二个单词开始首字母大写</li><li>不要使用中文</li></ol></blockquote></li></ul><h6 id="6-3-数据类型（重点）"><a href="#6-3-数据类型（重点）" class="headerlink" title="6-3 数据类型（重点）"></a>6-3 数据类型（重点）</h6><ul><li>是指我们存储在内存中的数据的类型</li><li>我们通常分为两大类 <strong>基本数据类型</strong> 和 <strong>复杂数据类型</strong></li></ul><p><strong>基本数据类型</strong></p><ol><li>数值类型（number）<ul><li>一切数字都是数值类型（包括二进制，十进制，十六进制等）</li><li><code>NaN</code>（not a number），一个非数字</li></ul></li><li>字符串类型（string）<ul><li>被引号包裹的所有内容（可以是单引号也可以是双引号）</li></ul></li><li>布尔类型（boolean）<ul><li>只有两个（<code>true</code> 或者 <code>false</code>）</li></ul></li><li>null类型（null）<ul><li>只有一个，就是 <code>null</code>，表示空的意思</li></ul></li><li>undefined类型（undefined）<ul><li>只有一个，就是 <code>undefined</code>，表示没有值的意思</li></ul></li></ol><p><strong>判断数据类型</strong> </p><ul><li>既然已经把数据分开了类型，那么我们就要知道我们存储的数据是一个什么类型的数据</li><li>使用 <code>typeof</code> 关键字来进行判断</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 第一种使用方式</span><br><span class="hljs-keyword">var</span> n1 = <span class="hljs-number">100</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> n1);<br><br><span class="hljs-comment">// 第二种使用方式</span><br><span class="hljs-keyword">var</span> s1 = <span class="hljs-string">&#x27;abcdefg&#x27;</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">typeof</span>(s1));<br></code></pre></td></tr></table></figure><h5 id="7-数据类型转换"><a href="#7-数据类型转换" class="headerlink" title="7. 数据类型转换"></a>7. 数据类型转换</h5><ul><li>数据类型之间的转换，比如数字转成字符串，字符串转成布尔，布尔转成数字等</li></ul><h6 id="7-1-其他数据类型转成数值"><a href="#7-1-其他数据类型转成数值" class="headerlink" title="7.1 其他数据类型转成数值"></a>7.1 其他数据类型转成数值</h6><ol><li><p><code>Number(变量)</code></p><blockquote><p>可以把一个变量强制转换成数值类型</p><p>可以转换小数，会保留小数</p><p>可以转换布尔值</p><p>遇到不可转换的都会返回 <code>NaN</code></p></blockquote></li><li><p><code>parseInt(变量)</code></p><blockquote><p>从第一位开始检查，是数字就转换，知道一个不是数字的内容</p><p>开头就不是数字，那么直接返回 <code>NaN</code></p><p>不认识小数点，只能保留整数</p></blockquote></li><li><p><code>parseFloat(变量)</code></p><blockquote><p>从第一位开始检查，是数字就转换，知道一个不是数字的内容</p><p>开头就不是数字，那么直接返回 <code>NaN</code></p><p>认识一次小数点</p></blockquote></li><li><p>除了加法以外的数学运算</p><blockquote><p>运算符两边都是可运算数字才行</p><p>如果运算符任何一遍不是一个可运算数字，那么就会返回 <code>NaN</code></p><p>加法不可以用</p></blockquote></li></ol><h6 id="7-2-其他数据类型转成字符串"><a href="#7-2-其他数据类型转成字符串" class="headerlink" title="7.2 其他数据类型转成字符串"></a>7.2 其他数据类型转成字符串</h6><ol><li><p><code>变量.toString()</code></p><blockquote><p>有一些数据类型不能使用 <code>toString()</code> 方法，比如 <code>undefined</code> 和 <code>null</code></p></blockquote></li><li><p><code>String(变量)</code></p><blockquote><p>所有数据类型都可以</p></blockquote></li><li><p>使用加法运算</p><blockquote><p>在 JS 里面，<code>+</code> 由两个含义</p><p>字符串拼接： 只要 <code>+</code> 任意一边是字符串，就会进行字符串拼接</p><p>加法运算：只有 <code>+</code> 两边都是数字的时候，才会进行数学运算</p></blockquote></li></ol><h6 id="7-3-其他数据类型转成布尔"><a href="#7-3-其他数据类型转成布尔" class="headerlink" title="7.3 其他数据类型转成布尔"></a>7.3 其他数据类型转成布尔</h6><ol><li><p><code>Boolean(变量)</code></p><blockquote><p>在 js 中，只有 <code>&#39;&#39;</code>、<code>0</code>、<code>null</code>、<code>undefined</code>、<code>NaN</code>，这些是 <code>false</code></p><p>其余都是 <code>true</code></p></blockquote></li></ol><h5 id="8-运算符"><a href="#8-运算符" class="headerlink" title="8. 运算符"></a>8. 运算符</h5><ul><li>就是在代码里面进行运算的时候使用的符号，不光只是数学运算，我们在 <code>js</code> 里面还有很多的运算方式</li></ul><h6 id="8-1-数学运算符"><a href="#8-1-数学运算符" class="headerlink" title="8-1 数学运算符"></a>8-1 数学运算符</h6><ol><li><p><code>+</code></p><blockquote><p>只有符号两边都是数字的时候才会进行加法运算</p><p>只要符号任意一边是字符串类型，就会进行字符串拼接</p></blockquote></li><li><p><code>-</code></p><blockquote><p>会执行减法运算</p><p>会自动把两边都转换成数字进行运算</p></blockquote></li><li><p><code>*</code></p><blockquote><p>会执行乘法运算</p><p>会自动把两边都转换成数字进行运算</p></blockquote></li><li><p><code>/</code></p><blockquote><p>会执行除法运算</p><p>会自动把两边都转换成数字进行运算</p></blockquote></li><li><p><code>%</code></p><blockquote><p>会执行取余运算</p><p>会自动把两边都转换成数字进行运算</p></blockquote></li></ol><h6 id="8-2-赋值运算符"><a href="#8-2-赋值运算符" class="headerlink" title="8-2 赋值运算符"></a>8-2 赋值运算符</h6><ol><li><p><code>=</code></p><blockquote><p>就是把 <code>=</code> 右边的赋值给等号左边的变量名</p><p><code>var num = 100</code></p><p>就是把 100 赋值给 num 变量</p><p>那么 num 变量的值就是 100</p></blockquote></li><li><p><code>+=</code></p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = <span class="hljs-number">10</span>;<br>a += <span class="hljs-number">10</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a); <span class="hljs-comment">//=&gt; 20</span><br></code></pre></td></tr></table></figure><p><code>a += 10</code> 等价于 <code>a = a + 10</code></p></blockquote></li><li><p><code>-=</code></p><blockquote><p>var a &#x3D; 10;</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">a -= <span class="hljs-number">10</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a); <span class="hljs-comment">//=&gt; 0</span><br></code></pre></td></tr></table></figure><p><code>a -= 10</code> 等价于 <code>a = a - 10</code></p></blockquote></li><li><p><code>*=</code></p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = <span class="hljs-number">10</span>;<br>a *= <span class="hljs-number">10</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a); <span class="hljs-comment">//=&gt; 100</span><br></code></pre></td></tr></table></figure><p><code>a *= 10</code> 等价于 <code>a = a * 10</code></p></blockquote></li><li><p><code>/+</code></p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = <span class="hljs-number">10</span>;<br>a /= <span class="hljs-number">10</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a); <span class="hljs-comment">//=&gt; 1</span><br></code></pre></td></tr></table></figure><p><code>a /= 10</code> 等价于 <code>a = a / 10</code></p></blockquote></li><li><p><code>%=</code></p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = <span class="hljs-number">10</span>;<br>a %= <span class="hljs-number">10</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a); <span class="hljs-comment">//=&gt; 0</span><br></code></pre></td></tr></table></figure><p><code>a %= 10</code> 等价于 <code>a = a % 10</code></p></blockquote></li></ol><h6 id="8-3-比较运算符"><a href="#8-3-比较运算符" class="headerlink" title="8-3 比较运算符"></a>8-3 比较运算符</h6><ol><li><p><code>==</code></p><ul><li><p>比较符号两边的值是否相等，不管数据类型</p><blockquote><p><code>1 == &#39;1&#39;</code></p><p>两个的值是一样的，所以得到 <code>true</code></p></blockquote></li></ul></li><li><p><code>===</code></p><ul><li><p>比较符号两边的值和数据类型是否都相等</p><blockquote><p><code>1 === &#39;1&#39;</code></p><p>两个值虽然一样，但是因为数据类型不一样，所以得到 <code>false</code></p></blockquote></li></ul></li><li><p><code>!=</code></p><ul><li><p>比较符号两边的值是否不等</p><blockquote><p><code>1 != &#39;1&#39;</code></p><p>因为两边的值是相等的，所以比较他们不等的时候得到 <code>false</code></p></blockquote></li></ul></li><li><p><code>!==</code></p><ul><li><p>比较符号两边的数据类型和值是否不等</p><blockquote><p><code>1 !== &#39;1&#39;</code></p><p>因为两边的数据类型确实不一样，所以得到 <code>true</code></p></blockquote></li></ul></li><li><p><code>&gt;=</code></p><ul><li><p>比较左边的值是否 <strong>大于或等于</strong> 右边的值</p><blockquote><p><code>1 &gt;= 1</code>  结果是 <code>true</code></p><p><code>1 &gt;= 0</code>  结果是 <code>true</code></p><p><code>1 &gt;= 2</code>  结果是 <code>false</code></p></blockquote></li></ul></li><li><p><code>&lt;=</code></p><ul><li><p>比较左边的值是否 <strong>小于或等于</strong> 右边的值</p><blockquote><p><code>1 &lt;= 2</code>  结果是 <code>true</code></p><p><code>1 &lt;= 1</code>  结果是 <code>true</code></p><p><code>1 &lt;= 0</code>  结果是 <code>false</code></p></blockquote></li></ul></li><li><p><code>&gt;</code></p><ul><li><p>比较左边的值是否 <strong>大于</strong> 右边的值</p><blockquote><p><code>1 &gt; 0</code>  结果是 <code>true</code></p><p><code>1 &gt; 1</code>  结果是 <code>false</code></p><p><code>1 &gt; 2</code>  结果是 <code>false</code></p></blockquote></li></ul></li><li><p><code>&lt;</code></p><ul><li><p>比较左边的值是否 <strong>小于</strong> 右边的值</p><blockquote><p><code>1 &lt; 2</code>  结果是 <code>true</code></p><p><code>1 &lt; 1</code>  结果是 <code>false</code></p><p><code>1 &lt; 0</code>  结果是 <code>false</code></p></blockquote></li></ul></li></ol><h6 id="8-4-逻辑运算符"><a href="#8-4-逻辑运算符" class="headerlink" title="8-4 逻辑运算符"></a>8-4 逻辑运算符</h6><ol><li><p><code>&amp;&amp;</code></p><ul><li><p>进行 且 的运算</p><blockquote><p>符号左边必须为 <code>true</code> 并且右边也是 <code>true</code>，才会返回 <code>true</code></p><p>只要有一边不是 <code>true</code>，那么就会返回 <code>false</code></p><p><code>true &amp;&amp; true</code>  结果是 <code>true</code></p><p><code>true &amp;&amp; false</code>  结果是 <code>false</code></p><p><code>false &amp;&amp; true</code>  结果是 <code>false</code></p><p><code>false &amp;&amp; false</code>  结果是 <code>false</code></p></blockquote></li></ul></li><li><p><code>||</code></p><ul><li><p>进行 或 的运算</p><blockquote><p>符号的左边为 <code>true</code> 或者右边为 <code>true</code>，都会返回 <code>true</code></p><p>只有两边都是 <code>false</code> 的时候才会返回 <code>false</code></p><p><code>true || true</code>  结果是 <code>true</code></p><p><code>true || false</code>  结果是 <code>true</code></p><p><code>false || true</code>  结果是 <code>true</code></p><p><code>false || false</code>  结果是 <code>false</code></p></blockquote></li></ul></li><li><p><code>!</code></p><ul><li><p>进行 取反 运算</p><blockquote><p>本身是 <code>true</code> 的，会变成 <code>false</code></p><p>本身是 <code>false</code> 的，会变成 <code>true</code></p><p><code>!true</code>  结果是 <code>false</code></p><p><code>!false</code>  结果是 <code>true</code></p></blockquote></li></ul></li></ol><h6 id="8-5-自增自减运算符"><a href="#8-5-自增自减运算符" class="headerlink" title="8-5 自增自减运算符"></a>8-5 自增自减运算符</h6><ol><li><p><code>++</code></p><ul><li><p>进行自增运算</p></li><li><p>分成两种，<strong>前置++</strong> 和 <strong>后置++</strong></p></li><li><p>前置++，会先把值自动 +1，在返回</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(++a);<br><span class="hljs-comment">// 会返回 11，并且把 a 的值变成 11</span><br></code></pre></td></tr></table></figure></li><li><p>后置++，会先把值返回，在自动+1</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a++);<br><span class="hljs-comment">// 会返回 10，然后把 a 的值变成 11</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p><code>--</code></p><ul><li>进行自减运算</li><li>分成两种，<strong>前置–</strong> 和 <strong>后置–</strong></li><li>和 <code>++</code> 运算符道理一样</li></ul></li></ol><h5 id="9-三元运算符"><a href="#9-三元运算符" class="headerlink" title="9. 三元运算符"></a>9. 三元运算符</h5><ul><li><p>三元运算，就是用 <strong>两个符号</strong> 组成一个语句</p></li><li><p>语法： <code>条件 ? 条件为 true 的时候执行 : 条件为 false 的时候执行</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> age = <span class="hljs-number">18</span>;<br>age &gt;= <span class="hljs-number">18</span> ? <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;已经成年&#x27;</span>) : <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;没有成年&#x27;</span>)<br></code></pre></td></tr></table></figure></li></ul><h5 id="10-分支结构"><a href="#10-分支结构" class="headerlink" title="10. 分支结构"></a>10. 分支结构</h5><ul><li>我们的 <code>js</code> 代码都是顺序执行的（从上到下）</li><li>逻辑分支就是根据我们设定好的条件来决定要不要执行某些代码</li></ul><h6 id="10-1-IF-条件分支结构（重点）"><a href="#10-1-IF-条件分支结构（重点）" class="headerlink" title="10-1 IF 条件分支结构（重点）"></a>10-1 IF 条件分支结构（重点）</h6><p><strong>if 语句</strong></p><ul><li><p>通过一个 <code>if</code> 语句来决定代码是否执行</p></li><li><p>语法： <code>if (条件) &#123; 要执行的代码 &#125;</code></p></li><li><p>通过 <code>()</code> 里面的条件是否成立来决定 <code>&#123;&#125;</code> 里面的代码是否执行</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 条件为 true 的时候执行 &#123;&#125; 里面的代码</span><br><span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>) &#123;<br>  <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;因为条件是 true，我会执行&#x27;</span>)<br>&#125;<br><br><span class="hljs-comment">// 条件为 false 的时候不执行 &#123;&#125; 里面的代码</span><br><span class="hljs-keyword">if</span> (<span class="hljs-literal">false</span>) &#123;<br><span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;因为条件是 false，我不会执行&#x27;</span>)    <br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p><strong>if else 语句</strong></p><ul><li><p>通过 <code>if</code> 条件来决定，执行哪一个 <code>&#123;&#125;</code> 里面的代码</p></li><li><p>语法： <code>if (条件) &#123; 条件为 true 的时候执行 &#125; else &#123; 条件为 false 的时候执行 &#125;</code></p></li><li><p>两个 <code>&#123;&#125;</code> 内的代码一定有一个会执行</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 条件为 true 的时候，会执行 if 后面的 &#123;&#125; </span><br><span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>) &#123;<br>  <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;因为条件是 true，我会执行&#x27;</span>)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>  <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;因为条件是 true，我不会执行&#x27;</span>)<br>&#125;<br><br><span class="hljs-comment">// 条件为 false 的时候，会执行 else 后面的 &#123;&#125;</span><br><span class="hljs-keyword">if</span> (<span class="hljs-literal">false</span>) &#123;<br>  <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;因为条件为 false，我不会执行&#x27;</span>)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>  <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;因为条件为 false，我会执行&#x27;</span>)<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p><strong>if else if … 语句</strong></p><ul><li><p>可以通过 <code>if</code> 和 <code>else if</code> 来设置多个条件进行判断</p></li><li><p>语法：<code>if (条件1) &#123; 条件1为 true 的时候执行 &#125; else if (条件2) &#123; 条件2为 true 的时候执行 &#125;</code></p></li><li><p>会从头开始依次判断条件</p><ul><li>如果第一个条件为 <code>true</code> 了，那么就会执行后面的 <code>&#123;&#125;</code> 里面的内容</li><li>如果第一个条件为 <code>false</code>，那么就会判断第二个条件，依次类推</li></ul></li><li><p>多个 <code>&#123;&#125;</code> ，只会有一个被执行，一旦有一个条件为 <code>true</code> 了，后面的就不在判断了</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 第一个条件为 true，第二个条件为 false，最终会打印 “我是代码段1”</span><br><span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>) &#123;<br>  <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;我是代码段1&#x27;</span>)<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-literal">false</span>) &#123;<br><span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;我是代码段2&#x27;</span>)           <br>&#125;<br><br><span class="hljs-comment">// 第一个条件为 true，第二个条件为 true，最终会打印 “我是代码段1”</span><br><span class="hljs-comment">// 因为只要前面有一个条件满足了，就不会继续判断了</span><br><span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>) &#123;<br>  <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;我是代码段1&#x27;</span>)<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>) &#123;<br>  <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;我是代码段2&#x27;</span>)<br>&#125;<br><br><span class="hljs-comment">// 第一个条件为 false，第二个条件为 true，最终会打印 “我是代码段2”</span><br><span class="hljs-comment">// 只有前一个条件为 false 的时候才会继续向后判断</span><br><span class="hljs-keyword">if</span> (<span class="hljs-literal">false</span>) &#123;<br>  <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;我是代码段1&#x27;</span>)<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>) &#123;<br>  <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;我是代码段2&#x27;</span>)<br>&#125;<br><br><span class="hljs-comment">// 第一个条件为 false，第二个条件为 false，最终什么也不会发生</span><br><span class="hljs-comment">// 因为当所有条件都为 false 的时候，两个 &#123;&#125; 里面的代码都不会执行</span><br><span class="hljs-keyword">if</span> (<span class="hljs-literal">false</span>) &#123;<br>  <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;我是代码段1&#x27;</span>)<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-literal">false</span>) &#123;<br>  <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;我是代码段2&#x27;</span>)<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p><strong>if else if … else 语句</strong></p><ul><li><p>和之前的 <code>if else if ...</code> 基本一致，只不过是在所有条件都不满足的时候，执行最后 <code>else</code> 后面的 <code>&#123;&#125;</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 第一个条件为 false，第二个条件为 false，最终会打印 “我是代码段3”</span><br><span class="hljs-comment">// 只有前面所有的条件都不满足的时候会执行 else 后面的 &#123;&#125; 里面的代码</span><br><span class="hljs-comment">// 只要前面有一个条件满足了，那么后面的就都不会执行了</span><br><span class="hljs-keyword">if</span> (<span class="hljs-literal">false</span>) &#123;<br>  <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;我是代码段1&#x27;</span>)<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-literal">false</span>) &#123;<br>  <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;我是代码段2&#x27;</span>)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>  <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;我是代码段3&#x27;</span>)<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h6 id="10-2-SWITCH-条件分支结构（重点）"><a href="#10-2-SWITCH-条件分支结构（重点）" class="headerlink" title="10-2 SWITCH 条件分支结构（重点）"></a>10-2 SWITCH 条件分支结构（重点）</h6><ul><li><p>也是条件判断语句的一种</p></li><li><p>是对于某一个变量的判断</p></li><li><p>语法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">switch</span> (要判断的变量) &#123;<br>  <span class="hljs-keyword">case</span> 情况<span class="hljs-number">1</span>:<br>    情况<span class="hljs-number">1</span>要执行的代码<br>    <span class="hljs-keyword">break</span><br>  <span class="hljs-keyword">case</span> 情况<span class="hljs-number">2</span>:<br>    情况<span class="hljs-number">2</span>要执行的代码<br>    <span class="hljs-keyword">break</span><br>  <span class="hljs-keyword">case</span> 情况<span class="hljs-number">3</span>:<br>    情况<span class="hljs-number">3</span>要执行的代码<br>    <span class="hljs-keyword">break</span><br>  <span class="hljs-attr">default</span>:<br>    上述情况都不满足的时候执行的代码<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>要判断某一个变量 <strong>等于</strong> 某一个值得时候使用</li></ul></li><li><p>例子🌰： 根据变量给出的数字显示是星期几</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> week = <span class="hljs-number">1</span><br><span class="hljs-keyword">switch</span> (week) &#123;<br>  <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>    <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;星期一&#x27;</span>)<br>    <span class="hljs-keyword">break</span><br>  <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>    <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;星期二&#x27;</span>)<br>    <span class="hljs-keyword">break</span><br>  <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<br>    <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;星期三&#x27;</span>)<br>    <span class="hljs-keyword">break</span><br>  <span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:<br>    <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;星期四&#x27;</span>)<br>    <span class="hljs-keyword">break</span><br>  <span class="hljs-keyword">case</span> <span class="hljs-number">5</span>:<br>    <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;星期五&#x27;</span>)<br>    <span class="hljs-keyword">break</span><br>  <span class="hljs-keyword">case</span> <span class="hljs-number">6</span>:<br>    <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;星期六&#x27;</span>)<br>    <span class="hljs-keyword">break</span><br>  <span class="hljs-keyword">case</span> <span class="hljs-number">7</span>:<br>    <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;星期日&#x27;</span>)<br>    <span class="hljs-keyword">break</span><br>  <span class="hljs-attr">default</span>:<br>    <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;请输入一个 1 ～ 7 之间的数字&#x27;</span>)<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h5 id="11-循环结构（重点）"><a href="#11-循环结构（重点）" class="headerlink" title="11. 循环结构（重点）"></a>11. 循环结构（重点）</h5><ul><li>循环结构，就是根据某些给出的条件，重复的执行同一段代码</li><li>循环必须要有某些固定的内容组成<ol><li>初始化</li><li>条件判断</li><li>要执行的代码</li><li>自身改变</li></ol></li></ul><h6 id="11-1-WHILE-循环"><a href="#11-1-WHILE-循环" class="headerlink" title="11-1 WHILE 循环"></a>11-1 WHILE 循环</h6><ul><li><p><code>while</code>，中文叫 当…时，其实就是当条件满足时就执行代码，一旦不满足了就不执行了</p></li><li><p>语法 <code>while (条件) &#123; 满足条件就执行 &#125;</code></p></li><li><p>因为满足条件就执行，所以我们写的时候一定要注意，就是设定一个边界值，不然就一直循环下去了</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 1. 初始化条件</span><br><span class="hljs-keyword">var</span> num = <span class="hljs-number">0</span>;<br><span class="hljs-comment">// 2. 条件判断</span><br><span class="hljs-keyword">while</span> (num &lt; <span class="hljs-number">10</span>) &#123;<br>  <span class="hljs-comment">// 3. 要执行的代码</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;当前的 num 的值是 &#x27;</span> + num)<br>  <span class="hljs-comment">// 4. 自身改变</span><br>  num = num + <span class="hljs-number">1</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>如果没有自身改变，那么就会一直循环不停了</li></ul></li></ul><h6 id="11-2-DO-WHILE-循环"><a href="#11-2-DO-WHILE-循环" class="headerlink" title="11-2 DO WHILE 循环"></a>11-2 DO WHILE 循环</h6><ul><li><p>是一个和 <code>while</code> 循环类似的循环</p></li><li><p><code>while</code> 会先进行条件判断，满足就执行，不满足直接就不执行了</p></li><li><p>但是 <code>do while</code> 循环是，先不管条件，先执行一回，然后在开始进行条件判断</p></li><li><p>语法： <code>do &#123; 要执行的代码 &#125; while (条件)</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 下面这个代码，条件一开始就不满足，但是依旧会执行一次 do 后面 &#123;&#125; 内部的代码</span><br><span class="hljs-keyword">var</span> num = <span class="hljs-number">10</span><br><span class="hljs-keyword">do</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;我执行了一次&#x27;</span>)<br>  num = num + <span class="hljs-number">1</span><br>&#125; <span class="hljs-keyword">while</span> (num &lt; <span class="hljs-number">10</span>)<br></code></pre></td></tr></table></figure></li></ul><h6 id="11-3-FOR-循环"><a href="#11-3-FOR-循环" class="headerlink" title="11-3 FOR 循环"></a>11-3 FOR 循环</h6><ul><li><p>和 <code>while</code> 和 <code>do while</code> 循环都不太一样的一种循环结构</p></li><li><p>道理是和其他两种一样的，都是循环执行代码的</p></li><li><p>语法： <code>for (var i = 0; i &lt; 10; i++) &#123; 要执行的代码 &#125;</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 把初始化，条件判断，自身改变，写在了一起</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">10</span>; i++) &#123;<br>  <span class="hljs-comment">// 这里写的是要执行的代码</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i)<br>&#125;<br><br><span class="hljs-comment">// 控制台会依次输出 1 ~ 10 </span><br></code></pre></td></tr></table></figure></li><li><p>这个只是看起来不太舒服，但是用起来比较好用</p></li></ul><h6 id="11-4-BREAK-终止循环"><a href="#11-4-BREAK-终止循环" class="headerlink" title="11-4 BREAK 终止循环"></a>11-4 BREAK 终止循环</h6><ul><li><p>在循环没有进行完毕的时候，因为我设置的条件满足，提前终止循环</p></li><li><p>比如：我要吃五个包子，吃到三个的时候，不能在吃了，我就停止吃包子这个事情</p></li><li><p>要终止循环，就可以直接使用 <code>break</code> 关键字</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">5</span>; i++) &#123;<br>  <span class="hljs-comment">// 没循环一次，吃一个包子</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;我吃了一个包子&#x27;</span>)<br>  <span class="hljs-comment">// 当 i 的值为 3 的时候，条件为 true，执行 &#123;&#125; 里面的代码终止循环</span><br>  <span class="hljs-comment">// 循环就不会继续向下执行了，也就没有 4 和 5 了</span><br>  <span class="hljs-keyword">if</span> (i === <span class="hljs-number">3</span>) &#123;<br>    <span class="hljs-keyword">break</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h6 id="11-5-CONTINUE-结束本次循环"><a href="#11-5-CONTINUE-结束本次循环" class="headerlink" title="11-5 CONTINUE 结束本次循环"></a>11-5 CONTINUE 结束本次循环</h6><ul><li><p>在循环中，把循环的本次跳过去，继续执行后续的循环</p></li><li><p>比如：吃五个包子，到第三个的时候，第三个掉地下了，不吃了，跳过第三个，继续吃第四个和第五个</p></li><li><p>跳过本次循环，就可以使用 <code>continue</code> 关键字</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">5</span>; i++) &#123;<br>  <span class="hljs-comment">// 当 i 的值为 3 的时候，执行 &#123;&#125; 里面的代码</span><br>  <span class="hljs-comment">// &#123;&#125; 里面有 continue，那么本次循环后面的代码就都不执行了</span><br>  <span class="hljs-comment">// 自动算作 i 为 3 的这一次结束了，去继续执行 i = 4 的那次循环了</span><br>  <span class="hljs-keyword">if</span> (i === <span class="hljs-number">3</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;这个是第三个包子，掉地下了，我不吃了&#x27;</span>)<br>    <span class="hljs-keyword">continue</span><br>  &#125;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;我吃了一个包子&#x27;</span>)<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><img src="F:/前端学习/视频笔记/javascript/笔记/笔记/笔记.assets/image-20220516112555912.png" alt="image-20220516112555912" style="zoom:67%;" /><h5 id="12-函数的概念"><a href="#12-函数的概念" class="headerlink" title="12 函数的概念"></a>12 函数的概念</h5><ul><li><p>对于 <code>js</code> 来说，函数就是把任意一段代码放在一个 <strong>盒子</strong> 里面</p></li><li><p>在我想要让这段代码执行的时候，直接执行这个 <strong>盒子</strong> 里面的代码就行</p></li><li><p>先看一段代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 这个是我们以前写的一段代码</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i)<br>&#125;<br><br><span class="hljs-comment">// 函数，这个 &#123;&#125; 就是那个 “盒子”</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">// 这个函数我们以前写的代码</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h6 id="12-1-函数定义阶段"><a href="#12-1-函数定义阶段" class="headerlink" title="12-1 函数定义阶段"></a>12-1 函数定义阶段</h6><ul><li><p>定义阶段就是我们把代码 <strong>放在盒子里面</strong></p></li><li><p>我们就要学习怎么 <strong>放进去</strong>，也就是书写一个函数</p></li><li><p>我们有两种定义方式 <strong>声明式</strong> 和 <strong>赋值式</strong></p></li></ul><p><strong>声明式</strong></p><ul><li><p>使用 <code>function</code> 这个关键字来声明一个函数</p></li><li><p>语法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">// 一段代码</span><br>&#125;<br><span class="hljs-comment">// function: 声明函数的关键字，表示接下来是一个函数了</span><br><span class="hljs-comment">// fn: 函数的名字，我们自己定义的（遵循变量名的命名规则和命名规范）</span><br><span class="hljs-comment">// (): 必须写，是用来放参数的位置（一会我们再聊）</span><br><span class="hljs-comment">// &#123;&#125;: 就是我们用来放一段代码的位置（也就是我们刚才说的 “盒子”）</span><br></code></pre></td></tr></table></figure></li></ul><p><strong>赋值式</strong></p><ul><li><p>其实就是和我们使用 <code>var</code> 关键字是一个道理了</p></li><li><p>首先使用 <code>var</code> 定义一个变量，把一个函数当作值直接赋值给这个变量就可以了</p></li><li><p>语法： </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> fn = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">// 一段代码</span><br>&#125;<br><span class="hljs-comment">// 不需要在 function 后面书写函数的名字了，因为在前面已经有了</span><br></code></pre></td></tr></table></figure></li></ul><h6 id="12-2-函数调用阶段"><a href="#12-2-函数调用阶段" class="headerlink" title="12-2 函数调用阶段"></a>12-2 函数调用阶段</h6><ul><li>就是让 <strong>盒子里面</strong> 的代码执行一下</li><li>让函数执行</li><li>两种定义函数的方式不同，但是调用函数的方式都以一样的</li></ul><p><strong>调用一个函数</strong></p><ul><li><p>函数调用就是直接写 <code>函数名()</code> 就可以了</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 声明式函数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;我是 fn 函数&#x27;</span>)<br>&#125;<br><br><span class="hljs-comment">// 调用函数</span><br><span class="hljs-title function_">fn</span>()<br><br><span class="hljs-comment">// 赋值式函数</span><br><span class="hljs-keyword">var</span> fn2 = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;我是 fn2 函数&#x27;</span>)<br>&#125;<br><br><span class="hljs-comment">// 调用函数</span><br><span class="hljs-title function_">fn</span>()<br></code></pre></td></tr></table></figure><ul><li>注意： <strong>定义完一个函数以后，如果没有函数调用，那么写在 {} 里面的代码没有意义，只有调用以后才会执行</strong></li></ul></li></ul><h6 id="12-3-调用上的区别"><a href="#12-3-调用上的区别" class="headerlink" title="12-3 调用上的区别"></a>12-3 调用上的区别</h6><ul><li><p>虽然两种定义方式的调用都是一样的，但是还是有一些区别的</p></li><li><p>声明式函数： 调用可以在 <strong>定义之前或者定义之后</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 可以调用</span><br><span class="hljs-title function_">fn</span>()<br><br><span class="hljs-comment">// 声明式函数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;我是 fn 函数&#x27;</span>)<br>&#125;<br><br><span class="hljs-comment">// 可以调用</span><br><span class="hljs-title function_">fn</span>()<br></code></pre></td></tr></table></figure></li><li><p>赋值式函数： 调用只能在 <strong>定义之后</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 会报错</span><br><span class="hljs-title function_">fn</span>()<br><br><span class="hljs-comment">// 赋值式函数</span><br><span class="hljs-keyword">var</span> fn = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;我是 fn 函数&#x27;</span>)<br>&#125;<br><br><span class="hljs-comment">// 可以调用</span><br><span class="hljs-title function_">fn</span>()<br></code></pre></td></tr></table></figure></li></ul><h6 id="12-4-函数的参数"><a href="#12-4-函数的参数" class="headerlink" title="12-4 函数的参数"></a>12-4 函数的参数</h6><ul><li><p>我们在定义函数和调用函数的时候都出现过 <code>()</code></p></li><li><p>现在我们就来说一下这个 <code>()</code> 的作用</p></li><li><p>就是用来放参数的位置</p></li><li><p>参数分为两种 <strong>行参</strong> 和 <strong>实参</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 声明式</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params">行参写在这里</span>) &#123;<br>  <span class="hljs-comment">// 一段代码</span><br>&#125;<br><br><span class="hljs-title function_">fn</span>(实参写在这里)<br><br><span class="hljs-comment">// 赋值式函数</span><br><span class="hljs-keyword">var</span> fn = <span class="hljs-keyword">function</span> (<span class="hljs-params">行参写在这里</span>) &#123;<br>  <span class="hljs-comment">// 一段代码</span><br>&#125;<br><span class="hljs-title function_">fn</span>(实参写在这里)<br></code></pre></td></tr></table></figure></li></ul><p><strong>行参和实参的作用</strong></p><ol><li><p>行参</p><ul><li><p>就是在函数内部可以使用的变量，在函数外部不能使用</p></li><li><p>每写一个单词，就相当于在函数内部定义了一个可以使用的变量（遵循变量名的命名规则和命名规范）</p></li><li><p>多个单词之间以 <code>,</code> 分隔</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 书写一个参数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params">num</span>) &#123;<br>  <span class="hljs-comment">// 在函数内部就可以使用 num 这个变量</span><br>&#125;<br><br><span class="hljs-keyword">var</span> fn1 = <span class="hljs-keyword">function</span> (<span class="hljs-params">num</span>) &#123;<br><span class="hljs-comment">// 在函数内部就可以使用 num 这个变量</span><br>&#125;<br><br><span class="hljs-comment">// 书写两个参数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">fun</span>(<span class="hljs-params">num1, num2</span>) &#123;<br>  <span class="hljs-comment">// 在函数内部就可以使用 num1 和 num2 这两个变量</span><br>&#125;<br><br><span class="hljs-keyword">var</span> fun1 = <span class="hljs-keyword">function</span> (<span class="hljs-params">num1, num2</span>) &#123;<br>  <span class="hljs-comment">// 在函数内部就可以使用 num1 和 num2 这两个变量</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>如果只有行参的话，那么在函数内部使用的值个变量是没有值的，也就是 <code>undefined</code></p></li><li><p><strong>行参的值是在函数调用的时候由实参决定的</strong></p></li></ul></li><li><p>实参</p><ul><li><p>在函数调用的时候给行参赋值的</p></li><li><p>也就是说，在调用的时候是给一个实际的内容的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params">num</span>) &#123;<br>  <span class="hljs-comment">// 函数内部可以使用 num </span><br>&#125;<br><br><span class="hljs-comment">// 这个函数的本次调用，书写的实参是 100</span><br><span class="hljs-comment">// 那么本次调用的时候函数内部的 num 就是 100</span><br><span class="hljs-title function_">fn</span>(<span class="hljs-number">100</span>) <br><br><span class="hljs-comment">// 这个函数的本次调用，书写的实参是 200</span><br><span class="hljs-comment">// 那么本次调用的时候函数内部的 num 就是 200</span><br><span class="hljs-title function_">fn</span>(<span class="hljs-number">200</span>)<br></code></pre></td></tr></table></figure></li><li><p><strong>函数内部的行参的值，由函数调用的时候传递的实参决定</strong></p></li><li><p><strong>多个参数的时候，是按照顺序一一对应的</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params">num1, num2</span>) &#123;<br>  <span class="hljs-comment">// 函数内部可以使用 num1 和 num2</span><br>&#125;<br><br><span class="hljs-comment">// 函数本次调用的时候，书写的参数是 100 和 200</span><br><span class="hljs-comment">// 那么本次调用的时候，函数内部的 num1 就是 100，num2 就是 200</span><br><span class="hljs-title function_">fn</span>(<span class="hljs-number">100</span>, <span class="hljs-number">200</span>)<br></code></pre></td></tr></table></figure></li></ul></li></ol><p><strong>参数个数的关系</strong></p><ol><li><p>行参比实参少</p><ul><li><p>因为是按照顺序一一对应的</p></li><li><p>行参少就会拿不到实参给的值，所以在函数内部就没有办法用到这个值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params">num1, num2</span>) &#123;<br>  <span class="hljs-comment">// 函数内部可以使用 num1 和 num2</span><br>&#125;<br><br><span class="hljs-comment">// 本次调用的时候，传递了两个实参，100 200 和 300</span><br><span class="hljs-comment">// 100 对应了 num1，200 对应了 num2，300 没有对应的变量</span><br><span class="hljs-comment">// 所以在函数内部就没有办法依靠变量来使用 300 这个值</span><br><span class="hljs-title function_">fn</span>(<span class="hljs-number">100</span>, <span class="hljs-number">200</span>, <span class="hljs-number">300</span>)<br></code></pre></td></tr></table></figure></li></ul></li><li><p>行参比实参多</p><ul><li><p>因为是按照顺序一一对应的</p></li><li><p>所以多出来的行参就是没有值的，就是 <code>undefined</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params">num1, num2, num3</span>) &#123;<br>  <span class="hljs-comment">// 函数内部可以使用 num1 num2 和 num3</span><br>&#125;<br><br><span class="hljs-comment">// 本次调用的时候，传递了两个实参，100 和 200</span><br><span class="hljs-comment">// 就分别对应了 num1 和 num2</span><br><span class="hljs-comment">// 而 num3 没有实参和其对应，那么 num3 的值就是 undefined</span><br><span class="hljs-title function_">fn</span>(<span class="hljs-number">100</span>, <span class="hljs-number">200</span>)<br></code></pre></td></tr></table></figure></li></ul></li></ol><h6 id="12-5-函数的return"><a href="#12-5-函数的return" class="headerlink" title="12-5 函数的return"></a>12-5 函数的return</h6><ul><li><code>return</code> 返回的意思，其实就是给函数一个 <strong>返回值</strong> 和 <strong>终断函数</strong></li></ul><p><strong>返回值</strong></p><ul><li><p>函数调用本身也是一个表达式，表达式就应该有一个值出现</p></li><li><p>现在的函数执行完毕之后，是不会有结果出现的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 比如 1 + 2 是一个表达式，那么 这个表达式的结果就是 3</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">1</span> + <span class="hljs-number">2</span>) <span class="hljs-comment">// 3</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">// 执行代码</span><br>&#125;<br><br><span class="hljs-comment">// fn() 也是一个表达式，这个表达式就没有结果出现</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">fn</span>()) <span class="hljs-comment">// undefined</span><br></code></pre></td></tr></table></figure></li><li><p><code>return</code> 关键字就是可以给函数执行完毕一个结果</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">// 执行代码</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">100</span><br>&#125;<br><br><span class="hljs-comment">// 此时，fn() 这个表达式执行完毕之后就有结果出现了</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">fn</span>()) <span class="hljs-comment">// 100</span><br></code></pre></td></tr></table></figure><ul><li>我们可以在函数内部使用 <code>return</code> 关键把任何内容当作这个函数运行后的结果</li></ul></li></ul><p><strong>终断函数</strong></p><ul><li><p>当我开始执行函数以后，函数内部的代码就会从上到下的依次执行</p></li><li><p>必须要等到函数内的代码执行完毕</p></li><li><p>而 <code>return</code> 关键字就是可以在函数中间的位置停掉，让后面的代码不在继续执行</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">1</span>)<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">2</span>)<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">3</span>)<br>  <br>  <span class="hljs-comment">// 写了 return 以后，后面的 4 和 5 就不会继续执行了</span><br>  <span class="hljs-keyword">return</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">4</span>)<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">5</span>)<br>&#125;<br><br><span class="hljs-comment">// 函数调用</span><br><span class="hljs-title function_">fn</span>()<br></code></pre></td></tr></table></figure></li></ul><h6 id="12-6-预解析（重点）"><a href="#12-6-预解析（重点）" class="headerlink" title="12-6 预解析（重点）"></a>12-6 预解析（重点）</h6><ul><li><strong>预解析</strong> 其实就是聊聊 <code>js</code> 代码的编译和执行</li><li><code>js</code> 是一个解释型语言，就是在代码执行之前，先对代码进行通读和解释，然后在执行代码</li><li>也就是说，我们的 <code>js</code> 代码在运行的时候，会经历两个环节 <strong>解释代码</strong> 和 <strong>执行代码</strong></li></ul><p><strong>解释代码</strong></p><ul><li><p>因为是在所有代码执行之前进行解释，所以叫做 <strong>预解析（预解释）</strong></p></li><li><p>需要解释的内容有两个</p><ul><li>声明式函数<ul><li>在内存中先声明有一个变量名是函数名，并且这个名字代表的内容是一个函数</li></ul></li><li><code>var</code> 关键字<ul><li>在内存中先声明有一个变量名</li></ul></li></ul></li><li><p>看下面一段代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">fn</span>()<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(num)<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;我是 fn 函数&#x27;</span>)<br>&#125;<br><br><span class="hljs-keyword">var</span> num = <span class="hljs-number">100</span><br></code></pre></td></tr></table></figure></li><li><p>经过预解析之后可以变形为</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;我是 fn 函数&#x27;</span>)<br>&#125;<br><span class="hljs-keyword">var</span> num<br><br><span class="hljs-title function_">fn</span>()<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(num)<br>num = <span class="hljs-number">100</span><br></code></pre></td></tr></table></figure></li><li><p>赋值式函数会按照 <code>var</code> 关键字的规则进行预解析</p></li></ul><h6 id="12-7-作用域"><a href="#12-7-作用域" class="headerlink" title="12-7 作用域"></a>12-7 作用域</h6><ul><li>什么是作用域，就是一个变量可以生效的范围</li><li>变量不是在所有地方都可以使用的，而这个变量的使用范围就是作用域</li></ul><p><strong>全局作用域</strong></p><ul><li><p>全局作用域是最大的作用域</p></li><li><p>在全局作用域中定义的变量可以在任何地方使用</p></li><li><p>页面打开的时候，浏览器会自动给我们生成一个全局作用域 <code>window</code></p></li><li><p>这个作用域会一直存在，直到页面关闭就销毁了</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 下面两个变量都是存在在全局作用域下面的，都是可以在任意地方使用的</span><br><span class="hljs-keyword">var</span> num = <span class="hljs-number">100</span><br><span class="hljs-keyword">var</span> num2 = <span class="hljs-number">200</span><br></code></pre></td></tr></table></figure></li></ul><p><strong>局部作用域</strong></p><ul><li><p>局部作用域就是在全局作用域下面有开辟出来的一个相对小一些的作用域</p></li><li><p>在局部作用域中定义的变量只能在这个局部作用域内部使用</p></li><li><p><strong>在 <code>JS</code> 中只有函数能生成一个局部作用域，别的都不行</strong></p></li><li><p>每一个函数，都是一个局部作用域</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 这个 num 是一个全局作用域下的变量 在任何地方都可以使用</span><br><span class="hljs-keyword">var</span> num = <span class="hljs-number">100</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">// 下面这个变量就是一个 fn 局部作用域内部的变量</span><br>  <span class="hljs-comment">// 只能在 fn 函数内部使用</span><br>  <span class="hljs-keyword">var</span> num2 = <span class="hljs-number">200</span><br>&#125;<br><br><span class="hljs-title function_">fn</span>()<br></code></pre></td></tr></table></figure></li></ul><h6 id="12-8-变量使用规则"><a href="#12-8-变量使用规则" class="headerlink" title="12-8 变量使用规则"></a>12-8 变量使用规则</h6><ul><li>有了作用域以后，变量就有了使用范围，也就有了使用规则</li><li>变量使用规则分为两种，<strong>访问规则</strong> 和 <strong>赋值规则</strong></li></ul><p><strong>访问规则</strong></p><ul><li><p>当我想获取一个变量的值的时候，我们管这个行为叫做 <strong>访问</strong></p></li><li><p>获取变量的规则： </p><ul><li>首先，在自己的作用域内部查找，如果有，就直接拿来使用</li><li>如果没有，就去上一级作用域查找，如果有，就拿来使用</li><li>如果没有，就继续去上一级作用域查找，依次类推</li><li>如果一直到全局作用域都没有这个变量，那么就会直接报错（该变量 is not defined）</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> num = <span class="hljs-number">100</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">var</span> num2 = <span class="hljs-number">200</span><br>  <br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">fun</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">var</span> num3 = <span class="hljs-number">300</span><br>    <br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(num3) <span class="hljs-comment">// 自己作用域内有，拿过来用</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(num2) <span class="hljs-comment">// 自己作用域内没有，就去上一级，就是 fn 的作用域里面找，发现有，拿过来用</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(num) <span class="hljs-comment">// 自己这没有，去上一级 fn 那里也没有，再上一级到全局作用域，发现有，直接用</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a) <span class="hljs-comment">// 自己没有，一级一级找上去到全局都没有，就会报错</span><br>  &#125;<br>  <br>  <span class="hljs-title function_">fun</span>()<br>&#125;<br><br><span class="hljs-title function_">fn</span>()<br></code></pre></td></tr></table></figure></li><li><p>变量的访问规则 也叫做 作用域的查找机制</p></li><li><p>作用域的查找机制只能是向上找，不能向下找</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">var</span> num = <span class="hljs-number">100</span><br>&#125;<br><span class="hljs-title function_">fn</span>()<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(num) <span class="hljs-comment">// 发现自己作用域没有，自己就是全局作用域，没有再上一级了，直接报错</span><br></code></pre></td></tr></table></figure></li></ul><p><strong>赋值规则</strong></p><ul><li><p>当你想给一个变量赋值的时候，那么就先要找到这个变量，在给他赋值</p></li><li><p>变量赋值规则：</p><ul><li>先在自己作用域内部查找，有就直接赋值</li><li>没有就去上一级作用域内部查找，有就直接赋值</li><li>还没有再去上一级作用域查找，有就直接赋值</li><li>如果一直找到全局作用域都没有，那么就把这个变量定义为全局变量，再给他赋值</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params"></span>) &#123;<br>  num = <span class="hljs-number">100</span><br>&#125;<br><span class="hljs-title function_">fn</span>()<br><br><span class="hljs-comment">// fn 调用以后，要给 num 赋值</span><br><span class="hljs-comment">// 查看自己的作用域内部没有 num 变量</span><br><span class="hljs-comment">// 就会向上一级查找</span><br><span class="hljs-comment">// 上一级就是全局作用域，发现依旧没有</span><br><span class="hljs-comment">// 那么就会把 num 定义为全局的变量，并为其赋值</span><br><span class="hljs-comment">// 所以 fn() 以后，全局就有了一个变量叫做 num 并且值是 100</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(num) <span class="hljs-comment">// 100</span><br></code></pre></td></tr></table></figure></li></ul><h5 id="13-对象"><a href="#13-对象" class="headerlink" title="13. 对象"></a>13. 对象</h5><ul><li><p>对象是一个复杂数据类型</p></li><li><p>其实说是复杂，但是没有很复杂，只不过是存储了一些基本数据类型的一个集合</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123;<br>  <span class="hljs-attr">num</span>: <span class="hljs-number">100</span>,<br>  <span class="hljs-attr">str</span>: <span class="hljs-string">&#x27;hello world&#x27;</span>,<br>  <span class="hljs-attr">boo</span>: <span class="hljs-literal">true</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>这里的 <code>&#123;&#125;</code> 和函数中的 <code>&#123;&#125;</code> 不一样</p></li><li><p>函数里面的是写代码的，而对象里面是写一些数据的</p></li><li><p><strong>对象就是一个键值对的集合</strong></p></li><li><p><code>&#123;&#125;</code> 里面的每一个键都是一个成员</p></li><li><p>也就是说，我们可以把一些数据放在一个对象里面，那么他们就互不干扰了</p></li><li><p>其实就是我们准备一个房子，把我们想要的数据放进去，然后把房子的地址给到变量名，当我们需要某一个数据的时候，就可以根据变量名里面存储的地址找到对应的房子，然后去房子里面找到对应的数据</p></li></ul><h6 id="13-1-创建对象"><a href="#13-1-创建对象" class="headerlink" title="13-1 创建对象"></a>13-1 创建对象</h6><ul><li><p>字面量的方式创建一个对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 创建一个空对象</span><br><span class="hljs-keyword">var</span> obj = &#123;&#125;<br><br><span class="hljs-comment">// 像对象中添加成员</span><br>obj.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;Jack&#x27;</span><br>obj.<span class="hljs-property">age</span> = <span class="hljs-number">18</span><br></code></pre></td></tr></table></figure></li><li><p>内置构造函数的方式创建对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 创建一个空对象</span><br><span class="hljs-keyword">var</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>()<br><br><span class="hljs-comment">// 向对象中添加成员</span><br>obj.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;Rose&#x27;</span><br>obj.<span class="hljs-property">age</span> = <span class="hljs-number">20</span><br></code></pre></td></tr></table></figure><ul><li><code>Object</code> 是 <code>js</code> 内置给我们的构造函数，用于创建一个对象使用的</li></ul></li></ul><h6 id="13-2-数据类型之间存储的区别"><a href="#13-2-数据类型之间存储的区别" class="headerlink" title="13-2 数据类型之间存储的区别"></a>13-2 数据类型之间存储的区别</h6><ul><li>既然我们区分了基本数据类型和复杂数据类型</li><li>那么他们之间就一定会存在一些区别</li><li>他们最大的区别就是在存储上的区别</li><li>我们的存储空间分成两种 <strong>栈</strong> 和 <strong>堆</strong></li><li>栈： 主要存储基本数据类型的内容</li><li>堆： 主要存储复杂数据类型的内容</li></ul><p><strong>基本数据类型在内存中的存储情况</strong></p><ul><li><code>var num = 100</code>，在内存中的存储情况</li><li>直接在 <strong>栈空间</strong> 内有存储一个数据</li></ul><p><strong>复杂数据类型在内存中的存储情况</strong></p><ul><li><p>下面这个 对象 的存储</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Jack&#x27;</span>,<br>  <span class="hljs-attr">age</span>: <span class="hljs-number">18</span>,<br>  <span class="hljs-attr">gender</span>: <span class="hljs-string">&#x27;男&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>复杂数据类型的存储</p><ol><li>在堆里面开辟一个存储空间</li><li>把数据存储到存储空间内</li><li>把存储空间的地址赋值给栈里面的变量</li></ol></li><li><p>这就是数据类型之间存储的区别</p></li></ul><p><strong>数据类型之间的比较</strong></p><ul><li><p>基本数据类型是 <strong>值</strong> 之间的比较</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> num = <span class="hljs-number">1</span><br><span class="hljs-keyword">var</span> str = <span class="hljs-string">&#x27;1&#x27;</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(num == str) <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure></li><li><p>复杂数据类型是 <strong>地址</strong> 之间的比较</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Jack&#x27;</span> &#125;<br><span class="hljs-keyword">var</span> obj2 = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Jack&#x27;</span> &#125;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj == obj2) <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><ul><li>因为我们创建了两个对象，那么就会在 堆空间 里面开辟两个存储空间存储数据（两个地址）</li><li>虽然存储的内容是一样的，那么也是两个存储空间，两个地址</li><li>复杂数据类型之间就是地址的比较，所以 <code>obj</code> 和 <code>obj2</code> 两个变量的地址不一样</li><li>所以我们得到的就是 <code>false</code></li></ul></li></ul><h5 id="14-数组"><a href="#14-数组" class="headerlink" title="14. 数组"></a>14. 数组</h5><ul><li><p>什么是数组？</p></li><li><p>字面理解就是 <strong>数字的组合</strong></p></li><li><p>其实不太准确，准确的来说数组是一个 <strong>数据的集合</strong></p></li><li><p>也就是我们把一些数据放在一个盒子里面，按照顺序排好</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-string">&#x27;hello&#x27;</span>, <span class="hljs-literal">true</span>, <span class="hljs-literal">false</span>]<br></code></pre></td></tr></table></figure></li><li><p>这个东西就是一个数组，存储着一些数据的集合</p></li></ul><p><strong>数据类型分类</strong></p><ul><li><p><code>number</code> &#x2F; <code>string</code> &#x2F; <code>boolean</code> &#x2F; <code>undefined</code> &#x2F; <code>null</code> &#x2F; <code>object</code> &#x2F; <code>function</code>  &#x2F;  <code>array</code> &#x2F; …</p></li><li><p>数组也是数据类型中的一种</p></li><li><p>我们简单的把所有数据类型分为两个大类 <strong>基本数据类型</strong> 和 <strong>复杂数据类型</strong></p></li><li><p>基本数据类型： <code>number</code> &#x2F; <code>string</code> &#x2F; <code>boolean</code> &#x2F; <code>undefined</code> &#x2F; <code>null</code> </p></li><li><p>复杂数据类型： <code>object</code> &#x2F; <code>function</code>  &#x2F;  <code>array</code> &#x2F; …</p></li></ul><h6 id="14-1-创建一个数组"><a href="#14-1-创建一个数组" class="headerlink" title="14-1 创建一个数组"></a>14-1 创建一个数组</h6><ul><li>数组就是一个 <code>[]</code></li><li>在 <code>[]</code> 里面存储着各种各样的数据，按照顺序依次排好</li></ul><p><strong>字面量创建一个数组</strong></p><ul><li><p>直接使用 <code>[]</code> 的方式创建一个数组</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 创建一个空数组</span><br><span class="hljs-keyword">var</span> arr1 = []<br><br><span class="hljs-comment">// 创建一个有内容的数组</span><br><span class="hljs-keyword">var</span> arr2 = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br></code></pre></td></tr></table></figure></li></ul><p><strong>内置构造函数创建数组</strong></p><ul><li><p>使用 <code>js</code> 的内置构造函数 <code>Array</code> 创建一个数组</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 创建一个空数组</span><br><span class="hljs-keyword">var</span> arr1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>()<br><br><span class="hljs-comment">// 创建一个长度为 10 的数组</span><br><span class="hljs-keyword">var</span> arr2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(<span class="hljs-number">10</span>)<br><br><span class="hljs-comment">// 创建一个有内容的数组</span><br><span class="hljs-keyword">var</span> arr3 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)<br></code></pre></td></tr></table></figure></li></ul><h6 id="14-2-数组的-length"><a href="#14-2-数组的-length" class="headerlink" title="14-2 数组的 length"></a>14-2 数组的 length</h6><ul><li><p><code>length</code>:  长度的意思</p></li><li><p><code>length</code> 就是表示数组的长度，数组里面有多少个成员，<code>length</code> 就是多少</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 创建一个数组</span><br><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr.<span class="hljs-property">length</span>) <span class="hljs-comment">// 3</span><br></code></pre></td></tr></table></figure></li></ul><h6 id="14-3-数组的索引"><a href="#14-3-数组的索引" class="headerlink" title="14-3 数组的索引"></a>14-3 数组的索引</h6><ul><li><p>索引，也叫做下标，是指一个数据在数组里面排在第几个的位置</p></li><li><p>注意： <strong>在所有的语言里面，索引都是从 0 开始的</strong></p></li><li><p>在 <code>js</code> 里面也一样，数组的索引从 0 开始</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 创建一个数组</span><br><span class="hljs-keyword">var</span> arr = [<span class="hljs-string">&#x27;hello&#x27;</span>, <span class="hljs-string">&#x27;world&#x27;</span>]<br></code></pre></td></tr></table></figure></li><li><p>上面这个数组中，<strong>第 0 个</strong> 数据就是字符串 <code>hello</code>，<strong>第 1 个</strong> 数据就是字符串 <code>world</code></p></li><li><p>想获取数组中的第几个就使用 <code>数组[索引]</code> 来获取</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> arr = [<span class="hljs-string">&#x27;hello&#x27;</span>, <span class="hljs-string">&#x27;world&#x27;</span>]<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr[<span class="hljs-number">0</span>]) <span class="hljs-comment">// hello</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr[<span class="hljs-number">1</span>]) <span class="hljs-comment">// world</span><br></code></pre></td></tr></table></figure></li></ul><h6 id="14-4-数组的排序"><a href="#14-4-数组的排序" class="headerlink" title="14-4 数组的排序"></a>14-4 数组的排序</h6><ul><li>排序，就是把一个乱序的数组，通过我们的处理，让他变成一个有序的数组</li></ul><p><strong>冒泡排序</strong></p><p><img src="F:/前端学习/视频笔记/javascript/笔记/笔记/笔记.assets/冒泡.gif"></p><ul><li><p>先遍历数组，让挨着的两个进行比较，如果前一个比后一个大，那么就把两个换个位置</p></li><li><p>数组遍历一遍以后，那么最后一个数字就是最大的那个了</p></li><li><p>然后进行第二遍的遍历，还是按照之前的规则，第二大的数字就会跑到倒数第二的位置</p></li><li><p>以此类推，最后就会按照顺序把数组排好了</p><ol><li><p>我们先来准备一个乱序的数组</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">4</span>, <span class="hljs-number">9</span>, <span class="hljs-number">7</span>, <span class="hljs-number">2</span>, <span class="hljs-number">8</span>]<br></code></pre></td></tr></table></figure><ul><li>接下来我们就会用代码让数组排序</li></ul></li><li><p>先不着急循环，先来看数组里面内容换个位置</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 假定我现在要让数组中的第 0 项和第 1 项换个位置</span><br><span class="hljs-comment">// 需要借助第三个变量</span><br><span class="hljs-keyword">var</span> tmp = arr[<span class="hljs-number">0</span>]<br>arr[<span class="hljs-number">0</span>] = arr[<span class="hljs-number">1</span>]<br>arr[<span class="hljs-number">1</span>] = tmp<br></code></pre></td></tr></table></figure></li><li><p>第一次遍历数组，把最大的放到最后面去</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; arr.<span class="hljs-property">length</span>; i++) &#123;<br>  <span class="hljs-comment">// 判断，如果数组中的当前一个比后一个大，那么两个交换一下位置</span><br>  <span class="hljs-keyword">if</span> (arr[i] &gt; arr[i + <span class="hljs-number">1</span>]) &#123;<br>    <span class="hljs-keyword">var</span> tmp = arr[i]<br>    arr[i] = arr[i + <span class="hljs-number">1</span>]<br>    arr[i + <span class="hljs-number">1</span>] = tmp<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 遍历完毕以后，数组就会变成 [3, 1, 5, 6, 4, 7, 2, 8, 9]</span><br></code></pre></td></tr></table></figure><ul><li>第一次结束以后，数组中的最后一个，就会是最大的那个数字</li><li>然后我们把上面的这段代码执行多次。数组有多少项就执行多少次</li></ul></li><li><p>按照数组的长度来遍历多少次</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> j = <span class="hljs-number">0</span>; j &lt; arr.<span class="hljs-property">length</span>; j++) &#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; arr.<span class="hljs-property">length</span>; i++) &#123;<br>    <span class="hljs-comment">// 判断，如果数组中的当前一个比后一个大，那么两个交换一下位置</span><br>    <span class="hljs-keyword">if</span> (arr[i] &gt; arr[i + <span class="hljs-number">1</span>]) &#123;<br>      <span class="hljs-keyword">var</span> tmp = arr[i]<br>      arr[i] = arr[i + <span class="hljs-number">1</span>]<br>      arr[i + <span class="hljs-number">1</span>] = tmp<br>    &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 结束以后，数组就排序好了</span><br></code></pre></td></tr></table></figure></li><li><p>给一些优化</p><ul><li><p>想象一个问题，假设数组长度是 9，第八次排完以后</p></li><li><p>后面八个数字已经按照顺序排列好了，剩下的那个最小的一定是在最前面</p></li><li><p>那么第九次就已经没有意义了，因为最小的已经在最前面了，不会再有任何换位置出现了</p></li><li><p>那么我们第九次遍历就不需要了，所以我们可以减少一次</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> j = <span class="hljs-number">0</span>; j &lt; arr.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>; j++) &#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; arr.<span class="hljs-property">length</span>; i++) &#123;<br>    <span class="hljs-comment">// 判断，如果数组中的当前一个比后一个大，那么两个交换一下位置</span><br>    <span class="hljs-keyword">if</span> (arr[i] &gt; arr[i + <span class="hljs-number">1</span>]) &#123;<br>      <span class="hljs-keyword">var</span> tmp = arr[i]<br>      arr[i] = arr[i + <span class="hljs-number">1</span>]<br>      arr[i + <span class="hljs-number">1</span>] = tmp<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>第二个问题，第一次的时候，已经把最大的数字放在最后面了</p></li><li><p>那么第二次的时候，其实倒数第二个和最后一个就不用比了</p></li><li><p>因为我们就是要把倒数第二大的放在倒数第二的位置，即使比较了，也不会换位置</p></li><li><p>第三次就要倒数第三个数字就不用再和后两个比较了</p></li><li><p>以此类推，那么其实每次遍历的时候，就遍历 <code>当前次数 - 1</code> 次</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> j = <span class="hljs-number">0</span>; j &lt; arr.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>; j++) &#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; arr.<span class="hljs-property">length</span> - <span class="hljs-number">1</span> - j; i++) &#123;<br>    <span class="hljs-comment">// 判断，如果数组中的当前一个比后一个大，那么两个交换一下位置</span><br>    <span class="hljs-keyword">if</span> (arr[i] &gt; arr[i + <span class="hljs-number">1</span>]) &#123;<br>      <span class="hljs-keyword">var</span> tmp = arr[i]<br>      arr[i] = arr[i + <span class="hljs-number">1</span>]<br>      arr[i + <span class="hljs-number">1</span>] = tmp<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>至此，一个冒泡排序就完成了</p></li></ol></li></ul><p><strong>选择排序</strong></p><p><img src="F:/前端学习/视频笔记/javascript/笔记/笔记/笔记.assets/选择.gif"></p><ul><li><p>先假定数组中的第 0 个就是最小的数字的索引</p></li><li><p>然后遍历数组，只要有一个数字比我小，那么就替换之前记录的索引</p></li><li><p>知道数组遍历结束后，就能找到最小的那个索引，然后让最小的索引换到第 0 个的位置</p></li><li><p>再来第二趟遍历，假定第 1 个是最小的数字的索引</p></li><li><p>在遍历一次数组，找到比我小的那个数字的索引</p></li><li><p>遍历结束后换个位置</p></li><li><p>依次类推，也可以把数组排序好</p><ol><li><p>准备一个数组</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">4</span>, <span class="hljs-number">9</span>, <span class="hljs-number">7</span>, <span class="hljs-number">2</span>, <span class="hljs-number">8</span>]<br></code></pre></td></tr></table></figure></li><li><p>假定数组中的第 0 个是最小数字的索引</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> minIndex = <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure></li><li><p>遍历数组，判断，只要数字比我小，那么就替换掉原先记录的索引</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> minIndex = <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; arr.<span class="hljs-property">length</span>; i++) &#123;<br>  <span class="hljs-keyword">if</span> (arr[i] &lt; arr[minIndex]) &#123;<br>    minIndex = i<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 遍历结束后找到最小的索引</span><br><span class="hljs-comment">// 让第 minIndex 个和第 0 个交换</span><br><span class="hljs-keyword">var</span> tmp = arr[minIndex]<br>arr[minIndex] = arr[<span class="hljs-number">0</span>]<br>arr[<span class="hljs-number">0</span>] = tmp<br></code></pre></td></tr></table></figure></li><li><p>按照数组的长度重复执行上面的代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> j = <span class="hljs-number">0</span>; j &lt; arr.<span class="hljs-property">length</span>; j++) &#123;<br>  <span class="hljs-comment">// 因为第一遍的时候假定第 0 个，第二遍的时候假定第 1 个</span><br>  <span class="hljs-comment">// 所以我们要假定第 j 个就行</span><br>  <span class="hljs-keyword">var</span> minIndex = j<br>  <br>  <span class="hljs-comment">// 因为之前已经把最小的放在最前面了，后面的循环就不需要判断前面的了</span><br>  <span class="hljs-comment">// 直接从 j + 1 开始</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = j + <span class="hljs-number">1</span>; i &lt; arr.<span class="hljs-property">length</span>; i++) &#123;<br>    <span class="hljs-keyword">if</span> (arr[i] &lt; arr[minIndex]) &#123;<br>      minIndex = i<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">// 遍历结束后找到最小的索引</span><br>  <span class="hljs-comment">// 第一堂的时候是和第 0 个交换，第二趟的时候是和第 1 个交换</span><br>  <span class="hljs-comment">// 我们直接和第 j 个交换就行</span><br>  <span class="hljs-keyword">var</span> tmp = arr[minIndex]<br>  arr[minIndex] = arr[j]<br>  arr[j] = tmp<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>一些优化</p><ul><li><p>和之前一样，倒数第二次排序完毕以后，就已经排好了，最后一次没有必要了</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> j = <span class="hljs-number">0</span>; j &lt; arr.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>; j++) &#123;<br>  <span class="hljs-keyword">var</span> minIndex = j<br>  <br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = j + <span class="hljs-number">1</span>; i &lt; arr.<span class="hljs-property">length</span>; i++) &#123;<br>    <span class="hljs-keyword">if</span> (arr[i] &lt; arr[minIndex]) &#123;<br>      minIndex = i<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">var</span> tmp = arr[minIndex]<br>  arr[minIndex] = arr[j]<br>  arr[j] = tmp<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>在交换变量之前，可以判断一下，如果我们遍历后得到的索引和当前的索引一直</p></li><li><p>那么就证明当前这个就是目前最小的，那么就没有必要交换</p></li><li><p>做一我们要判断，最小作引和当前作引不一样的时候，才交换</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> j = <span class="hljs-number">0</span>; j &lt; arr.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>; j++) &#123;<br>  <span class="hljs-keyword">var</span> minIndex = j<br>  <br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = j + <span class="hljs-number">1</span>; i &lt; arr.<span class="hljs-property">length</span>; i++) &#123;<br>    <span class="hljs-keyword">if</span> (arr[i] &lt; arr[minIndex]) &#123;<br>      minIndex = i<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">if</span> (minIndex !== j) &#123;<br>    <span class="hljs-keyword">var</span> tmp = arr[minIndex]<br>    arr[minIndex] = arr[j]<br>    arr[j] = tmp   <br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>至此，选择排序完成</p></li></ol></li></ul><h6 id="14-5-数组的常用方法"><a href="#14-5-数组的常用方法" class="headerlink" title="14-5 数组的常用方法"></a>14-5 数组的常用方法</h6><ul><li><p>数组是一个复杂数据类型，我们在操作它的时候就不能再想基本数据类型一样操作了</p></li><li><p>比如我们想改变一个数组</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 创建一个数组</span><br><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br><br><span class="hljs-comment">// 我们想把数组变成只有 1 和 2</span><br>arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>]<br></code></pre></td></tr></table></figure><ul><li>这样肯定是不合理，因为这样不是在改变之前的数组</li><li>相当于心弄了一个数组给到 <code>arr</code> 这个变量了</li><li>相当于把 <code>arr</code> 里面存储的地址给换了，也就是把存储空间换掉了，而不是在之前的空间里面修改</li><li>所以我们就需要借助一些方法，在不改变存储空间的情况下，把存储空间里面的数据改变了</li></ul></li></ul><p><strong>数组常用方法之 push</strong></p><ul><li><p><code>push</code> 是用来在数组的末尾追加一个元素</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br><br><span class="hljs-comment">// 使用 push 方法追加一个元素在末尾</span><br>arr.<span class="hljs-title function_">push</span>(<span class="hljs-number">4</span>)<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr) <span class="hljs-comment">// [1, 2, 3, 4]</span><br></code></pre></td></tr></table></figure></li></ul><p><strong>数组常用方法之 pop</strong></p><ul><li><p><code>pop</code> 是用来删除数组末尾的一个元素</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br><br><span class="hljs-comment">// 使用 pop 方法删除末尾的一个元素</span><br>arr.<span class="hljs-title function_">pop</span>()<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr) <span class="hljs-comment">// [1, 2]</span><br></code></pre></td></tr></table></figure></li></ul><p><strong>数组常用方法之 unshift</strong></p><ul><li><p><code>unshift</code> 是在数组的最前面添加一个元素</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br><br><span class="hljs-comment">// 使用 unshift 方法想数组的最前面添加一个元素</span><br>arr.<span class="hljs-title function_">unshift</span>(<span class="hljs-number">4</span>)<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr) <span class="hljs-comment">// [4, 1, 2, 3]</span><br></code></pre></td></tr></table></figure></li></ul><p><strong>数组常用方法之  shift</strong></p><ul><li><p><code>shift</code> 是删除数组最前面的一个元素</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br><br><span class="hljs-comment">// 使用 shift 方法删除数组最前面的一个元素</span><br>arr.<span class="hljs-title function_">shift</span>()<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr) <span class="hljs-comment">// [2, 3]</span><br></code></pre></td></tr></table></figure></li></ul><p><strong>数组常用方法之 splice</strong></p><ul><li><p><code>splice</code> 是截取数组中的某些内容，按照数组的索引来截取</p></li><li><p>语法： <code>splice(从哪一个索引位置开始，截取多少个，替换的新元素)</code> （第三个参数可以不写）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]<br><br><span class="hljs-comment">// 使用 splice 方法截取数组</span><br>arr.<span class="hljs-title function_">splice</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr) <span class="hljs-comment">// [1, 4, 5]</span><br></code></pre></td></tr></table></figure><ul><li><code>arr.splice(1, 2)</code> 表示从索引 1 开始截取 2 个内容</li><li>第三个参数没有写，就是没有新内容替换掉截取位置</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]<br><br><span class="hljs-comment">// 使用 splice 方法截取数组</span><br>arr.<span class="hljs-title function_">splice</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-string">&#x27;我是新内容&#x27;</span>)<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr) <span class="hljs-comment">// [1, &#x27;我是新内容&#x27;, 4, 5]</span><br></code></pre></td></tr></table></figure><ul><li><code>arr.splice(1, 2, &#39;我是新内容&#39;)</code> 表示从索引 1 开始截取 2 个内容</li><li>然后用第三个参数把截取完空出来的位置填充</li></ul></li></ul><p><strong>数组常用方法之 reverse</strong></p><ul><li><p><code>reverse</code> 是用来反转数组使用的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br><br><span class="hljs-comment">// 使用 reverse 方法来反转数组</span><br>arr.<span class="hljs-title function_">reverse</span>()<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr) <span class="hljs-comment">// [3, 2, 1]</span><br></code></pre></td></tr></table></figure></li></ul><p><strong>数组常用方法之 sort</strong></p><ul><li><p><code>sort</code> 是用来给数组排序的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>]<br><br><span class="hljs-comment">// 使用 sort 方法给数组排序</span><br>arr.<span class="hljs-title function_">sort</span>()<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr) <span class="hljs-comment">// [1, 2, 3]</span><br></code></pre></td></tr></table></figure><ul><li>这个只是一个基本的简单用法</li></ul></li></ul><p><strong>数组常用方法之 concat</strong></p><ul><li><p><code>concat</code> 是把多个数组进行拼接</p></li><li><p>和之前的方法有一些不一样的地方，就是 <code>concat</code> 不会改变原始数组，而是返回一个新的数组</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br><br><span class="hljs-comment">// 使用 concat 方法拼接数组</span><br><span class="hljs-keyword">var</span> newArr = arr.<span class="hljs-title function_">concat</span>([<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>])<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr) <span class="hljs-comment">// [1, 2, 3]</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(newArr) <span class="hljs-comment">// [1, 2, 3, 4, 5, 6]</span><br></code></pre></td></tr></table></figure><ul><li>注意： <strong><code>concat</code> 方法不会改变原始数组</strong></li></ul></li></ul><p><strong>数组常用方法之 join</strong></p><ul><li><p><code>join</code> 是把数组里面的每一项内容链接起来，变成一个字符串</p></li><li><p>可以自己定义每一项之间链接的内容 <code>join(要以什么内容链接)</code></p></li><li><p>不会改变原始数组，而是把链接好的字符串返回</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br><br><span class="hljs-comment">// 使用 join 链接数组</span><br><span class="hljs-keyword">var</span> str = arr.<span class="hljs-title function_">join</span>(<span class="hljs-string">&#x27;-&#x27;</span>)<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr) <span class="hljs-comment">// [1, 2, 3]</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str) <span class="hljs-comment">// 1-2-3</span><br></code></pre></td></tr></table></figure><ul><li>注意： <strong>join 方法不会改变原始数组，而是返回链接好的字符串</strong></li></ul></li></ul><p><strong>数组常用方法之 indexOf</strong></p><ul><li><p><code>indexOf</code> 用来找到数组中某一项的索引</p></li><li><p>语法： <code>indexOf(你要找的数组中的项)</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]<br><br><span class="hljs-comment">// 使用 indexOf 超找数组中的某一项</span><br><span class="hljs-keyword">var</span> index = arr.<span class="hljs-title function_">indexOf</span>(<span class="hljs-number">3</span>)<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(index) <span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure><ul><li>我们要找的是数组中值为 3 的那一项</li><li>返回的就是值为 3 的那一项在该数组中的索引</li></ul></li><li><p>如果你要找的内容在数组中没有，那么就会返回 -1</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]<br><br><span class="hljs-comment">// 使用 indexOf 超找数组中的某一项</span><br><span class="hljs-keyword">var</span> index = arr.<span class="hljs-title function_">indexOf</span>(<span class="hljs-number">10</span>)<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(index) <span class="hljs-comment">// -1</span><br></code></pre></td></tr></table></figure><ul><li>你要找的值在数组中不存在，那么就会返回 -1</li></ul></li></ul><p><strong>数组常用方法之 forEach</strong></p><ul><li><p>和 <code>for</code> 循环一个作用，就是用来遍历数组的</p></li><li><p>语法：<code>arr.forEach(function (item, index, arr) &#123;&#125;)</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br><br><span class="hljs-comment">// 使用 forEach 遍历数组</span><br>arr.<span class="hljs-title function_">forEach</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">item, index, arr</span>) &#123;<br>  <span class="hljs-comment">// item 就是数组中的每一项</span><br>  <span class="hljs-comment">// index 就是数组的索引</span><br>  <span class="hljs-comment">// arr 就是原始数组</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;数组的第 &#x27;</span> + index + <span class="hljs-string">&#x27; 项的值是 &#x27;</span> + item + <span class="hljs-string">&#x27;，原始数组是&#x27;</span>, arr)<br>&#125;)<br></code></pre></td></tr></table></figure><ul><li><code>forEach()</code> 的时候传递的那个函数，会根据数组的长度执行</li><li>数组的长度是多少，这个函数就会执行多少回</li></ul></li></ul><p><strong>数组常用方法之 map</strong> </p><ul><li><p>和 <code>forEach</code> 类似，只不过可以对数组中的每一项进行操作，返回一个新的数组</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br><br><span class="hljs-comment">// 使用 map 遍历数组</span><br><span class="hljs-keyword">var</span> newArr = arr.<span class="hljs-title function_">map</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">item, index, arr</span>) &#123;<br>  <span class="hljs-comment">// item 就是数组中的每一项</span><br>  <span class="hljs-comment">// index 就是数组的索引</span><br>  <span class="hljs-comment">// arr 就是原始数组</span><br>  <span class="hljs-keyword">return</span> item + <span class="hljs-number">10</span><br>&#125;)<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(newArr) <span class="hljs-comment">// [11, 12, 13]</span><br></code></pre></td></tr></table></figure></li></ul><p><strong>数组常用方法之 filter</strong></p><ul><li><p>和 <code>map</code> 的使用方式类似，按照我们的条件来筛选数组</p></li><li><p>把原始数组中满足条件的筛选出来，组成一个新的数组返回</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br><br><span class="hljs-comment">// 使用 filter 过滤数组</span><br><span class="hljs-keyword">var</span> newArr = arr.<span class="hljs-title function_">filter</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">item, index, arr</span>) &#123;<br>  <span class="hljs-comment">// item 就是数组中的每一项</span><br>  <span class="hljs-comment">// index 就是数组的索引</span><br>  <span class="hljs-comment">// arr 就是原始数组</span><br>  <span class="hljs-keyword">return</span> item &gt; <span class="hljs-number">1</span><br>&#125;)<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(newArr) <span class="hljs-comment">// [2, 3]</span><br></code></pre></td></tr></table></figure><ul><li>我们设置的条件就是 <code>&gt; 1</code></li><li>返回的新数组就会是原始数组中所有 <code>&gt; 1</code> 的项</li></ul></li></ul><h5 id="15-字符串"><a href="#15-字符串" class="headerlink" title="15 字符串"></a>15 字符串</h5><h6 id="15-1-创建字符串"><a href="#15-1-创建字符串" class="headerlink" title="15-1 创建字符串"></a>15-1 创建字符串</h6><ul><li><p>我们创建字符串也分为两种方法 <strong>字面量</strong> 和 <strong>构造函数</strong></p></li><li><p>字面量： </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> str = <span class="hljs-string">&#x27;hello&#x27;</span><br></code></pre></td></tr></table></figure></li><li><p>构造函数创建</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> str = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&#x27;hello&#x27;</span>)<br></code></pre></td></tr></table></figure></li></ul><h6 id="15-2-字符集"><a href="#15-2-字符集" class="headerlink" title="15-2 字符集"></a>15-2 字符集</h6><p><strong>ASCII 字符集</strong></p><ul><li>我们都知道，计算机只能存储 <code>0101010</code> 这样的二进制数字</li><li>那么我们的 <code>a ~ z</code> &#x2F; <code>A ~ Z</code> &#x2F; <code>$</code> &#x2F; <code>@</code> &#x2F;… 之类的内容也有由二进制数字组成的</li><li>我们可以简单的理解为， <code>a ~ z</code> &#x2F; <code>A ~ Z</code> &#x2F; <code>$</code> &#x2F; <code>@</code> &#x2F;… 之类的内容都有一个自己的编号，然后在计算机存储的时候，是存储的这些编号，我们看的时候，也是通过这些编号在解析成我们要看到的内容给我们看到</li><li><img src="F:/前端学习/视频笔记/javascript/笔记/笔记/笔记.assets/ASCII控制字符.png"></li><li><img src="F:/前端学习/视频笔记/javascript/笔记/笔记/笔记.assets/ASCII显示字符.png"></li><li>上面的就是 ASCII 对照表，我们只需要知道他是这么存储的就好</li></ul><p><strong>unicode 编码</strong></p><ul><li>我们看到了，<code>ASCII</code> 只有这 <code>128</code> 个字符的编码结构</li><li>但是因为 <code>ASCII</code> 出现的比较早，而且是美国发明的，早先时候这些内容就够用了</li><li>因为存储一些英文的内容，传递一些英文的文章什么的都够用了</li><li>那么对于这个世界来说肯定是不够用的</li><li>因为我们的汉字没有办法存储，包括一些其他国家的语言也没有办法存储</li><li>所以就出现了 <code>unicode</code> 编码，也叫（万国码，统一码）</li><li><code>unicode</code> 对照表就是一个和 <code>ASCII</code> 一样的对照表，只不过变得很大很大，因为存储的内容特别的多</li><li>而且包含了世界上大部分国家的文字，所以我们的文字和字符现在在存储的时候，都是按照 <code>unicode</code> 编码转换成数字进行存储</li><li>我们的 <code>UTF-8</code> 就是一种 <code>8 位的 unicode</code> 字符集</li></ul><h6 id="15-3-字符串的常用方法"><a href="#15-3-字符串的常用方法" class="headerlink" title="15-3 字符串的常用方法"></a>15-3 字符串的常用方法</h6><ul><li>我们操作字符串，也有一堆的方法来帮助我们操作</li><li>字符串和数组有一个一样的地方，也是按照索引来排列的</li></ul><p><strong>charAt</strong></p><ul><li><p><code>charAt(索引)</code>  是找到字符串中指定索引位置的内容返回</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> str = <span class="hljs-string">&#x27;Jack&#x27;</span><br><br><span class="hljs-comment">// 使用 charAt 找到字符串中的某一个内容</span><br><span class="hljs-keyword">var</span> index = str.<span class="hljs-title function_">charAt</span>(<span class="hljs-number">2</span>)<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(index) <span class="hljs-comment">// c</span><br></code></pre></td></tr></table></figure><ul><li>因为字符串也是按照索引进行排列的，也是同样从 0 开始</li><li>所以索引 2 的位置就是 <code>c</code></li></ul></li><li><p>如果没有对应的索引，那么就会返回 空字符串</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> str = <span class="hljs-string">&#x27;Jack&#x27;</span><br><br><span class="hljs-comment">// 使用 charAt 找到字符串中的某一个内容</span><br><span class="hljs-keyword">var</span> index = str.<span class="hljs-title function_">charAt</span>(<span class="hljs-number">10</span>)<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(index) <span class="hljs-comment">// &#x27;&#x27;</span><br></code></pre></td></tr></table></figure><ul><li>这个字符串根本没有索引 10 的位置</li><li>所以就会返回一个空字符串 <code>&#39;&#39;</code></li></ul></li></ul><p><strong>charCodeAt</strong></p><ul><li><p><code>charCodeAt(索引)</code> 就是返回对应索引位置的 <code>unicode</code> 编码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> str = <span class="hljs-string">&#x27;Jack&#x27;</span><br><br><span class="hljs-comment">// 使用 charAt 找到字符串中的某一个内容</span><br><span class="hljs-keyword">var</span> index = str.<span class="hljs-title function_">charCodeAt</span>(<span class="hljs-number">0</span>)<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(index) <span class="hljs-comment">// 74</span><br></code></pre></td></tr></table></figure><ul><li>因为 <code>J</code> 在 <code>unicode</code> 对照表里面存储的是 74，所以就会返回 74</li></ul></li></ul><p><strong>indexOf</strong></p><ul><li><p><code>indexOf</code> 就是按照字符找到对应的索引</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> str = <span class="hljs-string">&#x27;Jack&#x27;</span><br><br><span class="hljs-comment">// 使用 indexOf 找到对应的索引</span><br><span class="hljs-keyword">var</span> index = str.<span class="hljs-title function_">indexOf</span>(<span class="hljs-string">&#x27;J&#x27;</span>)<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(index) <span class="hljs-comment">// 0</span><br></code></pre></td></tr></table></figure><ul><li>因为字符 <code>J</code> 在字符串 <code>Jack</code> 中的索引位置是 0</li><li>所以会返回 0</li></ul></li></ul><p><strong>substring</strong></p><ul><li><p><code>substring</code> 是用来截取字符串使用的</p></li><li><p>语法： <code>substring(从哪个索引开始，到哪个索引截止)</code>，包含开始索引，不包含结束索引</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> str = <span class="hljs-string">&#x27;hello&#x27;</span><br><span class="hljs-comment">//         01234</span><br><br><span class="hljs-comment">// 使用 substring 截取字符串</span><br><span class="hljs-keyword">var</span> newStr = str.<span class="hljs-title function_">substring</span>(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>)<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(newStr) <span class="hljs-comment">// el</span><br></code></pre></td></tr></table></figure><ul><li>从索引 1 开始，到索引 3 截止，包含前面的索引不包含后面的索引</li><li>所以返回的是 el</li></ul></li></ul><p><strong>substr</strong></p><ul><li><p><code>substr</code> 也是用来截取字符串的</p></li><li><p>语法：<code>substr(从哪个索引开始，截取多少个)</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> str = <span class="hljs-string">&#x27;hello&#x27;</span><br><span class="hljs-comment">//         01234</span><br><br><span class="hljs-comment">// 使用 substr 截取字符串</span><br><span class="hljs-keyword">var</span> newStr = str.<span class="hljs-title function_">substr</span>(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>)<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(newStr) <span class="hljs-comment">// ell</span><br></code></pre></td></tr></table></figure><ul><li>这个方法和 <code>substring</code> 不一样的是，第二个参数是截取多少个</li><li>从索引 1 开始，截取 3 个，所以得到的是 <code>ell</code></li></ul></li></ul><p><strong>toLowerCase 和 toUpperCase</strong></p><ul><li><p>这两个方法分别使用用来给字符串转成 <strong>小写字母</strong> 和 <strong>大写字母</strong> 的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> str = hello<br><br><span class="hljs-comment">// 使用 toUpperCase 转换成大写</span><br><span class="hljs-keyword">var</span> upper = str.<span class="hljs-title function_">toUpperCase</span>()<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(upper) <span class="hljs-comment">// HELLO</span><br><br><span class="hljs-comment">// 使用 toLowerCase 转换成小写</span><br><span class="hljs-keyword">var</span> lower = upper.<span class="hljs-title function_">toLowerCase</span>()<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(lower) <span class="hljs-comment">// hello</span><br></code></pre></td></tr></table></figure></li></ul><h5 id="16-Math"><a href="#16-Math" class="headerlink" title="16 Math"></a>16 Math</h5><ul><li>Math 是 js 的一个内置对象，提供了一堆的方法帮助我们操作 <strong>数字</strong></li></ul><h6 id="16-1-random"><a href="#16-1-random" class="headerlink" title="16-1 random"></a>16-1 random</h6><ul><li><p><code>Math.random()</code> 这个方法是用来生成一个 <code>0 ~ 1</code> 之间的随机数</p></li><li><p>每次执行生成的数字都不一样，但是一定是 <code>0 ~ 1</code> 之间的</p></li><li><p><strong>生成的数字包含 0 ，但是不包含 1</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> num = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>()<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(num) <span class="hljs-comment">// 得到一个随机数</span><br></code></pre></td></tr></table></figure></li></ul><h6 id="16-2-round"><a href="#16-2-round" class="headerlink" title="16-2 round"></a>16-2 round</h6><ul><li><p><code>Math.round()</code> 是将一个小数 <strong>四舍五入</strong> 变成一个整数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> num = <span class="hljs-number">10.1</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">round</span>(num)) <span class="hljs-comment">// 10</span><br><br><span class="hljs-keyword">var</span> num2 = <span class="hljs-number">10.6</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">round</span>(num2)) <span class="hljs-comment">// 11</span><br></code></pre></td></tr></table></figure></li></ul><h6 id="16-3-abs"><a href="#16-3-abs" class="headerlink" title="16-3 abs"></a>16-3 abs</h6><ul><li><p><code>Math.abs()</code> 是返回一个数字的 <strong>绝对值</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> num = -<span class="hljs-number">10</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(math.<span class="hljs-title function_">abs</span>(num)) <span class="hljs-comment">// 10</span><br></code></pre></td></tr></table></figure></li></ul><h6 id="16-4-ceil"><a href="#16-4-ceil" class="headerlink" title="16-4 ceil"></a>16-4 ceil</h6><ul><li><p><code>Math.ceil()</code> 是将一个小数 <strong>向上取整</strong> 得到的整数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> num = <span class="hljs-number">10.1</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">ceil</span>(num)) <span class="hljs-comment">// 11</span><br><br><span class="hljs-keyword">var</span> num2 = <span class="hljs-number">10.9</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">ceil</span>(num2)) <span class="hljs-comment">// 11</span><br></code></pre></td></tr></table></figure></li></ul><h6 id="16-5-floor"><a href="#16-5-floor" class="headerlink" title="16-5 floor"></a>16-5 floor</h6><ul><li><p><code>Math.floor()</code> 是将一个小数 <strong>向下取整</strong> 的到的整数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> num = <span class="hljs-number">10.1</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(num)) <span class="hljs-comment">// 10</span><br><br><span class="hljs-keyword">var</span> num2 = <span class="hljs-number">10.9</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(num2)) <span class="hljs-comment">// 10</span><br></code></pre></td></tr></table></figure></li></ul><h6 id="16-6-max"><a href="#16-6-max" class="headerlink" title="16-6 max"></a>16-6 max</h6><ul><li><p><code>Math.max()</code> 得到的是你传入的几个数字之中 <strong>最大</strong> 的那个数字</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>)) <span class="hljs-comment">// 5</span><br></code></pre></td></tr></table></figure></li></ul><h6 id="16-7-min"><a href="#16-7-min" class="headerlink" title="16-7 min"></a>16-7 min</h6><ul><li><p><code>Math.min()</code> 得到的是你传入的几个数字之中 <strong>最小</strong> 的那个数字</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">min</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>)) <span class="hljs-comment">// 1</span><br></code></pre></td></tr></table></figure></li></ul><h6 id="16-8-PI"><a href="#16-8-PI" class="headerlink" title="16-8 PI"></a>16-8 PI</h6><ul><li><p><code>Math.PI</code> 得到的是 <code>π</code> 的值，也就是 <code>3.1415936...</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-property">PI</span>) <span class="hljs-comment">// 3.141592653589793</span><br></code></pre></td></tr></table></figure><ul><li>因为计算机的计算精度问题，只能得到小数点后 15 位</li><li><strong>使用 Math.PI 的时候，是不需要加 () 的</strong></li></ul></li></ul><h5 id="17-Date"><a href="#17-Date" class="headerlink" title="17 Date"></a>17 Date</h5><ul><li><code>js</code> 提供的内置构造函数，专门用来获取时间的</li></ul><h6 id="17-1-new-Date"><a href="#17-1-new-Date" class="headerlink" title="17-1 new Date()"></a>17-1 new Date()</h6><ul><li><p><code>new Date()</code> 在不传递参数的情况下是默认返回当前时间</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> time = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>()<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(time) <span class="hljs-comment">// 当前时间 Fri Mar 01 2019 13:11:23 GMT+0800 (中国标准时间)</span><br></code></pre></td></tr></table></figure></li><li><p><code>new Date()</code> 在传入参数的时候，可以获取到一个你传递进去的时间</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> time = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(<span class="hljs-string">&#x27;2019-03-03 13:11:11&#x27;</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(time) <span class="hljs-comment">// Sun Mar 03 2019 13:11:11 GMT+0800 (中国标准时间)</span><br></code></pre></td></tr></table></figure></li><li><p><code>new Date()</code> 传递的参数有多种情况</p><ol><li><p>传递两个数字，第一个表示年，第二个表示月份</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> time = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(<span class="hljs-number">2019</span>, <span class="hljs-number">00</span>) <span class="hljs-comment">// 月份从 0 开始计数，0 表示 1月，11 表示 12月</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(time) <span class="hljs-comment">// Tue Jan 01 2019 00:00:00 GMT+0800 (中国标准时间)</span><br></code></pre></td></tr></table></figure></li><li><p>传递三个数字，前两个不变，第三个表示该月份的第几天，从 1 到 31</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> time = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(<span class="hljs-number">2019</span>, <span class="hljs-number">00</span>, <span class="hljs-number">05</span>) <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(time) <span class="hljs-comment">// Sat Jan 05 2019 00:00:00 GMT+0800 (中国标准时间)</span><br></code></pre></td></tr></table></figure></li><li><p>传递四个数字，前三个不变，第四个表示当天的几点，从 0 到 23</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> time = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(<span class="hljs-number">2019</span>, <span class="hljs-number">00</span>, <span class="hljs-number">05</span>, <span class="hljs-number">22</span>) <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(time) <span class="hljs-comment">// Sat Jan 05 2019 22:00:00 GMT+0800 (中国标准时间)</span><br></code></pre></td></tr></table></figure></li><li><p>传递五个数字，前四个不变，第五个表示的是该小时的多少分钟，从 0 到 59</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> time = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(<span class="hljs-number">2019</span>, <span class="hljs-number">00</span>, <span class="hljs-number">05</span>, <span class="hljs-number">22</span>, <span class="hljs-number">33</span>) <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(time) <span class="hljs-comment">// Sat Jan 05 2019 22:33:00 GMT+0800 (中国标准时间)</span><br></code></pre></td></tr></table></figure></li><li><p>传递六个数字，前五个不变，第六个表示该分钟的多少秒，从 0 到 59</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> time = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(<span class="hljs-number">2019</span>, <span class="hljs-number">00</span>, <span class="hljs-number">05</span>, <span class="hljs-number">22</span>, <span class="hljs-number">33</span>, <span class="hljs-number">55</span>) <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(time) <span class="hljs-comment">// Sat Jan 05 2019 22:33:55 GMT+0800 (中国标准时间)</span><br></code></pre></td></tr></table></figure></li><li><p>传入字符串的形式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(<span class="hljs-string">&#x27;2019&#x27;</span>)) <br><span class="hljs-comment">// Tue Jan 01 2019 08:00:00 GMT+0800 (中国标准时间)</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(<span class="hljs-string">&#x27;2019-02&#x27;</span>)) <br><span class="hljs-comment">// Fri Feb 01 2019 08:00:00 GMT+0800 (中国标准时间)</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(<span class="hljs-string">&#x27;2019-02-03&#x27;</span>)) <br><span class="hljs-comment">// Sun Feb 03 2019 08:00:00 GMT+0800 (中国标准时间)</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(<span class="hljs-string">&#x27;2019-02-03 13:&#x27;</span>)) <br><span class="hljs-comment">// Sun Feb 03 2019 13:00:00 GMT+0800 (中国标准时间)</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(<span class="hljs-string">&#x27;2019-02-03 13:13:&#x27;</span>)) <br><span class="hljs-comment">// Sun Feb 03 2019 13:13:00 GMT+0800 (中国标准时间)</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(<span class="hljs-string">&#x27;2019-02-03 13:13:13&#x27;</span>)) <br><span class="hljs-comment">// Sun Feb 03 2019 13:13:13 GMT+0800 (中国标准时间)</span><br></code></pre></td></tr></table></figure></li></ol></li></ul><h6 id="17-2-将日期字符串格式化成指定内容"><a href="#17-2-将日期字符串格式化成指定内容" class="headerlink" title="17-2  将日期字符串格式化成指定内容"></a>17-2  将日期字符串格式化成指定内容</h6><ul><li>比如我们得到的时间字符串是 <code>Sun Feb 03 2019 13:13:13 GMT+0800 (中国标准时间)</code></li><li>我指向得到这个日期中是那一年，我们就要靠截取字符串的形式得到</li><li>但是现在 <code>js</code> 为我们提供了一系列的方法来得到里面的指定内容</li></ul><p><strong>getFullYear</strong></p><ul><li><p><code>getFullYear()</code> 方式是得到指定字符串中的哪一年</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> time = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(<span class="hljs-number">2019</span>, <span class="hljs-number">03</span>, <span class="hljs-number">03</span>, <span class="hljs-number">08</span>, <span class="hljs-number">00</span>, <span class="hljs-number">22</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(time.<span class="hljs-title function_">getFullYear</span>()) <span class="hljs-comment">// 2019</span><br></code></pre></td></tr></table></figure></li></ul><p><strong>getMonth</strong></p><ul><li><p><code>getMonth()</code> 方法是得到指定字符串中的哪一个月份 </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> time = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(<span class="hljs-number">2019</span>, <span class="hljs-number">03</span>, <span class="hljs-number">03</span>, <span class="hljs-number">08</span>, <span class="hljs-number">00</span>, <span class="hljs-number">22</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(time.<span class="hljs-title function_">getMonth</span>()) <span class="hljs-comment">// 3</span><br></code></pre></td></tr></table></figure><ul><li>这里要有一个注意的地方</li><li>月份是从 0 开始数的</li><li>0 表示 1月，1 表示 2月，依此类推</li></ul></li></ul><p><strong>getDate</strong></p><ul><li><p><code>getDate()</code> 方法是得到指定字符串中的哪一天</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> time = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(<span class="hljs-number">2019</span>, <span class="hljs-number">03</span>, <span class="hljs-number">03</span>, <span class="hljs-number">08</span>, <span class="hljs-number">00</span>, <span class="hljs-number">22</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(time.<span class="hljs-title function_">getDate</span>()) <span class="hljs-comment">// 3</span><br></code></pre></td></tr></table></figure></li></ul><p><strong>getHours</strong></p><ul><li><p><code>getHours()</code> 方法是得到指定字符串中的哪小时</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> time = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(<span class="hljs-number">2019</span>, <span class="hljs-number">03</span>, <span class="hljs-number">03</span>, <span class="hljs-number">08</span>, <span class="hljs-number">00</span>, <span class="hljs-number">22</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(time.<span class="hljs-title function_">getHours</span>()) <span class="hljs-comment">// 8</span><br></code></pre></td></tr></table></figure></li></ul><p><strong>getMinutes</strong></p><ul><li><p><code>getMinutes()</code> 方法是得到指定字符串中的哪分钟</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> time = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(<span class="hljs-number">2019</span>, <span class="hljs-number">03</span>, <span class="hljs-number">03</span>, <span class="hljs-number">08</span>, <span class="hljs-number">00</span>, <span class="hljs-number">22</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(time.<span class="hljs-title function_">getMinutes</span>()) <span class="hljs-comment">// 0</span><br></code></pre></td></tr></table></figure></li></ul><p><strong>getSeconds</strong></p><ul><li><p><code>getSeconds()</code> 方法是得到指定字符串中的哪秒钟</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> time = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(<span class="hljs-number">2019</span>, <span class="hljs-number">03</span>, <span class="hljs-number">03</span>, <span class="hljs-number">08</span>, <span class="hljs-number">00</span>, <span class="hljs-number">22</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(time.<span class="hljs-title function_">getSeconds</span>()) <span class="hljs-comment">// 22</span><br></code></pre></td></tr></table></figure></li></ul><p><strong>getDay</strong></p><ul><li><p><code>getDay()</code> 方法是得到指定字符串当前日期是一周中的第几天（周日是 0，周六是 6）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> time = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(<span class="hljs-number">2019</span>, <span class="hljs-number">03</span>, <span class="hljs-number">08</span>, <span class="hljs-number">08</span>, <span class="hljs-number">00</span>, <span class="hljs-number">22</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(time.<span class="hljs-title function_">getDay</span>()) <span class="hljs-comment">// 1</span><br></code></pre></td></tr></table></figure></li></ul><p><strong>getTime</strong></p><ul><li><p><code>getTime()</code> 方法是得到执行时间到 <code>格林威治时间</code> 的毫秒数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> time = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(<span class="hljs-number">2019</span>, <span class="hljs-number">03</span>, <span class="hljs-number">08</span>, <span class="hljs-number">08</span>, <span class="hljs-number">00</span>, <span class="hljs-number">22</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(time.<span class="hljs-title function_">getTime</span>()) <span class="hljs-comment">// 1554681622000</span><br></code></pre></td></tr></table></figure></li></ul><p><strong>获取时间差</strong></p><ul><li>是指获取两个时间点之间相差的时间</li><li>在 js 中是不能用时间直接做 减法 的</li><li>我们需要一些特殊的操作</li><li>在编程的世界里面，有一个特殊的时间，是 <code>1970年01月01日00时00分00秒</code></li><li>这个时间我们叫做 <code>格林威治时间</code></li><li>所有的编程世界里面，这个时间都是一样的，而且 <code>格林威治时间</code> 的数字是 0</li><li>从 <code>格林威治时间</code> 开始，每经过1毫秒，数字就会 + 1</li><li>所以我们可以获取到任意一个时间节点到 <code>格林威治时间</code> 的毫秒数</li><li>然后在用两个毫秒数相减，就能得到两个时间点之间相差的毫秒数</li><li>我们在通过这个毫秒数得到准确的时间</li></ul><h5 id="18-定时器"><a href="#18-定时器" class="headerlink" title="18 定时器"></a>18 定时器</h5><ul><li>在 <code>js</code> 里面，有两种定时器，<strong>倒计时定时器</strong> 和 <strong>间隔定时器</strong></li></ul><h6 id="18-1-倒计时定时器"><a href="#18-1-倒计时定时器" class="headerlink" title="18-1 倒计时定时器"></a>18-1 倒计时定时器</h6><ul><li><p>倒计时多少时间以后执行函数</p></li><li><p>语法： <code>setTimeout(要执行的函数，多长时间以后执行)</code></p></li><li><p>会在你设定的时间以后，执行函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> timerId = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;我执行了&#x27;</span>)<br>&#125;, <span class="hljs-number">1000</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(timerId) <span class="hljs-comment">// 1</span><br></code></pre></td></tr></table></figure><ul><li>时间是按照毫秒进行计算的，1000 毫秒就是 1秒钟</li><li>所以会在页面打开 1 秒钟以后执行函数</li><li>只执行一次，就不在执行了</li><li>返回值是，当前这个定时器是页面中的第几个定时器</li></ul></li></ul><h6 id="18-2-间隔定时器"><a href="#18-2-间隔定时器" class="headerlink" title="18-2 间隔定时器"></a>18-2 间隔定时器</h6><ul><li><p>每间隔多少时间就执行一次函数</p></li><li><p>语法： <code>setInterval(要执行的函数，间隔多少时间)</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> timerId = <span class="hljs-built_in">setInterval</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;我执行了&#x27;</span>)<br>&#125;, <span class="hljs-number">1000</span>)<br></code></pre></td></tr></table></figure><ul><li>时间和刚才一样，是按照毫秒进行计算的</li><li>每间隔 1 秒钟执行一次函数</li><li>只要不关闭，会一直执行</li><li>返回值是，当前这个定时器是页面中的第几个定时器</li></ul></li></ul><h6 id="18-3-定时器的返回值"><a href="#18-3-定时器的返回值" class="headerlink" title="18-3 定时器的返回值"></a>18-3 定时器的返回值</h6><ul><li><p>设置定时器的时候，他的返回值是部分 <code>setTimeout</code> 和 <code>setInterval</code> 的</p></li><li><p>只要有一个定时器，那么就是一个数字</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> timerId = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;倒计时定时器&#x27;</span>)<br>&#125;, <span class="hljs-number">1000</span>)<br><br><span class="hljs-keyword">var</span> timerId2 = <span class="hljs-built_in">setInterval</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;间隔定时器&#x27;</span>)<br>&#125;, <span class="hljs-number">1000</span>)<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(timerId) <span class="hljs-comment">// 1</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(timerId2) <span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure></li></ul><h6 id="18-4-关闭定时器"><a href="#18-4-关闭定时器" class="headerlink" title="18-4 关闭定时器"></a>18-4 关闭定时器</h6><ul><li><p>我们刚才提到过一个 <code>timerId</code>，是表示这个定时器是页面上的第几个定时器</p></li><li><p>这个 <code>timerId</code> 就是用来关闭定时器的数字</p></li><li><p>我们有两个方法来关闭定时器 <code>clearTimeout</code> 和 <code>clearInterval</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> timerId = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;倒计时定时器&#x27;</span>)<br>&#125;, <span class="hljs-number">1000</span>)<br><span class="hljs-built_in">clearTimeout</span>(timerId)<br></code></pre></td></tr></table></figure><ul><li>关闭以后，定时器就不会在执行了</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> timerId2 = <span class="hljs-built_in">setInterval</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;间隔定时器&#x27;</span>)<br>&#125;, <span class="hljs-number">1000</span>)<br><span class="hljs-title function_">coearInterval</span>(timerId2)<br></code></pre></td></tr></table></figure><ul><li>关闭以后定时器就不会在执行了</li></ul></li><li><p>原则上是</p><ul><li><code>clearTimeout</code> 关闭 <code>setTimeout</code></li><li><code>clearInterval</code> 关闭 <code>setInterval</code></li></ul></li><li><p>但是其实是可以通用的，他们可以混着使用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> timerId = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;倒计时定时器&#x27;</span>)<br>&#125;, <span class="hljs-number">1000</span>)<br><span class="hljs-comment">// 关闭倒计时定时器</span><br><span class="hljs-built_in">clearInterval</span>(timerId)<br><br><span class="hljs-keyword">var</span> timerId2 = <span class="hljs-built_in">setInterval</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;间隔定时器&#x27;</span>)<br>&#125;, <span class="hljs-number">1000</span>)<br><span class="hljs-comment">// 关闭间隔定时器</span><br><span class="hljs-built_in">clearTimeout</span>(timerId2)<br></code></pre></td></tr></table></figure></li></ul><h4 id="二-BOM"><a href="#二-BOM" class="headerlink" title="二 BOM"></a>二 BOM</h4><ul><li><code>BOM（Browser Object Model）</code>： 浏览器对象模型</li><li>其实就是操作浏览器的一些能力</li><li>我们可以操作哪些内容<ul><li>获取一些浏览器的相关信息（窗口的大小）</li><li>操作浏览器进行页面跳转</li><li>获取当前浏览器地址栏的信息</li><li>操作浏览器的滚动条</li><li>浏览器的信息（浏览器的版本）</li><li>让浏览器出现一个弹出框（<code>alert</code> &#x2F; <code>confirm</code> &#x2F; <code>prompt</code>）</li><li>…</li></ul></li><li><code>BOM</code> 的核心就是 <code>window</code> 对象</li><li><code>window</code> 是浏览器内置的一个对象，里面包含着操作浏览器的方法</li></ul><h5 id="1-获取浏览器窗口的尺寸"><a href="#1-获取浏览器窗口的尺寸" class="headerlink" title="1. 获取浏览器窗口的尺寸"></a>1. 获取浏览器窗口的尺寸</h5><ul><li><p><code> innerHeight</code> 和 <code>innerWidth</code></p></li><li><p>这两个方法分别是用来获取浏览器窗口的宽度和高度（包含滚动条的）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> windowHeight = <span class="hljs-variable language_">window</span>.<span class="hljs-property">innerHeight</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(windowHeight)<br><br><span class="hljs-keyword">var</span> windowWidth = <span class="hljs-variable language_">window</span>.<span class="hljs-property">innerWidth</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(windowWidth)<br></code></pre></td></tr></table></figure></li></ul><h5 id="2-浏览器的弹出层"><a href="#2-浏览器的弹出层" class="headerlink" title="2. 浏览器的弹出层"></a>2. 浏览器的弹出层</h5><ul><li><p><code>alert</code> 是在浏览器弹出一个提示框</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">window</span>.<span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;我是一个提示框&#x27;</span>)<br></code></pre></td></tr></table></figure><p><img src="F:/前端学习/视频笔记/javascript/笔记/笔记/笔记.assets/alert.png"></p><ul><li>这个弹出层知识一个提示内容，只有一个确定按钮</li><li>点击确定按钮以后，这个提示框就消失了</li></ul></li><li><p><code>confirm</code> 是在浏览器弹出一个询问框</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> boo = <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">confirm</span>(<span class="hljs-string">&#x27;我是一个询问框&#x27;</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(boo)<br></code></pre></td></tr></table></figure><p><img src="F:/前端学习/视频笔记/javascript/笔记/笔记/笔记.assets/confirm.png"></p><ul><li>这个弹出层有一个询问信息和两个按钮</li><li>当你点击确定的时候，就会得到 <code>true</code></li><li>当你点击取消的时候，就会得到 <code>false</code></li></ul></li><li><p><code>prompt</code> 是在浏览器弹出一个输入框</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> str = <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">prompt</span>(<span class="hljs-string">&#x27;请输入内容&#x27;</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str)<br></code></pre></td></tr></table></figure><p><img src="F:/前端学习/视频笔记/javascript/笔记/笔记/笔记.assets/prompt.png"></p><ul><li>这个弹出层有一个输入框和两个按钮</li><li>当你点击取消的时候，得到的是 <code>null</code></li><li>当你点击确定的时候得到的就是你输入的内容</li></ul></li></ul><h5 id="3-浏览器的地址信息"><a href="#3-浏览器的地址信息" class="headerlink" title="3. 浏览器的地址信息"></a>3. 浏览器的地址信息</h5><ul><li>在 <code>window</code> 中有一个对象叫做 <code>location</code></li><li>就是专门用来存储浏览器的地址栏内的信息的</li></ul><h6 id="location-href"><a href="#location-href" class="headerlink" title="location.href"></a>location.href</h6><ul><li><p><code>location.href</code> 这个属性存储的是浏览器地址栏内 <code>url</code> 地址的信息</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">window</span>.<span class="hljs-property">location</span>.<span class="hljs-property">href</span>)<br></code></pre></td></tr></table></figure><ul><li>会把中文变成 <code>url</code> 编码的格式</li></ul></li><li><p><code>location.href</code> 这个属性也可以给他赋值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">window</span>.<span class="hljs-property">location</span>.<span class="hljs-property">href</span> = <span class="hljs-string">&#x27;./index.html&#x27;</span><br><span class="hljs-comment">// 这个就会跳转页面到后面你给的那个地址</span><br></code></pre></td></tr></table></figure></li></ul><h6 id="location-reload"><a href="#location-reload" class="headerlink" title="location.reload"></a>location.reload</h6><ul><li><p><code>location.reload()</code> 这个方法会重新加载一遍页面，就相当于刷新是一个道理</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">window</span>.<span class="hljs-property">location</span>.<span class="hljs-title function_">reload</span>()<br></code></pre></td></tr></table></figure><ul><li>注意： <strong>不要写在全局，不然浏览器就会一直处在刷新状态</strong></li></ul></li></ul><h5 id="4-浏览器的历史记录"><a href="#4-浏览器的历史记录" class="headerlink" title="4. 浏览器的历史记录"></a>4. 浏览器的历史记录</h5><ul><li><code>window</code> 中有一个对象叫做 <code>history</code></li><li>是专门用来存储历史记录信息的</li></ul><h6 id="history-back"><a href="#history-back" class="headerlink" title="history.back"></a>history.back</h6><ul><li><p><code>history.back</code> 是用来会退历史记录的，就是回到前一个页面，就相当于浏览器上的 ⬅️ 按钮</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">window</span>.<span class="hljs-property">history</span>.<span class="hljs-title function_">back</span>()<br></code></pre></td></tr></table></figure><ul><li>前提是你要有上一条记录，不然就是一直在这个页面，也不会回退</li></ul></li></ul><h6 id="history-forword"><a href="#history-forword" class="headerlink" title="history.forword"></a>history.forword</h6><ul><li><p><code>history.forword</code> 是去到下一个历史记录里面，也就是去到下一个页面，就相当于浏览器上的 ➡️ 按钮</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">window</span>.<span class="hljs-property">history</span>.<span class="hljs-title function_">forward</span>()<br></code></pre></td></tr></table></figure><ul><li>前提是你要之前有过回退操作，不然的话你现在就是最后一个页面，没有下一个</li></ul></li></ul><h5 id="5-浏览器的-onload-事件"><a href="#5-浏览器的-onload-事件" class="headerlink" title="5. 浏览器的 onload 事件"></a>5. 浏览器的 onload 事件</h5><ul><li><p>这个不在是对象了，而是一个事件</p></li><li><p>是在页面所有资源加载完毕后执行的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">window</span>.<span class="hljs-property">onload</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;页面已经加载完毕&#x27;</span>)<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h6 id="5-1-在-html-页面中把-js-写在-head-里面"><a href="#5-1-在-html-页面中把-js-写在-head-里面" class="headerlink" title="5-1 在 html 页面中把 js 写在 head 里面"></a>5-1 在 html 页面中把 js 写在 head 里面</h6><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-comment">// 这个代码执行的时候，body 还没有加载</span></span><br><span class="language-javascript">      <span class="hljs-comment">// 这个时候我们就获取不到 body 中的那个 div</span></span><br><span class="language-javascript"></span><br><span class="language-javascript">      <span class="hljs-comment">// 就需要使用 window.onload 事件</span></span><br><span class="language-javascript">      <span class="hljs-variable language_">window</span>.<span class="hljs-property">onload</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">        <span class="hljs-comment">// 这个函数会在页面加载完毕以后在执行</span></span><br><span class="language-javascript">        <span class="hljs-comment">// 那么这个时候页面的 DOM 元素都已经加载了，我们就可以获取 div 了</span></span><br><span class="language-javascript">      &#125;</span><br><span class="language-javascript">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h6 id="5-2-在-html-页面中把-js-写在-body-最后面"><a href="#5-2-在-html-页面中把-js-写在-body-最后面" class="headerlink" title="5-2 在 html 页面中把 js 写在 body 最后面"></a>5-2 在 html 页面中把 js 写在 body 最后面</h6><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span> /&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-comment">// 这个代码执行的时候，body 已经加载完毕了</span></span><br><span class="language-javascript">      <span class="hljs-comment">// 在这里就可以获取到 div，写不写 window.onload 就无所谓了</span></span><br><span class="language-javascript"></span><br><span class="language-javascript">      <span class="hljs-variable language_">window</span>.<span class="hljs-property">onload</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">        <span class="hljs-comment">// 这个函数会在页面加载完毕以后在执行</span></span><br><span class="language-javascript">        <span class="hljs-comment">// 那么这个时候页面的 DOM 元素都已经加载了，我们就可以获取 div 了</span></span><br><span class="language-javascript">      &#125;</span><br><span class="language-javascript">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h5 id="6-浏览器的-onscroll-事件"><a href="#6-浏览器的-onscroll-事件" class="headerlink" title="6. 浏览器的 onscroll 事件"></a>6. 浏览器的 onscroll 事件</h5><ul><li><p>这个 <code>onscroll</code> 事件是当浏览器的滚动条滚动的时候触发</p></li><li><p>或者鼠标滚轮滚动的时候出发</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">window</span>.<span class="hljs-property">onscroll</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;浏览器滚动了&#x27;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>注意：<strong>前提是页面的高度要超过浏览器的可是窗口才可以</strong></li></ul></li></ul><h5 id="7-浏览器滚动的距离"><a href="#7-浏览器滚动的距离" class="headerlink" title="7. 浏览器滚动的距离"></a>7. 浏览器滚动的距离</h5><ul><li>浏览器内的内容即然可以滚动，那么我们就可以获取到浏览器滚动的距离</li><li>思考一个问题？<ul><li>浏览器真的滚动了吗？</li><li>其实我们的浏览器是没有滚动的，是一直在那里</li><li>滚动的是什么？是我们的页面</li><li>所以说，<strong>其实浏览器没有动，只不过是页面向上走了</strong></li></ul></li><li>所以，这个已经不能单纯的算是浏览器的内容了，而是我们页面的内容</li><li>所以不是在用 <code>window</code> 对象了，而是使用 <code>document</code> 对象</li></ul><h6 id="scrollTop"><a href="#scrollTop" class="headerlink" title="scrollTop"></a>scrollTop</h6><ul><li><p>获取的是页面向上滚动的距离</p></li><li><p>一共有两个获取方式</p><ul><li><code>document.body.scrollTop</code></li><li><code>document.documentElement.scrollTop</code></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">window</span>.<span class="hljs-property">onscroll</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-property">scrollTop</span>)<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">document</span>.<span class="hljs-property">documentElement</span>.<span class="hljs-property">scrollTop</span>)<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>两个都是获取页面向上滚动的距离</li><li>区别：<ul><li>IE 浏览器<ul><li>没有 <code>DOCTYPE</code> 声明的时候，用这两个都行</li><li>有 <code>DOCTYPE</code> 声明的时候，只能用 <code>document.documentElement.scrollTop</code></li></ul></li><li>Chrome 和 FireFox<ul><li>没有 <code>DOCTYPE</code> 声明的时候，用 <code>document.body.scrollTop</code></li><li>有 <code>DOCTYPE</code> 声明的时候，用 <code>document.documentElement.scrollTop</code></li></ul></li><li>Safari<ul><li>两个都不用，使用一个单独的方法 <code>window.pageYOffset </code></li></ul></li></ul></li></ul></li></ul><h6 id="scrollLeft"><a href="#scrollLeft" class="headerlink" title="scrollLeft"></a>scrollLeft</h6><ul><li><p>获取页面向左滚动的距离</p></li><li><p>也是两个方法</p><ul><li><p><code>document.body.scrollLeft</code></p></li><li><p><code>document.documentElementLeft</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">window</span>.<span class="hljs-property">onscroll</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-property">scrollLeft</span>)<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">document</span>.<span class="hljs-property">documentElement</span>.<span class="hljs-property">scrollLeft</span>)<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>两个之间的区别和之前的 <code>scrollTop</code> 一样</p></li></ul></li></ul><h5 id="8-本地存储"><a href="#8-本地存储" class="headerlink" title="8. 本地存储"></a>8. 本地存储</h5><h6 id="8-1-localStorage"><a href="#8-1-localStorage" class="headerlink" title="8-1 localStorage"></a>8-1 localStorage</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//增</span><br><span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">setItem</span>(<span class="hljs-string">&quot;name&quot;</span>,<span class="hljs-string">&quot;kerwin&quot;</span>)<br><span class="hljs-comment">//取</span><br><span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">getItem</span>(<span class="hljs-string">&quot;name&quot;</span>)<br><span class="hljs-comment">//删</span><br><span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">removeItem</span>(<span class="hljs-string">&quot;name&quot;</span>)<br><span class="hljs-comment">//清空</span><br><span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">clear</span>()<br><br></code></pre></td></tr></table></figure><h6 id="8-2-sessionStorage"><a href="#8-2-sessionStorage" class="headerlink" title="8-2 sessionStorage"></a>8-2 sessionStorage</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//增</span><br>sessionStorage.<span class="hljs-title function_">setItem</span>(<span class="hljs-string">&quot;name&quot;</span>,<span class="hljs-string">&quot;kerwin&quot;</span>)<br><span class="hljs-comment">//取</span><br>sessionStorage.<span class="hljs-title function_">getItem</span>(<span class="hljs-string">&quot;name&quot;</span>)<br><span class="hljs-comment">//删</span><br>sessionStorage.<span class="hljs-title function_">removeItem</span>(<span class="hljs-string">&quot;name&quot;</span>)<br><span class="hljs-comment">//清空</span><br>sessionStorage.<span class="hljs-title function_">clear</span>()<br></code></pre></td></tr></table></figure><h4 id="三-DOM"><a href="#三-DOM" class="headerlink" title="三. DOM"></a>三. DOM</h4><ul><li><code>DOM（Document Object Model）</code>： 文档对象模型</li><li>其实就是操作 <code>html</code> 中的标签的一些能力</li><li>我们可以操作哪些内容<ul><li>获取一个元素</li><li>移除一个元素</li><li>创建一个元素</li><li>向页面里面添加一个元素</li><li>给元素绑定一些事件</li><li>获取元素的属性</li><li>给元素添加一些 <code>css</code> 样式</li><li>…</li></ul></li><li><code>DOM</code> 的核心对象就是 <code>docuemnt</code> 对象</li><li><code>document</code> 对象是浏览器内置的一个对象，里面存储着专门用来操作元素的各种方法</li><li><code>DOM</code>： 页面中的标签，我们通过 <code>js</code> 获取到以后，就把这个对象叫做 <strong>DOM 对象</strong></li></ul><h5 id="1-获取一个元素"><a href="#1-获取一个元素" class="headerlink" title="1. 获取一个元素"></a>1. 获取一个元素</h5><ul><li>通过 <code>js</code> 代码来获取页面中的标签</li><li>获取到以后我们就可以操作这些标签了</li></ul><h6 id="1-1-getElementById"><a href="#1-1-getElementById" class="headerlink" title="1-1 getElementById"></a>1-1 getElementById</h6><ul><li><p><code>getElementById</code> 是通过标签的 <code>id</code> 名称来获取标签的</p></li><li><p>因为在一个页面中 <code>id</code> 是唯一的，所以获取到的就是一个元素</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;box&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-keyword">var</span> box = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;box&#x27;</span>)</span><br><span class="language-javascript">  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(box) <span class="hljs-comment">// &lt;div&gt;&lt;/div&gt;</span></span><br><span class="language-javascript">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>获取到的就是页面中的那个 <strong>id 为 box 的 div 标签</strong></li></ul></li></ul><h6 id="1-2-getElementsByClassName"><a href="#1-2-getElementsByClassName" class="headerlink" title="1-2 getElementsByClassName"></a>1-2 getElementsByClassName</h6><ul><li><p><code>getElementsByClassName</code> 是用过标签的 <code>class</code> 名称来获取标签的</p></li><li><p>因为页面中可能有多个元素的 <code>class</code> 名称一样，所以获取到的是一组元素</p></li><li><p>哪怕你获取的 <code>class</code> 只有一个，那也是获取一组元素，<strong>只不过这一组中只有一个 DOM 元素而已</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">calss</span>=<span class="hljs-string">&quot;box&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-keyword">var</span> box = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementsByClassName</span>(<span class="hljs-string">&#x27;box&#x27;</span>)</span><br><span class="language-javascript">  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(box) <span class="hljs-comment">// [&lt;div&gt;&lt;/div&gt;]</span></span><br><span class="language-javascript">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(box[<span class="hljs-number">0</span>]) <span class="hljs-comment">// &lt;div&gt;&lt;/div&gt;</span></span><br><span class="language-javascript">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>获取到的是一组元素，是一个长得和数组一样的数据结构，但是不是数组，是 <strong>伪数组</strong></li><li>这个一组数据也是按照索引排列的，所以我们想要准确的拿到这个 <code>div</code>，需要用索引来获取</li></ul></li></ul><h6 id="1-3-getElementsByTagName"><a href="#1-3-getElementsByTagName" class="headerlink" title="1-3 getElementsByTagName"></a>1-3 getElementsByTagName</h6><ul><li><p><code>getElementsByTagName</code> 是用过标签的 标签 名称来获取标签的</p></li><li><p>因为页面中可能有多个元素的 标签 名称一样，所以获取到的是一组元素</p></li><li><p>哪怕真的只有一个这个标签名，那么也是获取一组元素，只不过这一组中只有一个 DOM 元素而已</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-keyword">var</span> box = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementsByTagName</span>(<span class="hljs-string">&#x27;div&#x27;</span>)</span><br><span class="language-javascript">  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(box) <span class="hljs-comment">// [&lt;div&gt;&lt;/div&gt;]</span></span><br><span class="language-javascript">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(box[<span class="hljs-number">0</span>]) <span class="hljs-comment">// &lt;div&gt;&lt;/div&gt;</span></span><br><span class="language-javascript">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>和 <code>getElementsByClassName</code> 一样，获取到的是一个长得很像数组的元素</li><li>必须要用索引才能得到准确的 <code>DOM</code> 元素</li></ul></li></ul><h6 id="1-4-querySelector"><a href="#1-4-querySelector" class="headerlink" title="1-4 querySelector"></a>1-4 querySelector</h6><ul><li><p><code>querySelector</code> 是按照选择器的方式来获取元素</p></li><li><p>也就是说，按照我们写 <code>css</code> 的时候的选择器来获取</p></li><li><p>这个方法只能获取到一个元素，并且是页面中第一个满足条件的元素</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;div&#x27;</span>)) <span class="hljs-comment">// 获取页面中的第一个 div 元素</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(docuemnt.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;.box&#x27;</span>)) <span class="hljs-comment">// 获取页面中第一个有 box 类名的元素</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;#box&#x27;</span>)) <span class="hljs-comment">// 获取页面中第一个 id 名为 box 的元素</span><br></code></pre></td></tr></table></figure></li></ul><h6 id="1-5-querySelectorAll"><a href="#1-5-querySelectorAll" class="headerlink" title="1-5 querySelectorAll"></a>1-5 querySelectorAll</h6><ul><li><p><code>querySelectorAll</code> 是按照选择器的方式来获取元素</p></li><li><p>这个方法能获取到所有满足条件的元素，以一个伪数组的形式返回</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelectorAll</span>(<span class="hljs-string">&#x27;div&#x27;</span>)) <span class="hljs-comment">// 获取页面中的所有的 div 元素</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(docuemnt.<span class="hljs-title function_">querySelectorAll</span>(<span class="hljs-string">&#x27;.box&#x27;</span>)) <span class="hljs-comment">// 获取页面中所有有 box 类名的元素</span><br></code></pre></td></tr></table></figure><ul><li>获取到的是一组数据，也是需要用索引来获取到准确的每一个 <code>DOM</code> 元素</li></ul></li></ul><h5 id="2-操作属性"><a href="#2-操作属性" class="headerlink" title="2. 操作属性"></a>2. 操作属性</h5><ul><li>通过我们各种获取元素的方式获取到页面中的标签以后</li><li>我们可以直接操作 <code>DOM</code> 元素的属性，就能直接把效果展示在页面上</li></ul><h6 id="2-1-innerHTML"><a href="#2-1-innerHTML" class="headerlink" title="2-1 innerHTML"></a>2-1 innerHTML</h6><ul><li><p>获取元素内部的 <code>HTML</code> 结构</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>hello<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-keyword">var</span> div = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;div&#x27;</span>)</span><br><span class="language-javascript">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(div.<span class="hljs-property">innerHTML</span>)</span><br><span class="language-javascript">      <span class="hljs-comment">/*</span></span><br><span class="hljs-comment"><span class="language-javascript"></span></span><br><span class="hljs-comment"><span class="language-javascript">          &lt;p&gt;</span></span><br><span class="hljs-comment"><span class="language-javascript">            &lt;span&gt;hello&lt;/span&gt;</span></span><br><span class="hljs-comment"><span class="language-javascript">          &lt;/p&gt;</span></span><br><span class="hljs-comment"><span class="language-javascript"></span></span><br><span class="hljs-comment"><span class="language-javascript">  */</span></span><br><span class="language-javascript">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>设置元素的内容</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-keyword">var</span> div = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;div&#x27;</span>)</span><br><span class="language-javascript">   div.<span class="hljs-property">innerHTML</span> = <span class="hljs-string">&#x27;&lt;p&gt;hello&lt;/p&gt;&#x27;</span></span><br><span class="language-javascript">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>设置完以后，页面中的 <code>div</code> 元素里面就会嵌套一个 <code>p</code> 元素</li></ul></li></ul><h6 id="2-2-innerText"><a href="#2-2-innerText" class="headerlink" title="2-2 innerText"></a>2-2 innerText</h6><ul><li><p>获取元素内部的文本（只能获取到文本内容，获取不到 <code>html</code> 标签）</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>hello<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-keyword">var</span> div = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;div&#x27;</span>)</span><br><span class="language-javascript">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(div.<span class="hljs-property">innerText</span>) <span class="hljs-comment">// hello</span></span><br><span class="language-javascript">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>可以设置元素内部的文本</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-keyword">var</span> div = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;div&#x27;</span>)</span><br><span class="language-javascript">   div.<span class="hljs-property">innerText</span> = <span class="hljs-string">&#x27;&lt;p&gt;hello&lt;/p&gt;&#x27;</span></span><br><span class="language-javascript">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>设置完毕以后，会把 <code>&lt;p&gt;hello&lt;/p&gt;</code> 当作一个文本出现在 <code>div</code> 元素里面，而不会把 <code>p</code> 解析成标签</li></ul></li></ul><h6 id="2-3-getAttribute"><a href="#2-3-getAttribute" class="headerlink" title="2-3 getAttribute"></a>2-3 getAttribute</h6><ul><li><p>获取元素的某个属性（包括自定义属性）</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">a</span>=<span class="hljs-string">&quot;100&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;box&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-keyword">var</span> div = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;div&#x27;</span>)</span><br><span class="language-javascript">   <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(div.<span class="hljs-title function_">getAttribute</span>(<span class="hljs-string">&#x27;a&#x27;</span>)) <span class="hljs-comment">// 100</span></span><br><span class="language-javascript">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(div.<span class="hljs-title function_">getAttribute</span>(<span class="hljs-string">&#x27;class&#x27;</span>)) <span class="hljs-comment">// box</span></span><br><span class="language-javascript">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ul><h6 id="2-4-setAttribute"><a href="#2-4-setAttribute" class="headerlink" title="2-4 setAttribute"></a>2-4 setAttribute</h6><ul><li><p>给元素设置一个属性（包括自定义属性）</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-keyword">var</span> div = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;div&#x27;</span>)</span><br><span class="language-javascript">   div.<span class="hljs-title function_">setAttribute</span>(<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-number">100</span>)</span><br><span class="language-javascript">    div.<span class="hljs-title function_">setAttribute</span>(<span class="hljs-string">&#x27;class&#x27;</span>, <span class="hljs-string">&#x27;box&#x27;</span>)</span><br><span class="language-javascript">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(div) <span class="hljs-comment">// &lt;div a=&quot;100&quot; class=&quot;box&quot;&gt;&lt;/div&gt;</span></span><br><span class="language-javascript">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ul><h6 id="2-5-removeAttribute"><a href="#2-5-removeAttribute" class="headerlink" title="2-5 removeAttribute"></a>2-5 removeAttribute</h6><ul><li><p>直接移除元素的某个属性</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">a</span>=<span class="hljs-string">&quot;100&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;box&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-keyword">var</span> div = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;div&#x27;</span>)</span><br><span class="language-javascript">   div.<span class="hljs-title function_">removeAttribute</span>(<span class="hljs-string">&#x27;class&#x27;</span>)</span><br><span class="language-javascript">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(div) <span class="hljs-comment">// &lt;div a=&quot;100&quot;&gt;&lt;/div&gt;</span></span><br><span class="language-javascript">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ul><h6 id="2-6-style"><a href="#2-6-style" class="headerlink" title="2-6 style"></a>2-6 style</h6><ul><li><p>专门用来给元素添加 <code>css</code> 样式的</p></li><li><p>添加的都是行内样式</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-keyword">var</span> div = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;div&#x27;</span>)</span><br><span class="language-javascript">   div.<span class="hljs-property">style</span>.<span class="hljs-property">width</span> = <span class="hljs-string">&quot;100px&quot;</span></span><br><span class="language-javascript">    div.<span class="hljs-property">style</span>.<span class="hljs-property">height</span> = <span class="hljs-string">&quot;100px&quot;</span></span><br><span class="language-javascript">    div.<span class="hljs-property">style</span>.<span class="hljs-property">backgroundColor</span> = <span class="hljs-string">&quot;pink&quot;</span></span><br><span class="language-javascript">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(div)</span><br><span class="language-javascript">    <span class="hljs-comment">// &lt;div style=&quot;width: 100px; height: 100px; background-color: pink;&quot;&gt;&lt;/div&gt;</span></span><br><span class="language-javascript">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>页面中的 <code>div</code> 就会变成一个宽高都是 <code>100</code>，背景颜色是粉色</li></ul></li></ul><h6 id="2-7-获取元素的非行间样式"><a href="#2-7-获取元素的非行间样式" class="headerlink" title="2-7 获取元素的非行间样式"></a>2-7 获取元素的非行间样式</h6><ul><li><p>我们在操作 <code>DOM</code> 的时候，很重要的一点就是要操作元素的 <code>css</code> 样式</p></li><li><p>那么在操作 <code>css</code> 样式的时候，我们避免不了就要获取元素的样式</p></li><li><p>之前我们说过可以用 <code>元素.style.xxx</code> 来获取</p></li><li><p>但是这个方法只能获取到元素 <strong>行间样式</strong>，也就是写在行内的样式</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">  <span class="hljs-selector-tag">div</span> &#123;</span><br><span class="language-css">    <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;</span><br><span class="language-css">  &#125;</span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;height: 100px;&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>我是一个 p 标签<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-keyword">var</span> oDiv = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;div&#x27;</span>)</span><br><span class="language-javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(oDiv.<span class="hljs-property">style</span>.<span class="hljs-property">height</span>) <span class="hljs-comment">// 100px</span></span><br><span class="language-javascript">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(oDIv.<span class="hljs-property">style</span>.<span class="hljs-property">width</span>) <span class="hljs-comment">// &#x27;&#x27;</span></span><br><span class="language-javascript">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>不管是外链式还是内嵌式，我们都获取不到该元素的样式</p></li><li><p>这里我们就要使用方法来获取了 <strong><code>getComputedStyle</code></strong> 和 <strong><code>currentStyle</code></strong></p></li><li><p>这两个方法的作用是一样的，只不过一个在 <strong>非 IE</strong> 浏览器，一个在 <strong>IE</strong> 浏览器</p></li></ul><p><strong>getComputedStyle（非IE使用）</strong></p><ul><li><p>语法：<code>window.getComputedStyle(元素, null).要获取的属性</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">  <span class="hljs-selector-tag">div</span> &#123;</span><br><span class="language-css">    <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;</span><br><span class="language-css">  &#125;</span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;height: 100px;&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>我是一个 p 标签<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-keyword">var</span> oDiv = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;div&#x27;</span>)</span><br><span class="language-javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">window</span>.<span class="hljs-title function_">getComputedStyle</span>(oDiv).<span class="hljs-property">width</span>) <span class="hljs-comment">// 100px</span></span><br><span class="language-javascript">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">window</span>.<span class="hljs-title function_">getComputedStyle</span>(oDiv).<span class="hljs-property">height</span>) <span class="hljs-comment">// 100px</span></span><br><span class="language-javascript">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>这个方法获取行间样式和非行间样式都可以</li></ul></li></ul><p><strong>currentStyle（IE使用）</strong></p><ul><li><p>语法： <code>元素.currentStyle.要获取的属性</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">  <span class="hljs-selector-tag">div</span> &#123;</span><br><span class="language-css">    <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;</span><br><span class="language-css">  &#125;</span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;height: 100px;&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>我是一个 p 标签<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-keyword">var</span> oDiv = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;div&#x27;</span>)</span><br><span class="language-javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(oDiv.<span class="hljs-property">currentStyle</span>.<span class="hljs-property">width</span>) <span class="hljs-comment">// 100px</span></span><br><span class="language-javascript">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(oDiv.<span class="hljs-property">currentStyle</span>.<span class="hljs-property">height</span>) <span class="hljs-comment">// 100px</span></span><br><span class="language-javascript">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ul><h6 id="2-8-className"><a href="#2-8-className" class="headerlink" title="2-8 className"></a>2-8 className</h6><ul><li><p>专门用来操作元素的 <strong>类名的</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;box&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-keyword">var</span> div = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;div&#x27;</span>)</span><br><span class="language-javascript">   <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(div.<span class="hljs-property">className</span>) <span class="hljs-comment">// box</span></span><br><span class="language-javascript">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>也可以设置元素的类名，不过是全覆盖式的操作</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;box&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-keyword">var</span> div = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;div&#x27;</span>)</span><br><span class="language-javascript">   div.<span class="hljs-property">className</span> = <span class="hljs-string">&#x27;test&#x27;</span></span><br><span class="language-javascript">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(div) <span class="hljs-comment">// &lt;div class=&quot;test&quot;&gt;&lt;/div&gt;</span></span><br><span class="language-javascript">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>在设置的时候，不管之前有没有类名，都会全部被设置的值覆盖</li></ul></li></ul><h5 id="3-DOM节点"><a href="#3-DOM节点" class="headerlink" title="3. DOM节点"></a>3. DOM节点</h5><ul><li><code>DOM</code> 的节点我们一般分为常用的三大类 <strong>元素节点</strong> &#x2F; <strong>文本节点</strong> &#x2F; <strong>属性节点</strong></li><li>什么是分类，比如我们在获取元素的时候，通过各种方法获取到的我们叫做元素节点（标签节点）</li><li>比如我们标签里面写的文字，那么就是文本节点</li><li>写在每一个标签上的属性，就是属性节点</li></ul><h6 id="3-1-元素节点"><a href="#3-1-元素节点" class="headerlink" title="3-1 元素节点"></a>3-1 元素节点</h6><ul><li>我们通过 <code>getElementBy...</code> 获取到的都是元素节点</li></ul><h6 id="3-2-属性节点"><a href="#3-2-属性节点" class="headerlink" title="3-2 属性节点"></a>3-2 属性节点</h6><ul><li>我们通过 <code>getAttribute</code> 获取的就是元素的属性节点</li></ul><h6 id="3-3-文本节点"><a href="#3-3-文本节点" class="headerlink" title="3-3 文本节点"></a>3-3 文本节点</h6><ul><li>我们通过 <code>innerText</code> 获取到的就是元素的文本节点</li></ul><p><img src="F:/前端学习/视频笔记/javascript/笔记/笔记/笔记.assets/image-20220529093256532.png" alt="image-20220529093256532"></p><p><img src="F:/前端学习/视频笔记/javascript/笔记/笔记/笔记.assets/image-20220529093305827.png" alt="image-20220529093305827"></p><p><img src="F:/前端学习/视频笔记/javascript/笔记/笔记/笔记.assets/image-20220529093325381.png" alt="image-20220529093325381"></p><p><img src="F:/前端学习/视频笔记/javascript/笔记/笔记/笔记.assets/image-20220529093334602.png" alt="image-20220529093334602"></p><p><img src="F:/前端学习/视频笔记/javascript/笔记/笔记/笔记.assets/image-20220529093346903.png" alt="image-20220529093346903"></p><p><img src="F:/前端学习/视频笔记/javascript/笔记/笔记/笔记.assets/image-20220529093416413.png" alt="image-20220529093416413"></p><h6 id="3-4-获取节点"><a href="#3-4-获取节点" class="headerlink" title="3-4 获取节点"></a>3-4 获取节点</h6><ul><li><p><code>childNodes</code>：获取某一个节点下 <strong>所有的子一级节点</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>hello<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-comment">// 这个 oDiv 获取的是页面中的 div 元素，就是一个元素节点</span></span><br><span class="language-javascript">  <span class="hljs-keyword">var</span> oDiv = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;div&#x27;</span>)</span><br><span class="language-javascript">    </span><br><span class="language-javascript">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(oDiv.<span class="hljs-property">childNodes</span>) </span><br><span class="language-javascript">    <span class="hljs-comment">/*</span></span><br><span class="hljs-comment"><span class="language-javascript">    NodeList(3) [text, p, text]</span></span><br><span class="hljs-comment"><span class="language-javascript">      0: text</span></span><br><span class="hljs-comment"><span class="language-javascript">      1: p</span></span><br><span class="hljs-comment"><span class="language-javascript">      2: text</span></span><br><span class="hljs-comment"><span class="language-javascript">      length: 3</span></span><br><span class="hljs-comment"><span class="language-javascript">      __proto__: NodeList</span></span><br><span class="hljs-comment"><span class="language-javascript">    */</span></span><br><span class="language-javascript">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>我们会发现，拿到以后是一个伪数组，里面有三个节点</li><li>一个 <code>text</code>：从 <code>&lt;div&gt; 一直到 &lt;p&gt;</code> 中间有一个换行和一堆空格，这个是第一个节点，是一个文本节点</li><li>一个 <code>p</code>：这个 <code>p</code> 标签就是第二个节点，这个是一个元素节点</li><li>一个 <code>text</code>：从 <code>&lt;/p&gt; 一直到 &lt;/div&gt;</code> 中间有一个换行和一堆空格，这个是第三个节点，是一个文本节点</li><li>这个时候就能看到我们有不同的节点类型了</li></ul></li><li><p><code>children</code> ：获取某一节点下所有的子一级 <strong>元素节点</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>hello<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-comment">// 这个 oDiv 获取的是页面中的 div 元素，就是一个元素节点</span></span><br><span class="language-javascript">  <span class="hljs-keyword">var</span> oDiv = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;div&#x27;</span>)</span><br><span class="language-javascript">    </span><br><span class="language-javascript">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(oDiv.<span class="hljs-property">children</span>) </span><br><span class="language-javascript">    <span class="hljs-comment">/*</span></span><br><span class="hljs-comment"><span class="language-javascript">    HTMLCollection [p]</span></span><br><span class="hljs-comment"><span class="language-javascript">      0: p</span></span><br><span class="hljs-comment"><span class="language-javascript">      length: 1</span></span><br><span class="hljs-comment"><span class="language-javascript">      __proto__: HTMLCollection</span></span><br><span class="hljs-comment"><span class="language-javascript">    */</span></span><br><span class="language-javascript">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>我们发现只有一个节点了，因为 <code>children</code> 只要元素节点</li><li>div 下面又只有一个元素节点，就是 <code>p</code></li><li>所以就只有一个，虽然只有一个，但是也是一个 <strong>伪数组</strong></li></ul></li><li><p><code>firstChild</code>：获取某一节点下子一级的 <strong>第一个节点</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>hello<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-comment">// 这个 oDiv 获取的是页面中的 div 元素，就是一个元素节点</span></span><br><span class="language-javascript">  <span class="hljs-keyword">var</span> oDiv = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;div&#x27;</span>)</span><br><span class="language-javascript">    </span><br><span class="language-javascript">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(oDiv.<span class="hljs-property">firstChild</span>) <span class="hljs-comment">// #text </span></span><br><span class="language-javascript">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>这个是只获取一个节点，不再是伪数组了</li><li>获取的是第一个</li><li>第一个就是 <code>&lt;div&gt; 一直到 &lt;p&gt;</code> 的那个换行和空格，是个文本节点</li></ul></li><li><p><code>lastChild</code>：获取某一节点下子一级的 <strong>最后一个节点</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>hello<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-comment">// 这个 oDiv 获取的是页面中的 div 元素，就是一个元素节点</span></span><br><span class="language-javascript">  <span class="hljs-keyword">var</span> oDiv = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;div&#x27;</span>)</span><br><span class="language-javascript">    </span><br><span class="language-javascript">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(oDiv.<span class="hljs-property">lastChild</span>) <span class="hljs-comment">// #text </span></span><br><span class="language-javascript">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>只获取一个节点，不再是伪数组</li><li>获取的是最后一个</li><li>最后一个就是 <code>&lt;/p&gt; 一直到 &lt;/div&gt;</code> 之间的换行和空格，是个文本节点</li></ul></li><li><p><code>firstElementChild</code>：获取某一节点下子一级 <strong>第一个元素节点</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>hello<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-comment">// 这个 oDiv 获取的是页面中的 div 元素，就是一个元素节点</span></span><br><span class="language-javascript">  <span class="hljs-keyword">var</span> oDiv = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;div&#x27;</span>)</span><br><span class="language-javascript">    </span><br><span class="language-javascript">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(oDiv.<span class="hljs-property">firstElementChild</span>) <span class="hljs-comment">// &lt;p&gt;hello&lt;/p&gt;</span></span><br><span class="language-javascript">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>只获取一个节点，不在是伪数组</li><li>获取的是第一个 <strong>元素节点</strong></li><li>第一个元素节点就是 <code>p</code> 标签，是一个元素节点</li></ul></li><li><p><code>lastElementChild</code>：获取某一节点下子一级 <strong>最后一个元素节点</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>hello<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>world<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-comment">// 这个 oDiv 获取的是页面中的 div 元素，就是一个元素节点</span></span><br><span class="language-javascript">  <span class="hljs-keyword">var</span> oDiv = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;div&#x27;</span>)</span><br><span class="language-javascript">    </span><br><span class="language-javascript">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(oDiv.<span class="hljs-property">lastElementChild</span>) <span class="hljs-comment">// &lt;p&gt;world&lt;/p&gt;</span></span><br><span class="language-javascript">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>只获取一个节点，不在是伪数组</li><li>获取的是最后一个 <strong>元素节点</strong></li><li>最后一个元素节点是 <code>&lt;p&gt;world&lt;/p&gt;</code>，是一个元素节点</li></ul></li><li><p><code>nextSibling</code>：获取某一个节点的 <strong>下一个兄弟节点</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;a&quot;</span>&gt;</span>hello<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;b&quot;</span>&gt;</span>world<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;c&quot;</span>&gt;</span>!!!<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br>  <br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-comment">// 这个 oLi 获取的是页面中的 li 元素，就是一个元素节点</span></span><br><span class="language-javascript">  <span class="hljs-keyword">var</span> oLi = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;#b&#x27;</span>)</span><br><span class="language-javascript">    </span><br><span class="language-javascript">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(oLi.<span class="hljs-property">nextSibling</span>) <span class="hljs-comment">// #text</span></span><br><span class="language-javascript">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>只获取一个节点，不在是伪数组</li><li>获取的是 <code>id=&quot;b&quot;</code> 这个 <code>li</code> 的下一个兄弟节点</li><li>因为 <code>id=&quot;b&quot;</code> 的下一个节点，是两个 <code>li</code> 标签之间的换行和空格，所以是一个文本节点</li></ul></li><li><p><code>previousSibling</code>：获取某一个节点的 <strong>上一个兄弟节点</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;a&quot;</span>&gt;</span>hello<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;b&quot;</span>&gt;</span>world<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;c&quot;</span>&gt;</span>!!!<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br>  <br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-comment">// 这个 oLi 获取的是页面中的 li 元素，就是一个元素节点</span></span><br><span class="language-javascript">  <span class="hljs-keyword">var</span> oLi = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;#b&#x27;</span>)</span><br><span class="language-javascript">    </span><br><span class="language-javascript">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(oLi.<span class="hljs-property">previousSibling</span>) <span class="hljs-comment">// #text</span></span><br><span class="language-javascript">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>只获取一个节点，不在是伪数组</li><li>获取的是 <code>id=&quot;b&quot;</code> 这个 <code>li</code> 的上一个兄弟节点</li><li>因为 <code>id=&quot;b&quot;</code> 的上一个节点，是两个 <code>li</code> 标签之间的换行和空格，所以是一个文本节点</li></ul></li><li><p><code>nextElementSibling</code>：获取某一个节点的 <strong>下一个元素节点</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;a&quot;</span>&gt;</span>hello<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;b&quot;</span>&gt;</span>world<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;c&quot;</span>&gt;</span>!!!<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br>  <br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-comment">// 这个 oLi 获取的是页面中的 li 元素，就是一个元素节点</span></span><br><span class="language-javascript">  <span class="hljs-keyword">var</span> oLi = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;#b&#x27;</span>)</span><br><span class="language-javascript">    </span><br><span class="language-javascript">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(oLi.<span class="hljs-property">nextElementSibling</span>) <span class="hljs-comment">// &lt;li id=&quot;c&quot;&gt;!!!&lt;/li&gt;</span></span><br><span class="language-javascript">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>只获取一个节点，不在是伪数组</li><li>获取的是 <code>id=&quot;b&quot;</code> 这个 <code>li</code> 的下一个兄弟元素节点</li><li>因为 <code>id=&quot;b&quot;</code> 的下一个兄弟元素节点就是 <code>id=&quot;c&quot;</code> 的 <code>li</code>，是一个元素节点</li></ul></li><li><p><code>previousElementSibling</code>：获取某一个节点的 <strong>上一个元素节点</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;a&quot;</span>&gt;</span>hello<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;b&quot;</span>&gt;</span>world<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;c&quot;</span>&gt;</span>!!!<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br>  <br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-comment">// 这个 oLi 获取的是页面中的 li 元素，就是一个元素节点</span></span><br><span class="language-javascript">  <span class="hljs-keyword">var</span> oLi = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;#b&#x27;</span>)</span><br><span class="language-javascript">    </span><br><span class="language-javascript">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(oLi.<span class="hljs-property">previousElementSibling</span>) <span class="hljs-comment">// &lt;li id=&quot;a&quot;&gt;hello&lt;/li&gt;</span></span><br><span class="language-javascript">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>只获取一个节点，不在是伪数组</li><li>获取的是 <code>id=&quot;b&quot;</code> 这个 <code>li</code> 的上一个兄弟元素节点</li><li>因为 <code>id=&quot;b&quot;</code> 的上一个兄弟元素节点就是 <code>id=&quot;a&quot;</code> 的 <code>li</code>，是一个元素节点</li></ul></li><li><p><code>parentNode</code>：获取某一个节点的 <strong>父节点</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;a&quot;</span>&gt;</span>hello<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;b&quot;</span>&gt;</span>world<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;c&quot;</span>&gt;</span>!!!<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br>  <br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-comment">// 这个 oLi 获取的是页面中的 li 元素，就是一个元素节点</span></span><br><span class="language-javascript">  <span class="hljs-keyword">var</span> oLi = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;#b&#x27;</span>)</span><br><span class="language-javascript">    </span><br><span class="language-javascript">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(oLi.<span class="hljs-property">parentNode</span>) <span class="hljs-comment">// &lt;ul&gt;...&lt;/ul&gt;</span></span><br><span class="language-javascript">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>只获取一个节点，不在是伪数组</li><li>获取的是当前这个 <code>li</code> 的父元素节点</li><li>因为这个 <code>li</code> 的父亲就是 <code>ul</code>，所以获取到的就是 <code>ul</code>，是一个元素节点</li></ul></li><li><p><code>attributes</code>：获取某一个 <strong>元素节点</strong> 的所有 <strong>属性节点</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;a&quot;</span> <span class="hljs-attr">a</span>=<span class="hljs-string">&quot;100&quot;</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;test&quot;</span>&gt;</span>hello<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br>  <br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-comment">// 这个 oLi 获取的是页面中的 li 元素，就是一个元素节点</span></span><br><span class="language-javascript">  <span class="hljs-keyword">var</span> oLi = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;#a&#x27;</span>)</span><br><span class="language-javascript">    </span><br><span class="language-javascript">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(oLi.<span class="hljs-property">attributes</span>) </span><br><span class="language-javascript">    <span class="hljs-comment">/*</span></span><br><span class="hljs-comment"><span class="language-javascript">    NamedNodeMap &#123;0: id, 1: a, 2: test, id: id, a: a, test: test, length: 3&#125;</span></span><br><span class="hljs-comment"><span class="language-javascript">      0: id</span></span><br><span class="hljs-comment"><span class="language-javascript">      1: a</span></span><br><span class="hljs-comment"><span class="language-javascript">      2: test</span></span><br><span class="hljs-comment"><span class="language-javascript">      length: 3</span></span><br><span class="hljs-comment"><span class="language-javascript">      a: a</span></span><br><span class="hljs-comment"><span class="language-javascript">      id: id</span></span><br><span class="hljs-comment"><span class="language-javascript">      test: test</span></span><br><span class="hljs-comment"><span class="language-javascript">      __proto__: NamedNodeMap</span></span><br><span class="hljs-comment"><span class="language-javascript">    </span></span><br><span class="hljs-comment"><span class="language-javascript">    */</span></span><br><span class="language-javascript">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>获取的是一组数据，是该元素的所有属性，也是一个伪数组</li><li>这个 <code>li</code> 有三个属性，<code>id</code> &#x2F; <code>a</code> &#x2F; <code>test</code> 三个，所以就获取到了这三个</li></ul></li></ul><h5 id="4-节点属性"><a href="#4-节点属性" class="headerlink" title="4. 节点属性"></a>4. 节点属性</h5><ul><li><p>我们已经知道节点会分成很多种，而且我们也能获取到各种不同的节点</p></li><li><p>接下来我们就来聊一些各种节点之间属性的区别</p></li><li><p>我们先准备一段代码</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;我是 ul 的一个属性&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>hello<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-comment">// 先获取 ul</span></span><br><span class="language-javascript">    <span class="hljs-keyword">var</span> oUl = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;ul&#x27;</span>)</span><br><span class="language-javascript">    </span><br><span class="language-javascript">    <span class="hljs-comment">// 获取到 ul 下的第一个子元素节点，是一个元素节点</span></span><br><span class="language-javascript">    <span class="hljs-keyword">var</span> eleNode = oUl.<span class="hljs-property">firstElementChild</span></span><br><span class="language-javascript">    </span><br><span class="language-javascript">    <span class="hljs-comment">// 获取到 ul 的属性节点组合，因为是个组合，我们要拿到节点的话要用索引</span></span><br><span class="language-javascript">    <span class="hljs-keyword">var</span> attrNode = oUl.<span class="hljs-property">attributes</span>[<span class="hljs-number">0</span>]</span><br><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-comment">// 获取到 ul 下的第一个子节点，是一个文本节点</span></span><br><span class="language-javascript">    <span class="hljs-keyword">var</span> textNode = oUl.<span class="hljs-property">firstChild</span></span><br><span class="language-javascript">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ul><h6 id="nodeType"><a href="#nodeType" class="headerlink" title="nodeType"></a>nodeType</h6><ul><li><p><code>nodeType</code>：获取节点的节点类型，用数字表示</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(eleNode.<span class="hljs-property">nodeType</span>) <span class="hljs-comment">// 1</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(attrNode.<span class="hljs-property">nodeType</span>) <span class="hljs-comment">// 2</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(textNode.<span class="hljs-property">nodeType</span>) <span class="hljs-comment">// 3</span><br></code></pre></td></tr></table></figure><ul><li><code>nodeType === 1</code> 就表示该节点是一个 <strong>元素节点</strong></li><li><code>nodeType === 2</code> 就表示该节点是一个 <strong>属性节点</strong></li><li><code>nodeType === 3</code> 就表示该节点是一个 <strong>注释节点</strong></li></ul></li></ul><h6 id="nodeName"><a href="#nodeName" class="headerlink" title="nodeName"></a>nodeName</h6><ul><li><p><code>nodeName</code>：获取节点的节点名称</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(eleNode.<span class="hljs-property">nodeName</span>) <span class="hljs-comment">// LI</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(attrNode.<span class="hljs-property">nodeName</span>) <span class="hljs-comment">// test</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(textNode.<span class="hljs-property">nodeName</span>) <span class="hljs-comment">// #text</span><br></code></pre></td></tr></table></figure><ul><li>元素节点的 <code>nodeName</code> 就是 <strong>大写标签名</strong></li><li>属性节点的 <code>nodeName</code> 就是 <strong>属性名</strong></li><li>文本节点的 <code>nodeName</code> 都是 <strong>#text</strong></li></ul></li></ul><h6 id="nodeValue"><a href="#nodeValue" class="headerlink" title="nodeValue"></a>nodeValue</h6><ul><li><p><code>nodeValue</code>： 获取节点的值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(eleNode.<span class="hljs-property">nodeValue</span>) <span class="hljs-comment">// null</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(attrNode.<span class="hljs-property">nodeValue</span>) <span class="hljs-comment">// 我是 ul 的一个属性</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(textNode.<span class="hljs-property">nodeValue</span>) <span class="hljs-comment">// 换行 + 空格</span><br></code></pre></td></tr></table></figure><ul><li>元素节点没有 <code>nodeValue</code></li><li>属性节点的 <code>nodeValue</code> 就是 <strong>属性值</strong></li><li>文本节点的 <code>nodeValue</code> 就是 <strong>文本内容</strong></li></ul></li></ul><h6 id="汇总"><a href="#汇总" class="headerlink" title="汇总"></a>汇总</h6><table><thead><tr><th>-</th><th>nodeType</th><th>nodeName</th><th>nodeValue</th></tr></thead><tbody><tr><td>元素节点</td><td>1</td><td>大写标签名</td><td>null</td></tr><tr><td>属性节点</td><td>2</td><td>属性名</td><td>属性值</td></tr><tr><td>文本节点</td><td>3</td><td>#text</td><td>文本内容</td></tr></tbody></table><h5 id="5-操作-DOM-节点"><a href="#5-操作-DOM-节点" class="headerlink" title="5. 操作 DOM 节点"></a>5. 操作 DOM 节点</h5><ul><li>我们所说的操作无非就是 <strong>增删改查（CRUD）</strong></li><li>创建一个节点（因为向页面中增加之前，我们需要先创建一个节点出来）</li><li>向页面中增加一个节点</li><li>删除页面中的某一个节点</li><li>修改页面中的某一个节点</li><li>获取页面中的某一个节点</li></ul><h6 id="创建一个节点"><a href="#创建一个节点" class="headerlink" title="创建一个节点"></a>创建一个节点</h6><ul><li><p><code>createElement</code>：用于创建一个元素节点</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 创建一个 div 元素节点</span><br><span class="hljs-keyword">var</span> oDiv = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;div&#x27;</span>)<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(oDiv) <span class="hljs-comment">// &lt;div&gt;&lt;/div&gt;</span><br></code></pre></td></tr></table></figure><ul><li>创建出来的就是一个可以使用的 div 元素</li></ul></li><li><p><code>createTextNode</code>：用于创建一个文本节点</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 创建一个文本节点</span><br><span class="hljs-keyword">var</span> oText = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createTextNode</span>(<span class="hljs-string">&#x27;我是一个文本&#x27;</span>)<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(oText) <span class="hljs-comment">// &quot;我是一个文本&quot;</span><br></code></pre></td></tr></table></figure></li></ul><h6 id="向页面中加入一个节点"><a href="#向页面中加入一个节点" class="headerlink" title="向页面中加入一个节点"></a>向页面中加入一个节点</h6><ul><li><p><code>appendChild</code>：是向一个元素节点的末尾追加一个节点</p></li><li><p>语法： <code>父节点.appendChild(要插入的子节点)</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 创建一个 div 元素节点</span><br><span class="hljs-keyword">var</span> oDiv = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;div&#x27;</span>)<br><span class="hljs-keyword">var</span> oText = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createTextNode</span>(<span class="hljs-string">&#x27;我是一个文本&#x27;</span>)<br><br><span class="hljs-comment">// 向 div 中追加一个文本节点</span><br>oDiv.<span class="hljs-title function_">appendChild</span>(oText)<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(oDiv) <span class="hljs-comment">// &lt;div&gt;我是一个文本&lt;/div&gt;</span><br></code></pre></td></tr></table></figure></li><li><p><code>insertBefore</code>：向某一个节点前插入一个节点</p></li><li><p>语法： <code>父节点.insertBefore(要插入的节点，插入在哪一个节点的前面)</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>我是一个 p 标签<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-keyword">var</span> oDiv = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;div&#x27;</span>)</span><br><span class="language-javascript">    <span class="hljs-keyword">var</span> oP = oDiv.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;p&#x27;</span>)</span><br><span class="language-javascript">    </span><br><span class="language-javascript">    <span class="hljs-comment">// 创建一个元素节点</span></span><br><span class="language-javascript">    <span class="hljs-keyword">var</span> oSpan = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;span&#x27;</span>)</span><br><span class="language-javascript">    </span><br><span class="language-javascript">    <span class="hljs-comment">// 将这个元素节点添加到 div 下的 p 的前面</span></span><br><span class="language-javascript">    oDiv.<span class="hljs-title function_">insertBefore</span>(oSpan, oP)</span><br><span class="language-javascript">    </span><br><span class="language-javascript">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(oDiv)</span><br><span class="language-javascript">    <span class="hljs-comment">/*</span></span><br><span class="hljs-comment"><span class="language-javascript">    &lt;div&gt;</span></span><br><span class="hljs-comment"><span class="language-javascript">    &lt;span&gt;&lt;/span&gt;</span></span><br><span class="hljs-comment"><span class="language-javascript">    &lt;p&gt;我是一个 p 标签&lt;/p&gt;</span></span><br><span class="hljs-comment"><span class="language-javascript">    &lt;/div&gt;</span></span><br><span class="hljs-comment"><span class="language-javascript">    */</span></span><br><span class="language-javascript">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ul><h6 id="删除页面中的某一个节点"><a href="#删除页面中的某一个节点" class="headerlink" title="删除页面中的某一个节点"></a>删除页面中的某一个节点</h6><ul><li><p><code>removeChild</code>：移除某一节点下的某一个节点</p></li><li><p>语法：<code>父节点.removeChild(要移除的字节点)</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>我是一个 p 标签<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-keyword">var</span> oDiv = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;div&#x27;</span>)</span><br><span class="language-javascript">    <span class="hljs-keyword">var</span> oP = oDiv.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;p&#x27;</span>)</span><br><span class="language-javascript">    </span><br><span class="language-javascript">    <span class="hljs-comment">// 移除 div 下面的 p 标签</span></span><br><span class="language-javascript">    oDiv.<span class="hljs-title function_">removeChild</span>(oP)</span><br><span class="language-javascript">    </span><br><span class="language-javascript">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(oDiv) <span class="hljs-comment">// &lt;div&gt;&lt;/div&gt;</span></span><br><span class="language-javascript">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ul><h6 id="修改页面中的某一个节点"><a href="#修改页面中的某一个节点" class="headerlink" title="修改页面中的某一个节点"></a>修改页面中的某一个节点</h6><ul><li><p><code>replaceChild</code>：将页面中的某一个节点替换掉</p></li><li><p>语法： <code>父节点.replaceChild(新节点，旧节点)</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>我是一个 p 标签<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-keyword">var</span> oDiv = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;div&#x27;</span>)</span><br><span class="language-javascript">    <span class="hljs-keyword">var</span> oP = oDiv.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;p&#x27;</span>)</span><br><span class="language-javascript">    </span><br><span class="language-javascript">    <span class="hljs-comment">// 创建一个 span 节点</span></span><br><span class="language-javascript">    <span class="hljs-keyword">var</span> oSpan = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;span&#x27;</span>)</span><br><span class="language-javascript">    <span class="hljs-comment">// 向 span 元素中加点文字</span></span><br><span class="language-javascript">    oSpan.<span class="hljs-property">innerHTML</span> = <span class="hljs-string">&#x27;我是新创建的 span 标签&#x27;</span></span><br><span class="language-javascript">    </span><br><span class="language-javascript">   <span class="hljs-comment">// 用创建的 span 标签替换原先 div 下的 p 标签</span></span><br><span class="language-javascript">    oDiv.<span class="hljs-title function_">replaceChild</span>(oSpan, oP)</span><br><span class="language-javascript">    </span><br><span class="language-javascript">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(oDiv)</span><br><span class="language-javascript">    <span class="hljs-comment">/*</span></span><br><span class="hljs-comment"><span class="language-javascript">    &lt;div&gt;</span></span><br><span class="hljs-comment"><span class="language-javascript">    &lt;span&gt;我是新创建的 span 标签&lt;/span&gt;</span></span><br><span class="hljs-comment"><span class="language-javascript">    &lt;/div&gt;</span></span><br><span class="hljs-comment"><span class="language-javascript">    */</span></span><br><span class="language-javascript">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ul><h5 id="6-获取元素的偏移量"><a href="#6-获取元素的偏移量" class="headerlink" title="6. 获取元素的偏移量"></a>6. 获取元素的偏移量</h5><ul><li>就是元素在页面上相对于参考父级的左边和上边的距离</li></ul><h6 id="offsetParent"><a href="#offsetParent" class="headerlink" title="offsetParent"></a>offsetParent</h6><ul><li>获取元素的偏移量参考父级</li><li>其实就是假设你要给一个元素 <strong>绝对定位</strong> 的时候</li><li>它是根据谁来进行定位的</li><li>那么这个元素的偏移量参考父级就是谁</li></ul><h6 id="offsetLeft-和-offsetTop"><a href="#offsetLeft-和-offsetTop" class="headerlink" title="offsetLeft 和 offsetTop"></a>offsetLeft 和 offsetTop</h6><ul><li>获取的是元左边的偏移量和上边的偏移量</li><li><code>offsetLeft</code> ： 该元素相对于参考父级的左侧偏移量</li><li><code>offsetTop</code> ： 该元素相对于参考父级的上侧偏移量</li></ul><h5 id="7-获取元素尺寸"><a href="#7-获取元素尺寸" class="headerlink" title="7. 获取元素尺寸"></a>7. 获取元素尺寸</h5><ul><li>就是获取元素的 “占地面积”</li></ul><h6 id="offsetWith-和-offsetHeight"><a href="#offsetWith-和-offsetHeight" class="headerlink" title="offsetWith 和 offsetHeight"></a>offsetWith 和 offsetHeight</h6><ul><li><code>offsetWidth</code> ： 获取的是元素 内容 + padding + border 的宽度</li><li><code>offsetHeight</code> ： 获取的是元素 内容 + padding + border 的高度</li></ul><h6 id="clientWidth-和-clientHeight"><a href="#clientWidth-和-clientHeight" class="headerlink" title="clientWidth 和 clientHeight"></a>clientWidth 和 clientHeight</h6><ul><li><p><code>clientWidth</code> ： 获取的是元素 内容 + padding 的宽度</p></li><li><p><code>clientHeight</code> ： 获取的是元素 内容 + padding 的高度</p></li></ul><p>注意:</p><ul><li>获取到的尺寸是没有单位的数字</li><li>当元素在页面中不占位置的时候， 获取到的是 0<ul><li><code>display: none;</code> 元素在页面不占位</li><li><code>visibility: hidden;</code> 元素在页面占位</li></ul></li></ul><h5 id="8-获取浏览器窗口尺寸"><a href="#8-获取浏览器窗口尺寸" class="headerlink" title="8. 获取浏览器窗口尺寸"></a>8. 获取浏览器窗口尺寸</h5><ul><li><p>我们之前学过一个 <code>innerWidth</code> 和 <code>innerHeight</code></p></li><li><p>他们获取到的是窗口包含滚动条的尺寸</p></li><li><p>下面我们学习两个不包含滚动条的尺寸获取方式</p></li><li><p><code>document.documentElement.clientWidth</code> ： 可视窗口的宽度</p></li><li><p><code>document.documentElement.clientHeight</code> ： 可视窗口的高度</p></li></ul><h5 id="9-事件"><a href="#9-事件" class="headerlink" title="9. 事件"></a>9. 事件</h5><ul><li><p>一个事件由什么东西组成</p><ul><li>触发谁的事件：事件源</li><li>触发什么事件：事件类型</li><li>触发以后做什么：事件处理函数</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> oDiv = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;div&#x27;</span>)<br><br>oDiv.<span class="hljs-property">onclick</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;&#125;<br><span class="hljs-comment">// 谁来触发事件 =&gt; oDiv =&gt; 这个事件的事件源就是 oDiv</span><br><span class="hljs-comment">// 触发什么事件 =&gt; onclick =&gt; 这个事件类型就是 click</span><br><span class="hljs-comment">// 触发之后做什么 =&gt; function () &#123;&#125; =&gt; 这个事件的处理函数</span><br></code></pre></td></tr></table></figure><ul><li>我们想要在点击 div 以后做什么事情，就把我们要做的事情写在事件处理函数里面</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> oDiv = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;div&#x27;</span>)<br><br>oDiv.<span class="hljs-property">onclick</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;你点击了 div&#x27;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>当我们点击 <code>div</code> 的时候，就会执行事件处理函数内部的代码</li><li>每点击一次，就会执行一次事件处理函数</li></ul></li></ul><h5 id="10-事件的绑定方式"><a href="#10-事件的绑定方式" class="headerlink" title="10 事件的绑定方式"></a>10 事件的绑定方式</h5><ul><li><p>我们现在给一个注册事件都是使用 <code>onxxx</code> 的方式</p></li><li><p>但是这个方式不是很好，只能给一个元素注册一个事件</p></li><li><p>一旦写了第二个事件，那么第一个就被覆盖了</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript">oDiv.<span class="hljs-property">onclick</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;我是第一个事件&#x27;</span>)<br>&#125;<br><br>oDiv.<span class="hljs-property">onclick</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;我是第二个事件&#x27;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>当你点击的时候，只会执行第二个，第一个就没有了</li></ul></li><li><p>我们还有一种事件监听的方式去给元素绑定事件</p></li><li><p>使用 <code>addEventListener</code> 的方式添加</p><ul><li>这个方法不兼容，在 IE 里面要使用 <code>attachEvent</code></li></ul></li><li><p><code>addEventListener</code> :  非 IE 7 8 下使用</p></li><li><p>语法： <code>元素.addEventListener(&#39;事件类型&#39;， 事件处理函数， 冒泡还是捕获)</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript">oDiv.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;我是第一个事件&#x27;</span>)<br>&#125;, <span class="hljs-literal">false</span>)<br><br>oDiv.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;我是第二个事件&#x27;</span>)<br>&#125;, <span class="hljs-literal">false</span>)<br></code></pre></td></tr></table></figure><ul><li>当你点击 div 的时候，两个函数都会执行，并且会按照你注册的顺序执行</li><li>先打印 <code>我是第一个事件</code> 再打印 <code>我是第二个事件</code></li><li>注意： <strong>事件类型的时候不要写 on，点击事件就是 click，不是 onclick</strong></li></ul></li><li><p><code>attachEvent</code> ：IE 7 8 下使用</p></li><li><p>语法： <code>元素.attachEvent(&#39;事件类型&#39;， 事件处理函数)</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript">oDiv.<span class="hljs-title function_">attachEvent</span>(<span class="hljs-string">&#x27;onclick&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;我是第一个事件&#x27;</span>)<br>&#125;)<br><br>oDiv.<span class="hljs-title function_">attachEvent</span>(<span class="hljs-string">&#x27;onclick&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;我是第二个事件&#x27;</span>)<br>&#125;)<br></code></pre></td></tr></table></figure><ul><li>当你点击 div 的时候，两个函数都会执行，并且会按照你注册的顺序倒叙执行</li><li>先打印 <code>我是第二个事件</code> 再打印 <code>我是第一个事件</code></li><li>注意： <strong>事件类型的时候要写 on，点击事件就行 onclick</strong></li></ul></li></ul><p><strong>两个方式的区别</strong></p><ul><li>注册事件的时候事件类型参数的书写<ul><li><code>addEventListener</code> ： 不用写 on</li><li><code>attachEvent</code> ： 要写 on</li></ul></li><li>参数个数<ul><li><code>addEventListener</code> ： 一般是三个常用参数</li><li><code>attachEvent</code> ： 两个参数</li></ul></li><li>执行顺序<ul><li><code>addEventListener</code> ： 顺序注册，顺序执行</li><li><code>attachEvent</code> ： 顺序注册，倒叙执行</li></ul></li><li>适用浏览器<ul><li><code>addEventListener</code> ： 非 IE 7 8 的浏览器</li><li><code>attachEvent</code> ： IE 7 8 浏览器</li></ul></li></ul><h5 id="11-常见的事件"><a href="#11-常见的事件" class="headerlink" title="11. 常见的事件"></a>11. 常见的事件</h5><ul><li>我们在写页面的时候经常用到的一些事件</li><li>大致分为几类，<strong>浏览器事件</strong> &#x2F; <strong>鼠标事件</strong> &#x2F; <strong>键盘事件</strong> &#x2F; <strong>表单事件</strong> &#x2F; <strong>触摸事件</strong></li><li>不需要都记住，但是大概要知道</li></ul><h6 id="浏览器事件"><a href="#浏览器事件" class="headerlink" title="浏览器事件"></a>浏览器事件</h6><ul><li><code>load</code> ： 页面全部资源加载完毕</li><li><code>scroll</code> ： 浏览器滚动的时候触发</li><li>…</li></ul><h6 id="鼠标事件"><a href="#鼠标事件" class="headerlink" title="鼠标事件"></a>鼠标事件</h6><ul><li><code>click</code> ：点击事件</li><li><code>dblclick</code> ：双击事件</li><li><code>contextmenu</code> ： 右键单击事件</li><li><code>mousedown</code> ：鼠标左键按下事件</li><li><code>mouseup</code> ：鼠标左键抬起事件</li><li><code>mousemove</code> ：鼠标移动</li><li><code>mouseover</code> ：鼠标移入事件</li><li><code>mouseout</code> ：鼠标移出事件</li><li><code>mouseenter</code> ：鼠标移入事件</li><li><code>mouseleave</code> ：鼠标移出事件</li><li>…</li></ul><h6 id="键盘事件"><a href="#键盘事件" class="headerlink" title="键盘事件"></a>键盘事件</h6><ul><li><code>keyup</code> ： 键盘抬起事件</li><li><code>keydown</code> ： 键盘按下事件</li><li><code>keypress</code> ： 键盘按下再抬起事件</li><li>…</li></ul><h6 id="表单事件"><a href="#表单事件" class="headerlink" title="表单事件"></a>表单事件</h6><ul><li><code>change</code> : 表单内容改变事件</li><li><code>input</code> : 表单内容输入事件</li><li><code>submit</code> : 表单提交事件</li><li>…</li></ul><h6 id="触摸事件"><a href="#触摸事件" class="headerlink" title="触摸事件"></a>触摸事件</h6><ul><li><code>touchstart</code> ： 触摸开始事件</li><li><code>touchend</code> ： 触摸结束事件</li><li><code>touchmove</code> ： 触摸移动事件</li><li>…</li></ul><h5 id="12-事件对象"><a href="#12-事件对象" class="headerlink" title="12. 事件对象"></a>12. 事件对象</h5><ul><li><p>什么是事件对象？</p></li><li><p>就是当你触发了一个事件以后，对该事件的一些描述信息</p></li><li><p>例如：</p><ul><li>你触发一个点击事件的时候，你点在哪个位置了，坐标是多少</li><li>你触发一个键盘事件的时候，你按的是哪个按钮</li><li>…</li></ul></li><li><p>每一个事件都会有一个对应的对象来描述这些信息，我们就把这个对象叫做 <strong>事件对象</strong></p></li><li><p>浏览器给了我们一个 <strong>黑盒子</strong>，叫做 <code>window.event</code>，就是对事件信息的所有描述</p><ul><li>比如点击事件</li><li>你点在了 <code>0，0</code> 位置，那么你得到的这个事件对象里面对应的就会有这个点位的属性</li><li>你点在了 <code>10, 10</code> 位置，那么你得到的这个事件对象里面对应的就会有这个点位的属性</li><li>…</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript">oDiv.<span class="hljs-property">onclick</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">window</span>.<span class="hljs-property">event</span>.<span class="hljs-property">X</span>轴坐标点信息)<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">window</span>.<span class="hljs-property">event</span>.<span class="hljs-property">Y</span>轴坐标点信息)<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>这个玩意很好用，但是一般来说，好用的东西就会有 <strong>兼容性问题</strong></p></li><li><p>在 <code>IE低版本</code> 里面这个东西好用，但是在 <code>高版本IE</code> 和 <code>Chrome</code> 里面不好使了</p></li><li><p>我们就得用另一种方式来获取 <strong>事件对象</strong></p></li><li><p>在每一个事件处理函数的行参位置，默认第一个就是 <strong>事件对象</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript">oDiv.<span class="hljs-property">onclick</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) &#123;<br>  <span class="hljs-comment">// e 就是和 IE 的 window.event 一样的东西</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(e.<span class="hljs-property">X</span>轴坐标点信息)<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(e.<span class="hljs-property">Y</span>轴坐标点信息)<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>综上所述，我们以后在每一个事件里面，想获取事件对象的时候，都用兼容写法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript">oDiv.<span class="hljs-property">onclick</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) &#123;<br>  e = e || <span class="hljs-variable language_">window</span>.<span class="hljs-property">event</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(e.<span class="hljs-property">X</span>轴坐标点信息)<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(e.<span class="hljs-property">Y</span>轴坐标点信息)<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h6 id="点击事件的光标坐标点获取"><a href="#点击事件的光标坐标点获取" class="headerlink" title="点击事件的光标坐标点获取"></a>点击事件的光标坐标点获取</h6><img src="F:/前端学习/视频笔记/javascript/笔记/笔记/笔记.assets/image-20220530215226855.png" alt="image-20220530215226855" style="zoom: 67%;" /><img src="F:/前端学习/视频笔记/javascript/笔记/笔记/笔记.assets/image-20220530220140448.png" alt="image-20220530220140448" style="zoom: 67%;" /><img src="F:/前端学习/视频笔记/javascript/笔记/笔记/笔记.assets/image-20220530220229523.png" alt="image-20220530220229523" style="zoom: 67%;" /><h5 id="13-事件的传播"><a href="#13-事件的传播" class="headerlink" title="13. 事件的传播"></a>13. 事件的传播</h5><p><img src="F:/前端学习/视频笔记/javascript/笔记/笔记/笔记.assets/image-20220601095555972.png" alt="image-20220601095555972"></p><ul><li><strong>当元素触发一个事件的时候，其父元素也会触发相同的事件，父元素的父元素也会触发相同的事件</strong></li><li>就像上面的图片一样</li><li>点击在红色盒子上的时候，会触发红色盒子的点击事件</li><li>也是点击在了粉色的盒子上，也会触发粉色盒子的点击事件</li><li>也是点击在了 body 上，也会触发 body 的点击事件</li><li>也是点击在了 html 上，也会触发 html 的点击事件</li><li>也是点击在了 document 上，也会触发 document 的点击事件</li><li>也是点击在了 window 上，也会触发 window 的点击事件</li><li>也就是说，页面上任何一个元素触发事件，都会一层一层最终导致 window 的相同事件触发，前提是各层级元素得有注册相同的事件，不然不会触发</li><li>在事件传播的过程中，有一些注意的点：<ol><li>只会传播同类事件</li><li>只会从点击元素开始按照 html 的结构逐层向上元素的事件会被触发</li><li>内部元素不管有没有该事件，只要上层元素有该事件，那么上层元素的事件就会被触发</li></ol></li><li>到现在，我们已经了解了事件的传播，我们再来思考一个问题<ul><li>事件确实会从自己开始，到 window 的所有相同事件都会触发</li><li>是因为我们点在自己身上，也确实逐层的点在了直至 window 的每一个元素身上</li><li>但是到底是先点在自己身上，还是先点在了 window 身上呢</li><li>先点在自己身上，就是先执行自己的事件处理函数，逐层向上最后执行 window 的事件处理函数</li><li>反之，则是先执行 window 的事件处理函数，逐层向下最后执行自己身上的事件处理函数</li></ul></li></ul><h6 id="冒泡、捕获、目标"><a href="#冒泡、捕获、目标" class="headerlink" title="冒泡、捕获、目标"></a>冒泡、捕获、目标</h6><ul><li>我们刚才聊过了，每一个事件，都是有可能从自己到 window ，有可能要执行多个同类型事件</li><li>那么这个执行的顺序就有一些说法了</li></ul><p><strong>目标</strong></p><ul><li>你是点击在哪个元素身上了，那么这个事件的 <strong>目标</strong> 就是什么</li></ul><p><strong>冒泡</strong></p><ul><li>就是从事件 <strong>目标</strong> 的事件处理函数开始，依次向外，直到 window 的事件处理函数触发</li><li>也就是从下向上的执行事件处理函数</li></ul><p><strong>捕获</strong></p><ul><li>就是从 window 的事件处理函数开始，依次向内，只要事件 <strong>目标</strong> 的事件处理函数执行</li><li>也就是从上向下的执行事件处理函数</li></ul><p><strong>冒泡和捕获的区别</strong></p><ul><li>就是在事件的传播中，多个同类型事件处理函数的执行顺序不同</li></ul><h5 id="14-事件委托"><a href="#14-事件委托" class="headerlink" title="14. 事件委托"></a>14. 事件委托</h5><ul><li>就是把我要做的事情委托给别人来做</li><li>因为我们的冒泡机制，点击子元素的时候，也会同步触发父元素的相同事件</li><li>所以我们就可以把子元素的事件委托给父元素来做</li></ul><h6 id="事件触发"><a href="#事件触发" class="headerlink" title="事件触发"></a>事件触发</h6><ul><li><p>点击子元素的时候，不管子元素有没有点击事件，只要父元素有点击事件，那么就可以触发父元素的点击事件</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>2<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>3<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-keyword">var</span> oUl = docuemnt.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;ul&#x27;</span>)</span><br><span class="language-javascript">    </span><br><span class="language-javascript">    oUl.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) &#123;</span><br><span class="language-javascript">      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;我是 ul 的点击事件，我被触发了&#x27;</span>)</span><br><span class="language-javascript">    &#125;)</span><br><span class="language-javascript">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>像上面一段代码，当你点击 ul 的时候肯定会触发</li><li>但是当你点击 li 的时候，其实也会触发</li></ul></li></ul><h6 id="target"><a href="#target" class="headerlink" title="target"></a>target</h6><ul><li><p>target 这个属性是事件对象里面的属性，表示你点击的目标</p></li><li><p>当你触发点击事件的时候，你点击在哪个元素上，target 就是哪个元素</p></li><li><p>这个 target 也不兼容，在 IE 下要使用 srcElement</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>2<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>3<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-keyword">var</span> oUl = docuemnt.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;ul&#x27;</span>)</span><br><span class="language-javascript">    </span><br><span class="language-javascript">    oUl.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) &#123;</span><br><span class="language-javascript">      e = e || <span class="hljs-variable language_">window</span>.<span class="hljs-property">event</span></span><br><span class="language-javascript">      <span class="hljs-keyword">var</span> target = e.<span class="hljs-property">target</span> || e.<span class="hljs-property">srcElement</span></span><br><span class="language-javascript">      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(target)</span><br><span class="language-javascript">    &#125;)</span><br><span class="language-javascript">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>上面的代码，当你点击 ul 的时候，target 就是 ul</li><li>当你点击在 li 上面的时候，target 就是 li</li></ul></li></ul><h6 id="委托"><a href="#委托" class="headerlink" title="委托"></a>委托</h6><ul><li><p>这个时候，当我们点击 li 的时候，也可以触发 ul 的点事件</p></li><li><p>并且在事件内不，我们也可以拿到你点击的到底是 ul 还是 li</p></li><li><p>这个时候，我们就可以把 li 的事件委托给 ul 来做</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>2<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>3<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-keyword">var</span> oUl = docuemnt.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;ul&#x27;</span>)</span><br><span class="language-javascript">    </span><br><span class="language-javascript">    oUl.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) &#123;</span><br><span class="language-javascript">      e = e || <span class="hljs-variable language_">window</span>.<span class="hljs-property">event</span></span><br><span class="language-javascript">      <span class="hljs-keyword">var</span> target = e.<span class="hljs-property">target</span> || e.<span class="hljs-property">srcElement</span></span><br><span class="language-javascript">     </span><br><span class="language-javascript">      <span class="hljs-comment">// 判断你点击的是 li</span></span><br><span class="language-javascript">      <span class="hljs-keyword">if</span> (target.<span class="hljs-property">nodeName</span>.<span class="hljs-property">toUpperCase</span> === <span class="hljs-string">&#x27;LI&#x27;</span>) &#123;</span><br><span class="language-javascript">      <span class="hljs-comment">// 确定点击的是 li</span></span><br><span class="language-javascript">        <span class="hljs-comment">// 因为当你点击在 ul 上面的时候，nodeName 应该是 &#x27;UL&#x27;</span></span><br><span class="language-javascript">        <span class="hljs-comment">// 去做点击 li 的时候该做的事情了</span></span><br><span class="language-javascript">        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;我是 li，我被点击了&#x27;</span>)</span><br><span class="language-javascript">      &#125;</span><br><span class="language-javascript">    &#125;)</span><br><span class="language-javascript">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>上面的代码，我们就可以把 li 要做的事情委托给 ul 来做</li></ul></li></ul><h5 id="15-默认行为"><a href="#15-默认行为" class="headerlink" title="15. 默认行为"></a>15. 默认行为</h5><ul><li>默认行为，就是不用我们注册，它自己就存在的事情<ul><li>比如我们点击鼠标右键的时候，会自动弹出一个菜单</li><li>比如我们点击 a 标签的时候，我们不需要注册点击事件，他自己就会跳转页面</li><li>…</li></ul></li><li>这些不需要我们注册就能实现的事情，我们叫做 <strong>默认事件</strong></li></ul><h6 id="阻止默认行为"><a href="#阻止默认行为" class="headerlink" title="阻止默认行为"></a>阻止默认行为</h6><ul><li><p>有的时候，我们不希望浏览器执行默认事件</p><ul><li>比如我给 a 标签绑定了一个点击事件，我点击你的时候希望你能告诉我你的地址是什么</li><li>而不是直接跳转链接</li><li>那么我们就要把 a 标签原先的默认事件阻止，不让他执行默认事件</li></ul></li><li><p>我们有两个方法来阻止默认事件</p><ul><li><code>e.preventDefault()</code> : 非 IE 使用</li><li><code>e.returnValue = false</code> ：IE 使用</li></ul></li><li><p>我们阻止默认事件的时候也要写一个兼容的写法</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;https://www.baidu.com&quot;</span>&gt;</span>点击我试试<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">var</span> oA = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;a&#x27;</span>)</span><br><span class="language-javascript">  </span><br><span class="language-javascript">  a.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) &#123;</span><br><span class="language-javascript">    e = e || <span class="hljs-variable language_">window</span>.<span class="hljs-property">event</span></span><br><span class="language-javascript">    </span><br><span class="language-javascript">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">href</span>)</span><br><span class="language-javascript">    </span><br><span class="language-javascript">    e.<span class="hljs-property">preventDefault</span> ? e.<span class="hljs-title function_">preventDefault</span>() : e.<span class="hljs-property">returnValue</span> = <span class="hljs-literal">false</span></span><br><span class="language-javascript">  &#125;)</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>这样写完以后，你点击 a 标签的时候，就不会跳转链接了</li><li>而是会在控制台打印出 a 标签的 href 属性的值</li></ul></li></ul><h5 id="16-this-关键字"><a href="#16-this-关键字" class="headerlink" title="16. this 关键字"></a>16. this 关键字</h5><ul><li><p>每一个函数内部都有一个关键字是 <code>this</code> </p></li><li><p>可以让我们直接使用的</p></li><li><p>重点： <strong>函数内部的 this 只和函数的调用方式有关系，和函数的定义方式没有关系</strong></p></li><li><p>函数内部的 this 指向谁，取决于函数的调用方式</p><ul><li><p>全局定义的函数直接调用，<code>this =&gt; window</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>)<br>&#125;<br><span class="hljs-title function_">fn</span>()<br><span class="hljs-comment">// 此时 this 指向 window</span><br></code></pre></td></tr></table></figure></li><li><p>对象内部的方法调用，<code>this =&gt; 调用者</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123;<br>  <span class="hljs-attr">fn</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>)<br>  &#125;<br>&#125;<br>obj.<span class="hljs-title function_">fn</span>()<br><span class="hljs-comment">// 此时 this 指向 obj</span><br></code></pre></td></tr></table></figure></li><li><p>定时器的处理函数，<code>this =&gt; window</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>)<br>&#125;, <span class="hljs-number">0</span>)<br><span class="hljs-comment">// 此时定时器处理函数里面的 this 指向 window</span><br></code></pre></td></tr></table></figure></li><li><p>事件处理函数，<code>this =&gt; 事件源</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript">div.<span class="hljs-property">onclick</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>)<br>&#125;<br><span class="hljs-comment">// 当你点击 div 的时候，this 指向 div</span><br></code></pre></td></tr></table></figure></li><li><p>自调用函数，<code>this =&gt; window</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript">(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>)<br>&#125;)()<br><span class="hljs-comment">// 此时 this 指向 window</span><br></code></pre></td></tr></table></figure></li></ul></li></ul><p><strong>call 和 apply 和 bind</strong></p><ul><li>刚才我们说过的都是函数的基本调用方式里面的 this 指向</li><li>我们还有三个可以忽略函数本身的 this 指向转而指向别的地方</li><li>这三个方法就是 <strong>call</strong> &#x2F; <strong>apply</strong> &#x2F; <strong>bind</strong></li><li>是强行改变 this 指向的方法</li></ul><h6 id="call"><a href="#call" class="headerlink" title="call"></a>call</h6><ul><li><p><code>call</code> 方法是附加在函数调用后面使用，可以忽略函数本身的 this 指向</p></li><li><p>语法： <code>函数名.call(要改变的 this 指向，要给函数传递的参数1，要给函数传递的参数2， ...)</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Jack&#x27;</span> &#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params">a, b</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>)<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a)<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(b)<br>&#125;<br><span class="hljs-title function_">fn</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)<br>fn.<span class="hljs-title function_">call</span>(obj, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure><ul><li><code>fn()</code> 的时候，函数内部的 this 指向 window</li><li><code>fn.call(obj, 1, 2)</code> 的时候，函数内部的 this 就指向了 obj 这个对象</li><li>使用 call 方法的时候<ul><li>会立即执行函数</li><li>第一个参数是你要改变的函数内部的 this 指向</li><li>第二个参数开始，依次是向函数传递参数</li></ul></li></ul></li></ul><h6 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h6><ul><li><p><code>apply</code> 方法是附加在函数调用后面使用，可以忽略函数本身的 this 指向</p></li><li><p>语法： <code>函数名.apply(要改变的 this 指向，[要给函数传递的参数1， 要给函数传递的参数2， ...])</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Jack&#x27;</span> &#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params">a, b</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>)<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a)<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(b)<br>&#125;<br><span class="hljs-title function_">fn</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)<br>fn.<span class="hljs-title function_">call</span>(obj, [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>])<br></code></pre></td></tr></table></figure><ul><li><code>fn()</code> 的时候，函数内部的 this 指向 window</li><li><code>fn.apply(obj, [1, 2])</code> 的时候，函数内部的 this 就指向了 obj 这个对象</li><li>使用 apply 方法的时候<ul><li>会立即执行函数</li><li>第一个参数是你要改变的函数内部的 this 指向</li><li>第二个参数是一个 <strong>数组</strong>，数组里面的每一项依次是向函数传递的参数</li></ul></li></ul></li></ul><h6 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h6><ul><li><p><code>bind</code> 方法是附加在函数调用后面使用，可以忽略函数本身的 this 指向</p></li><li><p>和 call &#x2F; apply 有一些不一样，就是不会立即执行函数，而是返回一个已经改变了 this 指向的函数</p></li><li><p>语法： <code>var newFn = 函数名.bind(要改变的 this 指向); newFn(传递参数)</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Jack&#x27;</span> &#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params">a, b</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>)<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a)<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(b)<br>&#125;<br><span class="hljs-title function_">fn</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)<br><span class="hljs-keyword">var</span> newFn = fn.<span class="hljs-title function_">bind</span>(obj)<br><span class="hljs-title function_">newFn</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure><ul><li>bind 调用的时候，不会执行 fn 这个函数，而是返回一个新的函数</li><li>这个新的函数就是一个改变了 this 指向以后的 fn 函数</li><li><code>fn(1, 2)</code> 的时候 this 指向 window</li><li><code>newFn(1, 2)</code> 的时候执行的是一个和 fn 一摸一样的函数，只不过里面的 this 指向改成了 obj</li></ul></li></ul><h4 id="四-ES6"><a href="#四-ES6" class="headerlink" title="四. ES6"></a>四. ES6</h4><ul><li>我们所说的 ES5 和 ES6 其实就是在 js 语法的发展过程中的一个版本而已</li><li>ECMAScript 就是 js 的语法<ul><li>以前的版本没有某些功能</li><li>在 ES5 这个版本的时候增加了一些功能</li><li>在 ES6 这个版本的时候增加了一些功能</li></ul></li><li>因为浏览器是浏览器厂商生产的<ul><li>ECMAScript 发布了新的功能以后，浏览器厂商需要让自己的浏览器支持这些功能</li><li>这个过程是需要时间的</li><li>所以到现在，基本上大部分浏览器都可以比较完善的支持了</li><li>只不过有些浏览器还是不能全部支持</li><li>这就出现了兼容性问题</li><li>所以我们写代码的时候就要考虑哪些方法是 ES5 或者 ES6 的，看看是不是浏览器都支持</li></ul></li></ul><h5 id="let-和-const-关键字"><a href="#let-和-const-关键字" class="headerlink" title="let 和 const 关键字"></a>let 和 const 关键字</h5><ul><li><p>我们以前都是使用 <code>var</code> 关键字来声明变量的</p></li><li><p>在 ES6 的时候，多了两个关键字 <code>let</code> 和 <code>const</code>，也是用来声明变量的</p></li><li><p>只不过和 var 有一些区别</p><ol><li><p><code>let</code> 和 <code>const</code> 不允许重复声明变量</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 使用 var 的时候重复声明变量是没问题的，只不过就是后面会把前面覆盖掉</span><br><span class="hljs-keyword">var</span> num = <span class="hljs-number">100</span><br><span class="hljs-keyword">var</span> num = <span class="hljs-number">200</span><br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 使用 let 重复声明变量的时候就会报错了</span><br><span class="hljs-keyword">let</span> num = <span class="hljs-number">100</span><br><span class="hljs-keyword">let</span> num = <span class="hljs-number">200</span> <span class="hljs-comment">// 这里就会报错了</span><br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 使用 const 重复声明变量的时候就会报错</span><br><span class="hljs-keyword">const</span> num = <span class="hljs-number">100</span><br><span class="hljs-keyword">const</span> num = <span class="hljs-number">200</span> <span class="hljs-comment">// 这里就会报错了</span><br></code></pre></td></tr></table></figure></li><li><p><code>let</code> 和 <code>const</code> 声明的变量不会在预解析的时候解析（也就是没有变量提升）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 因为预解析（变量提升）的原因，在前面是有这个变量的，只不过没有赋值</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(num) <span class="hljs-comment">// undefined</span><br><span class="hljs-keyword">var</span> num = <span class="hljs-number">100</span><br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 因为 let 不会进行预解析（变量提升），所以直接报错了</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(num) <span class="hljs-comment">// undefined</span><br><span class="hljs-keyword">let</span> num = <span class="hljs-number">100</span><br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 因为 const 不会进行预解析（变量提升），所以直接报错了</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(num) <span class="hljs-comment">// undefined</span><br><span class="hljs-keyword">const</span> num = <span class="hljs-number">100</span><br></code></pre></td></tr></table></figure></li><li><p><code>let</code> 和 <code>const</code> 声明的变量会被所有代码块限制作用范围</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// var 声明的变量只有函数能限制其作用域，其他的不能限制</span><br><span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>) &#123;<br>  <span class="hljs-keyword">var</span> num = <span class="hljs-number">100</span><br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(num) <span class="hljs-comment">// 100</span><br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// let 声明的变量，除了函数可以限制，所有的代码块都可以限制其作用域（if/while/for/...）</span><br><span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>) &#123;<br>  <span class="hljs-keyword">let</span> num = <span class="hljs-number">100</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(num) <span class="hljs-comment">// 100</span><br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(num) <span class="hljs-comment">// 报错</span><br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// const 声明的变量，除了函数可以限制，所有的代码块都可以限制其作用域（if/while/for/...）</span><br><span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>) &#123;<br>  <span class="hljs-keyword">const</span> num = <span class="hljs-number">100</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(num) <span class="hljs-comment">// 100</span><br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(num) <span class="hljs-comment">// 报错</span><br></code></pre></td></tr></table></figure></li></ol></li><li><p><code>let</code> 和 <code>const</code> 的区别</p><ol><li><p><code>let</code> 声明的变量的值可以改变，<code>const</code> 声明的变量的值不可以改变</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> num = <span class="hljs-number">100</span><br>num = <span class="hljs-number">200</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(num) <span class="hljs-comment">// 200</span><br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> num = <span class="hljs-number">100</span><br>num = <span class="hljs-number">200</span> <span class="hljs-comment">// 这里就会报错了，因为 const 声明的变量值不可以改变（我们也叫做常量）</span><br></code></pre></td></tr></table></figure></li><li><p><code>let</code> 声明的时候可以不赋值，<code>const</code> 声明的时候必须赋值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> num<br>num = <span class="hljs-number">100</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(num) <span class="hljs-comment">// 100</span><br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> num <span class="hljs-comment">// 这里就会报错了，因为 const 声明的时候必须赋值</span><br></code></pre></td></tr></table></figure></li></ol></li></ul><h5 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h5><ul><li><p>箭头函数是 ES6 里面一个简写函数的语法方式</p></li><li><p>重点： <strong>箭头函数只能简写函数表达式，不能简写声明式函数</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params"></span>) &#123;&#125; <span class="hljs-comment">// 不能简写</span><br><span class="hljs-keyword">const</span> fun = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;&#125; <span class="hljs-comment">// 可以简写</span><br><span class="hljs-keyword">const</span> obj = &#123;<br>  <span class="hljs-attr">fn</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;&#125; <span class="hljs-comment">// 可以简写</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>语法： <code>(函数的行参) =&gt; &#123; 函数体内要执行的代码 &#125;</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> fn = <span class="hljs-keyword">function</span> (<span class="hljs-params">a, b</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a)<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(b)<br>&#125;<br><span class="hljs-comment">// 可以使用箭头函数写成</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">fun</span> = (<span class="hljs-params">a, b</span>) =&gt; &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a)<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(b)<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> obj = &#123;<br>  <span class="hljs-attr">fn</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">a, b</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a)<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(b)<br>  &#125;<br>&#125;<br><span class="hljs-comment">// 可以使用箭头函数写成</span><br><span class="hljs-keyword">const</span> obj2 = &#123;<br>  <span class="hljs-attr">fn</span>: <span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a)<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(b)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h6 id="箭头函数的特殊性"><a href="#箭头函数的特殊性" class="headerlink" title="箭头函数的特殊性"></a>箭头函数的特殊性</h6><ul><li><p>箭头函数内部没有 this，箭头函数的 this 是上下文的 this</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 在箭头函数定义的位置往上数，这一行是可以打印出 this 的</span><br><span class="hljs-comment">// 因为这里的 this 是 window</span><br><span class="hljs-comment">// 所以箭头函数内部的 this 就是 window</span><br><span class="hljs-keyword">const</span> obj = &#123;<br>  <span class="hljs-attr">fn</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>)<br>  &#125;,<br>  <span class="hljs-comment">// 这个位置是箭头函数的上一行，但是不能打印出 this</span><br>  <span class="hljs-attr">fun</span>: <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-comment">// 箭头函数内部的 this 是书写箭头函数的上一行一个可以打印出 this 的位置</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>)<br>  &#125;<br>&#125;<br><br>obj.<span class="hljs-title function_">fn</span>()<br>obj.<span class="hljs-title function_">fun</span>()<br></code></pre></td></tr></table></figure><ul><li>按照我们之前的 this 指向来判断，两个都应该指向 obj</li><li>但是 fun 因为是箭头函数，所以 this 不指向 obj，而是指向 fun 的外层，就是 window</li></ul></li><li><p>箭头函数内部没有 <code>arguments</code> 这个参数集合</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> obj = &#123;<br>  <span class="hljs-attr">fn</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">arguments</span>)<br>  &#125;,<br>  <span class="hljs-attr">fun</span>: <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">arguments</span>)<br>  &#125;<br>&#125;<br>obj.<span class="hljs-title function_">fn</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>) <span class="hljs-comment">// 会打印一个伪数组 [1, 2, 3]</span><br>obj.<span class="hljs-title function_">fun</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>) <span class="hljs-comment">// 会直接报错</span><br></code></pre></td></tr></table></figure></li><li><p>函数的行参只有一个的时候可以不写 <code>()</code> 其余情况必须写</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> obj = &#123;<br>  <span class="hljs-attr">fn</span>: <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;没有参数，必须写小括号&#x27;</span>)<br>  &#125;,<br>  <span class="hljs-attr">fn2</span>: <span class="hljs-function"><span class="hljs-params">a</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;一个行参，可以不写小括号&#x27;</span>)<br>  &#125;,<br>  <span class="hljs-attr">fn3</span>: <span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;两个或两个以上参数，必须写小括号&#x27;</span>)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>函数体只有一行代码的时候，可以不写 <code>&#123;&#125;</code> ，并且会自动 return</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> obj = &#123;<br>  <span class="hljs-attr">fn</span>: <span class="hljs-function"><span class="hljs-params">a</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> a + <span class="hljs-number">10</span><br>  &#125;,<br>  <span class="hljs-attr">fun</span>: <span class="hljs-function"><span class="hljs-params">a</span> =&gt;</span> a + <span class="hljs-number">10</span><br>&#125;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">fn</span>(<span class="hljs-number">10</span>)) <span class="hljs-comment">// 20</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">fun</span>(<span class="hljs-number">10</span>)) <span class="hljs-comment">// 20</span><br></code></pre></td></tr></table></figure></li></ul><h5 id="函数传递参数的时候的默认值"><a href="#函数传递参数的时候的默认值" class="headerlink" title="函数传递参数的时候的默认值"></a>函数传递参数的时候的默认值</h5><ul><li><p>我们在定义函数的时候，有的时候需要一个默认值出现</p></li><li><p>就是当我不传递参数的时候，使用默认值，传递参数了就使用传递的参数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params">a</span>) &#123;<br>  a = a || <span class="hljs-number">10</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a)<br>&#125;<br><span class="hljs-title function_">fn</span>()   <span class="hljs-comment">// 不传递参数的时候，函数内部的 a 就是 10</span><br><span class="hljs-title function_">fn</span>(<span class="hljs-number">20</span>) <span class="hljs-comment">// 传递了参数 20 的时候，函数内部的 a 就是 20</span><br></code></pre></td></tr></table></figure><ul><li>在 ES6 中我们可以直接把默认值写在函数的行参位置</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params">a = <span class="hljs-number">10</span></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a)<br>&#125;<br><span class="hljs-title function_">fn</span>()   <span class="hljs-comment">// 不传递参数的时候，函数内部的 a 就是 10</span><br><span class="hljs-title function_">fn</span>(<span class="hljs-number">20</span>) <span class="hljs-comment">// 传递了参数 20 的时候，函数内部的 a 就是 20</span><br></code></pre></td></tr></table></figure><ul><li>这个默认值的方式箭头函数也可以使用</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">fn</span> = (<span class="hljs-params">a = <span class="hljs-number">10</span></span>) =&gt; &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a)<br>&#125;<br><span class="hljs-title function_">fn</span>()   <span class="hljs-comment">// 不传递参数的时候，函数内部的 a 就是 10</span><br><span class="hljs-title function_">fn</span>(<span class="hljs-number">20</span>) <span class="hljs-comment">// 传递了参数 20 的时候，函数内部的 a 就是 20</span><br></code></pre></td></tr></table></figure><ul><li>注意： <strong>箭头函数如果你需要使用默认值的话，那么一个参数的时候也需要写 （）</strong></li></ul></li></ul><h5 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h5><ul><li>解构赋值，就是快速的从对象或者数组中取出成员的一个语法方式</li></ul><h6 id="解构对象"><a href="#解构对象" class="headerlink" title="解构对象"></a>解构对象</h6><ul><li><p>快速的从对象中获取成员</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// ES5 的方法向得到对象中的成员</span><br><span class="hljs-keyword">const</span> obj = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Jack&#x27;</span>,<br>  <span class="hljs-attr">age</span>: <span class="hljs-number">18</span>,<br>  <span class="hljs-attr">gender</span>: <span class="hljs-string">&#x27;男&#x27;</span><br>&#125;<br><br><span class="hljs-keyword">let</span> name = obj.<span class="hljs-property">name</span><br><span class="hljs-keyword">let</span> age = obj.<span class="hljs-property">age</span><br><span class="hljs-keyword">let</span> gender = obj.<span class="hljs-property">gender</span><br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 解构赋值的方式从对象中获取成员</span><br><span class="hljs-keyword">const</span> obj = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Jack&#x27;</span>,<br>  <span class="hljs-attr">age</span>: <span class="hljs-number">18</span>,<br>  <span class="hljs-attr">gender</span>: <span class="hljs-string">&#x27;男&#x27;</span><br>&#125;<br><br><span class="hljs-comment">// 前面的 &#123;&#125; 表示我要从 obj 这个对象中获取成员了</span><br><span class="hljs-comment">// name age gender 都得是 obj 中有的成员</span><br><span class="hljs-comment">// obj 必须是一个对象</span><br><span class="hljs-keyword">let</span> &#123; name, age, gender &#125; = obj<br></code></pre></td></tr></table></figure></li></ul><h6 id="解构数组"><a href="#解构数组" class="headerlink" title="解构数组"></a>解构数组</h6><ul><li><p>快速的从数组中获取成员</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// ES5 的方式从数组中获取成员</span><br><span class="hljs-keyword">const</span> arr = [<span class="hljs-string">&#x27;Jack&#x27;</span>, <span class="hljs-string">&#x27;Rose&#x27;</span>, <span class="hljs-string">&#x27;Tom&#x27;</span>]<br><span class="hljs-keyword">let</span> a = arr[<span class="hljs-number">0</span>]<br><span class="hljs-keyword">let</span> b = arr[<span class="hljs-number">1</span>]<br><span class="hljs-keyword">let</span> c = arr[<span class="hljs-number">2</span>]<br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 使用解构赋值的方式从数组中获取成员</span><br><span class="hljs-keyword">const</span> arr = [<span class="hljs-string">&#x27;Jack&#x27;</span>, <span class="hljs-string">&#x27;Rose&#x27;</span>, <span class="hljs-string">&#x27;Tom&#x27;</span>]<br><br><span class="hljs-comment">// 前面的 [] 表示要从 arr 这个数组中获取成员了</span><br><span class="hljs-comment">// a b c 分别对应这数组中的索引 0 1 2</span><br><span class="hljs-comment">// arr 必须是一个数组</span><br><span class="hljs-keyword">let</span> [a, b, c] = arr<br></code></pre></td></tr></table></figure></li></ul><h6 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h6><ul><li><code>&#123;&#125;</code> 是专门解构对象使用的</li><li><code>[]</code> 是专门解构数组使用的</li><li>不能混用</li></ul><h5 id="模版字符串"><a href="#模版字符串" class="headerlink" title="模版字符串"></a>模版字符串</h5><ul><li><p>ES5 中我们表示字符串的时候使用 <code>&#39;&#39;</code> 或者 <code>&quot;&quot;</code></p></li><li><p>在 ES6 中，我们还有一个东西可以表示字符串，就是 **&#96;&#96;**（反引号）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> str = <span class="hljs-string">`hello world`</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> str) <span class="hljs-comment">// string</span><br></code></pre></td></tr></table></figure></li><li><p>和单引号好友双引号的区别</p><ol><li><p>反引号可以换行书写</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 这个单引号或者双引号不能换行，换行就会报错了</span><br><span class="hljs-keyword">let</span> str = <span class="hljs-string">&#x27;hello world&#x27;</span> <br><br><span class="hljs-comment">// 下面这个就报错了</span><br><span class="hljs-keyword">let</span> str2 = <span class="hljs-string">&#x27;hello </span><br><span class="hljs-string">world&#x27;</span><br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> str = <span class="hljs-string">`</span><br><span class="hljs-string">hello</span><br><span class="hljs-string">world</span><br><span class="hljs-string">`</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str) <span class="hljs-comment">// 是可以使用的</span><br></code></pre></td></tr></table></figure></li><li><p>反引号可以直接在字符串里面拼接变量</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// ES5 需要字符串拼接变量的时候</span><br><span class="hljs-keyword">let</span> num = <span class="hljs-number">100</span><br><span class="hljs-keyword">let</span> str = <span class="hljs-string">&#x27;hello&#x27;</span> + num + <span class="hljs-string">&#x27;world&#x27;</span> + num<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str) <span class="hljs-comment">// hello100world100</span><br><br><span class="hljs-comment">// 直接写在字符串里面不好使</span><br><span class="hljs-keyword">let</span> str2 = <span class="hljs-string">&#x27;hellonumworldnum&#x27;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str2) <span class="hljs-comment">// hellonumworldnum</span><br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 模版字符串拼接变量</span><br><span class="hljs-keyword">let</span> num = <span class="hljs-number">100</span><br><span class="hljs-keyword">let</span> str = <span class="hljs-string">`hello<span class="hljs-subst">$&#123;num&#125;</span>world<span class="hljs-subst">$&#123;num&#125;</span>`</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str) <span class="hljs-comment">// hello100world100</span><br></code></pre></td></tr></table></figure><ul><li>在 <strong>&#96;&#96;</strong> 里面的 <code>$&#123;&#125;</code> 就是用来书写变量的位置</li></ul></li></ol></li></ul><h5 id="展开运算符"><a href="#展开运算符" class="headerlink" title="展开运算符"></a>展开运算符</h5><ul><li><p>ES6 里面号新添加了一个运算符 <code>...</code> ，叫做展开运算符</p></li><li><p>作用是把数组展开</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(...arr) <span class="hljs-comment">// 1 2 3 4 5</span><br></code></pre></td></tr></table></figure></li><li><p>合并数组的时候可以使用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]<br><span class="hljs-keyword">let</span> arr2 = [...arr, <span class="hljs-number">5</span>]<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr2)<br></code></pre></td></tr></table></figure></li><li><p>也可以合并对象使用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> obj = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Jack&#x27;</span>,<br>  <span class="hljs-attr">age</span>: <span class="hljs-number">18</span><br>&#125;<br><span class="hljs-keyword">let</span> obj2 = &#123;<br>  ...obj,<br>  <span class="hljs-attr">gender</span>: <span class="hljs-string">&#x27;男&#x27;</span><br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj2)<br></code></pre></td></tr></table></figure></li><li><p>在函数传递参数的时候也可以使用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params">a, b, c</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a)<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(b)<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(c)<br>&#125;<br><span class="hljs-title function_">fn</span>(...arr)<br><span class="hljs-comment">// 等价于 fn(1, 2, 3)</span><br></code></pre></td></tr></table></figure></li></ul><h4 id="五-面向对象"><a href="#五-面向对象" class="headerlink" title="五.面向对象"></a>五.面向对象</h4><ul><li>首先，我们要明确，面向对象不是语法，是一个思想，是一种 <strong>编程模式</strong></li><li>面向： 面（脸），向（朝着）</li><li>面向过程： 脸朝着过程 &#x3D;》 关注着过程的编程模式</li><li>面向对象： 脸朝着对象 &#x3D;》 关注着对象的编程模式</li><li>实现一个效果<ul><li>在面向过程的时候，我们要关注每一个元素，每一个元素之间的关系，顺序，。。。</li><li>在面向过程的时候，我们要关注的就是找到一个对象来帮我做这个事情，我等待结果</li></ul></li><li>我们以前的编程思想是，每一个功能，都按照需求一步一步的逐步完成</li></ul><h5 id="创建对象的方式"><a href="#创建对象的方式" class="headerlink" title="创建对象的方式"></a>创建对象的方式</h5><ul><li>因为面向对象就是一个找到对象的过程</li><li>所以我们先要了解如何创建一个对象</li></ul><h6 id="调用系统内置的构造函数创建对象"><a href="#调用系统内置的构造函数创建对象" class="headerlink" title="调用系统内置的构造函数创建对象"></a>调用系统内置的构造函数创建对象</h6><ul><li><p>js 给我们内置了一个 Object 构造函数</p></li><li><p>这个构造函数就是用来创造对象的</p></li><li><p>当 构造函数 和 new 关键字连用的时候，就可以为我们创造出一个对象</p></li><li><p>因为 js 是一个动态的语言，那么我们就可以动态的向对象中添加成员了</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 就能得到一个空对象</span><br><span class="hljs-keyword">var</span> o1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>() <br><br><span class="hljs-comment">// 正常操作对象</span><br>o1.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;Jack&#x27;</span><br>o1.<span class="hljs-property">age</span> = <span class="hljs-number">18</span><br>o1.<span class="hljs-property">gender</span> = <span class="hljs-string">&#x27;男&#x27;</span><br></code></pre></td></tr></table></figure></li></ul><h6 id="字面量的方式创建一个对象"><a href="#字面量的方式创建一个对象" class="headerlink" title="字面量的方式创建一个对象"></a>字面量的方式创建一个对象</h6><ul><li><p>直接使用字面量的形式，也就是直接写 <code>&#123;&#125;</code></p></li><li><p>可以在写的时候就添加好成员，也可以动态的添加</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 字面量方式创建对象</span><br><span class="hljs-keyword">var</span> o1 = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Jack&#x27;</span>,<br>  <span class="hljs-attr">age</span>: <span class="hljs-number">18</span>,<br>  <span class="hljs-attr">gender</span>: <span class="hljs-string">&#x27;男&#x27;</span><br>&#125;<br><br><span class="hljs-comment">// 再来一个</span><br><span class="hljs-keyword">var</span> o2 = &#123;&#125;<br>o2.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;Rose&#x27;</span><br>o2.<span class="hljs-property">age</span> = <span class="hljs-number">20</span><br>o2.<span class="hljs-property">gender</span> = <span class="hljs-string">&#x27;女&#x27;</span><br></code></pre></td></tr></table></figure></li></ul><h6 id="使用工厂函数的方式创建对象"><a href="#使用工厂函数的方式创建对象" class="headerlink" title="使用工厂函数的方式创建对象"></a>使用工厂函数的方式创建对象</h6><ul><li><p>先书写一个工厂函数</p></li><li><p>这个工厂函数里面可以创造出一个对象，并且给对象添加一些属性，还能把对象返回</p></li><li><p>使用这个工厂函数创造对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 1. 先创建一个工厂函数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">createObj</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">// 手动创建一个对象</span><br>  <span class="hljs-keyword">var</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>()<br><br>  <span class="hljs-comment">// 手动的向对象中添加成员</span><br>  obj.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;Jack&#x27;</span><br>  obj.<span class="hljs-property">age</span> = <span class="hljs-number">18</span><br>  obj.<span class="hljs-property">gender</span> = <span class="hljs-string">&#x27;男&#x27;</span><br><br>  <span class="hljs-comment">// 手动返回一个对象</span><br>  <span class="hljs-keyword">return</span> obj<br>&#125;<br><br><span class="hljs-comment">// 2. 使用这个工厂函数创建对象</span><br><span class="hljs-keyword">var</span> o1 = <span class="hljs-title function_">createObj</span>()<br><span class="hljs-keyword">var</span> o2 = <span class="hljs-title function_">createObj</span>()<br></code></pre></td></tr></table></figure></li></ul><h6 id="使用自定义构造函数创建对象"><a href="#使用自定义构造函数创建对象" class="headerlink" title="使用自定义构造函数创建对象"></a>使用自定义构造函数创建对象</h6><ul><li><p>工厂函数需要经历三个步骤</p><ul><li>手动创建对象</li><li>手动添加成员</li><li>手动返回对象</li></ul></li><li><p>构造函数会比工厂函数简单一下</p><ul><li>自动创建对象</li><li>手动添加成员</li><li>自动返回对象</li></ul></li><li><p>先书写一个构造函数</p></li><li><p>在构造函数内向对象添加一些成员</p></li><li><p>使用这个构造函数创造一个对象（和 new 连用）</p></li><li><p>构造函数可以创建对象，并且创建一个带有属性和方法的对象</p></li><li><p>面向对象就是要想办法找到一个有属性和方法的对象</p></li><li><p>面向对象就是我们自己制造 <strong>构造函数</strong> 的过程</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 1. 先创造一个构造函数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name, gender</span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = <span class="hljs-number">18</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">gender</span> = gender<br>&#125;<br><br><span class="hljs-comment">// 2. 使用构造函数创建对象</span><br><span class="hljs-keyword">var</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&#x27;Jack&#x27;</span>, <span class="hljs-string">&#x27;man&#x27;</span>)<br><span class="hljs-keyword">var</span> p2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&#x27;Rose&#x27;</span>, <span class="hljs-string">&#x27;woman&#x27;</span>)<br></code></pre></td></tr></table></figure></li></ul><h5 id="构造函数详解"><a href="#构造函数详解" class="headerlink" title="构造函数详解"></a>构造函数详解</h5><ul><li>我们了解了对象的创建方式</li><li>我们的面向对象就是要么能直接得到一个对象</li><li>要么就弄出一个能创造对象的东西，我们自己创造对象</li><li>我们的构造函数就能创造对象，所以接下来我们就详细聊聊 <strong>构造函数</strong></li></ul><h6 id="构造函数的基本使用"><a href="#构造函数的基本使用" class="headerlink" title="构造函数的基本使用"></a>构造函数的基本使用</h6><ul><li><p>和普通函数一样，只不过 <strong>调用的时候要和 new 连用</strong>，不然就是一个普通函数调用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params"></span>) &#123;&#125;<br><span class="hljs-keyword">var</span> o1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>()  <span class="hljs-comment">// 能得到一个空对象</span><br><span class="hljs-keyword">var</span> o2 = <span class="hljs-title class_">Person</span>()      <span class="hljs-comment">// 什么也得不到，这个就是普通函数调用</span><br></code></pre></td></tr></table></figure><ul><li>注意： <strong>不写 new 的时候就是普通函数调用，没有创造对象的能力</strong></li></ul></li><li><p>首字母大写</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">person</span>(<span class="hljs-params"></span>) &#123;&#125;<br><span class="hljs-keyword">var</span> o1 = <span class="hljs-keyword">new</span> <span class="hljs-title function_">person</span>() <span class="hljs-comment">// 能得到一个对象</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params"></span>) &#123;&#125;<br><span class="hljs-keyword">var</span> o2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>() <span class="hljs-comment">// 能得到一个对象</span><br></code></pre></td></tr></table></figure><ul><li>注意： <strong>首字母不大写，只要和 new 连用，就有创造对象的能力</strong></li></ul></li><li><p>当调用的时候如果不需要传递参数可以不写 <code>()</code>，建议都写上</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params"></span>) &#123;&#125;<br><span class="hljs-keyword">var</span> o1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>()  <span class="hljs-comment">// 能得到一个空对象</span><br><span class="hljs-keyword">var</span> o2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>    <span class="hljs-comment">// 能得到一个空对象 </span><br></code></pre></td></tr></table></figure><ul><li>注意： <strong>如果不需要传递参数，那么可以不写 （），如果传递参数就必须写</strong></li></ul></li><li><p>构造函数内部的 this，由于和 new 连用的关系，是指向当前实例对象的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>)<br>&#125;<br><span class="hljs-keyword">var</span> o1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>()  <span class="hljs-comment">// 本次调用的时候，this =&gt; o1</span><br><span class="hljs-keyword">var</span> o2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>()  <span class="hljs-comment">// 本次调用的时候，this =&gt; o2</span><br></code></pre></td></tr></table></figure><ul><li>注意： <strong>每次 new 的时候，函数内部的 this 都是指向当前这次的实例化对象</strong></li></ul></li><li><p>因为构造函数会自动返回一个对象，所以构造函数内部不要写 return</p><ul><li>你如果 return 一个基本数据类型，那么写了没有意义</li><li>如果你 return 一个引用数据类型，那么构造函数本身的意义就没有了</li></ul></li></ul><h6 id="使用构造函数创建一个对象"><a href="#使用构造函数创建一个对象" class="headerlink" title="使用构造函数创建一个对象"></a>使用构造函数创建一个对象</h6><ul><li><p>我们在使用构造函数的时候，可以通过一些代码和内容来向当前的对象中添加一些内容</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;Jack&#x27;</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = <span class="hljs-number">18</span><br>&#125;<br><br><span class="hljs-keyword">var</span> o1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>()<br><span class="hljs-keyword">var</span> o2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>()<br></code></pre></td></tr></table></figure><ul><li>我们得到的两个对象里面都有自己的成员 <strong>name</strong> 和 <strong>age</strong></li></ul></li><li><p>我们在写构造函数的时候，是不是也可以添加一些方法进去呢？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;Jack&#x27;</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = <span class="hljs-number">18</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">sayHi</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;hello constructor&#x27;</span>)<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">var</span> o1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>()<br><span class="hljs-keyword">var</span> o2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>()<br></code></pre></td></tr></table></figure><ul><li>显然是可以的，我们的到的两个对象中都有 <code>sayHi</code> 这个函数</li><li>也都可以正常调用</li></ul></li><li><p>但是这样好不好呢？缺点在哪里？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;Jack&#x27;</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = <span class="hljs-number">18</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">sayHi</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;hello constructor&#x27;</span>)<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 第一次 new 的时候， Person 这个函数要执行一遍</span><br><span class="hljs-comment">// 执行一遍就会创造一个新的函数，并且把函数地址赋值给 this.sayHi</span><br><span class="hljs-keyword">var</span> o1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>()<br><br><span class="hljs-comment">// 第二次 new 的时候， Person 这个函数要执行一遍</span><br><span class="hljs-comment">// 执行一遍就会创造一个新的函数，并且把函数地址赋值给 this.sayHi</span><br><span class="hljs-keyword">var</span> o2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>()<br></code></pre></td></tr></table></figure><ul><li>这样的话，那么我们两个对象内的 <code>sayHi</code> 函数就是一个代码一摸一样，功能一摸一样</li><li>但是是两个空间函数，占用两个内存空间</li><li>也就是说 <code>o1.sayHi</code> 是一个地址，<code>o2.sayHi</code> 是一个地址</li><li>所以我们执行 <code>console.log(o1 === o2.sayHi)</code> 的到的结果是 <code>false</code></li><li>缺点： <strong>一摸一样的函数出现了两次，占用了两个空间地址</strong></li></ul></li><li><p>怎么解决这个问题呢？</p><ul><li>就需要用到一个东西，叫做 <strong>原型</strong></li></ul></li></ul><h5 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h5><ul><li>原型的出现，就是为了解决 <strong>构造函数的缺点</strong></li><li>也就是给我们提供了一个给对象添加函数的方法</li><li>不然构造函数只能给对象添加属性，不能合理的添加函数就太 LOW 了</li></ul><h6 id="prototype"><a href="#prototype" class="headerlink" title="prototype"></a>prototype</h6><ul><li><p><strong>每一个函数天生自带一个成员，叫做 prototype，是一个对象空间</strong></p></li><li><p>即然每一个函数都有，构造函数也是函数，构造函数也有这个对象空间</p></li><li><p>这个 <code>prototype</code> 对象空间可以由函数名来访问</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params"></span>) &#123;&#125;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>) <span class="hljs-comment">// 是一个对象</span><br></code></pre></td></tr></table></figure><ul><li>即然是个对象，那么我们就可以向里面放入一些东西</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params"></span>) &#123;&#125;<br><br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;prototype&#x27;</span><br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">sayHi</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;&#125;<br></code></pre></td></tr></table></figure></li><li><p>我们发现了一个叫做 <code>prototype</code> 的空间是和函数有关联的</p></li><li><p>并且可以向里面存储一些东西</p></li><li><p>重点： <strong>在函数的 prototype 里面存储的内容，不是给函数使用的，是给函数的每一个实例化对象使用的</strong></p></li><li><p>那实例化对象怎么使用能？</p></li></ul><h6 id="proto"><a href="#proto" class="headerlink" title="__proto__"></a>__proto__</h6><ul><li><p><strong>每一个对象都天生自带一个成员，叫做 <code>__proto__</code>，是一个对象空间</strong></p></li><li><p>即然每一个对象都有，实例化对象也是对象，那么每一个实例化对象也有这个成员</p></li><li><p>这个 <code>__proto__</code> 对象空间是给每一个对象使用的</p></li><li><p>当你访问一个对象中的成员的时候</p><ul><li>如果这个对象自己本身有这个成员，那么就会直接给你结果</li><li>如果没有，就会去 <code>__proto__</code> 这个对象空间里面找，里面有的话就给你结果</li><li>未完待续。。。</li></ul></li><li><p>那么这个 <code>__proto__</code> 又指向哪里呢？</p><ul><li>这个对象是由哪个构造函数 new 出来的</li><li>那么这个对象的 <code>__proto__</code> 就指向这个构造函数的 <code>prototype</code></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params"></span>) &#123;&#125;<br><br><span class="hljs-keyword">var</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>()<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p1.<span class="hljs-property">__proto__</span> === <span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>) <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><ul><li>我们发现实例化对象的 <code>__proto__</code> 和所属的构造函数的 <code>prototype</code> 是一个对象空间</li><li>我们可以通过构造函数名称来向 <code>prototype</code> 中添加成员</li><li>对象在访问的时候自己没有，可以自动去自己的 <code>__proto__</code> 中查找</li><li>那么，我们之前构造函数的缺点就可以解决了<ul><li>我们可以把函数放在构造函数的 <code>prototype</code> 中</li><li>实例化对象访问的时候，自己没有，就会自动去 <code>__proto__</code> 中找</li><li>那么也可以使用了</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params"></span>) &#123;&#125;<br><br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">sayHi</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;hello Person&#x27;</span>)<br>&#125;<br><br><span class="hljs-keyword">var</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>()<br>p1.<span class="hljs-title function_">sayHi</span>()<br></code></pre></td></tr></table></figure><ul><li><code>p1</code> 自己没有 <code>sayHi</code> 方法，就会去自己的 <code>__proto__</code> 中查找</li><li><code>p1.__proto__</code> 就是 <code>Person.prototype</code></li><li>我们又向 <code>Person.prototype</code> 中添加了 <code>sayHi</code> 方法</li><li>所以 <code>p1.sayHi</code> 就可以执行了</li></ul></li><li><p>到这里，当我们实例化多个对象的时候，每个对象里面都没有方法</p><ul><li>都是去所属的构造函数的 <code>protottype</code> 中查找</li><li>那么每一个对象使用的函数，其实都是同一个函数</li><li>那么就解决了我们构造函数的缺点</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params"></span>) &#123;&#125;<br><br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">sayHi</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;hello&#x27;</span>)<br>&#125;<br><br><span class="hljs-keyword">var</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>()<br><span class="hljs-keyword">var</span> p2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>()<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p1.<span class="hljs-property">sayHi</span> === p2.<span class="hljs-property">sayHi</span>)<br></code></pre></td></tr></table></figure><ul><li><code>p1</code> 是 <code>Person</code> 的一个实例</li><li><code>p2</code> 是 <code>Person</code> 的一个实例</li><li>也就是说 <code>p1.__proto__</code> 和 <code>p2.__proto__</code> 指向的都是 <code>Person.prototype</code></li><li>当 <code>p1</code> 去调用 <code>sayHi</code> 方法的时候是去 <code>Person.prototype</code> 中找</li><li>当 <code>p2</code> 去调用 <code>sayHi</code> 方法的时候是去 <code>Person.prototype</code> 中找</li><li>那么两个实例化对象就是找到的一个方法，也是执行的一个方法</li></ul></li><li><p>结论</p><ul><li>当我们写构造函数的时候</li><li><strong>属性我们直接写在构造函数体内</strong></li><li><strong>方法我们写在原型上</strong></li></ul></li></ul><h5 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h5><ul><li>我们刚才聊过构造函数了，也聊了原型</li><li>那么问题出现了，我们说构造函数的 <code>prototype</code> 是一个对象</li><li>又说了每一个对象都天生自带一个 <code>__proto__</code> 属性</li><li>那么 <strong>构造函数的 prototype</strong> 里面的 <code>__proto__</code> 属性又指向哪里呢？</li></ul><h6 id="一个对象所属的构造函数"><a href="#一个对象所属的构造函数" class="headerlink" title="一个对象所属的构造函数"></a>一个对象所属的构造函数</h6><ul><li><p>每一个对象都有一个自己所属的构造函数</p></li><li><p>比如： 数组</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 数组本身也是一个对象</span><br><span class="hljs-keyword">var</span> arr = []<br><span class="hljs-keyword">var</span> arr2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>()<br></code></pre></td></tr></table></figure><ul><li>以上两种方式都是创造一个数组</li><li>我们就说数组所属的构造函数就是 <code>Array</code></li></ul></li><li><p>比如： 函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 函数本身也是一个对象</span><br><span class="hljs-keyword">var</span> fn = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;&#125;<br><span class="hljs-keyword">var</span> fun = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Function</span>()<br></code></pre></td></tr></table></figure><ul><li>以上两种方式都是创造一个函数</li><li>我们就说函数所属的构造函数就是 <code>Function</code></li></ul></li></ul><h6 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h6><ul><li>对象的 <code>__proto__</code> 里面也有一个成员叫做 <strong><code>constructor</code></strong></li><li>这个属性就是指向当前这个对象所属的构造函数</li></ul><h6 id="链状结构"><a href="#链状结构" class="headerlink" title="链状结构"></a>链状结构</h6><ul><li>当一个对象我们不知道准确的是谁构造的时候，我们呢就把它看成 <code>Object</code> 的实例化对象</li><li>也就是说，我们的 <strong>构造函数 的 prototype 的 <code>__proto__</code></strong> 指向的是 <code>Object.prototype</code></li><li>那么 <code>Object.prototype</code> 也是个对象，那么它的 <code>__proto__</code> 又指向谁呢？</li><li>因为 <code>Object</code> 的 js 中的顶级构造函数，我们有一句话叫 <strong>万物皆对象</strong></li><li>所以 <code>Object.prototype</code> 就到顶了，<code>Object.prototype</code> 的 <code>__proto__</code> 就是 null</li></ul><h6 id="原型链的访问原则"><a href="#原型链的访问原则" class="headerlink" title="原型链的访问原则"></a>原型链的访问原则</h6><ul><li>我们之前说过，访问一个对象的成员的时候，自己没有就会去 <code>__proto__</code> 中找</li><li>接下来就是，如果 <code>__proto__</code> 里面没有就再去 <code>__proto__</code> 里面找</li><li>一直找到 <code>Object.prototype</code> 里面都没有，那么就会返回 <code>undefiend</code></li></ul><h6 id="对象的赋值"><a href="#对象的赋值" class="headerlink" title="对象的赋值"></a>对象的赋值</h6><ul><li>到这里，我们就会觉得，如果是赋值的话，那么也会按照原型链的规则来</li><li>但是： <strong>并不是！并不是！并不是！</strong> 重要的事情说三遍</li><li>赋值的时候，就是直接给对象自己本身赋值<ul><li>如果原先有就是修改</li><li>原先没有就是添加</li><li>不会和 <code>__proto__</code> 有关系</li></ul></li></ul><h5 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h5><h6 id="构造函数继承"><a href="#构造函数继承" class="headerlink" title="构造函数继承"></a>构造函数继承</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Student</span>(<span class="hljs-params">name,age,classroom</span>)&#123;<br>            <span class="hljs-title class_">Person</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>,name,age)<br>            <span class="hljs-variable language_">this</span>.<span class="hljs-property">classroom</span> = classroom<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="原型继承"><a href="#原型继承" class="headerlink" title="原型继承"></a>原型继承</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Student</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>()<br></code></pre></td></tr></table></figure><h6 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h6><p>构造函数继承+原型继承</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name,age</span>)&#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age<br>&#125;<br><br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">say</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;hello&quot;</span>)<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Student</span>(<span class="hljs-params">name,age,classroom</span>)&#123;<br>    <span class="hljs-title class_">Person</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>,name,age)<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">classroom</span> = classroom<br>&#125;<br><br><span class="hljs-title class_">Student</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>()<br><br><span class="hljs-keyword">var</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;kerwin&quot;</span>,<span class="hljs-number">100</span>,<span class="hljs-string">&quot;1班&quot;</span>)<br></code></pre></td></tr></table></figure><h4 id="六-AJAX"><a href="#六-AJAX" class="headerlink" title="六. AJAX"></a>六. AJAX</h4><ul><li><code>ajax</code> 全名 <code>async javascript and XML</code></li><li>是前后台交互的能力</li><li>也就是我们客户端给服务端发送消息的工具，以及接受响应的工具</li><li>是一个 <strong>默认异步</strong> 执行机制的功能</li></ul><h5 id="AJAX-的优势"><a href="#AJAX-的优势" class="headerlink" title="AJAX 的优势"></a>AJAX 的优势</h5><ol><li>不需要插件的支持，原生 js 就可以使用</li><li>用户体验好（不需要刷新页面就可以更新数据）</li><li>减轻服务端和带宽的负担</li><li>缺点： 搜索引擎的支持度不够，因为数据都不在页面上，搜索引擎搜索不到</li></ol><h5 id="AJAX-的使用"><a href="#AJAX-的使用" class="headerlink" title="AJAX 的使用"></a>AJAX 的使用</h5><ul><li>在 js 中有内置的构造函数来创建 ajax 对象</li><li>创建 ajax 对象以后，我们就使用 ajax 对象的方法去发送请求和接受响应</li></ul><h6 id="创建一个-ajax-对象"><a href="#创建一个-ajax-对象" class="headerlink" title="创建一个 ajax 对象"></a>创建一个 ajax 对象</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// IE9及以上</span><br><span class="hljs-keyword">const</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>()<br><br><span class="hljs-comment">// IE9以下</span><br><span class="hljs-keyword">const</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ActiveXObject</span>(<span class="hljs-string">&#x27;Mricosoft.XMLHTTP&#x27;</span>)<br></code></pre></td></tr></table></figure><ul><li>上面就是有了一个 ajax 对象</li><li>我们就可以使用这个 <code>xhr</code> 对象来发送 ajax 请求了</li></ul><h6 id="配置链接信息"><a href="#配置链接信息" class="headerlink" title="配置链接信息"></a>配置链接信息</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>()<br><br><span class="hljs-comment">// xhr 对象中的 open 方法是来配置请求信息的</span><br><span class="hljs-comment">// 第一个参数是本次请求的请求方式 get / post / put / ...</span><br><span class="hljs-comment">// 第二个参数是本次请求的 url </span><br><span class="hljs-comment">// 第三个参数是本次请求是否异步，默认 true 表示异步，false 表示同步</span><br><span class="hljs-comment">// xhr.open(&#x27;请求方式&#x27;, &#x27;请求地址&#x27;, 是否异步)</span><br>xhr.<span class="hljs-title function_">open</span>(<span class="hljs-string">&#x27;get&#x27;</span>, <span class="hljs-string">&#x27;./data.php&#x27;</span>)<br></code></pre></td></tr></table></figure><ul><li>上面的代码执行完毕以后，本次请求的基本配置信息就写完了</li></ul><h6 id="发送请求"><a href="#发送请求" class="headerlink" title="发送请求"></a>发送请求</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>()<br>xhr.<span class="hljs-title function_">open</span>(<span class="hljs-string">&#x27;get&#x27;</span>, <span class="hljs-string">&#x27;./data.php&#x27;</span>)<br><br><span class="hljs-comment">// 使用 xhr 对象中的 send 方法来发送请求</span><br>xhr.<span class="hljs-title function_">send</span>()<br></code></pre></td></tr></table></figure><ul><li>上面代码是把配置好信息的 ajax 对象发送到服务端</li></ul><h6 id="一个基本的-ajax-请求"><a href="#一个基本的-ajax-请求" class="headerlink" title="一个基本的 ajax 请求"></a>一个基本的 ajax 请求</h6><ul><li>一个最基本的 ajax 请求就是上面三步</li><li>但是光有上面的三个步骤，我们确实能把请求发送的到服务端</li><li>如果服务端正常的话，响应也能回到客户端</li><li>但是我们拿不到响应</li><li>如果想拿到响应，我们有两个前提条件<ol><li>本次 HTTP 请求是成功的，也就是我们之前说的 http 状态码为 200 ~ 299</li><li>ajax 对象也有自己的状态码，用来表示本次 ajax 请求中各个阶段</li></ol></li></ul><h6 id="ajax-状态码"><a href="#ajax-状态码" class="headerlink" title="ajax 状态码"></a>ajax 状态码</h6><ul><li>ajax 状态码 - <code>xhr.readyState</code></li><li>是用来表示一个 ajax 请求的全部过程中的某一个状态<ul><li><code>readyState === 0</code>：  表示未初始化完成，也就是 <code>open</code> 方法还没有执行</li><li><code>readyState === 1</code>：  表示配置信息已经完成，也就是执行完 <code>open</code> 之后</li><li><code>readyState === 2</code>：  表示 <code>send</code> 方法已经执行完成</li><li><code>readyState === 3</code>：  表示正在解析响应内容</li><li><code>readyState === 4</code>：  表示响应内容已经解析完毕，可以在客户端使用了</li></ul></li><li>这个时候我们就会发现，当一个 ajax 请求的全部过程中，只有当 <code>readyState === 4</code> 的时候，我们才可以正常使用服务端给我们的数据</li><li>所以，配合 http 状态码为 200 ~ 299 <ul><li>一个 ajax 对象中有一个成员叫做 <code>xhr.status</code> </li><li>这个成员就是记录本次请求的 http 状态码的</li></ul></li><li>两个条件都满足的时候，才是本次请求正常完成</li></ul><h6 id="readyStateChange"><a href="#readyStateChange" class="headerlink" title="readyStateChange"></a>readyStateChange</h6><ul><li><p>在 ajax 对象中有一个事件，叫做 <code>readyStateChange</code> 事件</p></li><li><p>这个事件是专门用来监听 ajax 对象的 <code>readyState</code> 值改变的的行为</p></li><li><p>也就是说只要 <code>readyState</code> 的值发生变化了，那么就会触发该事件</p></li><li><p>所以我们就在这个事件中来监听 ajax 的 <code>readyState</code> 是不是到 4 了</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>()<br>xhr.<span class="hljs-title function_">open</span>(<span class="hljs-string">&#x27;get&#x27;</span>, <span class="hljs-string">&#x27;./data.php&#x27;</span>)<br><br>xhr.<span class="hljs-title function_">send</span>()<br><br>xhr.<span class="hljs-property">onreadyStateChange</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">// 每次 readyState 改变的时候都会触发该事件</span><br>  <span class="hljs-comment">// 我们就在这里判断 readyState 的值是不是到 4</span><br>  <span class="hljs-comment">// 并且 http 的状态码是不是 200 ~ 299</span><br>  <span class="hljs-keyword">if</span> (xhr.<span class="hljs-property">readyState</span> === <span class="hljs-number">4</span> &amp;&amp; <span class="hljs-regexp">/^2\d&#123;2&#125;$/</span>.<span class="hljs-title function_">test</span>(xhr.<span class="hljs-property">status</span>)) &#123;<br>    <span class="hljs-comment">// 这里表示验证通过</span><br>    <span class="hljs-comment">// 我们就可以获取服务端给我们响应的内容了</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h6 id="responseText"><a href="#responseText" class="headerlink" title="responseText"></a>responseText</h6><ul><li><p>ajax 对象中的 <code>responseText</code> 成员</p></li><li><p>就是用来记录服务端给我们的响应体内容的</p></li><li><p>所以我们就用这个成员来获取响应体内容就可以</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>()<br>xhr.<span class="hljs-title function_">open</span>(<span class="hljs-string">&#x27;get&#x27;</span>, <span class="hljs-string">&#x27;./data.php&#x27;</span>)<br><br>xhr.<span class="hljs-title function_">send</span>()<br><br>xhr.<span class="hljs-property">onreadyStateChange</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">if</span> (xhr.<span class="hljs-property">readyState</span> === <span class="hljs-number">4</span> &amp;&amp; <span class="hljs-regexp">/^2\d&#123;2&#125;$/</span>.<span class="hljs-title function_">test</span>(xhr.<span class="hljs-property">status</span>)) &#123;<br>    <span class="hljs-comment">// 我们在这里直接打印 xhr.responseText 来查看服务端给我们返回的内容</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(xhr.<span class="hljs-property">responseText</span>)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h5 id="使用-ajax-发送请求时携带参数"><a href="#使用-ajax-发送请求时携带参数" class="headerlink" title="使用 ajax 发送请求时携带参数"></a>使用 ajax 发送请求时携带参数</h5><ul><li>我们使用 ajax 发送请求也是可以携带参数的</li><li>参数就是和后台交互的时候给他的一些信息</li><li>但是携带参数 get 和 post 两个方式还是有区别的</li></ul><h6 id="发送一个带有参数的-get-请求"><a href="#发送一个带有参数的-get-请求" class="headerlink" title="发送一个带有参数的 get 请求"></a>发送一个带有参数的 get 请求</h6><ul><li><p>get 请求的参数就直接在 url 后面进行拼接就可以</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>()<br><span class="hljs-comment">// 直接在地址后面加一个 ?，然后以 key=value 的形式传递</span><br><span class="hljs-comment">// 两个数据之间以 &amp; 分割</span><br>xhr.<span class="hljs-title function_">open</span>(<span class="hljs-string">&#x27;get&#x27;</span>, <span class="hljs-string">&#x27;./data.php?a=100&amp;b=200&#x27;</span>)<br><br>xhr.<span class="hljs-title function_">send</span>()<br></code></pre></td></tr></table></figure><ul><li>这样服务端就能接受到两个参数</li><li>一个是 a，值是 100</li><li>一个是 b，值是 200</li></ul></li></ul><h6 id="发送一个带有参数的-post-请求"><a href="#发送一个带有参数的-post-请求" class="headerlink" title="发送一个带有参数的 post 请求"></a>发送一个带有参数的 post 请求</h6><ul><li><p>post 请求的参数是携带在请求体中的，所以不需要再 url 后面拼接</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>()<br>xhr.<span class="hljs-title function_">open</span>(<span class="hljs-string">&#x27;get&#x27;</span>, <span class="hljs-string">&#x27;./data.php&#x27;</span>)<br><br><span class="hljs-comment">// 如果是用 ajax 对象发送 post 请求，必须要先设置一下请求头中的 content-type</span><br><span class="hljs-comment">// 告诉一下服务端我给你的是一个什么样子的数据格式</span><br>xhr.<span class="hljs-title function_">setRequestHeader</span>(<span class="hljs-string">&#x27;content-type&#x27;</span>, <span class="hljs-string">&#x27;application/x-www-form-urlencoded&#x27;</span>)<br><br><span class="hljs-comment">// 请求体直接再 send 的时候写在 () 里面就行</span><br><span class="hljs-comment">// 不需要问号，直接就是 &#x27;key=value&amp;key=value&#x27; 的形式</span><br>xhr.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;a=100&amp;b=200&#x27;</span>)<br></code></pre></td></tr></table></figure><ul><li><code>application/x-www-form-urlencoded</code> 表示的数据格式就是 <code>key=value&amp;key=value</code></li></ul></li></ul><h5 id="封装ajax"><a href="#封装ajax" class="headerlink" title="封装ajax"></a>封装ajax</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * @作者: kerwin</span><br><span class="hljs-comment"> * @公众号: 大前端私房菜</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">// 对象转化为json格式</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">queryStringify</span>(<span class="hljs-params">obj</span>) &#123;<br>  <span class="hljs-keyword">let</span> str = <span class="hljs-string">&#x27;&#x27;</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> k <span class="hljs-keyword">in</span> obj) str += <span class="hljs-string">`<span class="hljs-subst">$&#123;k&#125;</span>=<span class="hljs-subst">$&#123;obj[k]&#125;</span>&amp;`</span><br>  <span class="hljs-keyword">return</span> str.<span class="hljs-title function_">slice</span>(<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>)<br>&#125;<br><br><span class="hljs-comment">// 封装 ajax</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">ajax</span>(<span class="hljs-params">options</span>) &#123;<br>  <span class="hljs-keyword">let</span> defaultoptions = &#123;<br>    <span class="hljs-attr">url</span>: <span class="hljs-string">&quot;&quot;</span>,<br>    <span class="hljs-attr">method</span>: <span class="hljs-string">&quot;GET&quot;</span>,<br>    <span class="hljs-attr">async</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-attr">data</span>: &#123;&#125;,<br>    <span class="hljs-attr">headers</span>: &#123;&#125;,<br>    <span class="hljs-attr">success</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123; &#125;,<br>    <span class="hljs-attr">error</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123; &#125;<br>  &#125;<br>  <span class="hljs-keyword">let</span> &#123; url, method, <span class="hljs-keyword">async</span>, data, headers, success, error &#125; = &#123;<br>    ...defaultoptions,<br>    ...options<br>  &#125;<br><br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> data === <span class="hljs-string">&#x27;object&#x27;</span> &amp;&amp; headers[<span class="hljs-string">&quot;content-type&quot;</span>]?.<span class="hljs-title function_">indexOf</span>(<span class="hljs-string">&quot;json&quot;</span>) &gt; -<span class="hljs-number">1</span>) &#123;<br>    data = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(data)<br>  &#125;<br>  <span class="hljs-keyword">else</span> &#123;<br>    data = <span class="hljs-title function_">queryStringify</span>(data)<br><br>  &#125;<br>  <span class="hljs-comment">// 如果是 get 请求, 并且有参数, 那么直接组装一下 url 信息</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-regexp">/^get$/i</span>.<span class="hljs-title function_">test</span>(method) &amp;&amp; data) url += <span class="hljs-string">&#x27;?&#x27;</span> + data<br><br>  <span class="hljs-comment">// 4. 发送请求</span><br>  <span class="hljs-keyword">const</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>()<br>  xhr.<span class="hljs-title function_">open</span>(method, url, <span class="hljs-keyword">async</span>)<br>  xhr.<span class="hljs-property">onload</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-regexp">/^2\d&#123;2&#125;$/</span>.<span class="hljs-title function_">test</span>(xhr.<span class="hljs-property">status</span>)) &#123;<br>      <span class="hljs-title function_">error</span>(<span class="hljs-string">`错误状态码:<span class="hljs-subst">$&#123;xhr.status&#125;</span>`</span>)<br>      <span class="hljs-keyword">return</span> <br>    &#125;<br>    <span class="hljs-comment">// 执行解析</span><br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-keyword">let</span> result = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(xhr.<span class="hljs-property">responseText</span>)<br>      <span class="hljs-title function_">success</span>(result)<br>    &#125; <span class="hljs-keyword">catch</span> (err) &#123;<br>      <span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;解析失败 ! 因为后端返回的结果不是 json 格式字符串&#x27;</span>)<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">// 设置请求头内的信息</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> k <span class="hljs-keyword">in</span> headers) xhr.<span class="hljs-title function_">setRequestHeader</span>(k, headers[k])<br>  <span class="hljs-keyword">if</span> (<span class="hljs-regexp">/^get$/i</span>.<span class="hljs-title function_">test</span>(method)) &#123;<br>    xhr.<span class="hljs-title function_">send</span>()<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    xhr.<span class="hljs-title function_">send</span>(data)<br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">ajax</span>(&#123;<br>    <span class="hljs-attr">url</span>:<span class="hljs-string">&quot;http://localhost:3000/users&quot;</span>,<br>    <span class="hljs-attr">method</span>:<span class="hljs-string">&quot;GET&quot;</span>,<br>    <span class="hljs-attr">async</span>:<span class="hljs-literal">true</span>,<br>    <span class="hljs-attr">data</span>:&#123;<br>        <span class="hljs-attr">username</span>:<span class="hljs-string">&quot;kerwin&quot;</span>,<br>        <span class="hljs-attr">password</span>:<span class="hljs-string">&quot;123&quot;</span><br>    &#125;, <br>    <span class="hljs-attr">headers</span>:&#123;&#125;,<br>    <span class="hljs-attr">success</span>:<span class="hljs-keyword">function</span>(<span class="hljs-params">res</span>)&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res)<br>    &#125;,<br>    <span class="hljs-attr">error</span>:<span class="hljs-keyword">function</span>(<span class="hljs-params">err</span>)&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err)<br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><h5 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h5><ul><li><code>promise</code> 是一个 ES6 的语法</li><li>承诺的意思，是一个专门用来解决异步 <strong>回调地狱</strong> 的问题</li></ul><h6 id="回调地狱"><a href="#回调地狱" class="headerlink" title="回调地狱"></a>回调地狱</h6><ul><li><p>当一个回调函数嵌套一个回调函数的时候</p></li><li><p>就会出现一个嵌套结构</p></li><li><p>当嵌套的多了就会出现回调地狱的情况</p></li><li><p>比如我们发送三个 ajax 请求</p><ul><li>第一个正常发送</li><li>第二个请求需要第一个请求的结果中的某一个值作为参数</li><li>第三个请求需要第二个请求的结果中的某一个值作为参数</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">ajax</span>(&#123;<br>  <span class="hljs-attr">url</span>: <span class="hljs-string">&#x27;我是第一个请求&#x27;</span>,<br>  success (res) &#123;<br>    <span class="hljs-comment">// 现在发送第二个请求</span><br>    <span class="hljs-title function_">ajax</span>(&#123;<br>      <span class="hljs-attr">url</span>: <span class="hljs-string">&#x27;我是第二个请求&#x27;</span>，<br>      <span class="hljs-attr">data</span>: &#123; <span class="hljs-attr">a</span>: res.<span class="hljs-property">a</span>, <span class="hljs-attr">b</span>: res.<span class="hljs-property">b</span> &#125;,<br>      success (res2) &#123;<br>        <span class="hljs-comment">// 进行第三个请求</span><br>        <span class="hljs-title function_">ajax</span>(&#123;<br>          <span class="hljs-attr">url</span>: <span class="hljs-string">&#x27;我是第三个请求&#x27;</span>,<br>          <span class="hljs-attr">data</span>: &#123; <span class="hljs-attr">a</span>: res2.<span class="hljs-property">a</span>, <span class="hljs-attr">b</span>: res2.<span class="hljs-property">b</span> &#125;,<br>  success (res3) &#123; <br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res3) <br>          &#125;<br>        &#125;)<br>      &#125;<br>    &#125;)<br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure></li><li><p><strong>回调地狱，其实就是回调函数嵌套过多导致的</strong></p></li></ul><p><img src="F:/前端学习/视频笔记/javascript/笔记/笔记/笔记.assets/回调地狱.jpeg"></p><ul><li>当代码成为这个结构以后，已经没有维护的可能了</li><li>所以我们要把代码写的更加的艺术一些</li></ul><h6 id="PROMISE"><a href="#PROMISE" class="headerlink" title="PROMISE"></a>PROMISE</h6><ul><li><p>为了解决回调地狱</p></li><li><p>我们就要使用 promise 语法</p></li><li><p>语法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">resolve, reject</span>) &#123;<br>  <span class="hljs-comment">// resolve 表示成功的回调</span><br>  <span class="hljs-comment">// reject 表示失败的回调</span><br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">res</span>) &#123;<br>  <span class="hljs-comment">// 成功的函数</span><br>&#125;).<span class="hljs-title function_">catch</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">err</span>) &#123;<br>  <span class="hljs-comment">// 失败的函数</span><br>&#125;)<br></code></pre></td></tr></table></figure></li><li><p>promise 就是一个语法</p><ul><li>我们的每一个异步事件，在执行的时候</li><li>都会有三个状态，执行中 &#x2F; 成功 &#x2F; 失败</li></ul></li><li><p>因为它包含了成功的回调函数</p></li><li><p>所以我们就可以使用 promise 来解决多个 ajax 发送的问题</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">resolve, reject</span>) &#123;<br>  <span class="hljs-title function_">ajax</span>(&#123;<br>    <span class="hljs-attr">url</span>: <span class="hljs-string">&#x27;第一个请求&#x27;</span>,<br>    success (res) &#123;<br>      <span class="hljs-title function_">resolve</span>(res)<br>    &#125;<br>  &#125;)<br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">res</span>) &#123;<br>  <span class="hljs-comment">// 准备发送第二个请求</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">resolve, reject</span>) &#123;<br>    <span class="hljs-title function_">ajax</span>(&#123;<br>      <span class="hljs-attr">url</span>: <span class="hljs-string">&#x27;第二个请求&#x27;</span>,<br>      <span class="hljs-attr">data</span>: &#123; <span class="hljs-attr">a</span>: res.<span class="hljs-property">a</span>, <span class="hljs-attr">b</span>: res.<span class="hljs-property">b</span> &#125;,<br>      success (res) &#123;<br>        <span class="hljs-title function_">resolve</span>(res)<br>      &#125;<br>    &#125;)<br>  &#125;)<br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">res</span>) &#123;<br>  <span class="hljs-title function_">ajax</span>(&#123;<br>    <span class="hljs-attr">url</span>: <span class="hljs-string">&#x27;第三个请求&#x27;</span>,<br>    <span class="hljs-attr">data</span>: &#123; <span class="hljs-attr">a</span>: res.<span class="hljs-property">a</span>, <span class="hljs-attr">b</span>: res.<span class="hljs-property">b</span> &#125;,<br>    success (res) &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res)<br>    &#125;<br>  &#125;)<br>&#125;)<br></code></pre></td></tr></table></figure></li></ul><h5 id="ASYNC-x2F-AWAIT"><a href="#ASYNC-x2F-AWAIT" class="headerlink" title="ASYNC&#x2F;AWAIT"></a>ASYNC&#x2F;AWAIT</h5><ul><li><p><code>async/await</code> 是一个 es7 的语法</p></li><li><p>这个语法是 <strong>回调地狱的终极解决方案</strong></p></li><li><p>语法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> promise对象<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>这个是一个特殊的函数方式</p></li><li><p>可以 await 一个 promise 对象</p></li><li><p><strong>可以把异步代码写的看起来像同步代码</strong></p></li><li><p>只要是一个 promiser 对象，那么我们就可以使用 <code>async/await</code> 来书写</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">resolve, reject</span>) &#123;<br>    <span class="hljs-title function_">ajax</span>(&#123;<br>      <span class="hljs-attr">url</span>: <span class="hljs-string">&#x27;第一个地址&#x27;</span>,<br>      success (res) &#123;<br>        <span class="hljs-title function_">resolve</span>(res)<br>      &#125;<br>    &#125;)<br>  &#125;)<br>  <br>  <span class="hljs-comment">// res 就可以得到请求的结果</span><br>  <span class="hljs-keyword">const</span> res2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">resolve, reject</span>) &#123;<br>    <span class="hljs-title function_">ajax</span>(&#123;<br>      <span class="hljs-attr">url</span>: <span class="hljs-string">&#x27;第二个地址&#x27;</span>,<br>      <span class="hljs-attr">data</span>: &#123; <span class="hljs-attr">a</span>: res.<span class="hljs-property">a</span>, <span class="hljs-attr">b</span>: res.<span class="hljs-property">b</span> &#125;,<br>      success (res) &#123;<br>        <span class="hljs-title function_">resolve</span>(res)<br>      &#125;<br>    &#125;)<br>  &#125;)<br>  <br>  <span class="hljs-keyword">const</span> res3 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">resolve, reject</span>) &#123;<br>    <span class="hljs-title function_">ajax</span>(&#123;<br>      <span class="hljs-attr">url</span>: <span class="hljs-string">&#x27;第三个地址&#x27;</span>,<br>      <span class="hljs-attr">data</span>: &#123; <span class="hljs-attr">a</span>: res2.<span class="hljs-property">a</span>, <span class="hljs-attr">b</span>: res2.<span class="hljs-property">b</span> &#125;,<br>      success (res) &#123;<br>        <span class="hljs-title function_">resolve</span>(res)<br>      &#125;<br>    &#125;)<br>  &#125;)<br>  <br>  <span class="hljs-comment">// res3 就是我们要的结果</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res3)<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>这样的异步代码写的就看起来像一个同步代码了</li></ul></li></ul><h5 id="fetch"><a href="#fetch" class="headerlink" title="fetch"></a>fetch</h5><p>​<em>XMLHttpRequest 是一个设计粗糙的 API，配置和调用方式非常混乱， 而且基于事件的异步模型写起来不友好。</em> </p><p>​<strong>兼容性不好 polyfill: <a href="https://github.com/camsong/fetch-ie8">https://github.com/camsong/fetch-ie8</a></strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">fetch</span>(<span class="hljs-string">&quot;http://localhost:3000/users&quot;</span>)<br>            .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span>=&gt;</span>res.<span class="hljs-title function_">json</span>())<br>            .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span>=&gt;</span>&#123;<br>                <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res)<br>            &#125;)<br><br><br><span class="hljs-title function_">fetch</span>(<span class="hljs-string">&quot;http://localhost:3000/users&quot;</span>,&#123;<br>            <span class="hljs-attr">method</span>:<span class="hljs-string">&quot;POST&quot;</span>,<br>            <span class="hljs-attr">headers</span>:&#123;<br>                <span class="hljs-string">&quot;content-type&quot;</span>:<span class="hljs-string">&quot;application/json&quot;</span><br>            &#125;,<br>            <span class="hljs-attr">body</span>:<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(&#123;<br>                <span class="hljs-attr">username</span>:<span class="hljs-string">&quot;kerwin&quot;</span>,<br>                <span class="hljs-attr">password</span>:<span class="hljs-string">&quot;123&quot;</span><br>            &#125;)<br>        &#125;)<br>            .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span>=&gt;</span>res.<span class="hljs-title function_">json</span>())<br>            .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span>=&gt;</span>&#123;<br>                <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res)<br>            &#125;)<br><br><span class="hljs-title function_">fetch</span>(<span class="hljs-string">&quot;http://localhost:3000/users/5&quot;</span>,&#123;<br>            <span class="hljs-attr">method</span>:<span class="hljs-string">&quot;PUT&quot;</span>,<br>            <span class="hljs-attr">headers</span>:&#123;<br>                <span class="hljs-string">&quot;content-type&quot;</span>:<span class="hljs-string">&quot;application/json&quot;</span><br>            &#125;,<br>            <span class="hljs-attr">body</span>:<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(&#123;<br>                <span class="hljs-attr">username</span>:<span class="hljs-string">&quot;kerwin&quot;</span>,<br>                <span class="hljs-attr">password</span>:<span class="hljs-string">&quot;456&quot;</span><br>            &#125;)<br>        &#125;)<br>            .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span>=&gt;</span>res.<span class="hljs-title function_">json</span>())<br>            .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span>=&gt;</span>&#123;<br>                <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res)<br>            &#125;)<br><br><span class="hljs-title function_">fetch</span>(<span class="hljs-string">&quot;http://localhost:3000/users/5&quot;</span>,&#123;<br>            <span class="hljs-attr">method</span>:<span class="hljs-string">&quot;DELETE&quot;</span><br>        &#125;)<br>            .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span>=&gt;</span>res.<span class="hljs-title function_">json</span>())<br>            .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span>=&gt;</span>&#123;<br>                <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res)<br>            &#125;)<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//错误处理</span><br><span class="hljs-title function_">fetch</span>(<span class="hljs-string">&quot;http://localhost:3000/users1&quot;</span>)<br>            .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span>=&gt;</span>&#123;<br>                <span class="hljs-keyword">if</span>(res.<span class="hljs-property">ok</span>)&#123;<br>                    <span class="hljs-keyword">return</span> res.<span class="hljs-title function_">json</span>()<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(&#123;<br>                        <span class="hljs-attr">status</span>:res.<span class="hljs-property">status</span>,<br>                        <span class="hljs-attr">statusText</span>:res.<span class="hljs-property">statusText</span><br>                    &#125;)<br>                &#125;<br>            &#125;)<br>            .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span>=&gt;</span>&#123;<br>                <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res)<br>            &#125;)<br>            .<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">err</span>=&gt;</span>&#123;<br>                <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err)<br>            &#125;)<br></code></pre></td></tr></table></figure><h5 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h5><p><strong>cookie的特点</strong></p><ol><li>只能存储文本</li><li>单条存储有大小限制4KB左右<br>数量限制（一般浏览器，限制大概在50条左右）</li><li>读取有域名限制：不可跨域读取，只能由来自 写入cookie的 同一域名 的网页可进行读取。简单的讲就是，哪个服务器发给你的cookie，只有哪个服务器有权利读取</li><li>时效限制：每个cookie都有时效，默认的有效期是，会话级别：就是当浏览器关闭，那么cookie立即销毁，但是我们也可以在存储的时候手动设置cookie的过期时间</li><li>路径限制：存cookie时候可以指定路径，只允许子路径读取外层cookie，外层不能读取内层。</li></ol><h5 id="jsonp"><a href="#jsonp" class="headerlink" title="jsonp"></a>jsonp</h5><p>Jsonp(JSON with Padding) 是 json 的一种”使用模式”，可以让网页从别的域名（网站）那获取资料，即跨域读取数据。</p><p>为什么我们从不同的域（网站）访问数据需要一个特殊的技术( JSONP )呢？这是因为同源策略。</p><p>jsonp原理： 动态创建script标签，src没有跨域限制 </p><p>​指向一个接口，接口返回的格式一定是  ********（）函数表达式</p><p> jsonp方法：</p><p>​      1.创建script标签 &#x3D;&#x3D;&gt; 设置src属性（一般callback或cb是设置函数名的） &#x3D;&#x3D;&gt; 动态插入script标签 &#x3D;&#x3D;&gt; 删除script标签</p><p>​      2.调用函数方法   function 函数名(obj){</p><p>​console.log(obj)}</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> oscript = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;script&#x27;</span>)  <span class="hljs-comment">//创建</span><br><span class="hljs-comment">//oscript.src = &#x27;./kerwin.txt&#x27;                     //设置src</span><br>oscript.<span class="hljs-property">src</span> = <span class="hljs-string">`https://www.baidu.com/sugrec?pre=1&amp;p=3&amp;ie=utf-8&amp;json=1&amp;prod=pc&amp;from=pc_web&amp;sugsid=37153,36549,37354,36885,36789,37261,26350,37384,37370&amp;wd=<span class="hljs-subst">$&#123;evt.target.value&#125;</span>%27a&amp;req=2&amp;csor=3&amp;pwd=a&amp;cb=test&amp;_=1663920458156`</span><br><span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">appendChild</span>(oscript)<span class="hljs-comment">//动态创建</span><br>oscript.<span class="hljs-property">onload</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<span class="hljs-comment">//删除创建的标签</span><br>    oscript.<span class="hljs-title function_">remove</span>()<br>&#125;<br><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">test</span>(<span class="hljs-params">obj</span>)&#123;    <span class="hljs-comment">//调用</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj)<br>&#125;<br><br><br></code></pre></td></tr></table></figure><p> 注意：</p><p>​    1.后端接口形式必须为 ***（），需要后端配合</p><p>​    2.jsonp缺点</p><p>​      （1）页面频繁创建标签，通过onload 删除动态创建的oscript </p><p>​      （2）只能get请求，不能post put delete</p><h4 id="七-jQuery"><a href="#七-jQuery" class="headerlink" title="七. jQuery"></a>七. jQuery</h4><ul><li><code>jQuery</code> 是一个前端库，也是一个方法库</li><li>他里面封装着一些列的方法供我们使用</li><li>我们常用的一些方法它里面都有，我们可以直接拿来使用就行了</li><li><code>jQuery</code> 之所以好用，很多人愿意使用，是因为他的几个优点太强大了<ol><li>优质的选择器和筛选器</li><li>好用的隐式迭代</li><li>强大的链式编程</li></ol></li><li>因为这些东西的出现，很多时候我们要做的事情被 “一行代码解决”</li><li>接下来我们就来认识一下 <code>jQuery</code></li></ul><h5 id="1-jQuery-的使用"><a href="#1-jQuery-的使用" class="headerlink" title="1. jQuery 的使用"></a>1. jQuery 的使用</h5><ul><li><p><a href="https://jquery.com/">jQuery官网</a></p></li><li><p><a href="http://jquery.cuishifeng.cn/">jQuery方法大全中文网</a></p><ul><li>这个网站可以多看看</li><li>里面是 <code>jQuery</code> 的方法大全，而且是中文的</li></ul></li><li><p>我们要使用 <code>jQuery</code> 首先要下载一个</p><ul><li>可以去官网下载</li></ul></li><li><p>然后就是再页面里面引入 <code>jQuery.js</code> 就行了</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;ie=edge&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./jquery/jquery.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>然后就可以开始使用了</p></li><li><p><code>jQuery</code> 向全局暴露的接口就是 <code>jQuery</code> 或者 <code>$</code> 都行</p></li></ul><h5 id="2-选择器和筛选器"><a href="#2-选择器和筛选器" class="headerlink" title="2.选择器和筛选器"></a>2.选择器和筛选器</h5><ul><li>选择器和筛选器就是用来帮我们获取 DOM 元素的</li></ul><h6 id="2-1选择器"><a href="#2-1选择器" class="headerlink" title="2-1选择器"></a>2-1选择器</h6><ul><li><p><code>jQuery</code> 有着相当强大的选择器</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 按照 id 获取页面中的元素</span><br><span class="hljs-keyword">const</span> ele = <span class="hljs-title function_">jQuery</span>(<span class="hljs-string">&#x27;#box&#x27;</span>) <br><span class="hljs-keyword">const</span> ele = $(<span class="hljs-string">&#x27;#box&#x27;</span>)<br></code></pre></td></tr></table></figure><ul><li>上面两个都可以按照 id 来获取元素</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 按照类名来选择</span><br><span class="hljs-keyword">const</span> eles = <span class="hljs-title function_">jQuery</span>(<span class="hljs-string">&#x27;.a&#x27;</span>)<br><span class="hljs-keyword">const</span> eles = $(<span class="hljs-string">&#x27;.a&#x27;</span>)<br></code></pre></td></tr></table></figure><ul><li>上面就是按照类名来选择元素，可以获取到一组元素</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> lis = <span class="hljs-title function_">jQuery</span>(<span class="hljs-string">&#x27;li&#x27;</span>)<br><span class="hljs-keyword">const</span> lis = $(<span class="hljs-string">&#x27;li&#x27;</span>)<br></code></pre></td></tr></table></figure><ul><li>上面就是按照标签名来获取元素，可以获取到一组元素</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> eles = <span class="hljs-title function_">jQuery</span>(<span class="hljs-string">&#x27;ul &gt; li&#x27;</span>)<br><span class="hljs-keyword">const</span> eles = $(<span class="hljs-string">&#x27;ul &gt; li&#x27;</span>)<br></code></pre></td></tr></table></figure><ul><li>上面就是按照选择器来获取元素，可以获取到一组元素</li></ul></li></ul><h6 id="2-2特殊选择器"><a href="#2-2特殊选择器" class="headerlink" title="2-2特殊选择器"></a>2-2特殊选择器</h6><ul><li><p>直接找到第一个</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">$(<span class="hljs-string">&#x27;li:first&#x27;</span>) <span class="hljs-comment">// 找到所有 li 中的第一个</span><br></code></pre></td></tr></table></figure></li><li><p>直接找到最后一个</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">$(<span class="hljs-string">&#x27;li:last&#x27;</span>) <span class="hljs-comment">// 找到所有 li 中的最后一个</span><br></code></pre></td></tr></table></figure></li><li><p>直接找到第几个</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">$(<span class="hljs-string">&#x27;li:eq(3)&#x27;</span>) <span class="hljs-comment">// 找到所有 li 中索引为 3 的那个</span><br></code></pre></td></tr></table></figure></li><li><p>找到所有奇数个</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">$(<span class="hljs-string">&#x27;li:odd&#x27;</span>) <span class="hljs-comment">// 找到所有 li 中索引为 奇数 的</span><br></code></pre></td></tr></table></figure></li><li><p>找到所有偶数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">$(<span class="hljs-string">&#x27;li:even&#x27;</span>) <span class="hljs-comment">// 找到所有 li 中索引为 偶数 的</span><br></code></pre></td></tr></table></figure></li></ul><h6 id="2-3筛选器"><a href="#2-3筛选器" class="headerlink" title="2-3筛选器"></a>2-3筛选器</h6><ul><li><p>jQuery 的筛选器就是在选择器选择到一组元素以后</p></li><li><p>对元素进行筛选，也可以对准确的某一个元素进行判断和获取</p><ol><li><p>找到所有元素中的第一个</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">$(<span class="hljs-string">&#x27;li&#x27;</span>).<span class="hljs-title function_">first</span>()<br></code></pre></td></tr></table></figure></li><li><p>找到所有元素中的最后一个</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">$(<span class="hljs-string">&#x27;li&#x27;</span>).<span class="hljs-title function_">last</span>()<br></code></pre></td></tr></table></figure></li><li><p>找到某一个元素的下一个兄弟元素</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">$(<span class="hljs-string">&#x27;li:eq(3)&#x27;</span>).<span class="hljs-title function_">next</span>()<br></code></pre></td></tr></table></figure></li><li><p>找到某一个元素的上一个兄弟元素</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">$(<span class="hljs-string">&#x27;li:eq(3)&#x27;</span>).<span class="hljs-title function_">prev</span>()<br></code></pre></td></tr></table></figure></li><li><p>找到某一个元素的后面的所有兄弟元素</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">$(<span class="hljs-string">&#x27;li:eq(3)&#x27;</span>).<span class="hljs-title function_">nextAll</span>()<br></code></pre></td></tr></table></figure></li><li><p>找到某一个元素的前面的所有兄弟元素</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">$(<span class="hljs-string">&#x27;li:eq(3)&#x27;</span>).<span class="hljs-title function_">prevAll</span>()<br></code></pre></td></tr></table></figure></li><li><p>找到某一个元素的父元素</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">$(<span class="hljs-string">&#x27;li:eq(3)&#x27;</span>).<span class="hljs-title function_">parent</span>()<br></code></pre></td></tr></table></figure></li><li><p>找到某一个元素的所有结构父级，一直到 html</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">$(<span class="hljs-string">&#x27;li:eq(3)&#x27;</span>).<span class="hljs-title function_">parents</span>()<br></code></pre></td></tr></table></figure></li><li><p>找到一组元素中的某一个</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 在 li 的所有父级里面找到所有 body 标签</span><br>$(<span class="hljs-string">&#x27;li&#x27;</span>).<span class="hljs-title function_">parents</span>().<span class="hljs-title function_">find</span>(<span class="hljs-string">&#x27;body&#x27;</span>)<br><br><span class="hljs-comment">// 找到 div 标签下所有后代元素中所有类名为 box 的元素</span><br>$(<span class="hljs-string">&#x27;div&#x27;</span>).<span class="hljs-title function_">find</span>(<span class="hljs-string">&#x27;.box&#x27;</span>)<br></code></pre></td></tr></table></figure></li></ol></li></ul><h5 id="3-属性操作"><a href="#3-属性操作" class="headerlink" title="3.属性操作"></a>3.属性操作</h5><ul><li><p>给一个元素添加某个属性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 给 div 元素添加一个 id 属性，值是 box</span><br>$(<span class="hljs-string">&#x27;div&#x27;</span>).<span class="hljs-title function_">prop</span>(<span class="hljs-string">&#x27;id&#x27;</span>, <span class="hljs-string">&#x27;box&#x27;</span>)<br><span class="hljs-comment">// 获取 div 的 id 属性</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>($(<span class="hljs-string">&#x27;div&#x27;</span>).<span class="hljs-title function_">prop</span>(<span class="hljs-string">&#x27;id&#x27;</span>))<br></code></pre></td></tr></table></figure><ul><li>prop 这个方法只能添加元素自己本身就有的属性</li><li>如果是添加的自定义属性，不会显示在标签上，但是可以使用</li></ul></li><li><p>给一个元素添加某个自定义属性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 给 div 添加一个 index 属性，值是 1</span><br>$(<span class="hljs-string">&#x27;div&#x27;</span>).<span class="hljs-title function_">attr</span>(<span class="hljs-string">&#x27;index&#x27;</span>, <span class="hljs-number">1</span>)<br><span class="hljs-comment">// 获取 div 的 index 属性</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>($(<span class="hljs-string">&#x27;div&#x27;</span>).<span class="hljs-title function_">attr</span>(<span class="hljs-string">&#x27;index&#x27;</span>))<br></code></pre></td></tr></table></figure></li><li><p>移除元素的某一个属性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 移除元素自己本身的属性</span><br>$(<span class="hljs-string">&#x27;div&#x27;</span>).<span class="hljs-title function_">removeProp</span>(<span class="hljs-string">&#x27;id&#x27;</span>)<br><span class="hljs-comment">// 移除元素的自定义属性</span><br>$(<span class="hljs-string">&#x27;div&#x27;</span>).<span class="hljs-title function_">removeAttr</span>(<span class="hljs-string">&#x27;index&#x27;</span>)<br></code></pre></td></tr></table></figure></li></ul><h5 id="4-操作元素的类名"><a href="#4-操作元素的类名" class="headerlink" title="4.操作元素的类名"></a>4.操作元素的类名</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 判断某一个元素有没有某一个 class</span><br>$(<span class="hljs-string">&#x27;div&#x27;</span>).<span class="hljs-title function_">hasClass</span>(<span class="hljs-string">&#x27;box&#x27;</span>) <span class="hljs-comment">// true 表示该元素有 box 类名，false 表示该元素没有 box 类名</span><br><br><span class="hljs-comment">// 给元素添加一个类名</span><br>$(<span class="hljs-string">&#x27;div&#x27;</span>).<span class="hljs-title function_">addClass</span>(<span class="hljs-string">&#x27;box2&#x27;</span>) <span class="hljs-comment">// 给 div 元素添加一个 box2 类名</span><br><br><span class="hljs-comment">// 移除元素的类名</span><br>$(<span class="hljs-string">&#x27;div&#x27;</span>).<span class="hljs-title function_">removeClass</span>(<span class="hljs-string">&#x27;box&#x27;</span>) <span class="hljs-comment">// 移除 div 的 box 类名</span><br><br><span class="hljs-comment">// 切换元素类名</span><br>$(<span class="hljs-string">&#x27;div&#x27;</span>).<span class="hljs-title function_">toggleClass</span>(<span class="hljs-string">&#x27;box3&#x27;</span>) <span class="hljs-comment">// 如果元素本身有这个类名就移除，本身没有就添加</span><br></code></pre></td></tr></table></figure><h5 id="5-操作元素的内容"><a href="#5-操作元素的内容" class="headerlink" title="5. 操作元素的内容"></a>5. 操作元素的内容</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js">给元素的 innerHTML 赋值<br>$(<span class="hljs-string">&#x27;div&#x27;</span>).<span class="hljs-title function_">html</span>(<span class="hljs-string">&#x27;&lt;span&gt;hello world&lt;/span&gt;&#x27;</span>)<br><span class="hljs-comment">// 获取元素的 innerHTML</span><br>$(<span class="hljs-string">&#x27;div&#x27;</span>).<span class="hljs-title function_">html</span>()<br><br><span class="hljs-comment">// 给元素的 innerText 赋值</span><br>$(<span class="hljs-string">&#x27;div&#x27;</span>).<span class="hljs-title function_">text</span>(<span class="hljs-string">&#x27;hello world&#x27;</span>)<br><span class="hljs-comment">// 获取元素的 innerText</span><br>$(<span class="hljs-string">&#x27;div&#x27;</span>).<span class="hljs-title function_">text</span>()<br><br><span class="hljs-comment">// 给元素的 value 赋值</span><br>$(<span class="hljs-string">&#x27;input&#x27;</span>).<span class="hljs-title function_">val</span>(<span class="hljs-string">&#x27;admin&#x27;</span>)<br><span class="hljs-comment">// 获取元素的 value 值</span><br>$(<span class="hljs-string">&#x27;input&#x27;</span>).<span class="hljs-title function_">val</span>()<br></code></pre></td></tr></table></figure><h5 id="6-操作样式"><a href="#6-操作样式" class="headerlink" title="6. 操作样式"></a>6. 操作样式</h5><ul><li><p>jQuery 操作元素的样式就是一个方法 <code>css</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 给元素设置一个 css 样式</span><br>$(<span class="hljs-string">&#x27;div&#x27;</span>).<span class="hljs-title function_">css</span>(<span class="hljs-string">&#x27;width&#x27;</span>, <span class="hljs-string">&#x27;100px&#x27;</span>)<br><br><span class="hljs-comment">// 获取元素的某一个样式</span><br>$(<span class="hljs-string">&#x27;div&#x27;</span>).<span class="hljs-title function_">css</span>(<span class="hljs-string">&#x27;width&#x27;</span>)<br><br><span class="hljs-comment">// 给元素设置一组样式</span><br>$(<span class="hljs-string">&#x27;div&#x27;</span>).<span class="hljs-title function_">css</span>(&#123;<br>    <span class="hljs-attr">width</span>: <span class="hljs-string">&#x27;100px&#x27;</span>,<br>    <span class="hljs-attr">height</span>: <span class="hljs-string">&#x27;200px&#x27;</span><br>&#125;)<br></code></pre></td></tr></table></figure></li></ul><h5 id="7-元素尺寸"><a href="#7-元素尺寸" class="headerlink" title="7. 元素尺寸"></a>7. 元素尺寸</h5><ul><li><p>操作元素的宽和高</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 获取 div 元素内容位置的高，不包含 padding 和 border</span><br>$(<span class="hljs-string">&#x27;div&#x27;</span>).<span class="hljs-title function_">height</span>()<br><span class="hljs-comment">// 设置 div 内容位置的高为 200px</span><br>$(<span class="hljs-string">&#x27;div&#x27;</span>).<span class="hljs-title function_">height</span>(<span class="hljs-number">200</span>)<br><br><span class="hljs-comment">// 获取 div 元素内容位置的宽，不包含 padding 和 border</span><br>$(<span class="hljs-string">&#x27;div&#x27;</span>).<span class="hljs-title function_">width</span>()<br><span class="hljs-comment">// 设置 div 内容位置的宽为 200px</span><br>$(<span class="hljs-string">&#x27;div&#x27;</span>).<span class="hljs-title function_">width</span>(<span class="hljs-number">200</span>)<br></code></pre></td></tr></table></figure></li><li><p>获取元素的内置宽和高</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 获取 div 元素内容位置的高，包含 padding 不包含 border</span><br>$(<span class="hljs-string">&#x27;div&#x27;</span>).<span class="hljs-title function_">innerHeight</span>()<br><br><span class="hljs-comment">// 获取 div 元素内容位置的宽，包含 padding 不包含 border</span><br>$(<span class="hljs-string">&#x27;div&#x27;</span>).<span class="hljs-title function_">innerWidth</span>()<br></code></pre></td></tr></table></figure></li><li><p>获取元素的外置宽和高</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 获取 div 元素内容位置的高，包含 padding 和 border</span><br>$(<span class="hljs-string">&#x27;div&#x27;</span>).<span class="hljs-title function_">outerHeight</span>()<br><span class="hljs-comment">// 获取 div 元素内容位置的高，包含 padding 和 border 和 margin</span><br>$(<span class="hljs-string">&#x27;div&#x27;</span>).<span class="hljs-title function_">outerHeight</span>(<span class="hljs-literal">true</span>)<br><br><span class="hljs-comment">// 获取 div 元素内容位置的宽，包含 padding 和 border</span><br>$(<span class="hljs-string">&#x27;div&#x27;</span>).<span class="hljs-title function_">outerWidth</span>()<br><span class="hljs-comment">// 获取 div 元素内容位置的高，包含 padding 和 border 和 margin</span><br>$(<span class="hljs-string">&#x27;div&#x27;</span>).<span class="hljs-title function_">outerWidth</span>(<span class="hljs-literal">true</span>)<br></code></pre></td></tr></table></figure></li></ul><h5 id="8-元素位置"><a href="#8-元素位置" class="headerlink" title="8. 元素位置"></a>8. 元素位置</h5><ul><li><p>元素相对页面的位置</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 获取 div 相对页面的位置</span><br>$(<span class="hljs-string">&#x27;div&#x27;</span>).<span class="hljs-title function_">offset</span>() <span class="hljs-comment">// 得到的是以一个对象 &#123; left: 值, top: 值 &#125;</span><br><br><span class="hljs-comment">// 给 div 设置相对页面的位置</span><br>$(<span class="hljs-string">&#x27;div&#x27;</span>).<span class="hljs-title function_">offset</span>(&#123; <span class="hljs-attr">left</span>: <span class="hljs-number">100</span>, <span class="hljs-attr">top</span>: <span class="hljs-number">100</span> &#125;)<br><span class="hljs-comment">// 获取定位到一个距离页面左上角 100 100 的位置</span><br></code></pre></td></tr></table></figure></li><li><p>元素相对于父元素的偏移量</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 获取 div 相对于父元素的偏移量（定位的值）</span><br>$(<span class="hljs-string">&#x27;div&#x27;</span>).<span class="hljs-title function_">position</span>()<br></code></pre></td></tr></table></figure></li><li><p>获取页面卷去的高度和宽度</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">window</span>.<span class="hljs-property">onscroll</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// 获取浏览器卷去的高度</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>($(<span class="hljs-variable language_">window</span>).<span class="hljs-title function_">scrollTop</span>())<br>&#125;<br><br><span class="hljs-variable language_">window</span>.<span class="hljs-property">onscroll</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// 获取浏览器卷去的宽度</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>($(<span class="hljs-variable language_">window</span>).<span class="hljs-title function_">scrollLeft</span>())<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h5 id="9-元素事件"><a href="#9-元素事件" class="headerlink" title="9. 元素事件"></a>9. 元素事件</h5><ul><li><p>绑定事件的方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 给 button 按钮绑定一个点击事件</span><br>$(<span class="hljs-string">&#x27;button&#x27;</span>).<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;我被点击了&#x27;</span>)<br>&#125;)<br><br><span class="hljs-comment">// 给 button 按钮绑定一个点击事件，并且携带参数</span><br>$(<span class="hljs-string">&#x27;button&#x27;</span>).<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;click&#x27;</span>, &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Jack&#x27;</span> &#125;, <span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(e) <span class="hljs-comment">// 所有的内容都再事件对象里面</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(e.<span class="hljs-property">data</span>) <span class="hljs-comment">// &#123; name: &#x27;Jack&#x27; &#125;</span><br>&#125;)<br><br><span class="hljs-comment">// 事件委托的方式给 button 绑定点击事件</span><br>$(<span class="hljs-string">&#x27;div&#x27;</span>).<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-string">&#x27;button&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>) <span class="hljs-comment">// button 按钮</span><br>&#125;)<br><br><span class="hljs-comment">// 事件委托的方式给 button 绑定点击事件并携带参数</span><br>$(<span class="hljs-string">&#x27;div&#x27;</span>).<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-string">&#x27;button&#x27;</span>, &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Jack&#x27;</span> &#125;, <span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>) <span class="hljs-comment">// button 按钮</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(e.<span class="hljs-property">data</span>)<br>&#125;)<br></code></pre></td></tr></table></figure></li><li><p>移除事件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 给 button 按钮绑定一个 点击事件，执行 handler 函数</span><br>$(<span class="hljs-string">&#x27;button&#x27;</span>).<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;click&#x27;</span>, handler)<br><br><span class="hljs-comment">// 移除事件使用 off</span><br>$(<span class="hljs-string">&#x27;button&#x27;</span>).<span class="hljs-title function_">off</span>(<span class="hljs-string">&#x27;click&#x27;</span>, handler)<br></code></pre></td></tr></table></figure></li><li><p>只能执行一次的事件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 这个事件绑定再 button 按钮身上</span><br><span class="hljs-comment">// 当执行过一次以后就不会再执行了</span><br>$(<span class="hljs-string">&#x27;button&#x27;</span>).<span class="hljs-title function_">one</span>(<span class="hljs-string">&#x27;click&#x27;</span>, handler)<br></code></pre></td></tr></table></figure></li><li><p>直接触发事件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 当代码执行到这里的时候，会自动触发一下 button 的 click 事件</span><br>$(<span class="hljs-string">&#x27;button&#x27;</span>).<span class="hljs-title function_">trigger</span>(<span class="hljs-string">&#x27;click&#x27;</span>)<br></code></pre></td></tr></table></figure></li></ul><p><strong>可以直接使用的常见事件</strong></p><ul><li><p>可以直接使用的事件就是可以不利用 <code>on</code> 来绑定，直接就可以使用的事件方法</p></li><li><p><code>click</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 直接给 div 绑定一个点击事件</span><br>$(<span class="hljs-string">&#x27;div&#x27;</span>).<span class="hljs-title function_">click</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;我被点击了&#x27;</span>)<br>&#125;)<br><br><span class="hljs-comment">// 给 div 绑定一个点击事件并传递参数</span><br>$(<span class="hljs-string">&#x27;div&#x27;</span>).<span class="hljs-title function_">click</span>(&#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Jack&#x27;</span> &#125;, <span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(e.<span class="hljs-property">data</span>)<br>&#125;)<br></code></pre></td></tr></table></figure></li><li><p><code>dblclick</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 直接给 div 绑定一个双击事件</span><br>$(<span class="hljs-string">&#x27;div&#x27;</span>).<span class="hljs-title function_">dblclick</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;我被点击了&#x27;</span>)<br>&#125;)<br><br><span class="hljs-comment">// 给 div 绑定一个双击事件并传递参数</span><br>$(<span class="hljs-string">&#x27;div&#x27;</span>).<span class="hljs-title function_">dblclick</span>(&#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Jack&#x27;</span> &#125;, <span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(e.<span class="hljs-property">data</span>)<br>&#125;)<br></code></pre></td></tr></table></figure></li><li><p><code>scroll</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 直接给 div 绑定一个滚动事件</span><br>$(<span class="hljs-string">&#x27;div&#x27;</span>).<span class="hljs-title function_">scroll</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;我被点击了&#x27;</span>)<br>&#125;)<br><br><span class="hljs-comment">// 给 div 绑定一个滚动事件并传递参数</span><br>$(<span class="hljs-string">&#x27;div&#x27;</span>).<span class="hljs-title function_">scroll</span>(&#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Jack&#x27;</span> &#125;, <span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(e.<span class="hljs-property">data</span>)<br>&#125;)<br></code></pre></td></tr></table></figure></li></ul><h5 id="10-动画"><a href="#10-动画" class="headerlink" title="10.动画"></a>10.动画</h5><ul><li><p><code>show</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 给 div 绑定一个显示的动画</span><br>$(<span class="hljs-string">&#x27;div&#x27;</span>).<span class="hljs-title function_">show</span>() <span class="hljs-comment">// 如果元素本身是 display none 的状态可以显示出来</span><br><br><span class="hljs-comment">// 给 div 绑定一个显示的动画</span><br><span class="hljs-comment">// 接受三个参数</span><br><span class="hljs-comment">// $(&#x27;div&#x27;).show(&#x27;毫秒&#x27;, &#x27;速度&#x27;, &#x27;回调函数&#x27;) </span><br>$(<span class="hljs-string">&#x27;div&#x27;</span>).<span class="hljs-title function_">show</span>(<span class="hljs-number">1000</span>, <span class="hljs-string">&#x27;linear&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;我显示完毕&#x27;</span>)<br>&#125;) <br></code></pre></td></tr></table></figure></li><li><p><code>hide</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 给 div 绑定一个隐藏的动画</span><br>$(<span class="hljs-string">&#x27;div&#x27;</span>).<span class="hljs-title function_">hide</span>() <span class="hljs-comment">// 如果元素本身是 display block 的状态可以隐藏起来</span><br><br><span class="hljs-comment">// 给 div 绑定一个显示的动画</span><br><span class="hljs-comment">// 接受三个参数</span><br><span class="hljs-comment">// $(&#x27;div&#x27;).show(&#x27;毫秒&#x27;, &#x27;速度&#x27;, &#x27;回调函数&#x27;) </span><br>$(<span class="hljs-string">&#x27;div&#x27;</span>).<span class="hljs-title function_">hide</span>(<span class="hljs-number">1000</span>, <span class="hljs-string">&#x27;linear&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;我隐藏完毕&#x27;</span>)<br>&#125;) <br></code></pre></td></tr></table></figure></li><li><p><code>toggle</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 给 div 绑定一个切换的动画</span><br>$(<span class="hljs-string">&#x27;div&#x27;</span>).<span class="hljs-title function_">hide</span>() <span class="hljs-comment">// 元素本身是显示，那么就隐藏，本身是隐藏那么就显示</span><br><br><span class="hljs-comment">// 给 div 绑定一个显示的动画</span><br><span class="hljs-comment">// 接受三个参数</span><br><span class="hljs-comment">// $(&#x27;div&#x27;).show(&#x27;毫秒&#x27;, &#x27;速度&#x27;, &#x27;回调函数&#x27;) </span><br>$(<span class="hljs-string">&#x27;div&#x27;</span>).<span class="hljs-title function_">toggle</span>(<span class="hljs-number">1000</span>, <span class="hljs-string">&#x27;linear&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;动画执行完毕&#x27;</span>)<br>&#125;) <br></code></pre></td></tr></table></figure></li><li><p><code>animate</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 定义一个自定义动画</span><br>$(<span class="hljs-string">&#x27;.show&#x27;</span>).<span class="hljs-title function_">click</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    $(<span class="hljs-string">&#x27;div&#x27;</span>).<span class="hljs-title function_">animate</span>(&#123;<br>        <span class="hljs-attr">width</span>: <span class="hljs-number">500</span>,<br>        <span class="hljs-attr">height</span>: <span class="hljs-number">300</span><br>    &#125;, <span class="hljs-number">1000</span>, <span class="hljs-string">&#x27;linear&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;动画运动完毕&#x27;</span>)<br>    &#125;)<br>&#125;)<br></code></pre></td></tr></table></figure></li><li><p><code>stop</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 立刻定制动画</span><br>$(<span class="hljs-string">&#x27;div&#x27;</span>).<span class="hljs-title function_">stop</span>() <span class="hljs-comment">// 就停止再当前状态</span><br></code></pre></td></tr></table></figure></li><li><p><code>finish</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 立刻结束动画</span><br>$(<span class="hljs-string">&#x27;div&#x27;</span>).<span class="hljs-title function_">finish</span>() <span class="hljs-comment">// 停止在动画结束状态</span><br></code></pre></td></tr></table></figure></li></ul><h5 id="11-元素操作"><a href="#11-元素操作" class="headerlink" title="11. 元素操作"></a>11. 元素操作</h5><ul><li><p>创建一个元素</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> div = $(<span class="hljs-string">&#x27;&lt;div&gt;&lt;/div&gt;&#x27;</span>)<br></code></pre></td></tr></table></figure></li><li><p>内部插入元素</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 向 div 元素中插入一个 p 元素，放在最后</span><br>$(<span class="hljs-string">&#x27;div&#x27;</span>).<span class="hljs-title function_">append</span>($(<span class="hljs-string">&#x27;&lt;p&gt;&lt;/p&gt;&#x27;</span>))<br><br><span class="hljs-comment">// 把 p 元素插入到 div 中去，放在最后</span><br>$(<span class="hljs-string">&#x27;&lt;p&gt;hello&lt;/p&gt;&#x27;</span>).<span class="hljs-title function_">appendTo</span>($(<span class="hljs-string">&#x27;div&#x27;</span>))<br><br><span class="hljs-comment">// 向 div 元素中插入一个 p 元素，放在最前</span><br>$(<span class="hljs-string">&#x27;div&#x27;</span>).<span class="hljs-title function_">prepend</span>($(<span class="hljs-string">&#x27;&lt;p&gt;&lt;/p&gt;&#x27;</span>))<br><br><span class="hljs-comment">// 把 p 元素插入到 div 中去，放在最前</span><br>$(<span class="hljs-string">&#x27;&lt;p&gt;hello&lt;/p&gt;&#x27;</span>).<span class="hljs-title function_">prependTo</span>($(<span class="hljs-string">&#x27;div&#x27;</span>))<br></code></pre></td></tr></table></figure></li><li><p>外部插入元素</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 在 div 的后面插入一个元素 p</span><br>$(<span class="hljs-string">&#x27;div&#x27;</span>).<span class="hljs-title function_">after</span>($(<span class="hljs-string">&#x27;&lt;p&gt;&lt;/p&gt;&#x27;</span>))<br><br><span class="hljs-comment">// 在 div 的前面插入一个元素 p</span><br>$(<span class="hljs-string">&#x27;div&#x27;</span>).<span class="hljs-title function_">before</span>($(<span class="hljs-string">&#x27;&lt;p&gt;&lt;/p&gt;&#x27;</span>))<br><br><span class="hljs-comment">// 把 p 元素插入到 div 元素的后面</span><br>$(<span class="hljs-string">&#x27;div&#x27;</span>).<span class="hljs-title function_">insertAfter</span>($(<span class="hljs-string">&#x27;&lt;p&gt;&lt;/p&gt;&#x27;</span>))<br><br><span class="hljs-comment">// 把 p 元素插入到 div 元素的前面</span><br>$(<span class="hljs-string">&#x27;div&#x27;</span>).<span class="hljs-title function_">insertBefore</span>($(<span class="hljs-string">&#x27;&lt;p&gt;&lt;/p&gt;&#x27;</span>))<br></code></pre></td></tr></table></figure></li><li><p>替换元素</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 把 div 元素替换成 p 元素</span><br>$(<span class="hljs-string">&#x27;div&#x27;</span>).<span class="hljs-title function_">replaceWith</span>($(<span class="hljs-string">&#x27;&lt;p&gt;&lt;/p&gt;&#x27;</span>))<br><br><span class="hljs-comment">// 用 p 元素替换掉 div 元素</span><br>$(<span class="hljs-string">&#x27;&lt;p&gt;&lt;/p&gt;&#x27;</span>).<span class="hljs-title function_">replaceAll</span>($(<span class="hljs-string">&#x27;div&#x27;</span>))<br></code></pre></td></tr></table></figure></li><li><p>删除元素</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 删除元素下的所有子节点</span><br>$(<span class="hljs-string">&#x27;div&#x27;</span>).<span class="hljs-title function_">empty</span>()<br><br><span class="hljs-comment">// 把自己从页面中移除</span><br>$(<span class="hljs-string">&#x27;div&#x27;</span>).<span class="hljs-title function_">remove</span>()<br></code></pre></td></tr></table></figure></li><li><p>克隆元素</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 克隆一个 li 元素</span><br><span class="hljs-comment">// 接受两个参数</span><br><span class="hljs-comment">//   参数1： 自己身上的事件要不要复制，默认是 false</span><br><span class="hljs-comment">//   参数2： 所有子节点身上的事件要不要复制，默认是 true</span><br>$(<span class="hljs-string">&#x27;li&#x27;</span>).<span class="hljs-title function_">clone</span>()<br></code></pre></td></tr></table></figure></li></ul><h5 id="12-发送-ajax-请求"><a href="#12-发送-ajax-请求" class="headerlink" title="12. 发送 ajax 请求"></a>12. 发送 ajax 请求</h5><ul><li><p>发送 get 请求</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 直接使用 $.get 方法来发送一个请求</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">参数一： 请求地址</span><br><span class="hljs-comment">参数二： 请求时携带的参数</span><br><span class="hljs-comment">参数三： 请求成功的回调</span><br><span class="hljs-comment">参数四： 返回的数据类型</span><br><span class="hljs-comment">*/</span><br>$.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;./ajax.php&#x27;</span>, &#123; <span class="hljs-attr">id</span>: <span class="hljs-number">10</span> &#125;, <span class="hljs-keyword">function</span> (<span class="hljs-params">res</span>) &#123; <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res) &#125;, <span class="hljs-string">&#x27;json&#x27;</span>)<br></code></pre></td></tr></table></figure></li><li><p>发送 post 请求</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 直接使用 $.post 方法来发送一个请求</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">参数一： 请求地址</span><br><span class="hljs-comment">参数二： 请求时携带的参数</span><br><span class="hljs-comment">参数三： 请求成功的回调</span><br><span class="hljs-comment">参数四： 返回的数据类型</span><br><span class="hljs-comment">*/</span><br>$.<span class="hljs-title function_">post</span>(<span class="hljs-string">&#x27;./ajax.php&#x27;</span>, &#123; <span class="hljs-attr">id</span>: <span class="hljs-number">10</span> &#125;, <span class="hljs-keyword">function</span> (<span class="hljs-params">res</span>) &#123; <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res) &#125;, <span class="hljs-string">&#x27;json&#x27;</span>)<br></code></pre></td></tr></table></figure></li><li><p>综合发送 ajax 请求</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 使用 $.ajax 方法</span><br><span class="hljs-comment">// 只接受一个参数，是一个对象，这个对象对当前的请求进行所有的配置</span><br>$.<span class="hljs-title function_">ajax</span>(&#123;<br>    <span class="hljs-attr">url</span>: <span class="hljs-string">&#x27;./ajax&#x27;</span>,   <span class="hljs-comment">// 必填，请求的地址</span><br>    <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;GET&#x27;</span>,   <span class="hljs-comment">// 选填，请求方式，默认是 GET（忽略大小写）</span><br>    <span class="hljs-attr">data</span>: &#123;&#125;,   <span class="hljs-comment">// 选填，发送请求是携带的参数</span><br>    <span class="hljs-attr">dataType</span>: <span class="hljs-string">&#x27;json&#x27;</span>,   <span class="hljs-comment">// 选填，期望返回值的数据类型</span><br>    <span class="hljs-attr">async</span>: <span class="hljs-literal">true</span>,   <span class="hljs-comment">// 选填，是否异步，默认是 true</span><br>    success () &#123;&#125;,   <span class="hljs-comment">// 选填，成功的回调函数</span><br>    error () &#123;&#125;,   <span class="hljs-comment">// 选填，失败的回调函数</span><br>    <span class="hljs-attr">cache</span>: <span class="hljs-literal">true</span>,   <span class="hljs-comment">// 选填，是否缓存，默认是 true</span><br>    <span class="hljs-attr">context</span>: div,   <span class="hljs-comment">// 选填，回调函数中的 this 指向，默认是 ajax 对象</span><br>    <span class="hljs-attr">status</span>: &#123;&#125;,   <span class="hljs-comment">// 选填，根据对应的状态码进行函数执行</span><br>    <span class="hljs-attr">timeout</span>: <span class="hljs-number">1000</span>,   <span class="hljs-comment">// 选填，超时事件</span><br>&#125;)<br></code></pre></td></tr></table></figure></li><li><p>发送一个 jsonp 请求</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 使用 $.ajax 方法也可以发送 jsonp 请求</span><br><span class="hljs-comment">// 只不过 dataType 要写成 jsonp</span><br>$.<span class="hljs-title function_">ajax</span>(&#123;<br>    <span class="hljs-attr">url</span>: <span class="hljs-string">&#x27;./jsonp.php&#x27;</span>,<br>    <span class="hljs-attr">dataType</span>: <span class="hljs-string">&#x27;jsonp&#x27;</span>,<br>    <span class="hljs-attr">data</span>: &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Jack&#x27;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">18</span> &#125;,<br>    success (res) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res)<br>    &#125;,<br>    <span class="hljs-attr">jsonp</span>: <span class="hljs-string">&#x27;cb&#x27;</span>,  <span class="hljs-comment">// jsonp 请求的时候回调函数的 key</span><br>    <span class="hljs-attr">jsonpCallback</span>: <span class="hljs-string">&#x27;fn&#x27;</span>   <span class="hljs-comment">// jsonp 请求的时候回调函数的名称</span><br>&#125;)<br></code></pre></td></tr></table></figure></li></ul><h5 id="13-全局-ajax-函数"><a href="#13-全局-ajax-函数" class="headerlink" title="13. 全局 ajax 函数"></a>13. 全局 ajax 函数</h5><ul><li>全局的 <code>ajax</code> 函数我们也叫做 <strong><code>ajax</code> 的钩子函数</strong></li><li>也就是在一个 <code>ajax</code> 的整个过程中的某一个阶段执行的函数</li><li>而且每一个 <code>ajax</code> 请求都会触发</li></ul><h6 id="ajaxStart"><a href="#ajaxStart" class="headerlink" title="ajaxStart"></a>ajaxStart</h6><ul><li><p>任意一个请求在 <strong>开始</strong> 的时候就会触发这个函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript">$(<span class="hljs-variable language_">window</span>).<span class="hljs-title function_">ajaxStart</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;有一个请求开始了&#x27;</span>)<br>&#125;)<br></code></pre></td></tr></table></figure></li></ul><h6 id="ajaxSend"><a href="#ajaxSend" class="headerlink" title="ajaxSend"></a>ajaxSend</h6><ul><li><p>任意一个请求在 <strong>准备 send 之前</strong> 会触发这个函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript">$(<span class="hljs-variable language_">window</span>).<span class="hljs-title function_">ajaxSend</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;有一个要发送出去了&#x27;</span>)<br>&#125;)<br></code></pre></td></tr></table></figure></li></ul><h6 id="ajaxSuccess"><a href="#ajaxSuccess" class="headerlink" title="ajaxSuccess"></a>ajaxSuccess</h6><ul><li><p>任意一个请求在 <strong>成功</strong> 的时候就会触发这个函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript">$(<span class="hljs-variable language_">window</span>).<span class="hljs-title function_">ajaxSuccess</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;有一个请求成功了&#x27;</span>)<br>&#125;)<br></code></pre></td></tr></table></figure></li></ul><h6 id="ajaxError"><a href="#ajaxError" class="headerlink" title="ajaxError"></a>ajaxError</h6><ul><li><p>任意一个请求在 <strong>失败</strong> 的时候就会触发这个函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript">$(<span class="hljs-variable language_">window</span>).<span class="hljs-title function_">ajaxError</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;有一个请求失败了&#x27;</span>)<br>&#125;)<br></code></pre></td></tr></table></figure></li></ul><h6 id="ajaxComplete"><a href="#ajaxComplete" class="headerlink" title="ajaxComplete"></a>ajaxComplete</h6><ul><li><p>任意一个请求在 <strong>完成</strong> 的时候就会触发这个函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript">$(<span class="hljs-variable language_">window</span>).<span class="hljs-title function_">ajaxComplete</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;有一个请求完成了&#x27;</span>)<br>&#125;)<br></code></pre></td></tr></table></figure></li></ul><h6 id="ajaxStop"><a href="#ajaxStop" class="headerlink" title="ajaxStop"></a>ajaxStop</h6><ul><li><p>任意一个请求在 <strong>结束</strong> 的时候就会触发这个函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript">$(<span class="hljs-variable language_">window</span>).<span class="hljs-title function_">ajaxStop</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;有一个请求结束了&#x27;</span>)<br>&#125;)<br></code></pre></td></tr></table></figure></li></ul><h5 id="14-jQuery-的多库共存"><a href="#14-jQuery-的多库共存" class="headerlink" title="14.jQuery 的多库共存"></a>14.jQuery 的多库共存</h5><ul><li><p>我们一直在使用 <code>jQuery</code>，都没有什么问题</p></li><li><p>但是如果有一天，我们需要引入一个别的插件或者库的时候</p></li><li><p>人家也向外暴露的是 <code>$</code> 获取 <code>jQuery</code></p></li><li><p>那么，我们的 <code>jQuery</code> 就不能用了</p></li><li><p>那么这个时候，<code>jQuery</code> 为我们提供了一个多库并存的方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 这个方法可以交还 jQuery 命名的控制权</span><br>jQuery.<span class="hljs-title function_">noConflict</span>()<br><br><span class="hljs-comment">// 上面代码执行完毕以后 $ 这个变量就不能用了</span><br><span class="hljs-comment">// 但是 jQuery 可以使用</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>($) <span class="hljs-comment">// undefined</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(jQuery) <span class="hljs-comment">// 可以使用</span><br></code></pre></td></tr></table></figure></li><li><p>完全交出控制权</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 这个方法可以交并且传递一个 true 的时候，会完全交出控制权</span><br>jQuery.<span class="hljs-title function_">noConflict</span>(<span class="hljs-literal">true</span>)<br><br><span class="hljs-comment">// 上面代码执行完毕以后 $ 这个变量就不能用了</span><br><span class="hljs-comment">// jQuery 这个变量也不能用了</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>($) <span class="hljs-comment">// undefined</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(jQuery) <span class="hljs-comment">// undefined</span><br></code></pre></td></tr></table></figure></li><li><p>更换控制权</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 可以用一个变量来接受返回值，这个变量就是新的控制权</span><br><span class="hljs-keyword">var</span> aa = jQuery.<span class="hljs-title function_">noConflict</span>(<span class="hljs-literal">true</span>)<br><br><span class="hljs-comment">// 接下来就可以把 aa 当作 jQuery 向外暴露的接口使用了</span><br><span class="hljs-title function_">aa</span>(<span class="hljs-string">&#x27;div&#x27;</span>).<span class="hljs-title function_">click</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123; <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;我被点击了&#x27;</span>) &#125;)<br></code></pre></td></tr></table></figure></li></ul><h5 id="15-JQuery-的插件扩展"><a href="#15-JQuery-的插件扩展" class="headerlink" title="15 . JQuery 的插件扩展"></a>15 . JQuery 的插件扩展</h5><ul><li><code>jQuery</code> 确实很好很强大</li><li>但是也有一些方法是他没有的，我们的业务需求中有的时候会遇到一些它里面没有的方法</li><li>那么我们就可以给他扩展一些方法</li></ul><h6 id="扩展给他自己本身"><a href="#扩展给他自己本身" class="headerlink" title="扩展给他自己本身"></a>扩展给他自己本身</h6><ul><li><p>扩展给自己本身使用 <code>jQuery.extend</code> 这个方法</p></li><li><p>扩展完后的内容只能用 <code>$</code> 或者 <code>jQuery</code> 来调用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// jQuery.extend 接受一个参数，是一个对象，对象里面是我们扩展的方法</span><br>jQuery.<span class="hljs-title function_">extend</span>(&#123;<br>    <span class="hljs-attr">max</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">...n</span>) &#123; <span class="hljs-keyword">return</span> <span class="hljs-title class_">Math</span>.<span class="hljs-property">max</span>.<span class="hljs-title function_">apply</span>(<span class="hljs-literal">null</span>, n) &#125;,<br>    <span class="hljs-attr">min</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">...n</span>) &#123; <span class="hljs-keyword">return</span> <span class="hljs-title class_">Math</span>.<span class="hljs-property">min</span>.<span class="hljs-title function_">apply</span>(<span class="hljs-literal">null</span>, n) &#125;<br>&#125;)<br></code></pre></td></tr></table></figure></li><li><p>扩展完毕我们就可以使用了</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> max = $.<span class="hljs-title function_">max</span>(<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">6</span>, <span class="hljs-number">1</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(max) <span class="hljs-comment">// 6</span><br><span class="hljs-keyword">const</span> min = $.<span class="hljs-title function_">min</span>(<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">6</span>, <span class="hljs-number">1</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(min) <span class="hljs-comment">// 1</span><br></code></pre></td></tr></table></figure></li></ul><h6 id="扩展给元素集"><a href="#扩展给元素集" class="headerlink" title="扩展给元素集"></a>扩展给元素集</h6><ul><li><p>扩展完毕以后给元素的集合使用</p></li><li><p>也就是我们用 <code>$(&#39;li&#39;)</code> 这样的选择器获取到的元素集合来使用</p></li><li><p>使用 <code>jQuery.fn.extend()</code> 方法来扩展</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// jQuery.fn.extend() 接受一个参数，是一个对象，对象里面是我们扩展的方法</span><br>jQuery.<span class="hljs-property">fn</span>.<span class="hljs-title function_">extend</span>(&#123;<br>    <span class="hljs-attr">checked</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-comment">// return 关键字是为了保证链式编程</span><br>        <span class="hljs-comment">// 后面的代码才是业务逻辑</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">each</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-variable language_">this</span>.<span class="hljs-property">checked</span> = <span class="hljs-literal">true</span> &#125;)<br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure></li><li><p>扩展完毕我们就可以使用了</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 靠元素集合来调用</span><br>$(<span class="hljs-string">&#x27;input[type=checkbox]&#x27;</span>).<span class="hljs-title function_">checked</span>()<br><span class="hljs-comment">// 执行完毕之后，所有的 复选框 就都是选中状态了</span><br></code></pre></td></tr></table></figure></li></ul><h4 id="八-swiper"><a href="#八-swiper" class="headerlink" title="八. swiper"></a>八. swiper</h4><blockquote><p><a href="https://www.swiper.com.cn/">https://www.swiper.com.cn/</a></p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs js">$.<span class="hljs-title function_">get</span>(<span class="hljs-string">&quot;http://localhost:3000/banner&quot;</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;<br>          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res)<br>          <span class="hljs-title function_">render</span>(res)<br>          <span class="hljs-title function_">initSwiper</span>()<br>      &#125;)<br><br>      <span class="hljs-keyword">function</span> <span class="hljs-title function_">render</span>(<span class="hljs-params">list</span>) &#123;<br>          <span class="hljs-keyword">var</span> oslides = list.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> <span class="hljs-string">`</span><br><span class="hljs-string">          &lt;div class=&quot;swiper-slide&quot;&gt;</span><br><span class="hljs-string">              &lt;img src=&quot;<span class="hljs-subst">$&#123;item.imgUrl&#125;</span>&quot;/&gt;</span><br><span class="hljs-string">          &lt;/div&gt;</span><br><span class="hljs-string">          `</span>)<br><br>          <span class="hljs-comment">// console.log(oslides.join(&quot;&quot;))</span><br><br>          $(<span class="hljs-string">&quot;.swiper-wrapper&quot;</span>).<span class="hljs-title function_">html</span>(oslides.<span class="hljs-title function_">join</span>(<span class="hljs-string">&quot;&quot;</span>))<br>      &#125;<br><br><br>      $.<span class="hljs-title function_">extend</span>(&#123;<br>          <span class="hljs-attr">swiper</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">ele, obj</span>) &#123;<br>              <span class="hljs-keyword">new</span> <span class="hljs-title class_">Swiper</span>(ele,obj)<br>          &#125;<br>      &#125;)<br><br>      <span class="hljs-keyword">function</span> <span class="hljs-title function_">initSwiper</span>(<span class="hljs-params"></span>) &#123;<br>          $.<span class="hljs-title function_">swiper</span>(<span class="hljs-string">&quot;.kerwin&quot;</span>, &#123;<br>              <span class="hljs-comment">// direction: &#x27;vertical&#x27;, // 垂直切换选项</span><br>              <span class="hljs-attr">loop</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 循环模式选项</span><br>              <span class="hljs-comment">// 如果需要分页器</span><br>              <span class="hljs-attr">pagination</span>: &#123;<br>                  <span class="hljs-attr">el</span>: <span class="hljs-string">&#x27;.swiper-pagination&#x27;</span>,<br>                  <span class="hljs-attr">clickable</span>: <span class="hljs-literal">true</span><br>              &#125;,<br>              <span class="hljs-attr">observer</span>: <span class="hljs-literal">true</span><br>          &#125;)<br>      &#125;<br></code></pre></td></tr></table></figure><h4 id="九-BootStrap"><a href="#九-BootStrap" class="headerlink" title="九. BootStrap"></a>九. BootStrap</h4><p><img src="F:/前端学习/视频笔记/javascript/笔记/笔记/笔记.assets/image-20220716160225615.png" alt="image-20220716160225615"></p><blockquote><p><a href="https://www.bootcss.com/">https://www.bootcss.com/</a></p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;row&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;col-xl-3 col-lg-4 col-md-6 col-sm-12&quot;</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;card&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;width: 18rem;&quot;</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;...&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;card-img-top&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;...&quot;</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;card-body&quot;</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">h5</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;card-title&quot;</span>&gt;</span>Card title<span class="hljs-tag">&lt;/<span class="hljs-name">h5</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;card-text&quot;</span>&gt;</span>Some quick example text to build on the card title and make up the bulk of<br>                            the card&#x27;s content.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;btn btn-primary&quot;</span>&gt;</span>Go somewhere<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>                    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;col-xl-3 col-lg-4 col-md-6 col-sm-12&quot;</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;card&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;width: 18rem;&quot;</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;...&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;card-img-top&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;...&quot;</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;card-body&quot;</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">h5</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;card-title&quot;</span>&gt;</span>Card title<span class="hljs-tag">&lt;/<span class="hljs-name">h5</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;card-text&quot;</span>&gt;</span>Some quick example text to build on the card title and make up the bulk of<br>                            the card&#x27;s content.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;btn btn-primary&quot;</span>&gt;</span>Go somewhere<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>                    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;col-xl-3 col-lg-4 col-md-6 col-sm-12&quot;</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;card&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;width: 18rem;&quot;</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;...&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;card-img-top&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;...&quot;</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;card-body&quot;</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">h5</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;card-title&quot;</span>&gt;</span>Card title<span class="hljs-tag">&lt;/<span class="hljs-name">h5</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;card-text&quot;</span>&gt;</span>Some quick example text to build on the card title and make up the bulk of<br>                            the card&#x27;s content.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;btn btn-primary&quot;</span>&gt;</span>Go somewhere<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>                    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;col-xl-3 col-lg-4 col-md-6 col-sm-12&quot;</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;card&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;width: 18rem;&quot;</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;...&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;card-img-top aaa&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;...&quot;</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;card-body&quot;</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">h5</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;card-title&quot;</span>&gt;</span>Card title<span class="hljs-tag">&lt;/<span class="hljs-name">h5</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;card-text&quot;</span>&gt;</span>Some quick example text to build on the card title and make up the bulk of<br>                            the card&#x27;s content.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;btn btn-primary&quot;</span>&gt;</span>Go somewhere<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>                    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="十-Sass"><a href="#十-Sass" class="headerlink" title="十. Sass"></a>十. Sass</h4><ul><li><p><a href="https://www.sass.hk/">SASS官网</a></p></li><li><p>世界上最成熟、最稳定、最强大的专业级CSS扩展语言！</p></li><li><p><code>sass</code> 是一个 <code>css</code> 的预编译工具</p></li><li><p>也就是能够 <strong>更优雅</strong> 的书写 <code>css</code></p></li><li><p><code>sass</code> 写出来的东西 <strong>浏览器不认识</strong></p></li><li><p>依旧是要转换成 <code>css</code> 在浏览器中运行</p></li></ul><h5 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h5><ul><li><p>定义一个变量，在后面的代码中使用</p></li><li><p>使用 <code>$</code> 来定义变量</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-comment">// 定义一个 $c 作为变量，值是 红色</span><br><span class="hljs-variable">$c</span>: red;<br><br><span class="hljs-selector-tag">h1</span> &#123;<br>    <span class="hljs-comment">// 在使用 $c 这个变量</span><br>    <span class="hljs-attribute">color</span>: <span class="hljs-variable">$c</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>上面定义的变量全局都可以使用</p></li><li><p>我们也可以在规则块内定义私有变量</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-selector-tag">h1</span> &#123;<br>    <span class="hljs-comment">// 这个 $w 变量只能在 h1 这个规则块中使用</span><br>    <span class="hljs-variable">$w</span>: <span class="hljs-number">100px</span>;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-variable">$w</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h5 id="嵌套"><a href="#嵌套" class="headerlink" title="嵌套"></a>嵌套</h5><ul><li><p><code>sass</code> 里面我们最长用到的就是嵌套了</p></li><li><p>而且相当的好用</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-selector-tag">h1</span> &#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br><br>    <span class="hljs-selector-tag">div</span> &#123;<br>        <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 编译结果</span><br><span class="hljs-selector-tag">h1</span> &#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br>&#125;<br><br><span class="hljs-selector-tag">h1</span> <span class="hljs-selector-tag">div</span> &#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>这个就是嵌套，理论上可以无限嵌套下去</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-selector-tag">ul</span> &#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br><br>    <span class="hljs-selector-tag">li</span> &#123;<br>        <span class="hljs-attribute">width</span>: <span class="hljs-number">90px</span>;<br><br>        <span class="hljs-selector-tag">div</span> &#123;<br>            <span class="hljs-attribute">width</span>: <span class="hljs-number">80px</span>;<br><br>            <span class="hljs-selector-tag">p</span> &#123;<br>                <span class="hljs-attribute">width</span>: <span class="hljs-number">70px</span>;<br><br>                <span class="hljs-selector-tag">span</span>: &#123;<br>                    <span class="hljs-attribute">color</span>: red;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h6 id="嵌套中的-amp"><a href="#嵌套中的-amp" class="headerlink" title="嵌套中的 &amp;"></a>嵌套中的 &amp;</h6><ul><li><p>在嵌套中还有一个标识符是 <code>&amp;</code> 我们可以使用</p></li><li><p>先来看一个例子</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-selector-tag">div</span> &#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br><br>    <span class="hljs-selector-pseudo">:hover</span> &#123;<br>        <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 我想的是 div 被鼠标悬停的时候 width 变成 200</span><br><span class="hljs-comment">// 但是编译结果却是</span><br><span class="hljs-selector-tag">div</span> &#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>&#125;<br><span class="hljs-selector-tag">div</span> <span class="hljs-selector-pseudo">:hover</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>和预想的结果不一样了</p></li><li><p>这个时候就要用到 <code>&amp;</code> 来连接了</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-selector-tag">div</span> &#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br><br>    &amp;<span class="hljs-selector-pseudo">:hover</span> &#123;<br>        <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 编译结果</span><br><span class="hljs-selector-tag">div</span> &#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>&#125;<br><span class="hljs-selector-tag">div</span><span class="hljs-selector-pseudo">:hover</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>这个时候就和我需要的一样了</p></li></ul><h6 id="群组嵌套"><a href="#群组嵌套" class="headerlink" title="群组嵌套"></a>群组嵌套</h6><ul><li><p>群组嵌套就是多个标签同时嵌套</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-selector-tag">div</span> &#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br><br>    <span class="hljs-selector-class">.box1</span>, <span class="hljs-selector-class">.box2</span>, <span class="hljs-selector-class">.box3</span> &#123;<br>        <span class="hljs-attribute">color</span>: red;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 编译结果</span><br><span class="hljs-selector-tag">div</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br>&#125;<br><span class="hljs-selector-tag">div</span> <span class="hljs-selector-class">.box1</span>, <span class="hljs-selector-tag">div</span> <span class="hljs-selector-class">.box2</span>, <span class="hljs-selector-tag">div</span> <span class="hljs-selector-class">.box3</span> &#123;<br> <span class="hljs-attribute">color</span>: red;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>还有一种就是多个标签同时嵌套一个标签</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-selector-tag">h1</span>, <span class="hljs-selector-tag">h2</span>, <span class="hljs-selector-tag">h3</span> &#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br><br>    <span class="hljs-selector-class">.box</span> &#123;<br>        <span class="hljs-attribute">color</span>: red;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 编译结果</span><br><span class="hljs-selector-tag">h1</span>, <span class="hljs-selector-tag">h2</span>, <span class="hljs-selector-tag">h3</span> &#123;<br> <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br>&#125;<br><span class="hljs-selector-tag">h1</span> <span class="hljs-selector-class">.box</span>, <span class="hljs-selector-tag">h2</span> <span class="hljs-selector-class">.box</span>, <span class="hljs-selector-tag">h3</span> <span class="hljs-selector-class">.box</span> &#123;<br>  <span class="hljs-attribute">color</span>: red;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h5 id="混入"><a href="#混入" class="headerlink" title="混入"></a>混入</h5><ul><li><p>也叫 <strong>混合器</strong></p></li><li><p>其实就是定义一个 <strong><span style="color: red;">“函数”</span></strong> 在 <code>scss</code> 文件中使用</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-comment">// 定义一个混合器使用  @mixin 关键字</span><br><span class="hljs-keyword">@mixin</span> radius &#123;<br>    -webkit-<span class="hljs-attribute">border-radius</span>: <span class="hljs-number">10px</span>;<br>    -moz-<span class="hljs-attribute">border-radius</span>: <span class="hljs-number">10px</span>;<br>    -ms-<span class="hljs-attribute">border-radius</span>: <span class="hljs-number">10px</span>;<br>    -o-<span class="hljs-attribute">border-radius</span>: <span class="hljs-number">10px</span>;<br>    <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">10px</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>上面是定义好的一个混合器</p></li><li><p>他是不会被编译的，只有当你使用了他以后，才会被编译</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-comment">// 使用混合器使用 @include 关键字</span><br><span class="hljs-selector-tag">div</span> &#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br><br>    <span class="hljs-keyword">@include</span> radius;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>这个就是吧刚才定义的混合器拿过来使用</p></li><li><p>编译结果</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-selector-tag">div</span> &#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>    -webkit-<span class="hljs-attribute">border-radius</span>: <span class="hljs-number">10px</span>;<br>    -moz-<span class="hljs-attribute">border-radius</span>: <span class="hljs-number">10px</span>;<br>    -ms-<span class="hljs-attribute">border-radius</span>: <span class="hljs-number">10px</span>;<br>    -o-<span class="hljs-attribute">border-radius</span>: <span class="hljs-number">10px</span>;<br>    <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">10px</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h6 id="混合器传参"><a href="#混合器传参" class="headerlink" title="混合器传参"></a>混合器传参</h6><ul><li><p>我们既然说了，混合器就像一个 “函数” 一样，那么就一定可以像 “函数” 一样传递参数</p></li><li><p>和 “函数” 的使用方式一样，在定时的时候是 “形参”，在调用的时候是 “实参”</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-comment">// 定义混合器</span><br><span class="hljs-keyword">@mixin</span> my_transition(<span class="hljs-variable">$pro</span>, <span class="hljs-variable">$dur</span>, <span class="hljs-variable">$delay</span>, <span class="hljs-variable">$tim</span>) &#123;<br>    -webkit-<span class="hljs-attribute">transition</span>: <span class="hljs-variable">$pro</span> <span class="hljs-variable">$dur</span> <span class="hljs-variable">$delay</span> <span class="hljs-variable">$tim</span>;<br>    -moz-<span class="hljs-attribute">transition</span>: <span class="hljs-variable">$pro</span> <span class="hljs-variable">$dur</span> <span class="hljs-variable">$delay</span> <span class="hljs-variable">$tim</span>;<br>    -ms-<span class="hljs-attribute">transition</span>: <span class="hljs-variable">$pro</span> <span class="hljs-variable">$dur</span> <span class="hljs-variable">$delay</span> <span class="hljs-variable">$tim</span>;<br>    -o-<span class="hljs-attribute">transition</span>: <span class="hljs-variable">$pro</span> <span class="hljs-variable">$dur</span> <span class="hljs-variable">$delay</span> <span class="hljs-variable">$tim</span>;<br>    <span class="hljs-attribute">transition</span>: <span class="hljs-variable">$pro</span> <span class="hljs-variable">$dur</span> <span class="hljs-variable">$delay</span> <span class="hljs-variable">$tim</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>使用这个混合器的时候传递 “实参”</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-selector-tag">div</span> &#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br><br>    <span class="hljs-keyword">@include</span> my_transition(all, <span class="hljs-number">1s</span>, <span class="hljs-number">0s</span>, linear);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>编译结果</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-selector-tag">div</span> &#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>    -webkit-<span class="hljs-attribute">transition</span>: all <span class="hljs-number">1s</span> <span class="hljs-number">0s</span> linear;<br>    -moz-<span class="hljs-attribute">transition</span>: all <span class="hljs-number">1s</span> <span class="hljs-number">0s</span> linear;<br>    -ms-<span class="hljs-attribute">transition</span>: all <span class="hljs-number">1s</span> <span class="hljs-number">0s</span> linear;<br>    -o-<span class="hljs-attribute">transition</span>: all <span class="hljs-number">1s</span> <span class="hljs-number">0s</span> linear;<br>    <span class="hljs-attribute">transition</span>: all <span class="hljs-number">1s</span> <span class="hljs-number">0s</span> linear;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>写了多少个 “形参”，那么调用的时候就要传递多少个 “实参”</p></li><li><p>不然会报错的</p></li></ul><h6 id="参数默认值"><a href="#参数默认值" class="headerlink" title="参数默认值"></a>参数默认值</h6><ul><li><p>我们在定义混合器的时候，也可以给一些参数写一些默认值</p></li><li><p>这样一来，就可以不传递 “实参” 了</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-comment">// 设置一些带有默认值的参数</span><br><span class="hljs-keyword">@mixin</span> my_transition(<span class="hljs-variable">$dur</span>: <span class="hljs-number">1s</span>, <span class="hljs-variable">$pro</span>: all, <span class="hljs-variable">$delay</span>: <span class="hljs-number">0s</span>, <span class="hljs-variable">$tim</span>: linear) &#123;<br>    -webkit-<span class="hljs-attribute">transition</span>: <span class="hljs-variable">$dur</span> <span class="hljs-variable">$pro</span> <span class="hljs-variable">$delay</span> <span class="hljs-variable">$tim</span>;<br>    -moz-<span class="hljs-attribute">transition</span>: <span class="hljs-variable">$dur</span> <span class="hljs-variable">$pro</span> <span class="hljs-variable">$delay</span> <span class="hljs-variable">$tim</span>;<br>    -ms-<span class="hljs-attribute">transition</span>: <span class="hljs-variable">$dur</span> <span class="hljs-variable">$pro</span> <span class="hljs-variable">$delay</span> <span class="hljs-variable">$tim</span>;<br>    -o-<span class="hljs-attribute">transition</span>: <span class="hljs-variable">$dur</span> <span class="hljs-variable">$pro</span> <span class="hljs-variable">$delay</span> <span class="hljs-variable">$tim</span>;<br>    <span class="hljs-attribute">transition</span>: <span class="hljs-variable">$dur</span> <span class="hljs-variable">$pro</span> <span class="hljs-variable">$delay</span> <span class="hljs-variable">$tim</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>使用的时候，如果你不传递，那么就是使用默认值</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-selector-tag">div</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br><br>  <span class="hljs-comment">// 使用的时候，只传递一个，剩下的使用默认值</span><br>  <span class="hljs-keyword">@include</span> my_transition(<span class="hljs-number">2s</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>编译结果</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-selector-tag">div</span> &#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>    -webkit-<span class="hljs-attribute">transition</span>: <span class="hljs-number">2s</span> all <span class="hljs-number">0s</span> linear;<br>    -moz-<span class="hljs-attribute">transition</span>: <span class="hljs-number">2s</span> all <span class="hljs-number">0s</span> linear;<br>    -ms-<span class="hljs-attribute">transition</span>: <span class="hljs-number">2s</span> all <span class="hljs-number">0s</span> linear;<br>    -o-<span class="hljs-attribute">transition</span>: <span class="hljs-number">2s</span> all <span class="hljs-number">0s</span> linear;<br>    <span class="hljs-attribute">transition</span>: <span class="hljs-number">2s</span> all <span class="hljs-number">0s</span> linear;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h5 id="继承-1"><a href="#继承-1" class="headerlink" title="继承"></a>继承</h5><ul><li><p>在 <code>sass</code> 里面使用继承可以大大的提高开发效率</p></li><li><p>其实继承很简单，就是把之前写过的选择器里面的内容直接拿过来一份</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-selector-tag">div</span> &#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>    <span class="hljs-attribute">background-color</span>: pink;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>这个是之前写过的一个规则样式表</p></li><li><p>接下来我要写另外一个样式了，发现我要写的一些内容和之前这个 <code>div</code> 一样，并且还有一些我自己的内容</p></li><li><p>那么我就可以把这个样式表先继承下来，再写我自己的内容就好了</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-selector-tag">p</span> &#123;<br>      <span class="hljs-keyword">@extend</span> div;<br><br>      <span class="hljs-attribute">font-size</span>: <span class="hljs-number">20px</span>;<br>      <span class="hljs-attribute">color</span>: red;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>编译结果</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-selector-tag">div</span>, <span class="hljs-selector-tag">p</span> &#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>    <span class="hljs-attribute">background-color</span>: pink;<br>&#125;<br><br><span class="hljs-selector-tag">p</span> &#123;<br>    <span class="hljs-attribute">font-size</span>: <span class="hljs-number">20px</span>;<br>    <span class="hljs-attribute">color</span>: red;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h5 id="导入文件"><a href="#导入文件" class="headerlink" title="导入文件"></a>导入文件</h5><ul><li><p>我们刚才学过了定义变量，定义混合器</p></li><li><p>而这两个内容在定义过以后，如果没有使用，是不会被编译出内容的</p></li><li><p>所以我们可以把变量单独写一个文件，混合器单独写一个文件，然后直接导入后使用</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-comment">// 我是 variable.scss</span><br><span class="hljs-variable">$w</span>: <span class="hljs-number">100px</span>;<br><span class="hljs-variable">$h</span>: <span class="hljs-number">200px</span>;<br><span class="hljs-variable">$c</span>: pink;<br><br><span class="hljs-comment">// 我是 mixin.scss</span><br><span class="hljs-keyword">@mixin</span> my_transition(<span class="hljs-variable">$dur</span>: <span class="hljs-number">1s</span>, <span class="hljs-variable">$pro</span>: all, <span class="hljs-variable">$delay</span>: <span class="hljs-number">0s</span>, <span class="hljs-variable">$tim</span>: linear) &#123;<br>    -webkit-<span class="hljs-attribute">transition</span>: <span class="hljs-variable">$dur</span> <span class="hljs-variable">$pro</span> <span class="hljs-variable">$delay</span> <span class="hljs-variable">$tim</span>;<br>    -moz-<span class="hljs-attribute">transition</span>: <span class="hljs-variable">$dur</span> <span class="hljs-variable">$pro</span> <span class="hljs-variable">$delay</span> <span class="hljs-variable">$tim</span>;<br>    -ms-<span class="hljs-attribute">transition</span>: <span class="hljs-variable">$dur</span> <span class="hljs-variable">$pro</span> <span class="hljs-variable">$delay</span> <span class="hljs-variable">$tim</span>;<br>    -o-<span class="hljs-attribute">transition</span>: <span class="hljs-variable">$dur</span> <span class="hljs-variable">$pro</span> <span class="hljs-variable">$delay</span> <span class="hljs-variable">$tim</span>;<br>    <span class="hljs-attribute">transition</span>: <span class="hljs-variable">$dur</span> <span class="hljs-variable">$pro</span> <span class="hljs-variable">$delay</span> <span class="hljs-variable">$tim</span>;<br>&#125;<br><br><span class="hljs-keyword">@mixin</span> radius &#123;<br>    -webkit-<span class="hljs-attribute">border-radius</span>: <span class="hljs-number">10px</span>;<br>    -moz-<span class="hljs-attribute">border-radius</span>: <span class="hljs-number">10px</span>;<br>    -ms-<span class="hljs-attribute">border-radius</span>: <span class="hljs-number">10px</span>;<br>    -o-<span class="hljs-attribute">border-radius</span>: <span class="hljs-number">10px</span>;<br>    <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">10px</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>然后在我们的主要文件中把这个两个文件导入进来就行了</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-comment">// 我是 index.scss</span><br><span class="hljs-keyword">@import</span> <span class="hljs-string">&#x27;./variable.scss&#x27;</span>;<br><span class="hljs-keyword">@import</span> <span class="hljs-string">&#x27;./mixin.scss&#x27;</span>;<br><br><span class="hljs-selector-tag">div</span> &#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-variable">$w</span>;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-variable">$h</span>;<br>    <span class="hljs-attribute">background-color</span>: <span class="hljs-variable">$c</span>;<br><br>    <span class="hljs-keyword">@include</span> radius;<br>&#125;<br><br><span class="hljs-selector-tag">h1</span> &#123;<br>    <span class="hljs-keyword">@include</span> my_transition;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>编译结果</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-selector-tag">div</span> &#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;<br>    <span class="hljs-attribute">background-color</span>: pink;<br>    -webkit-<span class="hljs-attribute">border-radius</span>: <span class="hljs-number">10px</span>;<br>    -moz-<span class="hljs-attribute">border-radius</span>: <span class="hljs-number">10px</span>;<br>    -ms-<span class="hljs-attribute">border-radius</span>: <span class="hljs-number">10px</span>;<br>    -o-<span class="hljs-attribute">border-radius</span>: <span class="hljs-number">10px</span>;<br>    <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">10px</span>;<br>&#125;<br><br><span class="hljs-selector-tag">h1</span> &#123;<br>    -webkit-<span class="hljs-attribute">transition</span>: <span class="hljs-number">1s</span> all <span class="hljs-number">0s</span> linear;<br>    -moz-<span class="hljs-attribute">transition</span>: <span class="hljs-number">1s</span> all <span class="hljs-number">0s</span> linear;<br>    -ms-<span class="hljs-attribute">transition</span>: <span class="hljs-number">1s</span> all <span class="hljs-number">0s</span> linear;<br>    -o-<span class="hljs-attribute">transition</span>: <span class="hljs-number">1s</span> all <span class="hljs-number">0s</span> linear;<br>    <span class="hljs-attribute">transition</span>: <span class="hljs-number">1s</span> all <span class="hljs-number">0s</span> linear;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>javascript</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
